import Markdoc from '@markdoc/markdoc';
import { aj as basicFormFieldWithSimpleReaderParse, ai as FieldDataError, aB as text, aF as getDefaultValue, aG as DocumentFieldInput, aH as parseToEditorState, aI as collectDirectoriesUsedInSchema, o as object, aq as fixPath, aJ as serializeFromEditorState, aK as createEditorStateFromYJS, aL as parseToEditorStateMDX, aM as serializeFromEditorStateMDX, aN as createEditorSchema } from './index-7cfe6b6b.react-server.js';
import { block } from './keystatic-core-content-components.react-server.js';
import { c as cloudImageSchema, b as CloudImagePreviewForNewEditor, a as cloudImageToolbarIcon } from './cloud-image-schema-a0abaf28.react-server.js';
import { jsx } from 'react/jsx-runtime';
import 'emery';
import 'decimal.js';
import '@sindresorhus/slugify';
import '@braintree/sanitize-url';
import { prosemirrorToYXmlFragment } from 'y-prosemirror';
import 'slate';
import 'emery/assertions';
import 'yjs';
import 'js-base64';
import './hex-fad676b3.react-server.js';
import '@emotion/weak-memoize';
import './index-84b456f5.react-server.js';

const defaultAltField = text({
  label: 'Alt text',
  description: 'This text will be used by screen readers and search engines.'
});
const emptyTitleField = basicFormFieldWithSimpleReaderParse({
  Input() {
    return null;
  },
  defaultValue() {
    return '';
  },
  parse(value) {
    if (value === undefined) return '';
    if (typeof value !== 'string') {
      throw new FieldDataError('Must be string');
    }
    return value;
  },
  validate(value) {
    return value;
  },
  serialize(value) {
    return {
      value
    };
  },
  label: 'Title'
});
function editorOptionsToConfig(options) {
  var _options$bold, _options$italic, _options$strikethroug, _options$code, _options$blockquote, _options$orderedList, _options$unorderedLis, _options$table, _options$link, _options$divider;
  return {
    bold: (_options$bold = options.bold) !== null && _options$bold !== void 0 ? _options$bold : true,
    italic: (_options$italic = options.italic) !== null && _options$italic !== void 0 ? _options$italic : true,
    strikethrough: (_options$strikethroug = options.strikethrough) !== null && _options$strikethroug !== void 0 ? _options$strikethroug : true,
    code: (_options$code = options.code) !== null && _options$code !== void 0 ? _options$code : true,
    heading: (() => {
      let levels = [];
      let levelsOpt = typeof options.heading === 'object' && !Array.isArray(options.heading) ? options.heading.levels : options.heading;
      if (levelsOpt === true || levelsOpt === undefined) {
        levels = [1, 2, 3, 4, 5, 6];
      }
      if (Array.isArray(levelsOpt)) {
        levels = levelsOpt;
      }
      return {
        levels,
        schema: options.heading && typeof options.heading === 'object' && 'schema' in options.heading ? options.heading.schema : {}
      };
    })(),
    blockquote: (_options$blockquote = options.blockquote) !== null && _options$blockquote !== void 0 ? _options$blockquote : true,
    orderedList: (_options$orderedList = options.orderedList) !== null && _options$orderedList !== void 0 ? _options$orderedList : true,
    unorderedList: (_options$unorderedLis = options.unorderedList) !== null && _options$unorderedLis !== void 0 ? _options$unorderedLis : true,
    table: (_options$table = options.table) !== null && _options$table !== void 0 ? _options$table : true,
    link: (_options$link = options.link) !== null && _options$link !== void 0 ? _options$link : true,
    image: options.image !== false ? ((_opts$schema$alt, _opts$schema, _opts$schema$title, _opts$schema2) => {
      const opts = options.image === true ? undefined : options.image;
      return {
        directory: opts === null || opts === void 0 ? void 0 : opts.directory,
        publicPath: opts === null || opts === void 0 ? void 0 : opts.publicPath,
        schema: {
          alt: (_opts$schema$alt = opts === null || opts === void 0 || (_opts$schema = opts.schema) === null || _opts$schema === void 0 ? void 0 : _opts$schema.alt) !== null && _opts$schema$alt !== void 0 ? _opts$schema$alt : defaultAltField,
          title: (_opts$schema$title = opts === null || opts === void 0 || (_opts$schema2 = opts.schema) === null || _opts$schema2 === void 0 ? void 0 : _opts$schema2.title) !== null && _opts$schema$title !== void 0 ? _opts$schema$title : emptyTitleField
        }
      };
    })() : undefined,
    divider: (_options$divider = options.divider) !== null && _options$divider !== void 0 ? _options$divider : true,
    codeBlock: options.codeBlock === false ? undefined : {
      schema: typeof options.codeBlock === 'object' ? options.codeBlock.schema : {}
    }
  };
}

function getTypeForField(field) {
  if (field.kind === 'object' || field.kind === 'conditional') {
    return {
      type: Object,
      required: true
    };
  }
  if (field.kind === 'array') {
    return {
      type: Array,
      required: true
    };
  }
  if (field.kind === 'child') {
    return {};
  }
  if (field.formKind === undefined) {
    if (typeof field.defaultValue === 'string' && 'options' in field && Array.isArray(field.options) && field.options.every(val => typeof val === 'object' && val !== null && 'value' in val && typeof val.value === 'string')) {
      return {
        type: String,
        matches: field.options.map(x => x.value),
        required: true
      };
    }
    if (typeof field.defaultValue === 'string') {
      let required = false;
      try {
        field.parse('');
      } catch {
        required = true;
      }
      return {
        type: String,
        required
      };
    }
    try {
      field.parse(1);
      return {
        type: Number
      };
    } catch {}
    if (typeof field.defaultValue === 'boolean') {
      return {
        type: Boolean,
        required: true
      };
    }
    return {};
  }
  if (field.formKind === 'slug') {
    let required = false;
    try {
      field.parse('', undefined);
    } catch {
      required = true;
    }
    return {
      type: String,
      required
    };
  }
  if (field.formKind === 'asset') {
    let required = false;
    try {
      field.validate(null);
    } catch {
      required = true;
    }
    return {
      type: String,
      required
    };
  }
  return {};
}
function fieldsToMarkdocAttributes(fields) {
  return Object.fromEntries(Object.entries(fields).map(([name, field]) => {
    const schema = getTypeForField(field);
    return [name, schema];
  }));
}
const {
  nodes
} = Markdoc;
function createMarkdocConfig(opts) {
  const editorConfig = editorOptionsToConfig(opts.options || {});
  const config = {
    nodes: {
      ...nodes
    },
    tags: {}
  };
  if (editorConfig.heading.levels.length) {
    config.nodes.heading = {
      ...nodes.heading,
      attributes: {
        ...nodes.heading.attributes,
        ...fieldsToMarkdocAttributes(editorConfig.heading.schema)
      }
    };
  } else {
    config.nodes.heading = undefined;
  }
  if (!editorConfig.blockquote) {
    config.nodes.blockquote = undefined;
  }
  if (editorConfig.codeBlock) {
    config.nodes.fence = {
      ...nodes.fence,
      attributes: {
        ...nodes.fence.attributes,
        ...fieldsToMarkdocAttributes(editorConfig.codeBlock.schema)
      }
    };
  } else {
    config.nodes.fence = undefined;
  }
  if (!editorConfig.orderedList && !editorConfig.unorderedList) {
    config.nodes.list = undefined;
  }
  if (!editorConfig.bold) {
    config.nodes.strong = undefined;
  }
  if (!editorConfig.italic) {
    config.nodes.em = undefined;
  }
  if (!editorConfig.strikethrough) {
    config.nodes.s = undefined;
  }
  if (!editorConfig.link) {
    config.nodes.link = undefined;
  }
  if (!editorConfig.image) {
    config.nodes.image = undefined;
  }
  if (!editorConfig.divider) {
    config.nodes.hr = undefined;
  }
  if (!editorConfig.table) {
    config.nodes.table = undefined;
  }
  for (const [name, component] of Object.entries(opts.components || {})) {
    var _opts$render;
    const isEmpty = component.kind === 'block' || component.kind === 'inline';
    config.tags[name] = {
      render: (_opts$render = opts.render) === null || _opts$render === void 0 || (_opts$render = _opts$render.tags) === null || _opts$render === void 0 ? void 0 : _opts$render[name],
      children: isEmpty ? [] : undefined,
      selfClosing: isEmpty,
      attributes: fieldsToMarkdocAttributes(component.schema),
      description: 'description' in component ? component.description : undefined,
      inline: component.kind === 'inline' || component.kind === 'mark'
    };
  }
  for (const [name, render] of Object.entries(((_opts$render2 = opts.render) === null || _opts$render2 === void 0 ? void 0 : _opts$render2.nodes) || {})) {
    var _opts$render2;
    const nodeSchema = config.nodes[name];
    if (nodeSchema) {
      nodeSchema.render = render;
    }
  }
  return config;
}

const textDecoder = new TextDecoder();

/**
 * @deprecated This is experimental and buggy, use at your own risk.
 */
function __experimental_markdoc_field({
  label,
  description,
  options = {},
  components = {}
}) {
  let schema;
  const config = editorOptionsToConfig(options);
  let getSchema = () => {
    if (!schema) {
      schema = createEditorSchema();
    }
    return schema;
  };
  return {
    kind: 'form',
    formKind: 'content',
    defaultValue() {
      return getDefaultValue(getSchema());
    },
    Input(props) {
      return /*#__PURE__*/jsx(DocumentFieldInput, {
        description: description,
        label: label,
        ...props
      });
    },
    parse: (_, {
      content,
      other,
      external,
      slug
    }) => {
      return parseToEditorState(content, getSchema());
    },
    contentExtension: '.mdoc',
    validate(value) {
      return value;
    },
    directories: [...collectDirectoriesUsedInSchema(object(Object.fromEntries(Object.entries(components).map(([name, component]) => [name, object(component.schema)])))), ...(typeof config.image === 'object' && typeof config.image.directory === 'string' ? [fixPath(config.image.directory)] : [])],
    serialize(value, {
      slug
    }) {
      return {
        ...serializeFromEditorState(),
        value: undefined
      };
    },
    reader: {
      parse: (_, {
        content
      }) => {
        const text = textDecoder.decode(content);
        return {
          node: Markdoc.parse(text)
        };
      }
    },
    collaboration: {
      toYjs(value) {
        return prosemirrorToYXmlFragment(value.doc);
      },
      fromYjs(yjsValue, awareness) {
        return createEditorStateFromYJS(getSchema());
      }
    }
  };
}
/**
 * @deprecated This is experimental and buggy, use at your own risk.
 */
function __experimental_mdx_field({
  label,
  description,
  options = {},
  components = {}
}) {
  let schema;
  const config = editorOptionsToConfig(options);
  let getSchema = () => {
    if (!schema) {
      schema = createEditorSchema();
    }
    return schema;
  };
  return {
    kind: 'form',
    formKind: 'content',
    defaultValue() {
      return getDefaultValue(getSchema());
    },
    Input(props) {
      return /*#__PURE__*/jsx(DocumentFieldInput, {
        description: description,
        label: label,
        ...props
      });
    },
    parse: (_, {
      content,
      other,
      external,
      slug
    }) => {
      return parseToEditorStateMDX(content, getSchema());
    },
    contentExtension: '.mdx',
    validate(value) {
      return value;
    },
    directories: [...collectDirectoriesUsedInSchema(object(Object.fromEntries(Object.entries(components).map(([name, component]) => [name, object(component.schema)])))), ...(typeof config.image === 'object' && typeof config.image.directory === 'string' ? [fixPath(config.image.directory)] : [])],
    serialize(value, {
      slug
    }) {
      return {
        ...serializeFromEditorStateMDX(),
        value: undefined
      };
    },
    reader: {
      parse: (_, {
        content
      }) => {
        const text = textDecoder.decode(content);
        return text;
      }
    }
  };
}
function __experimental_markdoc_field_cloudImageBlock(args) {
  return block({
    label: args.label,
    schema: cloudImageSchema,
    NodeView: CloudImagePreviewForNewEditor,
    icon: cloudImageToolbarIcon
  });
}

export { __experimental_markdoc_field, __experimental_markdoc_field_cloudImageBlock, __experimental_mdx_field, createMarkdocConfig };
