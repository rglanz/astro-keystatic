import {
  bytesToHex,
  require_cookie,
  z
} from "./chunk-CO6I4FWO.js";
import {
  require_jsx_runtime
} from "./chunk-6Y4BSO2J.js";
import {
  require_react_dom
} from "./chunk-JDB2MZQC.js";
import {
  require_react
} from "./chunk-ZVHPWISC.js";
import {
  __commonJS,
  __export,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField,
  __toESM
} from "./chunk-UF6YC252.js";

// node_modules/direction/index.js
var require_direction = __commonJS({
  "node_modules/direction/index.js"(exports, module) {
    "use strict";
    module.exports = direction;
    var RTL = "֑-߿יִ-﷽ﹰ-ﻼ";
    var LTR = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿";
    var rtl = new RegExp("^[^" + LTR + "]*[" + RTL + "]");
    var ltr = new RegExp("^[^" + RTL + "]*[" + LTR + "]");
    function direction(value2) {
      value2 = String(value2 || "");
      if (rtl.test(value2)) {
        return "rtl";
      }
      if (ltr.test(value2)) {
        return "ltr";
      }
      return "neutral";
    }
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports, module) {
    function isObject2(value2) {
      var type2 = typeof value2;
      return value2 != null && (type2 == "object" || type2 == "function");
    }
    module.exports = isObject2;
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports, module) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  }
});

// node_modules/lodash/now.js
var require_now = __commonJS({
  "node_modules/lodash/now.js"(exports, module) {
    var root = require_root();
    var now = function() {
      return root.Date.now();
    };
    module.exports = now;
  }
});

// node_modules/lodash/_trimmedEndIndex.js
var require_trimmedEndIndex = __commonJS({
  "node_modules/lodash/_trimmedEndIndex.js"(exports, module) {
    var reWhitespace = /\s/;
    function trimmedEndIndex(string3) {
      var index3 = string3.length;
      while (index3-- && reWhitespace.test(string3.charAt(index3))) {
      }
      return index3;
    }
    module.exports = trimmedEndIndex;
  }
});

// node_modules/lodash/_baseTrim.js
var require_baseTrim = __commonJS({
  "node_modules/lodash/_baseTrim.js"(exports, module) {
    var trimmedEndIndex = require_trimmedEndIndex();
    var reTrimStart = /^\s+/;
    function baseTrim(string3) {
      return string3 ? string3.slice(0, trimmedEndIndex(string3) + 1).replace(reTrimStart, "") : string3;
    }
    module.exports = baseTrim;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports, module) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty4 = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value2) {
      var isOwn = hasOwnProperty4.call(value2, symToStringTag), tag2 = value2[symToStringTag];
      try {
        value2[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e6) {
      }
      var result = nativeObjectToString.call(value2);
      if (unmasked) {
        if (isOwn) {
          value2[symToStringTag] = tag2;
        } else {
          delete value2[symToStringTag];
        }
      }
      return result;
    }
    module.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports, module) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value2) {
      return nativeObjectToString.call(value2);
    }
    module.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value2) {
      if (value2 == null) {
        return value2 === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value2) ? getRawTag(value2) : objectToString(value2);
    }
    module.exports = baseGetTag;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports, module) {
    function isObjectLike2(value2) {
      return value2 != null && typeof value2 == "object";
    }
    module.exports = isObjectLike2;
  }
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/lodash/isSymbol.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike2 = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value2) {
      return typeof value2 == "symbol" || isObjectLike2(value2) && baseGetTag(value2) == symbolTag;
    }
    module.exports = isSymbol;
  }
});

// node_modules/lodash/toNumber.js
var require_toNumber = __commonJS({
  "node_modules/lodash/toNumber.js"(exports, module) {
    var baseTrim = require_baseTrim();
    var isObject2 = require_isObject();
    var isSymbol = require_isSymbol();
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber2(value2) {
      if (typeof value2 == "number") {
        return value2;
      }
      if (isSymbol(value2)) {
        return NAN;
      }
      if (isObject2(value2)) {
        var other = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
        value2 = isObject2(other) ? other + "" : other;
      }
      if (typeof value2 != "string") {
        return value2 === 0 ? value2 : +value2;
      }
      value2 = baseTrim(value2);
      var isBinary2 = reIsBinary.test(value2);
      return isBinary2 || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary2 ? 2 : 8) : reIsBadHex.test(value2) ? NAN : +value2;
    }
    module.exports = toNumber2;
  }
});

// node_modules/lodash/debounce.js
var require_debounce = __commonJS({
  "node_modules/lodash/debounce.js"(exports, module) {
    var isObject2 = require_isObject();
    var now = require_now();
    var toNumber2 = require_toNumber();
    var FUNC_ERROR_TEXT = "Expected a function";
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    function debounce2(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber2(wait) || 0;
      if (isObject2(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber2(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time2) {
        var args2 = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time2;
        result = func.apply(thisArg, args2);
        return result;
      }
      function leadingEdge(time2) {
        lastInvokeTime = time2;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time2) : result;
      }
      function remainingWait(time2) {
        var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time2) {
        var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time2 = now();
        if (shouldInvoke(time2)) {
          return trailingEdge(time2);
        }
        timerId = setTimeout(timerExpired, remainingWait(time2));
      }
      function trailingEdge(time2) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time2);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush2() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time2 = now(), isInvoking = shouldInvoke(time2);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time2;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush2;
      return debounced;
    }
    module.exports = debounce2;
  }
});

// node_modules/lodash/throttle.js
var require_throttle = __commonJS({
  "node_modules/lodash/throttle.js"(exports, module) {
    var debounce2 = require_debounce();
    var isObject2 = require_isObject();
    var FUNC_ERROR_TEXT = "Expected a function";
    function throttle2(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject2(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce2(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    module.exports = throttle2;
  }
});

// node_modules/slate-react/node_modules/is-hotkey/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/slate-react/node_modules/is-hotkey/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var IS_MAC = typeof window != "undefined" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
    var MODIFIERS = {
      alt: "altKey",
      control: "ctrlKey",
      meta: "metaKey",
      shift: "shiftKey"
    };
    var ALIASES = {
      add: "+",
      break: "pause",
      cmd: "meta",
      command: "meta",
      ctl: "control",
      ctrl: "control",
      del: "delete",
      down: "arrowdown",
      esc: "escape",
      ins: "insert",
      left: "arrowleft",
      mod: IS_MAC ? "meta" : "control",
      opt: "alt",
      option: "alt",
      return: "enter",
      right: "arrowright",
      space: " ",
      spacebar: " ",
      up: "arrowup",
      win: "meta",
      windows: "meta"
    };
    var CODES = {
      backspace: 8,
      tab: 9,
      enter: 13,
      shift: 16,
      control: 17,
      alt: 18,
      pause: 19,
      capslock: 20,
      escape: 27,
      " ": 32,
      pageup: 33,
      pagedown: 34,
      end: 35,
      home: 36,
      arrowleft: 37,
      arrowup: 38,
      arrowright: 39,
      arrowdown: 40,
      insert: 45,
      delete: 46,
      meta: 91,
      numlock: 144,
      scrolllock: 145,
      ";": 186,
      "=": 187,
      ",": 188,
      "-": 189,
      ".": 190,
      "/": 191,
      "`": 192,
      "[": 219,
      "\\": 220,
      "]": 221,
      "'": 222
    };
    for (f6 = 1; f6 < 20; f6++) {
      CODES["f" + f6] = 111 + f6;
    }
    var f6;
    function isHotkey2(hotkey, options, event) {
      if (options && !("byKey" in options)) {
        event = options;
        options = null;
      }
      if (!Array.isArray(hotkey)) {
        hotkey = [hotkey];
      }
      var array = hotkey.map(function(string3) {
        return parseHotkey(string3, options);
      });
      var check = function check2(e6) {
        return array.some(function(object2) {
          return compareHotkey(object2, e6);
        });
      };
      var ret = event == null ? check : check(event);
      return ret;
    }
    function isCodeHotkey(hotkey, event) {
      return isHotkey2(hotkey, event);
    }
    function isKeyHotkey2(hotkey, event) {
      return isHotkey2(hotkey, { byKey: true }, event);
    }
    function parseHotkey(hotkey, options) {
      var byKey = options && options.byKey;
      var ret = {};
      hotkey = hotkey.replace("++", "+add");
      var values3 = hotkey.split("+");
      var length4 = values3.length;
      for (var k2 in MODIFIERS) {
        ret[MODIFIERS[k2]] = false;
      }
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = values3[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var value2 = _step.value;
          var optional = value2.endsWith("?") && value2.length > 1;
          if (optional) {
            value2 = value2.slice(0, -1);
          }
          var name2 = toKeyName(value2);
          var modifier = MODIFIERS[name2];
          if (length4 === 1 || !modifier) {
            if (byKey) {
              ret.key = name2;
            } else {
              ret.which = toKeyCode(value2);
            }
          }
          if (modifier) {
            ret[modifier] = optional ? null : true;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return ret;
    }
    function compareHotkey(object2, event) {
      for (var key in object2) {
        var expected = object2[key];
        var actual = void 0;
        if (expected == null) {
          continue;
        }
        if (key === "key" && event.key != null) {
          actual = event.key.toLowerCase();
        } else if (key === "which") {
          actual = expected === 91 && event.which === 93 ? 91 : event.which;
        } else {
          actual = event[key];
        }
        if (actual == null && expected === false) {
          continue;
        }
        if (actual !== expected) {
          return false;
        }
      }
      return true;
    }
    function toKeyCode(name2) {
      name2 = toKeyName(name2);
      var code3 = CODES[name2] || name2.toUpperCase().charCodeAt(0);
      return code3;
    }
    function toKeyName(name2) {
      name2 = name2.toLowerCase();
      name2 = ALIASES[name2] || name2;
      return name2;
    }
    exports.default = isHotkey2;
    exports.isHotkey = isHotkey2;
    exports.isCodeHotkey = isCodeHotkey;
    exports.isKeyHotkey = isKeyHotkey2;
    exports.parseHotkey = parseHotkey;
    exports.compareHotkey = compareHotkey;
    exports.toKeyCode = toKeyCode;
    exports.toKeyName = toKeyName;
  }
});

// node_modules/is-hotkey/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/is-hotkey/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var IS_MAC = typeof window != "undefined" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
    var MODIFIERS = {
      alt: "altKey",
      control: "ctrlKey",
      meta: "metaKey",
      shift: "shiftKey"
    };
    var ALIASES = {
      add: "+",
      break: "pause",
      cmd: "meta",
      command: "meta",
      ctl: "control",
      ctrl: "control",
      del: "delete",
      down: "arrowdown",
      esc: "escape",
      ins: "insert",
      left: "arrowleft",
      mod: IS_MAC ? "meta" : "control",
      opt: "alt",
      option: "alt",
      return: "enter",
      right: "arrowright",
      space: " ",
      spacebar: " ",
      up: "arrowup",
      win: "meta",
      windows: "meta"
    };
    var CODES = {
      backspace: 8,
      tab: 9,
      enter: 13,
      shift: 16,
      control: 17,
      alt: 18,
      pause: 19,
      capslock: 20,
      escape: 27,
      " ": 32,
      pageup: 33,
      pagedown: 34,
      end: 35,
      home: 36,
      arrowleft: 37,
      arrowup: 38,
      arrowright: 39,
      arrowdown: 40,
      insert: 45,
      delete: 46,
      meta: 91,
      numlock: 144,
      scrolllock: 145,
      ";": 186,
      "=": 187,
      ",": 188,
      "-": 189,
      ".": 190,
      "/": 191,
      "`": 192,
      "[": 219,
      "\\": 220,
      "]": 221,
      "'": 222
    };
    for (f6 = 1; f6 < 20; f6++) {
      CODES["f" + f6] = 111 + f6;
    }
    var f6;
    function isHotkey2(hotkey, options, event) {
      if (options && !("byKey" in options)) {
        event = options;
        options = null;
      }
      if (!Array.isArray(hotkey)) {
        hotkey = [hotkey];
      }
      var array = hotkey.map(function(string3) {
        return parseHotkey(string3, options);
      });
      var check = function check2(e6) {
        return array.some(function(object2) {
          return compareHotkey(object2, e6);
        });
      };
      var ret = event == null ? check : check(event);
      return ret;
    }
    function isCodeHotkey(hotkey, event) {
      return isHotkey2(hotkey, event);
    }
    function isKeyHotkey2(hotkey, event) {
      return isHotkey2(hotkey, { byKey: true }, event);
    }
    function parseHotkey(hotkey, options) {
      var byKey = options && options.byKey;
      var ret = {};
      hotkey = hotkey.replace("++", "+add");
      var values3 = hotkey.split("+");
      var length4 = values3.length;
      for (var k2 in MODIFIERS) {
        ret[MODIFIERS[k2]] = false;
      }
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = values3[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var value2 = _step.value;
          var optional = value2.endsWith("?") && value2.length > 1;
          if (optional) {
            value2 = value2.slice(0, -1);
          }
          var name2 = toKeyName(value2);
          var modifier = MODIFIERS[name2];
          if (value2.length > 1 && !modifier && !ALIASES[value2] && !CODES[name2]) {
            throw new TypeError('Unknown modifier: "' + value2 + '"');
          }
          if (length4 === 1 || !modifier) {
            if (byKey) {
              ret.key = name2;
            } else {
              ret.which = toKeyCode(value2);
            }
          }
          if (modifier) {
            ret[modifier] = optional ? null : true;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return ret;
    }
    function compareHotkey(object2, event) {
      for (var key in object2) {
        var expected = object2[key];
        var actual = void 0;
        if (expected == null) {
          continue;
        }
        if (key === "key" && event.key != null) {
          actual = event.key.toLowerCase();
        } else if (key === "which") {
          actual = expected === 91 && event.which === 93 ? 91 : event.which;
        } else {
          actual = event[key];
        }
        if (actual == null && expected === false) {
          continue;
        }
        if (actual !== expected) {
          return false;
        }
      }
      return true;
    }
    function toKeyCode(name2) {
      name2 = toKeyName(name2);
      var code3 = CODES[name2] || name2.toUpperCase().charCodeAt(0);
      return code3;
    }
    function toKeyName(name2) {
      name2 = name2.toLowerCase();
      name2 = ALIASES[name2] || name2;
      return name2;
    }
    exports.default = isHotkey2;
    exports.isHotkey = isHotkey2;
    exports.isCodeHotkey = isCodeHotkey;
    exports.isKeyHotkey = isKeyHotkey2;
    exports.parseHotkey = parseHotkey;
    exports.compareHotkey = compareHotkey;
    exports.toKeyCode = toKeyCode;
    exports.toKeyName = toKeyName;
  }
});

// node_modules/@braintree/sanitize-url/dist/index.js
var require_dist = __commonJS({
  "node_modules/@braintree/sanitize-url/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sanitizeUrl = exports.BLANK_URL = void 0;
    var invalidProtocolRegex = /^([^\w]*)(javascript|data|vbscript)/im;
    var htmlEntitiesRegex = /&#(\w+)(^\w|;)?/g;
    var htmlCtrlEntityRegex = /&(newline|tab);/gi;
    var ctrlCharactersRegex = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim;
    var urlSchemeRegex = /^.+(:|&colon;)/gim;
    var relativeFirstCharacters = [".", "/"];
    exports.BLANK_URL = "about:blank";
    function isRelativeUrlWithoutProtocol(url) {
      return relativeFirstCharacters.indexOf(url[0]) > -1;
    }
    function decodeHtmlCharacters(str) {
      var removedNullByte = str.replace(ctrlCharactersRegex, "");
      return removedNullByte.replace(htmlEntitiesRegex, function(match3, dec) {
        return String.fromCharCode(dec);
      });
    }
    function sanitizeUrl2(url) {
      if (!url) {
        return exports.BLANK_URL;
      }
      var sanitizedUrl = decodeHtmlCharacters(url).replace(htmlCtrlEntityRegex, "").replace(ctrlCharactersRegex, "").trim();
      if (!sanitizedUrl) {
        return exports.BLANK_URL;
      }
      if (isRelativeUrlWithoutProtocol(sanitizedUrl)) {
        return sanitizedUrl;
      }
      var urlSchemeParseResults = sanitizedUrl.match(urlSchemeRegex);
      if (!urlSchemeParseResults) {
        return sanitizedUrl;
      }
      var urlScheme = urlSchemeParseResults[0];
      if (invalidProtocolRegex.test(urlScheme)) {
        return exports.BLANK_URL;
      }
      return sanitizedUrl;
    }
    exports.sanitizeUrl = sanitizeUrl2;
  }
});

// node_modules/remove-accents/index.js
var require_remove_accents = __commonJS({
  "node_modules/remove-accents/index.js"(exports, module) {
    var characterMap = {
      "À": "A",
      "Á": "A",
      "Â": "A",
      "Ã": "A",
      "Ä": "A",
      "Å": "A",
      "Ấ": "A",
      "Ắ": "A",
      "Ẳ": "A",
      "Ẵ": "A",
      "Ặ": "A",
      "Æ": "AE",
      "Ầ": "A",
      "Ằ": "A",
      "Ȃ": "A",
      "Ả": "A",
      "Ạ": "A",
      "Ẩ": "A",
      "Ẫ": "A",
      "Ậ": "A",
      "Ç": "C",
      "Ḉ": "C",
      "È": "E",
      "É": "E",
      "Ê": "E",
      "Ë": "E",
      "Ế": "E",
      "Ḗ": "E",
      "Ề": "E",
      "Ḕ": "E",
      "Ḝ": "E",
      "Ȇ": "E",
      "Ẻ": "E",
      "Ẽ": "E",
      "Ẹ": "E",
      "Ể": "E",
      "Ễ": "E",
      "Ệ": "E",
      "Ì": "I",
      "Í": "I",
      "Î": "I",
      "Ï": "I",
      "Ḯ": "I",
      "Ȋ": "I",
      "Ỉ": "I",
      "Ị": "I",
      "Ð": "D",
      "Ñ": "N",
      "Ò": "O",
      "Ó": "O",
      "Ô": "O",
      "Õ": "O",
      "Ö": "O",
      "Ø": "O",
      "Ố": "O",
      "Ṍ": "O",
      "Ṓ": "O",
      "Ȏ": "O",
      "Ỏ": "O",
      "Ọ": "O",
      "Ổ": "O",
      "Ỗ": "O",
      "Ộ": "O",
      "Ờ": "O",
      "Ở": "O",
      "Ỡ": "O",
      "Ớ": "O",
      "Ợ": "O",
      "Ù": "U",
      "Ú": "U",
      "Û": "U",
      "Ü": "U",
      "Ủ": "U",
      "Ụ": "U",
      "Ử": "U",
      "Ữ": "U",
      "Ự": "U",
      "Ý": "Y",
      "à": "a",
      "á": "a",
      "â": "a",
      "ã": "a",
      "ä": "a",
      "å": "a",
      "ấ": "a",
      "ắ": "a",
      "ẳ": "a",
      "ẵ": "a",
      "ặ": "a",
      "æ": "ae",
      "ầ": "a",
      "ằ": "a",
      "ȃ": "a",
      "ả": "a",
      "ạ": "a",
      "ẩ": "a",
      "ẫ": "a",
      "ậ": "a",
      "ç": "c",
      "ḉ": "c",
      "è": "e",
      "é": "e",
      "ê": "e",
      "ë": "e",
      "ế": "e",
      "ḗ": "e",
      "ề": "e",
      "ḕ": "e",
      "ḝ": "e",
      "ȇ": "e",
      "ẻ": "e",
      "ẽ": "e",
      "ẹ": "e",
      "ể": "e",
      "ễ": "e",
      "ệ": "e",
      "ì": "i",
      "í": "i",
      "î": "i",
      "ï": "i",
      "ḯ": "i",
      "ȋ": "i",
      "ỉ": "i",
      "ị": "i",
      "ð": "d",
      "ñ": "n",
      "ò": "o",
      "ó": "o",
      "ô": "o",
      "õ": "o",
      "ö": "o",
      "ø": "o",
      "ố": "o",
      "ṍ": "o",
      "ṓ": "o",
      "ȏ": "o",
      "ỏ": "o",
      "ọ": "o",
      "ổ": "o",
      "ỗ": "o",
      "ộ": "o",
      "ờ": "o",
      "ở": "o",
      "ỡ": "o",
      "ớ": "o",
      "ợ": "o",
      "ù": "u",
      "ú": "u",
      "û": "u",
      "ü": "u",
      "ủ": "u",
      "ụ": "u",
      "ử": "u",
      "ữ": "u",
      "ự": "u",
      "ý": "y",
      "ÿ": "y",
      "Ā": "A",
      "ā": "a",
      "Ă": "A",
      "ă": "a",
      "Ą": "A",
      "ą": "a",
      "Ć": "C",
      "ć": "c",
      "Ĉ": "C",
      "ĉ": "c",
      "Ċ": "C",
      "ċ": "c",
      "Č": "C",
      "č": "c",
      "C̆": "C",
      "c̆": "c",
      "Ď": "D",
      "ď": "d",
      "Đ": "D",
      "đ": "d",
      "Ē": "E",
      "ē": "e",
      "Ĕ": "E",
      "ĕ": "e",
      "Ė": "E",
      "ė": "e",
      "Ę": "E",
      "ę": "e",
      "Ě": "E",
      "ě": "e",
      "Ĝ": "G",
      "Ǵ": "G",
      "ĝ": "g",
      "ǵ": "g",
      "Ğ": "G",
      "ğ": "g",
      "Ġ": "G",
      "ġ": "g",
      "Ģ": "G",
      "ģ": "g",
      "Ĥ": "H",
      "ĥ": "h",
      "Ħ": "H",
      "ħ": "h",
      "Ḫ": "H",
      "ḫ": "h",
      "Ĩ": "I",
      "ĩ": "i",
      "Ī": "I",
      "ī": "i",
      "Ĭ": "I",
      "ĭ": "i",
      "Į": "I",
      "į": "i",
      "İ": "I",
      "ı": "i",
      "Ĳ": "IJ",
      "ĳ": "ij",
      "Ĵ": "J",
      "ĵ": "j",
      "Ķ": "K",
      "ķ": "k",
      "Ḱ": "K",
      "ḱ": "k",
      "K̆": "K",
      "k̆": "k",
      "Ĺ": "L",
      "ĺ": "l",
      "Ļ": "L",
      "ļ": "l",
      "Ľ": "L",
      "ľ": "l",
      "Ŀ": "L",
      "ŀ": "l",
      "Ł": "l",
      "ł": "l",
      "Ḿ": "M",
      "ḿ": "m",
      "M̆": "M",
      "m̆": "m",
      "Ń": "N",
      "ń": "n",
      "Ņ": "N",
      "ņ": "n",
      "Ň": "N",
      "ň": "n",
      "ŉ": "n",
      "N̆": "N",
      "n̆": "n",
      "Ō": "O",
      "ō": "o",
      "Ŏ": "O",
      "ŏ": "o",
      "Ő": "O",
      "ő": "o",
      "Œ": "OE",
      "œ": "oe",
      "P̆": "P",
      "p̆": "p",
      "Ŕ": "R",
      "ŕ": "r",
      "Ŗ": "R",
      "ŗ": "r",
      "Ř": "R",
      "ř": "r",
      "R̆": "R",
      "r̆": "r",
      "Ȓ": "R",
      "ȓ": "r",
      "Ś": "S",
      "ś": "s",
      "Ŝ": "S",
      "ŝ": "s",
      "Ş": "S",
      "Ș": "S",
      "ș": "s",
      "ş": "s",
      "Š": "S",
      "š": "s",
      "Ţ": "T",
      "ţ": "t",
      "ț": "t",
      "Ț": "T",
      "Ť": "T",
      "ť": "t",
      "Ŧ": "T",
      "ŧ": "t",
      "T̆": "T",
      "t̆": "t",
      "Ũ": "U",
      "ũ": "u",
      "Ū": "U",
      "ū": "u",
      "Ŭ": "U",
      "ŭ": "u",
      "Ů": "U",
      "ů": "u",
      "Ű": "U",
      "ű": "u",
      "Ų": "U",
      "ų": "u",
      "Ȗ": "U",
      "ȗ": "u",
      "V̆": "V",
      "v̆": "v",
      "Ŵ": "W",
      "ŵ": "w",
      "Ẃ": "W",
      "ẃ": "w",
      "X̆": "X",
      "x̆": "x",
      "Ŷ": "Y",
      "ŷ": "y",
      "Ÿ": "Y",
      "Y̆": "Y",
      "y̆": "y",
      "Ź": "Z",
      "ź": "z",
      "Ż": "Z",
      "ż": "z",
      "Ž": "Z",
      "ž": "z",
      "ſ": "s",
      "ƒ": "f",
      "Ơ": "O",
      "ơ": "o",
      "Ư": "U",
      "ư": "u",
      "Ǎ": "A",
      "ǎ": "a",
      "Ǐ": "I",
      "ǐ": "i",
      "Ǒ": "O",
      "ǒ": "o",
      "Ǔ": "U",
      "ǔ": "u",
      "Ǖ": "U",
      "ǖ": "u",
      "Ǘ": "U",
      "ǘ": "u",
      "Ǚ": "U",
      "ǚ": "u",
      "Ǜ": "U",
      "ǜ": "u",
      "Ứ": "U",
      "ứ": "u",
      "Ṹ": "U",
      "ṹ": "u",
      "Ǻ": "A",
      "ǻ": "a",
      "Ǽ": "AE",
      "ǽ": "ae",
      "Ǿ": "O",
      "ǿ": "o",
      "Þ": "TH",
      "þ": "th",
      "Ṕ": "P",
      "ṕ": "p",
      "Ṥ": "S",
      "ṥ": "s",
      "X́": "X",
      "x́": "x",
      "Ѓ": "Г",
      "ѓ": "г",
      "Ќ": "К",
      "ќ": "к",
      "A̋": "A",
      "a̋": "a",
      "E̋": "E",
      "e̋": "e",
      "I̋": "I",
      "i̋": "i",
      "Ǹ": "N",
      "ǹ": "n",
      "Ồ": "O",
      "ồ": "o",
      "Ṑ": "O",
      "ṑ": "o",
      "Ừ": "U",
      "ừ": "u",
      "Ẁ": "W",
      "ẁ": "w",
      "Ỳ": "Y",
      "ỳ": "y",
      "Ȁ": "A",
      "ȁ": "a",
      "Ȅ": "E",
      "ȅ": "e",
      "Ȉ": "I",
      "ȉ": "i",
      "Ȍ": "O",
      "ȍ": "o",
      "Ȑ": "R",
      "ȑ": "r",
      "Ȕ": "U",
      "ȕ": "u",
      "B̌": "B",
      "b̌": "b",
      "Č̣": "C",
      "č̣": "c",
      "Ê̌": "E",
      "ê̌": "e",
      "F̌": "F",
      "f̌": "f",
      "Ǧ": "G",
      "ǧ": "g",
      "Ȟ": "H",
      "ȟ": "h",
      "J̌": "J",
      "ǰ": "j",
      "Ǩ": "K",
      "ǩ": "k",
      "M̌": "M",
      "m̌": "m",
      "P̌": "P",
      "p̌": "p",
      "Q̌": "Q",
      "q̌": "q",
      "Ř̩": "R",
      "ř̩": "r",
      "Ṧ": "S",
      "ṧ": "s",
      "V̌": "V",
      "v̌": "v",
      "W̌": "W",
      "w̌": "w",
      "X̌": "X",
      "x̌": "x",
      "Y̌": "Y",
      "y̌": "y",
      "A̧": "A",
      "a̧": "a",
      "B̧": "B",
      "b̧": "b",
      "Ḑ": "D",
      "ḑ": "d",
      "Ȩ": "E",
      "ȩ": "e",
      "Ɛ̧": "E",
      "ɛ̧": "e",
      "Ḩ": "H",
      "ḩ": "h",
      "I̧": "I",
      "i̧": "i",
      "Ɨ̧": "I",
      "ɨ̧": "i",
      "M̧": "M",
      "m̧": "m",
      "O̧": "O",
      "o̧": "o",
      "Q̧": "Q",
      "q̧": "q",
      "U̧": "U",
      "u̧": "u",
      "X̧": "X",
      "x̧": "x",
      "Z̧": "Z",
      "z̧": "z",
      "й": "и",
      "Й": "И",
      "ё": "е",
      "Ё": "Е"
    };
    var chars = Object.keys(characterMap).join("|");
    var allAccents = new RegExp(chars, "g");
    var firstAccent = new RegExp(chars, "");
    function matcher(match3) {
      return characterMap[match3];
    }
    var removeAccents2 = function(string3) {
      return string3.replace(allAccents, matcher);
    };
    var hasAccents = function(string3) {
      return !!string3.match(firstAccent);
    };
    module.exports = removeAccents2;
    module.exports.has = hasAccents;
    module.exports.remove = removeAccents2;
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports, module) {
    "use strict";
    module.exports = balanced;
    function balanced(a3, b2, str) {
      if (a3 instanceof RegExp)
        a3 = maybeMatch(a3, str);
      if (b2 instanceof RegExp)
        b2 = maybeMatch(b2, str);
      var r7 = range(a3, b2, str);
      return r7 && {
        start: r7[0],
        end: r7[1],
        pre: str.slice(0, r7[0]),
        body: str.slice(r7[0] + a3.length, r7[1]),
        post: str.slice(r7[1] + b2.length)
      };
    }
    function maybeMatch(reg, str) {
      var m3 = str.match(reg);
      return m3 ? m3[0] : null;
    }
    balanced.range = range;
    function range(a3, b2, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a3);
      var bi = str.indexOf(b2, ai + 1);
      var i6 = ai;
      if (ai >= 0 && bi > 0) {
        if (a3 === b2) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i6 >= 0 && !result) {
          if (i6 == ai) {
            begs.push(i6);
            ai = str.indexOf(a3, i6 + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b2, i6 + 1);
          }
          i6 = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports, module) {
    var balanced = require_balanced_match();
    module.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m3 = balanced("{", "}", str);
      if (!m3)
        return str.split(",");
      var pre = m3.pre;
      var body = m3.body;
      var post = m3.post;
      var p5 = pre.split(",");
      p5[p5.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p5[p5.length - 1] += postParts.shift();
        p5.push.apply(p5, postParts);
      }
      parts.push.apply(parts, p5);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand2(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i6, y4) {
      return i6 <= y4;
    }
    function gte(i6, y4) {
      return i6 >= y4;
    }
    function expand2(str, isTop) {
      var expansions = [];
      var m3 = balanced("{", "}", str);
      if (!m3)
        return [str];
      var pre = m3.pre;
      var post = m3.post.length ? expand2(m3.post, false) : [""];
      if (/\$$/.test(m3.pre)) {
        for (var k2 = 0; k2 < post.length; k2++) {
          var expansion = pre + "{" + m3.body + "}" + post[k2];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m3.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m3.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m3.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m3.post.match(/,.*\}/)) {
            str = m3.pre + "{" + m3.body + escClose + m3.post;
            return expand2(str);
          }
          return [str];
        }
        var n6;
        if (isSequence) {
          n6 = m3.body.split(/\.\./);
        } else {
          n6 = parseCommaParts(m3.body);
          if (n6.length === 1) {
            n6 = expand2(n6[0], false).map(embrace);
            if (n6.length === 1) {
              return post.map(function(p5) {
                return m3.pre + n6[0] + p5;
              });
            }
          }
        }
        var N2;
        if (isSequence) {
          var x4 = numeric(n6[0]);
          var y4 = numeric(n6[1]);
          var width = Math.max(n6[0].length, n6[1].length);
          var incr = n6.length == 3 ? Math.abs(numeric(n6[2])) : 1;
          var test = lte;
          var reverse = y4 < x4;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n6.some(isPadded);
          N2 = [];
          for (var i6 = x4; test(i6, y4); i6 += incr) {
            var c5;
            if (isAlphaSequence) {
              c5 = String.fromCharCode(i6);
              if (c5 === "\\")
                c5 = "";
            } else {
              c5 = String(i6);
              if (pad) {
                var need = width - c5.length;
                if (need > 0) {
                  var z3 = new Array(need + 1).join("0");
                  if (i6 < 0)
                    c5 = "-" + z3 + c5.slice(1);
                  else
                    c5 = z3 + c5;
                }
              }
            }
            N2.push(c5);
          }
        } else {
          N2 = [];
          for (var j4 = 0; j4 < n6.length; j4++) {
            N2.push.apply(N2, expand2(n6[j4], false));
          }
        }
        for (var j4 = 0; j4 < N2.length; j4++) {
          for (var k2 = 0; k2 < post.length; k2++) {
            var expansion = pre + N2[j4] + post[k2];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/escape-string-regexp/index.js"(exports, module) {
    "use strict";
    module.exports = (string3) => {
      if (typeof string3 !== "string") {
        throw new TypeError("Expected a string");
      }
      return string3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    };
  }
});

// node_modules/lodash.deburr/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.deburr/index.js"(exports, module) {
    var INFINITY = 1 / 0;
    var symbolTag = "[object Symbol]";
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
    var rsComboSymbolsRange = "\\u20d0-\\u20f0";
    var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
    var reComboMark = RegExp(rsCombo, "g");
    var deburredLetters = {
      // Latin-1 Supplement block.
      "À": "A",
      "Á": "A",
      "Â": "A",
      "Ã": "A",
      "Ä": "A",
      "Å": "A",
      "à": "a",
      "á": "a",
      "â": "a",
      "ã": "a",
      "ä": "a",
      "å": "a",
      "Ç": "C",
      "ç": "c",
      "Ð": "D",
      "ð": "d",
      "È": "E",
      "É": "E",
      "Ê": "E",
      "Ë": "E",
      "è": "e",
      "é": "e",
      "ê": "e",
      "ë": "e",
      "Ì": "I",
      "Í": "I",
      "Î": "I",
      "Ï": "I",
      "ì": "i",
      "í": "i",
      "î": "i",
      "ï": "i",
      "Ñ": "N",
      "ñ": "n",
      "Ò": "O",
      "Ó": "O",
      "Ô": "O",
      "Õ": "O",
      "Ö": "O",
      "Ø": "O",
      "ò": "o",
      "ó": "o",
      "ô": "o",
      "õ": "o",
      "ö": "o",
      "ø": "o",
      "Ù": "U",
      "Ú": "U",
      "Û": "U",
      "Ü": "U",
      "ù": "u",
      "ú": "u",
      "û": "u",
      "ü": "u",
      "Ý": "Y",
      "ý": "y",
      "ÿ": "y",
      "Æ": "Ae",
      "æ": "ae",
      "Þ": "Th",
      "þ": "th",
      "ß": "ss",
      // Latin Extended-A block.
      "Ā": "A",
      "Ă": "A",
      "Ą": "A",
      "ā": "a",
      "ă": "a",
      "ą": "a",
      "Ć": "C",
      "Ĉ": "C",
      "Ċ": "C",
      "Č": "C",
      "ć": "c",
      "ĉ": "c",
      "ċ": "c",
      "č": "c",
      "Ď": "D",
      "Đ": "D",
      "ď": "d",
      "đ": "d",
      "Ē": "E",
      "Ĕ": "E",
      "Ė": "E",
      "Ę": "E",
      "Ě": "E",
      "ē": "e",
      "ĕ": "e",
      "ė": "e",
      "ę": "e",
      "ě": "e",
      "Ĝ": "G",
      "Ğ": "G",
      "Ġ": "G",
      "Ģ": "G",
      "ĝ": "g",
      "ğ": "g",
      "ġ": "g",
      "ģ": "g",
      "Ĥ": "H",
      "Ħ": "H",
      "ĥ": "h",
      "ħ": "h",
      "Ĩ": "I",
      "Ī": "I",
      "Ĭ": "I",
      "Į": "I",
      "İ": "I",
      "ĩ": "i",
      "ī": "i",
      "ĭ": "i",
      "į": "i",
      "ı": "i",
      "Ĵ": "J",
      "ĵ": "j",
      "Ķ": "K",
      "ķ": "k",
      "ĸ": "k",
      "Ĺ": "L",
      "Ļ": "L",
      "Ľ": "L",
      "Ŀ": "L",
      "Ł": "L",
      "ĺ": "l",
      "ļ": "l",
      "ľ": "l",
      "ŀ": "l",
      "ł": "l",
      "Ń": "N",
      "Ņ": "N",
      "Ň": "N",
      "Ŋ": "N",
      "ń": "n",
      "ņ": "n",
      "ň": "n",
      "ŋ": "n",
      "Ō": "O",
      "Ŏ": "O",
      "Ő": "O",
      "ō": "o",
      "ŏ": "o",
      "ő": "o",
      "Ŕ": "R",
      "Ŗ": "R",
      "Ř": "R",
      "ŕ": "r",
      "ŗ": "r",
      "ř": "r",
      "Ś": "S",
      "Ŝ": "S",
      "Ş": "S",
      "Š": "S",
      "ś": "s",
      "ŝ": "s",
      "ş": "s",
      "š": "s",
      "Ţ": "T",
      "Ť": "T",
      "Ŧ": "T",
      "ţ": "t",
      "ť": "t",
      "ŧ": "t",
      "Ũ": "U",
      "Ū": "U",
      "Ŭ": "U",
      "Ů": "U",
      "Ű": "U",
      "Ų": "U",
      "ũ": "u",
      "ū": "u",
      "ŭ": "u",
      "ů": "u",
      "ű": "u",
      "ų": "u",
      "Ŵ": "W",
      "ŵ": "w",
      "Ŷ": "Y",
      "ŷ": "y",
      "Ÿ": "Y",
      "Ź": "Z",
      "Ż": "Z",
      "Ž": "Z",
      "ź": "z",
      "ż": "z",
      "ž": "z",
      "Ĳ": "IJ",
      "ĳ": "ij",
      "Œ": "Oe",
      "œ": "oe",
      "ŉ": "'n",
      "ſ": "ss"
    };
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function basePropertyOf(object2) {
      return function(key) {
        return object2 == null ? void 0 : object2[key];
      };
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var Symbol2 = root.Symbol;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value2) {
      if (typeof value2 == "string") {
        return value2;
      }
      if (isSymbol(value2)) {
        return symbolToString ? symbolToString.call(value2) : "";
      }
      var result = value2 + "";
      return result == "0" && 1 / value2 == -INFINITY ? "-0" : result;
    }
    function isObjectLike2(value2) {
      return !!value2 && typeof value2 == "object";
    }
    function isSymbol(value2) {
      return typeof value2 == "symbol" || isObjectLike2(value2) && objectToString.call(value2) == symbolTag;
    }
    function toString3(value2) {
      return value2 == null ? "" : baseToString(value2);
    }
    function deburr(string3) {
      string3 = toString3(string3);
      return string3 && string3.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    module.exports = deburr;
  }
});

// node_modules/@sindresorhus/transliterate/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp2 = __commonJS({
  "node_modules/@sindresorhus/transliterate/node_modules/escape-string-regexp/index.js"(exports, module) {
    "use strict";
    var matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;
    module.exports = (string3) => {
      if (typeof string3 !== "string") {
        throw new TypeError("Expected a string");
      }
      return string3.replace(matchOperatorsRegex, "\\$&");
    };
  }
});

// node_modules/@sindresorhus/transliterate/replacements.js
var require_replacements2 = __commonJS({
  "node_modules/@sindresorhus/transliterate/replacements.js"(exports, module) {
    "use strict";
    module.exports = [
      // German umlauts
      ["ß", "ss"],
      ["ä", "ae"],
      ["Ä", "Ae"],
      ["ö", "oe"],
      ["Ö", "Oe"],
      ["ü", "ue"],
      ["Ü", "Ue"],
      // Latin
      ["À", "A"],
      ["Á", "A"],
      ["Â", "A"],
      ["Ã", "A"],
      ["Ä", "Ae"],
      ["Å", "A"],
      ["Æ", "AE"],
      ["Ç", "C"],
      ["È", "E"],
      ["É", "E"],
      ["Ê", "E"],
      ["Ë", "E"],
      ["Ì", "I"],
      ["Í", "I"],
      ["Î", "I"],
      ["Ï", "I"],
      ["Ð", "D"],
      ["Ñ", "N"],
      ["Ò", "O"],
      ["Ó", "O"],
      ["Ô", "O"],
      ["Õ", "O"],
      ["Ö", "Oe"],
      ["Ő", "O"],
      ["Ø", "O"],
      ["Ù", "U"],
      ["Ú", "U"],
      ["Û", "U"],
      ["Ü", "Ue"],
      ["Ű", "U"],
      ["Ý", "Y"],
      ["Þ", "TH"],
      ["ß", "ss"],
      ["à", "a"],
      ["á", "a"],
      ["â", "a"],
      ["ã", "a"],
      ["ä", "ae"],
      ["å", "a"],
      ["æ", "ae"],
      ["ç", "c"],
      ["è", "e"],
      ["é", "e"],
      ["ê", "e"],
      ["ë", "e"],
      ["ì", "i"],
      ["í", "i"],
      ["î", "i"],
      ["ï", "i"],
      ["ð", "d"],
      ["ñ", "n"],
      ["ò", "o"],
      ["ó", "o"],
      ["ô", "o"],
      ["õ", "o"],
      ["ö", "oe"],
      ["ő", "o"],
      ["ø", "o"],
      ["ù", "u"],
      ["ú", "u"],
      ["û", "u"],
      ["ü", "ue"],
      ["ű", "u"],
      ["ý", "y"],
      ["þ", "th"],
      ["ÿ", "y"],
      ["ẞ", "SS"],
      // Vietnamese
      ["à", "a"],
      ["À", "A"],
      ["á", "a"],
      ["Á", "A"],
      ["â", "a"],
      ["Â", "A"],
      ["ã", "a"],
      ["Ã", "A"],
      ["è", "e"],
      ["È", "E"],
      ["é", "e"],
      ["É", "E"],
      ["ê", "e"],
      ["Ê", "E"],
      ["ì", "i"],
      ["Ì", "I"],
      ["í", "i"],
      ["Í", "I"],
      ["ò", "o"],
      ["Ò", "O"],
      ["ó", "o"],
      ["Ó", "O"],
      ["ô", "o"],
      ["Ô", "O"],
      ["õ", "o"],
      ["Õ", "O"],
      ["ù", "u"],
      ["Ù", "U"],
      ["ú", "u"],
      ["Ú", "U"],
      ["ý", "y"],
      ["Ý", "Y"],
      ["ă", "a"],
      ["Ă", "A"],
      ["Đ", "D"],
      ["đ", "d"],
      ["ĩ", "i"],
      ["Ĩ", "I"],
      ["ũ", "u"],
      ["Ũ", "U"],
      ["ơ", "o"],
      ["Ơ", "O"],
      ["ư", "u"],
      ["Ư", "U"],
      ["ạ", "a"],
      ["Ạ", "A"],
      ["ả", "a"],
      ["Ả", "A"],
      ["ấ", "a"],
      ["Ấ", "A"],
      ["ầ", "a"],
      ["Ầ", "A"],
      ["ẩ", "a"],
      ["Ẩ", "A"],
      ["ẫ", "a"],
      ["Ẫ", "A"],
      ["ậ", "a"],
      ["Ậ", "A"],
      ["ắ", "a"],
      ["Ắ", "A"],
      ["ằ", "a"],
      ["Ằ", "A"],
      ["ẳ", "a"],
      ["Ẳ", "A"],
      ["ẵ", "a"],
      ["Ẵ", "A"],
      ["ặ", "a"],
      ["Ặ", "A"],
      ["ẹ", "e"],
      ["Ẹ", "E"],
      ["ẻ", "e"],
      ["Ẻ", "E"],
      ["ẽ", "e"],
      ["Ẽ", "E"],
      ["ế", "e"],
      ["Ế", "E"],
      ["ề", "e"],
      ["Ề", "E"],
      ["ể", "e"],
      ["Ể", "E"],
      ["ễ", "e"],
      ["Ễ", "E"],
      ["ệ", "e"],
      ["Ệ", "E"],
      ["ỉ", "i"],
      ["Ỉ", "I"],
      ["ị", "i"],
      ["Ị", "I"],
      ["ọ", "o"],
      ["Ọ", "O"],
      ["ỏ", "o"],
      ["Ỏ", "O"],
      ["ố", "o"],
      ["Ố", "O"],
      ["ồ", "o"],
      ["Ồ", "O"],
      ["ổ", "o"],
      ["Ổ", "O"],
      ["ỗ", "o"],
      ["Ỗ", "O"],
      ["ộ", "o"],
      ["Ộ", "O"],
      ["ớ", "o"],
      ["Ớ", "O"],
      ["ờ", "o"],
      ["Ờ", "O"],
      ["ở", "o"],
      ["Ở", "O"],
      ["ỡ", "o"],
      ["Ỡ", "O"],
      ["ợ", "o"],
      ["Ợ", "O"],
      ["ụ", "u"],
      ["Ụ", "U"],
      ["ủ", "u"],
      ["Ủ", "U"],
      ["ứ", "u"],
      ["Ứ", "U"],
      ["ừ", "u"],
      ["Ừ", "U"],
      ["ử", "u"],
      ["Ử", "U"],
      ["ữ", "u"],
      ["Ữ", "U"],
      ["ự", "u"],
      ["Ự", "U"],
      ["ỳ", "y"],
      ["Ỳ", "Y"],
      ["ỵ", "y"],
      ["Ỵ", "Y"],
      ["ỷ", "y"],
      ["Ỷ", "Y"],
      ["ỹ", "y"],
      ["Ỹ", "Y"],
      // Arabic
      ["ء", "e"],
      ["آ", "a"],
      ["أ", "a"],
      ["ؤ", "w"],
      ["إ", "i"],
      ["ئ", "y"],
      ["ا", "a"],
      ["ب", "b"],
      ["ة", "t"],
      ["ت", "t"],
      ["ث", "th"],
      ["ج", "j"],
      ["ح", "h"],
      ["خ", "kh"],
      ["د", "d"],
      ["ذ", "dh"],
      ["ر", "r"],
      ["ز", "z"],
      ["س", "s"],
      ["ش", "sh"],
      ["ص", "s"],
      ["ض", "d"],
      ["ط", "t"],
      ["ظ", "z"],
      ["ع", "e"],
      ["غ", "gh"],
      ["ـ", "_"],
      ["ف", "f"],
      ["ق", "q"],
      ["ك", "k"],
      ["ل", "l"],
      ["م", "m"],
      ["ن", "n"],
      ["ه", "h"],
      ["و", "w"],
      ["ى", "a"],
      ["ي", "y"],
      ["َ‎", "a"],
      ["ُ", "u"],
      ["ِ‎", "i"],
      ["٠", "0"],
      ["١", "1"],
      ["٢", "2"],
      ["٣", "3"],
      ["٤", "4"],
      ["٥", "5"],
      ["٦", "6"],
      ["٧", "7"],
      ["٨", "8"],
      ["٩", "9"],
      // Persian / Farsi
      ["چ", "ch"],
      ["ک", "k"],
      ["گ", "g"],
      ["پ", "p"],
      ["ژ", "zh"],
      ["ی", "y"],
      ["۰", "0"],
      ["۱", "1"],
      ["۲", "2"],
      ["۳", "3"],
      ["۴", "4"],
      ["۵", "5"],
      ["۶", "6"],
      ["۷", "7"],
      ["۸", "8"],
      ["۹", "9"],
      // Pashto
      ["ټ", "p"],
      ["ځ", "z"],
      ["څ", "c"],
      ["ډ", "d"],
      ["ﺫ", "d"],
      ["ﺭ", "r"],
      ["ړ", "r"],
      ["ﺯ", "z"],
      ["ږ", "g"],
      ["ښ", "x"],
      ["ګ", "g"],
      ["ڼ", "n"],
      ["ۀ", "e"],
      ["ې", "e"],
      ["ۍ", "ai"],
      // Urdu
      ["ٹ", "t"],
      ["ڈ", "d"],
      ["ڑ", "r"],
      ["ں", "n"],
      ["ہ", "h"],
      ["ھ", "h"],
      ["ے", "e"],
      // Russian
      ["А", "A"],
      ["а", "a"],
      ["Б", "B"],
      ["б", "b"],
      ["В", "V"],
      ["в", "v"],
      ["Г", "G"],
      ["г", "g"],
      ["Д", "D"],
      ["д", "d"],
      ["Е", "E"],
      ["е", "e"],
      ["Ж", "Zh"],
      ["ж", "zh"],
      ["З", "Z"],
      ["з", "z"],
      ["И", "I"],
      ["и", "i"],
      ["Й", "J"],
      ["й", "j"],
      ["К", "K"],
      ["к", "k"],
      ["Л", "L"],
      ["л", "l"],
      ["М", "M"],
      ["м", "m"],
      ["Н", "N"],
      ["н", "n"],
      ["О", "O"],
      ["о", "o"],
      ["П", "P"],
      ["п", "p"],
      ["Р", "R"],
      ["р", "r"],
      ["С", "S"],
      ["с", "s"],
      ["Т", "T"],
      ["т", "t"],
      ["У", "U"],
      ["у", "u"],
      ["Ф", "F"],
      ["ф", "f"],
      ["Х", "H"],
      ["х", "h"],
      ["Ц", "Cz"],
      ["ц", "cz"],
      ["Ч", "Ch"],
      ["ч", "ch"],
      ["Ш", "Sh"],
      ["ш", "sh"],
      ["Щ", "Shh"],
      ["щ", "shh"],
      ["Ъ", ""],
      ["ъ", ""],
      ["Ы", "Y"],
      ["ы", "y"],
      ["Ь", ""],
      ["ь", ""],
      ["Э", "E"],
      ["э", "e"],
      ["Ю", "Yu"],
      ["ю", "yu"],
      ["Я", "Ya"],
      ["я", "ya"],
      ["Ё", "Yo"],
      ["ё", "yo"],
      // Romanian
      ["ă", "a"],
      ["Ă", "A"],
      ["ș", "s"],
      ["Ș", "S"],
      ["ț", "t"],
      ["Ț", "T"],
      ["ţ", "t"],
      ["Ţ", "T"],
      // Turkish
      ["ş", "s"],
      ["Ş", "S"],
      ["ç", "c"],
      ["Ç", "C"],
      ["ğ", "g"],
      ["Ğ", "G"],
      ["ı", "i"],
      ["İ", "I"],
      // Armenian
      ["ա", "a"],
      ["Ա", "A"],
      ["բ", "b"],
      ["Բ", "B"],
      ["գ", "g"],
      ["Գ", "G"],
      ["դ", "d"],
      ["Դ", "D"],
      ["ե", "ye"],
      ["Ե", "Ye"],
      ["զ", "z"],
      ["Զ", "Z"],
      ["է", "e"],
      ["Է", "E"],
      ["ը", "y"],
      ["Ը", "Y"],
      ["թ", "t"],
      ["Թ", "T"],
      ["ժ", "zh"],
      ["Ժ", "Zh"],
      ["ի", "i"],
      ["Ի", "I"],
      ["լ", "l"],
      ["Լ", "L"],
      ["խ", "kh"],
      ["Խ", "Kh"],
      ["ծ", "ts"],
      ["Ծ", "Ts"],
      ["կ", "k"],
      ["Կ", "K"],
      ["հ", "h"],
      ["Հ", "H"],
      ["ձ", "dz"],
      ["Ձ", "Dz"],
      ["ղ", "gh"],
      ["Ղ", "Gh"],
      ["ճ", "tch"],
      ["Ճ", "Tch"],
      ["մ", "m"],
      ["Մ", "M"],
      ["յ", "y"],
      ["Յ", "Y"],
      ["ն", "n"],
      ["Ն", "N"],
      ["շ", "sh"],
      ["Շ", "Sh"],
      ["ո", "vo"],
      ["Ո", "Vo"],
      ["չ", "ch"],
      ["Չ", "Ch"],
      ["պ", "p"],
      ["Պ", "P"],
      ["ջ", "j"],
      ["Ջ", "J"],
      ["ռ", "r"],
      ["Ռ", "R"],
      ["ս", "s"],
      ["Ս", "S"],
      ["վ", "v"],
      ["Վ", "V"],
      ["տ", "t"],
      ["Տ", "T"],
      ["ր", "r"],
      ["Ր", "R"],
      ["ց", "c"],
      ["Ց", "C"],
      ["ու", "u"],
      ["ՈՒ", "U"],
      ["Ու", "U"],
      ["փ", "p"],
      ["Փ", "P"],
      ["ք", "q"],
      ["Ք", "Q"],
      ["օ", "o"],
      ["Օ", "O"],
      ["ֆ", "f"],
      ["Ֆ", "F"],
      ["և", "yev"],
      // Georgian
      ["ა", "a"],
      ["ბ", "b"],
      ["გ", "g"],
      ["დ", "d"],
      ["ე", "e"],
      ["ვ", "v"],
      ["ზ", "z"],
      ["თ", "t"],
      ["ი", "i"],
      ["კ", "k"],
      ["ლ", "l"],
      ["მ", "m"],
      ["ნ", "n"],
      ["ო", "o"],
      ["პ", "p"],
      ["ჟ", "zh"],
      ["რ", "r"],
      ["ს", "s"],
      ["ტ", "t"],
      ["უ", "u"],
      ["ფ", "ph"],
      ["ქ", "q"],
      ["ღ", "gh"],
      ["ყ", "k"],
      ["შ", "sh"],
      ["ჩ", "ch"],
      ["ც", "ts"],
      ["ძ", "dz"],
      ["წ", "ts"],
      ["ჭ", "tch"],
      ["ხ", "kh"],
      ["ჯ", "j"],
      ["ჰ", "h"],
      // Czech
      ["č", "c"],
      ["ď", "d"],
      ["ě", "e"],
      ["ň", "n"],
      ["ř", "r"],
      ["š", "s"],
      ["ť", "t"],
      ["ů", "u"],
      ["ž", "z"],
      ["Č", "C"],
      ["Ď", "D"],
      ["Ě", "E"],
      ["Ň", "N"],
      ["Ř", "R"],
      ["Š", "S"],
      ["Ť", "T"],
      ["Ů", "U"],
      ["Ž", "Z"],
      // Dhivehi
      ["ހ", "h"],
      ["ށ", "sh"],
      ["ނ", "n"],
      ["ރ", "r"],
      ["ބ", "b"],
      ["ޅ", "lh"],
      ["ކ", "k"],
      ["އ", "a"],
      ["ވ", "v"],
      ["މ", "m"],
      ["ފ", "f"],
      ["ދ", "dh"],
      ["ތ", "th"],
      ["ލ", "l"],
      ["ގ", "g"],
      ["ޏ", "gn"],
      ["ސ", "s"],
      ["ޑ", "d"],
      ["ޒ", "z"],
      ["ޓ", "t"],
      ["ޔ", "y"],
      ["ޕ", "p"],
      ["ޖ", "j"],
      ["ޗ", "ch"],
      ["ޘ", "tt"],
      ["ޙ", "hh"],
      ["ޚ", "kh"],
      ["ޛ", "th"],
      ["ޜ", "z"],
      ["ޝ", "sh"],
      ["ޞ", "s"],
      ["ޟ", "d"],
      ["ޠ", "t"],
      ["ޡ", "z"],
      ["ޢ", "a"],
      ["ޣ", "gh"],
      ["ޤ", "q"],
      ["ޥ", "w"],
      ["ަ", "a"],
      ["ާ", "aa"],
      ["ި", "i"],
      ["ީ", "ee"],
      ["ު", "u"],
      ["ޫ", "oo"],
      ["ެ", "e"],
      ["ޭ", "ey"],
      ["ޮ", "o"],
      ["ޯ", "oa"],
      ["ް", ""],
      // Greek
      ["α", "a"],
      ["β", "v"],
      ["γ", "g"],
      ["δ", "d"],
      ["ε", "e"],
      ["ζ", "z"],
      ["η", "i"],
      ["θ", "th"],
      ["ι", "i"],
      ["κ", "k"],
      ["λ", "l"],
      ["μ", "m"],
      ["ν", "n"],
      ["ξ", "ks"],
      ["ο", "o"],
      ["π", "p"],
      ["ρ", "r"],
      ["σ", "s"],
      ["τ", "t"],
      ["υ", "y"],
      ["φ", "f"],
      ["χ", "x"],
      ["ψ", "ps"],
      ["ω", "o"],
      ["ά", "a"],
      ["έ", "e"],
      ["ί", "i"],
      ["ό", "o"],
      ["ύ", "y"],
      ["ή", "i"],
      ["ώ", "o"],
      ["ς", "s"],
      ["ϊ", "i"],
      ["ΰ", "y"],
      ["ϋ", "y"],
      ["ΐ", "i"],
      ["Α", "A"],
      ["Β", "B"],
      ["Γ", "G"],
      ["Δ", "D"],
      ["Ε", "E"],
      ["Ζ", "Z"],
      ["Η", "I"],
      ["Θ", "TH"],
      ["Ι", "I"],
      ["Κ", "K"],
      ["Λ", "L"],
      ["Μ", "M"],
      ["Ν", "N"],
      ["Ξ", "KS"],
      ["Ο", "O"],
      ["Π", "P"],
      ["Ρ", "R"],
      ["Σ", "S"],
      ["Τ", "T"],
      ["Υ", "Y"],
      ["Φ", "F"],
      ["Χ", "X"],
      ["Ψ", "PS"],
      ["Ω", "O"],
      ["Ά", "A"],
      ["Έ", "E"],
      ["Ί", "I"],
      ["Ό", "O"],
      ["Ύ", "Y"],
      ["Ή", "I"],
      ["Ώ", "O"],
      ["Ϊ", "I"],
      ["Ϋ", "Y"],
      // Disabled as it conflicts with German and Latin.
      // Hungarian
      // ['ä', 'a'],
      // ['Ä', 'A'],
      // ['ö', 'o'],
      // ['Ö', 'O'],
      // ['ü', 'u'],
      // ['Ü', 'U'],
      // ['ű', 'u'],
      // ['Ű', 'U'],
      // Latvian
      ["ā", "a"],
      ["ē", "e"],
      ["ģ", "g"],
      ["ī", "i"],
      ["ķ", "k"],
      ["ļ", "l"],
      ["ņ", "n"],
      ["ū", "u"],
      ["Ā", "A"],
      ["Ē", "E"],
      ["Ģ", "G"],
      ["Ī", "I"],
      ["Ķ", "K"],
      ["Ļ", "L"],
      ["Ņ", "N"],
      ["Ū", "U"],
      ["č", "c"],
      ["š", "s"],
      ["ž", "z"],
      ["Č", "C"],
      ["Š", "S"],
      ["Ž", "Z"],
      // Lithuanian
      ["ą", "a"],
      ["č", "c"],
      ["ę", "e"],
      ["ė", "e"],
      ["į", "i"],
      ["š", "s"],
      ["ų", "u"],
      ["ū", "u"],
      ["ž", "z"],
      ["Ą", "A"],
      ["Č", "C"],
      ["Ę", "E"],
      ["Ė", "E"],
      ["Į", "I"],
      ["Š", "S"],
      ["Ų", "U"],
      ["Ū", "U"],
      // Macedonian
      ["Ќ", "Kj"],
      ["ќ", "kj"],
      ["Љ", "Lj"],
      ["љ", "lj"],
      ["Њ", "Nj"],
      ["њ", "nj"],
      ["Тс", "Ts"],
      ["тс", "ts"],
      // Polish
      ["ą", "a"],
      ["ć", "c"],
      ["ę", "e"],
      ["ł", "l"],
      ["ń", "n"],
      ["ś", "s"],
      ["ź", "z"],
      ["ż", "z"],
      ["Ą", "A"],
      ["Ć", "C"],
      ["Ę", "E"],
      ["Ł", "L"],
      ["Ń", "N"],
      ["Ś", "S"],
      ["Ź", "Z"],
      ["Ż", "Z"],
      // Disabled as it conflicts with Vietnamese.
      // Serbian
      // ['љ', 'lj'],
      // ['њ', 'nj'],
      // ['Љ', 'Lj'],
      // ['Њ', 'Nj'],
      // ['đ', 'dj'],
      // ['Đ', 'Dj'],
      // ['ђ', 'dj'],
      // ['ј', 'j'],
      // ['ћ', 'c'],
      // ['џ', 'dz'],
      // ['Ђ', 'Dj'],
      // ['Ј', 'j'],
      // ['Ћ', 'C'],
      // ['Џ', 'Dz'],
      // Disabled as it conflicts with German and Latin.
      // Slovak
      // ['ä', 'a'],
      // ['Ä', 'A'],
      // ['ľ', 'l'],
      // ['ĺ', 'l'],
      // ['ŕ', 'r'],
      // ['Ľ', 'L'],
      // ['Ĺ', 'L'],
      // ['Ŕ', 'R'],
      // Disabled as it conflicts with German and Latin.
      // Swedish
      // ['å', 'o'],
      // ['Å', 'o'],
      // ['ä', 'a'],
      // ['Ä', 'A'],
      // ['ë', 'e'],
      // ['Ë', 'E'],
      // ['ö', 'o'],
      // ['Ö', 'O'],
      // Ukrainian
      ["Є", "Ye"],
      ["І", "I"],
      ["Ї", "Yi"],
      ["Ґ", "G"],
      ["є", "ye"],
      ["і", "i"],
      ["ї", "yi"],
      ["ґ", "g"]
      // Danish
      // ['Æ', 'Ae'],
      // ['Ø', 'Oe'],
      // ['Å', 'Aa'],
      // ['æ', 'ae'],
      // ['ø', 'oe'],
      // ['å', 'aa']
    ];
  }
});

// node_modules/@sindresorhus/transliterate/index.js
var require_transliterate = __commonJS({
  "node_modules/@sindresorhus/transliterate/index.js"(exports, module) {
    "use strict";
    var deburr = require_lodash();
    var escapeStringRegexp2 = require_escape_string_regexp2();
    var builtinReplacements = require_replacements2();
    var doCustomReplacements = (string3, replacements) => {
      for (const [key, value2] of replacements) {
        string3 = string3.replace(new RegExp(escapeStringRegexp2(key), "g"), value2);
      }
      return string3;
    };
    module.exports = (string3, options) => {
      if (typeof string3 !== "string") {
        throw new TypeError(`Expected a string, got \`${typeof string3}\``);
      }
      options = {
        customReplacements: [],
        ...options
      };
      const customReplacements = new Map([
        ...builtinReplacements,
        ...options.customReplacements
      ]);
      string3 = string3.normalize();
      string3 = doCustomReplacements(string3, customReplacements);
      string3 = deburr(string3);
      return string3;
    };
  }
});

// node_modules/@sindresorhus/slugify/overridable-replacements.js
var require_overridable_replacements = __commonJS({
  "node_modules/@sindresorhus/slugify/overridable-replacements.js"(exports, module) {
    "use strict";
    module.exports = [
      ["&", " and "],
      ["🦄", " unicorn "],
      ["♥", " love "]
    ];
  }
});

// node_modules/@sindresorhus/slugify/index.js
var require_slugify = __commonJS({
  "node_modules/@sindresorhus/slugify/index.js"(exports, module) {
    "use strict";
    var escapeStringRegexp2 = require_escape_string_regexp();
    var transliterate = require_transliterate();
    var builtinOverridableReplacements = require_overridable_replacements();
    var decamelize = (string3) => {
      return string3.replace(/([A-Z]{2,})(\d+)/g, "$1 $2").replace(/([a-z\d]+)([A-Z]{2,})/g, "$1 $2").replace(/([a-z\d])([A-Z])/g, "$1 $2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1 $2");
    };
    var removeMootSeparators = (string3, separator) => {
      const escapedSeparator = escapeStringRegexp2(separator);
      return string3.replace(new RegExp(`${escapedSeparator}{2,}`, "g"), separator).replace(new RegExp(`^${escapedSeparator}|${escapedSeparator}$`, "g"), "");
    };
    var slugify = (string3, options) => {
      if (typeof string3 !== "string") {
        throw new TypeError(`Expected a string, got \`${typeof string3}\``);
      }
      options = {
        separator: "-",
        lowercase: true,
        decamelize: true,
        customReplacements: [],
        preserveLeadingUnderscore: false,
        ...options
      };
      const shouldPrependUnderscore = options.preserveLeadingUnderscore && string3.startsWith("_");
      const customReplacements = new Map([
        ...builtinOverridableReplacements,
        ...options.customReplacements
      ]);
      string3 = transliterate(string3, { customReplacements });
      if (options.decamelize) {
        string3 = decamelize(string3);
      }
      let patternSlug = /[^a-zA-Z\d]+/g;
      if (options.lowercase) {
        string3 = string3.toLowerCase();
        patternSlug = /[^a-z\d]+/g;
      }
      string3 = string3.replace(patternSlug, options.separator);
      string3 = string3.replace(/\\/g, "");
      if (options.separator) {
        string3 = removeMootSeparators(string3, options.separator);
      }
      if (shouldPrependUnderscore) {
        string3 = `_${string3}`;
      }
      return string3;
    };
    var counter2 = () => {
      const occurrences = /* @__PURE__ */ new Map();
      const countable = (string3, options) => {
        string3 = slugify(string3, options);
        if (!string3) {
          return "";
        }
        const stringLower = string3.toLowerCase();
        const numberless = occurrences.get(stringLower.replace(/(?:-\d+?)+?$/, "")) || 0;
        const counter3 = occurrences.get(stringLower);
        occurrences.set(stringLower, typeof counter3 === "number" ? counter3 + 1 : 1);
        const newCounter = occurrences.get(stringLower) || 2;
        if (newCounter >= 2 || numberless > 2) {
          string3 = `${string3}-${newCounter}`;
        }
        return string3;
      };
      countable.reset = () => {
        occurrences.clear();
      };
      return countable;
    };
    module.exports = slugify;
    module.exports.counter = counter2;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s4 = 1e3;
    var m3 = s4 * 60;
    var h3 = m3 * 60;
    var d5 = h3 * 24;
    var w2 = d5 * 7;
    var y4 = d5 * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type2 = typeof val;
      if (type2 === "string" && val.length > 0) {
        return parse8(val);
      } else if (type2 === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse8(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match3 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match3) {
        return;
      }
      var n6 = parseFloat(match3[1]);
      var type2 = (match3[2] || "ms").toLowerCase();
      switch (type2) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n6 * y4;
        case "weeks":
        case "week":
        case "w":
          return n6 * w2;
        case "days":
        case "day":
        case "d":
          return n6 * d5;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n6 * h3;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n6 * m3;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n6 * s4;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n6;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d5) {
        return Math.round(ms / d5) + "d";
      }
      if (msAbs >= h3) {
        return Math.round(ms / h3) + "h";
      }
      if (msAbs >= m3) {
        return Math.round(ms / m3) + "m";
      }
      if (msAbs >= s4) {
        return Math.round(ms / s4) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d5) {
        return plural(ms, msAbs, d5, "day");
      }
      if (msAbs >= h3) {
        return plural(ms, msAbs, h3, "hour");
      }
      if (msAbs >= m3) {
        return plural(ms, msAbs, m3, "minute");
      }
      if (msAbs >= s4) {
        return plural(ms, msAbs, s4, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n6, name2) {
      var isPlural = msAbs >= n6 * 1.5;
      return Math.round(ms / n6) + " " + name2 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug2.debug = createDebug2;
      createDebug2.default = createDebug2;
      createDebug2.coerce = coerce;
      createDebug2.disable = disable2;
      createDebug2.enable = enable;
      createDebug2.enabled = enabled;
      createDebug2.humanize = require_ms();
      createDebug2.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug2[key] = env[key];
      });
      createDebug2.names = [];
      createDebug2.skips = [];
      createDebug2.formatters = {};
      function selectColor(namespace) {
        let hash2 = 0;
        for (let i6 = 0; i6 < namespace.length; i6++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i6);
          hash2 |= 0;
        }
        return createDebug2.colors[Math.abs(hash2) % createDebug2.colors.length];
      }
      createDebug2.selectColor = selectColor;
      function createDebug2(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug5(...args2) {
          if (!debug5.enabled) {
            return;
          }
          const self2 = debug5;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args2[0] = createDebug2.coerce(args2[0]);
          if (typeof args2[0] !== "string") {
            args2.unshift("%O");
          }
          let index3 = 0;
          args2[0] = args2[0].replace(/%([a-zA-Z%])/g, (match3, format2) => {
            if (match3 === "%%") {
              return "%";
            }
            index3++;
            const formatter = createDebug2.formatters[format2];
            if (typeof formatter === "function") {
              const val = args2[index3];
              match3 = formatter.call(self2, val);
              args2.splice(index3, 1);
              index3--;
            }
            return match3;
          });
          createDebug2.formatArgs.call(self2, args2);
          const logFn = self2.log || createDebug2.log;
          logFn.apply(self2, args2);
        }
        debug5.namespace = namespace;
        debug5.useColors = createDebug2.useColors();
        debug5.color = createDebug2.selectColor(namespace);
        debug5.extend = extend;
        debug5.destroy = createDebug2.destroy;
        Object.defineProperty(debug5, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug2.namespaces) {
              namespacesCache = createDebug2.namespaces;
              enabledCache = createDebug2.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v6) => {
            enableOverride = v6;
          }
        });
        if (typeof createDebug2.init === "function") {
          createDebug2.init(debug5);
        }
        return debug5;
      }
      function extend(namespace, delimiter2) {
        const newDebug = createDebug2(this.namespace + (typeof delimiter2 === "undefined" ? ":" : delimiter2) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug2.save(namespaces);
        createDebug2.namespaces = namespaces;
        createDebug2.names = [];
        createDebug2.skips = [];
        let i6;
        const split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split2.length;
        for (i6 = 0; i6 < len; i6++) {
          if (!split2[i6]) {
            continue;
          }
          namespaces = split2[i6].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug2.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug2.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable2() {
        const namespaces = [
          ...createDebug2.names.map(toNamespace),
          ...createDebug2.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug2.enable("");
        return namespaces;
      }
      function enabled(name2) {
        if (name2[name2.length - 1] === "*") {
          return true;
        }
        let i6;
        let len;
        for (i6 = 0, len = createDebug2.skips.length; i6 < len; i6++) {
          if (createDebug2.skips[i6].test(name2)) {
            return false;
          }
        }
        for (i6 = 0, len = createDebug2.names.length; i6 < len; i6++) {
          if (createDebug2.names[i6].test(name2)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug2.enable(createDebug2.load());
      return createDebug2;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned2 = false;
      return () => {
        if (!warned2) {
          warned2 = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args2) {
      args2[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args2[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c5 = "color: " + this.color;
      args2.splice(1, 0, c5, "color: inherit");
      let index3 = 0;
      let lastC = 0;
      args2[0].replace(/%[a-zA-Z%]/g, (match3) => {
        if (match3 === "%%") {
          return;
        }
        index3++;
        if (match3 === "%c") {
          lastC = index3;
        }
      });
      args2.splice(lastC, 0, c5);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error3) {
      }
    }
    function load() {
      let r7;
      try {
        r7 = exports.storage.getItem("debug");
      } catch (error3) {
      }
      if (!r7 && typeof process !== "undefined" && "env" in process) {
        r7 = process.env.DEBUG;
      }
      return r7;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error3) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v6) {
      try {
        return JSON.stringify(v6);
      } catch (error3) {
        return "[UnexpectedJSONParseError]: " + error3.message;
      }
    };
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React13 = require_react();
        var ReactSharedInternals = React13.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error3(format2) {
          {
            {
              for (var _len2 = arguments.length, args2 = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args2[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format2, args2);
            }
          }
        }
        function printWarning(level, format2, args2) {
          {
            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame.getStackAddendum();
            if (stack !== "") {
              format2 += "%s";
              args2 = args2.concat([stack]);
            }
            var argsWithFormat = args2.map(function(item2) {
              return String(item2);
            });
            argsWithFormat.unshift("Warning: " + format2);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function is2(x4, y4) {
          return x4 === y4 && (x4 !== 0 || 1 / x4 === 1 / y4) || x4 !== x4 && y4 !== y4;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is2;
        var useState13 = React13.useState, useEffect12 = React13.useEffect, useLayoutEffect5 = React13.useLayoutEffect, useDebugValue = React13.useDebugValue;
        var didWarnOld18Alpha = false;
        var didWarnUncachedGetSnapshot = false;
        function useSyncExternalStore3(subscribe5, getSnapshot, getServerSnapshot) {
          {
            if (!didWarnOld18Alpha) {
              if (React13.startTransition !== void 0) {
                didWarnOld18Alpha = true;
                error3("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
              }
            }
          }
          var value2 = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedValue = getSnapshot();
              if (!objectIs(value2, cachedValue)) {
                error3("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var _useState = useState13({
            inst: {
              value: value2,
              getSnapshot
            }
          }), inst = _useState[0].inst, forceUpdate = _useState[1];
          useLayoutEffect5(function() {
            inst.value = value2;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          }, [subscribe5, value2, getSnapshot]);
          useEffect12(function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            };
            return subscribe5(handleStoreChange);
          }, [subscribe5]);
          useDebugValue(value2);
          return value2;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error4) {
            return true;
          }
        }
        function useSyncExternalStore$1(subscribe5, getSnapshot, getServerSnapshot) {
          return getSnapshot();
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var isServerEnvironment = !canUseDOM;
        var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore3;
        var useSyncExternalStore$2 = React13.useSyncExternalStore !== void 0 ? React13.useSyncExternalStore : shim;
        exports.useSyncExternalStore = useSyncExternalStore$2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// node_modules/@markdoc/markdoc/dist/index.mjs
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS2 = (cb, mod2) => function __require() {
  return mod2 || (0, cb[Object.keys(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export2 = (target, all3) => {
  __markAsModule(target);
  for (var name2 in all3)
    __defProp(target, name2, { get: all3[name2], enumerable: true });
};
var __reExport = (target, module, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module) => {
  return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
};
var require_tag = __commonJS2({
  "src/grammar/tag.js"(exports, module) {
    "use strict";
    function peg$subclass(child, parent) {
      function C3() {
        this.constructor = child;
      }
      C3.prototype = parent.prototype;
      child.prototype = new C3();
    }
    function peg$SyntaxError(message, expected, found, location2) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location2;
      this.name = "SyntaxError";
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }
    peg$subclass(peg$SyntaxError, Error);
    peg$SyntaxError.buildMessage = function(expected, found, location2) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        },
        not: function(expectation) {
          return "not " + describeExpectation(expectation.expected);
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i6, j4;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i6 = 1, j4 = 1; i6 < descriptions.length; i6++) {
            if (descriptions[i6 - 1] !== descriptions[i6]) {
              descriptions[j4] = descriptions[i6];
              j4++;
            }
          }
          descriptions.length = j4;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$startRuleFunctions = { Top: peg$parseTop };
      var peg$startRuleFunction = peg$parseTop;
      var peg$c0 = "/";
      var peg$c1 = ".";
      var peg$c2 = "#";
      var peg$c3 = "=";
      var peg$c4 = "(";
      var peg$c5 = ")";
      var peg$c6 = ",";
      var peg$c7 = "[";
      var peg$c8 = "]";
      var peg$c9 = "null";
      var peg$c10 = "true";
      var peg$c11 = "false";
      var peg$c12 = "{";
      var peg$c13 = "}";
      var peg$c14 = ":";
      var peg$c15 = "-";
      var peg$c16 = '"';
      var peg$c17 = "\\";
      var peg$r0 = /^[$@]/;
      var peg$r1 = /^[0-9]/;
      var peg$r2 = /^[^\0-\x1F"\\]/;
      var peg$r3 = /^[a-zA-Z0-9_\-]/;
      var peg$r4 = /^[ \n\t]/;
      var peg$e0 = peg$literalExpectation("/", false);
      var peg$e1 = peg$otherExpectation("tag name");
      var peg$e2 = peg$otherExpectation("class");
      var peg$e3 = peg$otherExpectation("id");
      var peg$e4 = peg$literalExpectation("=", false);
      var peg$e5 = peg$literalExpectation("(", false);
      var peg$e6 = peg$literalExpectation(")", false);
      var peg$e7 = peg$literalExpectation(",", false);
      var peg$e8 = peg$otherExpectation("variable");
      var peg$e9 = peg$otherExpectation("null");
      var peg$e10 = peg$otherExpectation("boolean");
      var peg$e11 = peg$literalExpectation("[", false);
      var peg$e12 = peg$literalExpectation("]", false);
      var peg$e13 = peg$literalExpectation("{", false);
      var peg$e14 = peg$literalExpectation("}", false);
      var peg$e15 = peg$literalExpectation(":", false);
      var peg$e16 = peg$otherExpectation("number");
      var peg$e17 = peg$otherExpectation("string");
      var peg$e18 = peg$otherExpectation("identifier");
      var peg$e19 = peg$otherExpectation("whitespace");
      var peg$f0 = function(variable) {
        return { type: "variable", meta: { variable } };
      };
      var peg$f1 = function(attributes) {
        return { type: "annotation", meta: { attributes } };
      };
      var peg$f2 = function(tag2, value2) {
        return value2;
      };
      var peg$f3 = function(tag2, primary, attributes, close) {
        if (primary) {
          attributes = attributes || [];
          attributes.unshift({
            type: "attribute",
            name: "primary",
            value: primary
          });
        }
        const [type2, nesting] = close ? ["tag", 0] : ["tag_open", 1];
        return { type: type2, nesting, meta: { tag: tag2, attributes } };
      };
      var peg$f4 = function(tag2) {
        return { type: "tag_close", nesting: -1, meta: { tag: tag2 } };
      };
      var peg$f5 = function(head, tail) {
        return !head ? [] : [head, ...tail];
      };
      var peg$f6 = function(item2) {
        return item2;
      };
      var peg$f7 = function(ids) {
        return ids;
      };
      var peg$f8 = function(classes) {
        return classes;
      };
      var peg$f9 = function(attribute) {
        return attribute;
      };
      var peg$f10 = function(name2) {
        return { type: "class", name: name2, value: true };
      };
      var peg$f11 = function(value2) {
        return { type: "attribute", name: "id", value: value2 };
      };
      var peg$f12 = function(name2, value2) {
        return { type: "attribute", name: name2, value: value2 };
      };
      var peg$f13 = function(name2, head, tail) {
        return head ? [head, ...tail] : [];
      };
      var peg$f14 = function(name2, params2) {
        let parameters = {};
        for (let [index3, { name: name22, value: value2 }] of params2.entries())
          parameters[name22 || index3] = value2;
        return new Function3(name2, parameters);
      };
      var peg$f15 = function(name2) {
        return name2;
      };
      var peg$f16 = function(name2, value2) {
        return { name: name2, value: value2 };
      };
      var peg$f17 = function(value2) {
        return value2;
      };
      var peg$f18 = function(prefix4, head, tail) {
        if (prefix4 === "@")
          return [head, ...tail];
        return new Variable2([head, ...tail]);
      };
      var peg$f19 = function() {
        return null;
      };
      var peg$f20 = function() {
        return true;
      };
      var peg$f21 = function() {
        return false;
      };
      var peg$f22 = function(head, tail) {
        return [head, ...tail];
      };
      var peg$f23 = function(value2) {
        return value2 || [];
      };
      var peg$f24 = function(head, tail) {
        return Object.assign(head, ...tail);
      };
      var peg$f25 = function(value2) {
        return value2 || {};
      };
      var peg$f26 = function(key, value2) {
        return key === "$$mdtype" ? {} : { [key]: value2 };
      };
      var peg$f27 = function() {
        return parseFloat(text22());
      };
      var peg$f28 = function(value2) {
        return value2.join("");
      };
      var peg$f29 = function(sequence) {
        return sequence;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$expected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text22() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return [peg$savedPos, peg$currPos];
      }
      function location2() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location22) {
        location22 = location22 !== void 0 ? location22 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location22);
      }
      function error22(message, location22) {
        location22 = location22 !== void 0 ? location22 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location22);
      }
      function peg$literalExpectation(text32, ignoreCase) {
        return { type: "literal", text: text32, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts,
          inverted,
          ignoreCase
        };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p5;
        if (details) {
          return details;
        } else {
          p5 = pos - 1;
          while (!peg$posDetailsCache[p5]) {
            p5--;
          }
          details = peg$posDetailsCache[p5];
          details = {
            line: details.line,
            column: details.column
          };
          while (p5 < pos) {
            if (input.charCodeAt(p5) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p5++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      var peg$VALIDFILENAME = typeof options.filename === "string" && options.filename.length > 0;
      function peg$computeLocation(startPos, endPos) {
        var loc = {};
        if (peg$VALIDFILENAME)
          loc.filename = options.filename;
        var startPosDetails = peg$computePosDetails(startPos);
        loc.start = {
          offset: startPos,
          line: startPosDetails.line,
          column: startPosDetails.column
        };
        var endPosDetails = peg$computePosDetails(endPos);
        loc.end = {
          offset: endPos,
          line: endPosDetails.line,
          column: endPosDetails.column
        };
        return loc;
      }
      function peg$begin() {
        peg$expected.push({ pos: peg$currPos, variants: [] });
      }
      function peg$expect(expected2) {
        var top = peg$expected[peg$expected.length - 1];
        if (peg$currPos < top.pos) {
          return;
        }
        if (peg$currPos > top.pos) {
          top.pos = peg$currPos;
          top.variants = [];
        }
        top.variants.push(expected2);
      }
      function peg$end(invert) {
        var expected2 = peg$expected.pop();
        var top = peg$expected[peg$expected.length - 1];
        var variants = expected2.variants;
        if (top.pos !== expected2.pos) {
          return;
        }
        if (invert) {
          variants = variants.map(function(e6) {
            return e6.type === "not" ? e6.expected : { type: "not", expected: e6 };
          });
        }
        Array.prototype.push.apply(top.variants, variants);
      }
      function peg$buildSimpleError(message, location22) {
        return new peg$SyntaxError(message, null, null, location22);
      }
      function peg$buildStructuredError(expected2, found, location22) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found, location22), expected2, found, location22);
      }
      function peg$buildError() {
        var expected2 = peg$expected[0];
        var failPos = expected2.pos;
        return peg$buildStructuredError(expected2.variants, failPos < input.length ? input.charAt(failPos) : null, failPos < input.length ? peg$computeLocation(failPos, failPos + 1) : peg$computeLocation(failPos, failPos));
      }
      function peg$parseTop() {
        var s0;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$parseTopLevelValue();
        if (s0 === peg$FAILED) {
          s0 = peg$parseAnnotation();
          if (s0 === peg$FAILED) {
            s0 = peg$parseTagOpen();
            if (s0 === peg$FAILED) {
              s0 = peg$parseTagClose();
            }
          }
        }
        return s0;
      }
      function peg$parseTopLevelValue() {
        var s0, s1;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseVariable();
        if (s1 === peg$FAILED) {
          s1 = peg$parseFunction();
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f0(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseAnnotation() {
        var s0, s1, s22, s32;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseTagAttributes();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parse_();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parse_();
          }
          peg$savedPos = s0;
          s0 = peg$f1(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTagOpen() {
        var s0, s1, s22, s32, s4, s5, s6;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseTagName();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parse_();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parse_();
          }
          s32 = peg$currPos;
          s4 = peg$parseValue();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            peg$savedPos = s32;
            s32 = peg$f2(s1, s4);
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          s4 = peg$parseTagAttributes();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          s5 = [];
          s6 = peg$parse_();
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$parse_();
          }
          rule$expects(peg$e0);
          if (input.charCodeAt(peg$currPos) === 47) {
            s6 = peg$c0;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
          }
          if (s6 === peg$FAILED) {
            s6 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f3(s1, s32, s4, s6);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTagClose() {
        var s0, s1, s22;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        rule$expects(peg$e0);
        if (input.charCodeAt(peg$currPos) === 47) {
          s1 = peg$c0;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseTagName();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f4(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTagName() {
        var s0;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e1);
        peg$silentFails++;
        s0 = peg$parseIdentifier();
        peg$silentFails--;
        return s0;
      }
      function peg$parseTagAttributes() {
        var s0, s1, s22, s32;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseTagAttributesItem();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parseTagAttributesTail();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parseTagAttributesTail();
          }
          peg$savedPos = s0;
          s0 = peg$f5(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTagAttributesTail() {
        var s0, s1, s22;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parse_();
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseTagAttributesItem();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTagAttributesItem() {
        var s0, s1;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseTagShortcutId();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f7(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseTagShortcutClass();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f8(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseTagAttribute();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f9(s1);
            }
            s0 = s1;
          }
        }
        return s0;
      }
      function peg$parseTagShortcutClass() {
        var s0, s1, s22;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e2);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c1;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseIdentifier();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f10(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseTagShortcutId() {
        var s0, s1, s22;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e3);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c2;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseIdentifier();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f11(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseTagAttribute() {
        var s0, s1, s22, s32;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseIdentifier();
        if (s1 !== peg$FAILED) {
          rule$expects(peg$e4);
          if (input.charCodeAt(peg$currPos) === 61) {
            s22 = peg$c3;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parseValue();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f12(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseFunction() {
        var s0, s1, s22, s32, s4, s5, s6, s7;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseIdentifier();
        if (s1 !== peg$FAILED) {
          rule$expects(peg$e5);
          if (input.charCodeAt(peg$currPos) === 40) {
            s22 = peg$c4;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s32 = [];
            s4 = peg$parse_();
            while (s4 !== peg$FAILED) {
              s32.push(s4);
              s4 = peg$parse_();
            }
            s4 = peg$currPos;
            s5 = peg$parseFunctionParameter();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            s6 = [];
            s7 = peg$parseFunctionParameterTail();
            while (s7 !== peg$FAILED) {
              s6.push(s7);
              s7 = peg$parseFunctionParameterTail();
            }
            peg$savedPos = s4;
            s4 = peg$f13(s1, s5, s6);
            rule$expects(peg$e6);
            if (input.charCodeAt(peg$currPos) === 41) {
              s5 = peg$c5;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f14(s1, s4);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseFunctionParameter() {
        var s0, s1, s22, s32;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parseIdentifier();
        if (s22 !== peg$FAILED) {
          rule$expects(peg$e4);
          if (input.charCodeAt(peg$currPos) === 61) {
            s32 = peg$c3;
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            peg$savedPos = s1;
            s1 = peg$f15(s22);
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = peg$parseValue();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f16(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseFunctionParameterTail() {
        var s0, s1, s22, s32, s4;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        rule$expects(peg$e7);
        if (input.charCodeAt(peg$currPos) === 44) {
          s22 = peg$c6;
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s32 = [];
          s4 = peg$parse_();
          while (s4 !== peg$FAILED) {
            s32.push(s4);
            s4 = peg$parse_();
          }
          s4 = peg$parseFunctionParameter();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s4);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTrailingComma() {
        var s0, s1, s22;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        rule$expects(peg$e7);
        if (input.charCodeAt(peg$currPos) === 44) {
          s22 = peg$c6;
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s1 = [s1, s22];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = null;
        }
        return s0;
      }
      function peg$parseVariable() {
        var s0, s1, s22, s32, s4;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e8);
        peg$silentFails++;
        s0 = peg$currPos;
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseIdentifier();
          if (s22 !== peg$FAILED) {
            s32 = [];
            s4 = peg$parseVariableTail();
            while (s4 !== peg$FAILED) {
              s32.push(s4);
              s4 = peg$parseVariableTail();
            }
            peg$savedPos = s0;
            s0 = peg$f18(s1, s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseVariableTail() {
        var s0, s1, s22, s32;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c1;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseIdentifier();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f15(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c7;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parseValueNumber();
            if (s22 === peg$FAILED) {
              s22 = peg$parseValueString();
            }
            if (s22 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s32 = peg$c8;
                peg$currPos++;
              } else {
                s32 = peg$FAILED;
              }
              if (s32 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f17(s22);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseValue() {
        var s0;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$parseValueNull();
        if (s0 === peg$FAILED) {
          s0 = peg$parseValueBoolean();
          if (s0 === peg$FAILED) {
            s0 = peg$parseValueString();
            if (s0 === peg$FAILED) {
              s0 = peg$parseValueNumber();
              if (s0 === peg$FAILED) {
                s0 = peg$parseValueArray();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseValueHash();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseFunction();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseVariable();
                    }
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parseValueNull() {
        var s0, s1;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e9);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c9) {
          s1 = peg$c9;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f19();
        }
        s0 = s1;
        peg$silentFails--;
        return s0;
      }
      function peg$parseValueBoolean() {
        var s0, s1;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e10);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c10) {
          s1 = peg$c10;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f20();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c11) {
            s1 = peg$c11;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f21();
          }
          s0 = s1;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseValueArray() {
        var s0, s1, s22, s32, s4, s5, s6;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        rule$expects(peg$e11);
        if (input.charCodeAt(peg$currPos) === 91) {
          s1 = peg$c7;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parse_();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parse_();
          }
          s32 = peg$currPos;
          s4 = peg$parseValue();
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parseValueArrayTail();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parseValueArrayTail();
            }
            s6 = peg$parseTrailingComma();
            peg$savedPos = s32;
            s32 = peg$f22(s4, s5);
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          s4 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parse_();
          }
          rule$expects(peg$e12);
          if (input.charCodeAt(peg$currPos) === 93) {
            s5 = peg$c8;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f23(s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseValueArrayTail() {
        var s0, s1, s22, s32, s4;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        rule$expects(peg$e7);
        if (input.charCodeAt(peg$currPos) === 44) {
          s22 = peg$c6;
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s32 = [];
          s4 = peg$parse_();
          while (s4 !== peg$FAILED) {
            s32.push(s4);
            s4 = peg$parse_();
          }
          s4 = peg$parseValue();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s4);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseValueHash() {
        var s0, s1, s22, s32, s4, s5, s6;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        rule$expects(peg$e13);
        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c12;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parse_();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parse_();
          }
          s32 = peg$currPos;
          s4 = peg$parseValueHashItem();
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parseValueHashTail();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parseValueHashTail();
            }
            s6 = peg$parseTrailingComma();
            peg$savedPos = s32;
            s32 = peg$f24(s4, s5);
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          s4 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parse_();
          }
          rule$expects(peg$e14);
          if (input.charCodeAt(peg$currPos) === 125) {
            s5 = peg$c13;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseValueHashTail() {
        var s0, s1, s22, s32, s4;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        rule$expects(peg$e7);
        if (input.charCodeAt(peg$currPos) === 44) {
          s22 = peg$c6;
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s32 = [];
          s4 = peg$parse_();
          while (s4 !== peg$FAILED) {
            s32.push(s4);
            s4 = peg$parse_();
          }
          s4 = peg$parseValueHashItem();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s4);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseValueHashItem() {
        var s0, s1, s22, s32, s4;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseIdentifier();
        if (s1 === peg$FAILED) {
          s1 = peg$parseValueString();
        }
        if (s1 !== peg$FAILED) {
          rule$expects(peg$e15);
          if (input.charCodeAt(peg$currPos) === 58) {
            s22 = peg$c14;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s32 = [];
            s4 = peg$parse_();
            while (s4 !== peg$FAILED) {
              s32.push(s4);
              s4 = peg$parse_();
            }
            s4 = peg$parseValue();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f26(s1, s4);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseValueNumber() {
        var s0, s1, s22, s32, s4, s5, s6;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e16);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 45) {
          s1 = peg$c15;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = [];
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s32 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s32 = peg$FAILED;
        }
        if (s32 !== peg$FAILED) {
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s32 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
            }
          }
        } else {
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s32 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s4 = peg$c1;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s5 = [];
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                if (peg$r1.test(input.charAt(peg$currPos))) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                }
              }
            } else {
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s32 = s4;
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f27();
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseValueString() {
        var s0, s1, s22, s32;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e17);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c16;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parseValueStringChars();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parseValueStringChars();
          }
          if (input.charCodeAt(peg$currPos) === 34) {
            s32 = peg$c16;
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f28(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseValueStringChars() {
        var s0;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parseValueStringEscapes();
        }
        return s0;
      }
      function peg$parseValueStringEscapes() {
        var s0, s1, s22;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s1 = peg$c17;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s22 = peg$c16;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 92) {
              s22 = peg$c17;
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f29(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseIdentifier() {
        var s0, s1, s22;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e18);
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        if (peg$r3.test(input.charAt(peg$currPos))) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            if (peg$r3.test(input.charAt(peg$currPos))) {
              s22 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parse_() {
        var s0;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e19);
        peg$silentFails++;
        if (peg$r4.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      const { Variable: Variable2, Function: Function3 } = options;
      peg$begin();
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$expect(peg$endExpectation());
        }
        throw peg$buildError();
      }
    }
    module.exports = {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }
});
var require_entities = __commonJS2({
  "node_modules/entities/lib/maps/entities.json"(exports, module) {
    module.exports = { Aacute: "Á", aacute: "á", Abreve: "Ă", abreve: "ă", ac: "∾", acd: "∿", acE: "∾̳", Acirc: "Â", acirc: "â", acute: "´", Acy: "А", acy: "а", AElig: "Æ", aelig: "æ", af: "⁡", Afr: "𝔄", afr: "𝔞", Agrave: "À", agrave: "à", alefsym: "ℵ", aleph: "ℵ", Alpha: "Α", alpha: "α", Amacr: "Ā", amacr: "ā", amalg: "⨿", amp: "&", AMP: "&", andand: "⩕", And: "⩓", and: "∧", andd: "⩜", andslope: "⩘", andv: "⩚", ang: "∠", ange: "⦤", angle: "∠", angmsdaa: "⦨", angmsdab: "⦩", angmsdac: "⦪", angmsdad: "⦫", angmsdae: "⦬", angmsdaf: "⦭", angmsdag: "⦮", angmsdah: "⦯", angmsd: "∡", angrt: "∟", angrtvb: "⊾", angrtvbd: "⦝", angsph: "∢", angst: "Å", angzarr: "⍼", Aogon: "Ą", aogon: "ą", Aopf: "𝔸", aopf: "𝕒", apacir: "⩯", ap: "≈", apE: "⩰", ape: "≊", apid: "≋", apos: "'", ApplyFunction: "⁡", approx: "≈", approxeq: "≊", Aring: "Å", aring: "å", Ascr: "𝒜", ascr: "𝒶", Assign: "≔", ast: "*", asymp: "≈", asympeq: "≍", Atilde: "Ã", atilde: "ã", Auml: "Ä", auml: "ä", awconint: "∳", awint: "⨑", backcong: "≌", backepsilon: "϶", backprime: "‵", backsim: "∽", backsimeq: "⋍", Backslash: "∖", Barv: "⫧", barvee: "⊽", barwed: "⌅", Barwed: "⌆", barwedge: "⌅", bbrk: "⎵", bbrktbrk: "⎶", bcong: "≌", Bcy: "Б", bcy: "б", bdquo: "„", becaus: "∵", because: "∵", Because: "∵", bemptyv: "⦰", bepsi: "϶", bernou: "ℬ", Bernoullis: "ℬ", Beta: "Β", beta: "β", beth: "ℶ", between: "≬", Bfr: "𝔅", bfr: "𝔟", bigcap: "⋂", bigcirc: "◯", bigcup: "⋃", bigodot: "⨀", bigoplus: "⨁", bigotimes: "⨂", bigsqcup: "⨆", bigstar: "★", bigtriangledown: "▽", bigtriangleup: "△", biguplus: "⨄", bigvee: "⋁", bigwedge: "⋀", bkarow: "⤍", blacklozenge: "⧫", blacksquare: "▪", blacktriangle: "▴", blacktriangledown: "▾", blacktriangleleft: "◂", blacktriangleright: "▸", blank: "␣", blk12: "▒", blk14: "░", blk34: "▓", block: "█", bne: "=⃥", bnequiv: "≡⃥", bNot: "⫭", bnot: "⌐", Bopf: "𝔹", bopf: "𝕓", bot: "⊥", bottom: "⊥", bowtie: "⋈", boxbox: "⧉", boxdl: "┐", boxdL: "╕", boxDl: "╖", boxDL: "╗", boxdr: "┌", boxdR: "╒", boxDr: "╓", boxDR: "╔", boxh: "─", boxH: "═", boxhd: "┬", boxHd: "╤", boxhD: "╥", boxHD: "╦", boxhu: "┴", boxHu: "╧", boxhU: "╨", boxHU: "╩", boxminus: "⊟", boxplus: "⊞", boxtimes: "⊠", boxul: "┘", boxuL: "╛", boxUl: "╜", boxUL: "╝", boxur: "└", boxuR: "╘", boxUr: "╙", boxUR: "╚", boxv: "│", boxV: "║", boxvh: "┼", boxvH: "╪", boxVh: "╫", boxVH: "╬", boxvl: "┤", boxvL: "╡", boxVl: "╢", boxVL: "╣", boxvr: "├", boxvR: "╞", boxVr: "╟", boxVR: "╠", bprime: "‵", breve: "˘", Breve: "˘", brvbar: "¦", bscr: "𝒷", Bscr: "ℬ", bsemi: "⁏", bsim: "∽", bsime: "⋍", bsolb: "⧅", bsol: "\\", bsolhsub: "⟈", bull: "•", bullet: "•", bump: "≎", bumpE: "⪮", bumpe: "≏", Bumpeq: "≎", bumpeq: "≏", Cacute: "Ć", cacute: "ć", capand: "⩄", capbrcup: "⩉", capcap: "⩋", cap: "∩", Cap: "⋒", capcup: "⩇", capdot: "⩀", CapitalDifferentialD: "ⅅ", caps: "∩︀", caret: "⁁", caron: "ˇ", Cayleys: "ℭ", ccaps: "⩍", Ccaron: "Č", ccaron: "č", Ccedil: "Ç", ccedil: "ç", Ccirc: "Ĉ", ccirc: "ĉ", Cconint: "∰", ccups: "⩌", ccupssm: "⩐", Cdot: "Ċ", cdot: "ċ", cedil: "¸", Cedilla: "¸", cemptyv: "⦲", cent: "¢", centerdot: "·", CenterDot: "·", cfr: "𝔠", Cfr: "ℭ", CHcy: "Ч", chcy: "ч", check: "✓", checkmark: "✓", Chi: "Χ", chi: "χ", circ: "ˆ", circeq: "≗", circlearrowleft: "↺", circlearrowright: "↻", circledast: "⊛", circledcirc: "⊚", circleddash: "⊝", CircleDot: "⊙", circledR: "®", circledS: "Ⓢ", CircleMinus: "⊖", CirclePlus: "⊕", CircleTimes: "⊗", cir: "○", cirE: "⧃", cire: "≗", cirfnint: "⨐", cirmid: "⫯", cirscir: "⧂", ClockwiseContourIntegral: "∲", CloseCurlyDoubleQuote: "”", CloseCurlyQuote: "’", clubs: "♣", clubsuit: "♣", colon: ":", Colon: "∷", Colone: "⩴", colone: "≔", coloneq: "≔", comma: ",", commat: "@", comp: "∁", compfn: "∘", complement: "∁", complexes: "ℂ", cong: "≅", congdot: "⩭", Congruent: "≡", conint: "∮", Conint: "∯", ContourIntegral: "∮", copf: "𝕔", Copf: "ℂ", coprod: "∐", Coproduct: "∐", copy: "©", COPY: "©", copysr: "℗", CounterClockwiseContourIntegral: "∳", crarr: "↵", cross: "✗", Cross: "⨯", Cscr: "𝒞", cscr: "𝒸", csub: "⫏", csube: "⫑", csup: "⫐", csupe: "⫒", ctdot: "⋯", cudarrl: "⤸", cudarrr: "⤵", cuepr: "⋞", cuesc: "⋟", cularr: "↶", cularrp: "⤽", cupbrcap: "⩈", cupcap: "⩆", CupCap: "≍", cup: "∪", Cup: "⋓", cupcup: "⩊", cupdot: "⊍", cupor: "⩅", cups: "∪︀", curarr: "↷", curarrm: "⤼", curlyeqprec: "⋞", curlyeqsucc: "⋟", curlyvee: "⋎", curlywedge: "⋏", curren: "¤", curvearrowleft: "↶", curvearrowright: "↷", cuvee: "⋎", cuwed: "⋏", cwconint: "∲", cwint: "∱", cylcty: "⌭", dagger: "†", Dagger: "‡", daleth: "ℸ", darr: "↓", Darr: "↡", dArr: "⇓", dash: "‐", Dashv: "⫤", dashv: "⊣", dbkarow: "⤏", dblac: "˝", Dcaron: "Ď", dcaron: "ď", Dcy: "Д", dcy: "д", ddagger: "‡", ddarr: "⇊", DD: "ⅅ", dd: "ⅆ", DDotrahd: "⤑", ddotseq: "⩷", deg: "°", Del: "∇", Delta: "Δ", delta: "δ", demptyv: "⦱", dfisht: "⥿", Dfr: "𝔇", dfr: "𝔡", dHar: "⥥", dharl: "⇃", dharr: "⇂", DiacriticalAcute: "´", DiacriticalDot: "˙", DiacriticalDoubleAcute: "˝", DiacriticalGrave: "`", DiacriticalTilde: "˜", diam: "⋄", diamond: "⋄", Diamond: "⋄", diamondsuit: "♦", diams: "♦", die: "¨", DifferentialD: "ⅆ", digamma: "ϝ", disin: "⋲", div: "÷", divide: "÷", divideontimes: "⋇", divonx: "⋇", DJcy: "Ђ", djcy: "ђ", dlcorn: "⌞", dlcrop: "⌍", dollar: "$", Dopf: "𝔻", dopf: "𝕕", Dot: "¨", dot: "˙", DotDot: "⃜", doteq: "≐", doteqdot: "≑", DotEqual: "≐", dotminus: "∸", dotplus: "∔", dotsquare: "⊡", doublebarwedge: "⌆", DoubleContourIntegral: "∯", DoubleDot: "¨", DoubleDownArrow: "⇓", DoubleLeftArrow: "⇐", DoubleLeftRightArrow: "⇔", DoubleLeftTee: "⫤", DoubleLongLeftArrow: "⟸", DoubleLongLeftRightArrow: "⟺", DoubleLongRightArrow: "⟹", DoubleRightArrow: "⇒", DoubleRightTee: "⊨", DoubleUpArrow: "⇑", DoubleUpDownArrow: "⇕", DoubleVerticalBar: "∥", DownArrowBar: "⤓", downarrow: "↓", DownArrow: "↓", Downarrow: "⇓", DownArrowUpArrow: "⇵", DownBreve: "̑", downdownarrows: "⇊", downharpoonleft: "⇃", downharpoonright: "⇂", DownLeftRightVector: "⥐", DownLeftTeeVector: "⥞", DownLeftVectorBar: "⥖", DownLeftVector: "↽", DownRightTeeVector: "⥟", DownRightVectorBar: "⥗", DownRightVector: "⇁", DownTeeArrow: "↧", DownTee: "⊤", drbkarow: "⤐", drcorn: "⌟", drcrop: "⌌", Dscr: "𝒟", dscr: "𝒹", DScy: "Ѕ", dscy: "ѕ", dsol: "⧶", Dstrok: "Đ", dstrok: "đ", dtdot: "⋱", dtri: "▿", dtrif: "▾", duarr: "⇵", duhar: "⥯", dwangle: "⦦", DZcy: "Џ", dzcy: "џ", dzigrarr: "⟿", Eacute: "É", eacute: "é", easter: "⩮", Ecaron: "Ě", ecaron: "ě", Ecirc: "Ê", ecirc: "ê", ecir: "≖", ecolon: "≕", Ecy: "Э", ecy: "э", eDDot: "⩷", Edot: "Ė", edot: "ė", eDot: "≑", ee: "ⅇ", efDot: "≒", Efr: "𝔈", efr: "𝔢", eg: "⪚", Egrave: "È", egrave: "è", egs: "⪖", egsdot: "⪘", el: "⪙", Element: "∈", elinters: "⏧", ell: "ℓ", els: "⪕", elsdot: "⪗", Emacr: "Ē", emacr: "ē", empty: "∅", emptyset: "∅", EmptySmallSquare: "◻", emptyv: "∅", EmptyVerySmallSquare: "▫", emsp13: " ", emsp14: " ", emsp: " ", ENG: "Ŋ", eng: "ŋ", ensp: " ", Eogon: "Ę", eogon: "ę", Eopf: "𝔼", eopf: "𝕖", epar: "⋕", eparsl: "⧣", eplus: "⩱", epsi: "ε", Epsilon: "Ε", epsilon: "ε", epsiv: "ϵ", eqcirc: "≖", eqcolon: "≕", eqsim: "≂", eqslantgtr: "⪖", eqslantless: "⪕", Equal: "⩵", equals: "=", EqualTilde: "≂", equest: "≟", Equilibrium: "⇌", equiv: "≡", equivDD: "⩸", eqvparsl: "⧥", erarr: "⥱", erDot: "≓", escr: "ℯ", Escr: "ℰ", esdot: "≐", Esim: "⩳", esim: "≂", Eta: "Η", eta: "η", ETH: "Ð", eth: "ð", Euml: "Ë", euml: "ë", euro: "€", excl: "!", exist: "∃", Exists: "∃", expectation: "ℰ", exponentiale: "ⅇ", ExponentialE: "ⅇ", fallingdotseq: "≒", Fcy: "Ф", fcy: "ф", female: "♀", ffilig: "ﬃ", fflig: "ﬀ", ffllig: "ﬄ", Ffr: "𝔉", ffr: "𝔣", filig: "ﬁ", FilledSmallSquare: "◼", FilledVerySmallSquare: "▪", fjlig: "fj", flat: "♭", fllig: "ﬂ", fltns: "▱", fnof: "ƒ", Fopf: "𝔽", fopf: "𝕗", forall: "∀", ForAll: "∀", fork: "⋔", forkv: "⫙", Fouriertrf: "ℱ", fpartint: "⨍", frac12: "½", frac13: "⅓", frac14: "¼", frac15: "⅕", frac16: "⅙", frac18: "⅛", frac23: "⅔", frac25: "⅖", frac34: "¾", frac35: "⅗", frac38: "⅜", frac45: "⅘", frac56: "⅚", frac58: "⅝", frac78: "⅞", frasl: "⁄", frown: "⌢", fscr: "𝒻", Fscr: "ℱ", gacute: "ǵ", Gamma: "Γ", gamma: "γ", Gammad: "Ϝ", gammad: "ϝ", gap: "⪆", Gbreve: "Ğ", gbreve: "ğ", Gcedil: "Ģ", Gcirc: "Ĝ", gcirc: "ĝ", Gcy: "Г", gcy: "г", Gdot: "Ġ", gdot: "ġ", ge: "≥", gE: "≧", gEl: "⪌", gel: "⋛", geq: "≥", geqq: "≧", geqslant: "⩾", gescc: "⪩", ges: "⩾", gesdot: "⪀", gesdoto: "⪂", gesdotol: "⪄", gesl: "⋛︀", gesles: "⪔", Gfr: "𝔊", gfr: "𝔤", gg: "≫", Gg: "⋙", ggg: "⋙", gimel: "ℷ", GJcy: "Ѓ", gjcy: "ѓ", gla: "⪥", gl: "≷", glE: "⪒", glj: "⪤", gnap: "⪊", gnapprox: "⪊", gne: "⪈", gnE: "≩", gneq: "⪈", gneqq: "≩", gnsim: "⋧", Gopf: "𝔾", gopf: "𝕘", grave: "`", GreaterEqual: "≥", GreaterEqualLess: "⋛", GreaterFullEqual: "≧", GreaterGreater: "⪢", GreaterLess: "≷", GreaterSlantEqual: "⩾", GreaterTilde: "≳", Gscr: "𝒢", gscr: "ℊ", gsim: "≳", gsime: "⪎", gsiml: "⪐", gtcc: "⪧", gtcir: "⩺", gt: ">", GT: ">", Gt: "≫", gtdot: "⋗", gtlPar: "⦕", gtquest: "⩼", gtrapprox: "⪆", gtrarr: "⥸", gtrdot: "⋗", gtreqless: "⋛", gtreqqless: "⪌", gtrless: "≷", gtrsim: "≳", gvertneqq: "≩︀", gvnE: "≩︀", Hacek: "ˇ", hairsp: " ", half: "½", hamilt: "ℋ", HARDcy: "Ъ", hardcy: "ъ", harrcir: "⥈", harr: "↔", hArr: "⇔", harrw: "↭", Hat: "^", hbar: "ℏ", Hcirc: "Ĥ", hcirc: "ĥ", hearts: "♥", heartsuit: "♥", hellip: "…", hercon: "⊹", hfr: "𝔥", Hfr: "ℌ", HilbertSpace: "ℋ", hksearow: "⤥", hkswarow: "⤦", hoarr: "⇿", homtht: "∻", hookleftarrow: "↩", hookrightarrow: "↪", hopf: "𝕙", Hopf: "ℍ", horbar: "―", HorizontalLine: "─", hscr: "𝒽", Hscr: "ℋ", hslash: "ℏ", Hstrok: "Ħ", hstrok: "ħ", HumpDownHump: "≎", HumpEqual: "≏", hybull: "⁃", hyphen: "‐", Iacute: "Í", iacute: "í", ic: "⁣", Icirc: "Î", icirc: "î", Icy: "И", icy: "и", Idot: "İ", IEcy: "Е", iecy: "е", iexcl: "¡", iff: "⇔", ifr: "𝔦", Ifr: "ℑ", Igrave: "Ì", igrave: "ì", ii: "ⅈ", iiiint: "⨌", iiint: "∭", iinfin: "⧜", iiota: "℩", IJlig: "Ĳ", ijlig: "ĳ", Imacr: "Ī", imacr: "ī", image: "ℑ", ImaginaryI: "ⅈ", imagline: "ℐ", imagpart: "ℑ", imath: "ı", Im: "ℑ", imof: "⊷", imped: "Ƶ", Implies: "⇒", incare: "℅", in: "∈", infin: "∞", infintie: "⧝", inodot: "ı", intcal: "⊺", int: "∫", Int: "∬", integers: "ℤ", Integral: "∫", intercal: "⊺", Intersection: "⋂", intlarhk: "⨗", intprod: "⨼", InvisibleComma: "⁣", InvisibleTimes: "⁢", IOcy: "Ё", iocy: "ё", Iogon: "Į", iogon: "į", Iopf: "𝕀", iopf: "𝕚", Iota: "Ι", iota: "ι", iprod: "⨼", iquest: "¿", iscr: "𝒾", Iscr: "ℐ", isin: "∈", isindot: "⋵", isinE: "⋹", isins: "⋴", isinsv: "⋳", isinv: "∈", it: "⁢", Itilde: "Ĩ", itilde: "ĩ", Iukcy: "І", iukcy: "і", Iuml: "Ï", iuml: "ï", Jcirc: "Ĵ", jcirc: "ĵ", Jcy: "Й", jcy: "й", Jfr: "𝔍", jfr: "𝔧", jmath: "ȷ", Jopf: "𝕁", jopf: "𝕛", Jscr: "𝒥", jscr: "𝒿", Jsercy: "Ј", jsercy: "ј", Jukcy: "Є", jukcy: "є", Kappa: "Κ", kappa: "κ", kappav: "ϰ", Kcedil: "Ķ", kcedil: "ķ", Kcy: "К", kcy: "к", Kfr: "𝔎", kfr: "𝔨", kgreen: "ĸ", KHcy: "Х", khcy: "х", KJcy: "Ќ", kjcy: "ќ", Kopf: "𝕂", kopf: "𝕜", Kscr: "𝒦", kscr: "𝓀", lAarr: "⇚", Lacute: "Ĺ", lacute: "ĺ", laemptyv: "⦴", lagran: "ℒ", Lambda: "Λ", lambda: "λ", lang: "⟨", Lang: "⟪", langd: "⦑", langle: "⟨", lap: "⪅", Laplacetrf: "ℒ", laquo: "«", larrb: "⇤", larrbfs: "⤟", larr: "←", Larr: "↞", lArr: "⇐", larrfs: "⤝", larrhk: "↩", larrlp: "↫", larrpl: "⤹", larrsim: "⥳", larrtl: "↢", latail: "⤙", lAtail: "⤛", lat: "⪫", late: "⪭", lates: "⪭︀", lbarr: "⤌", lBarr: "⤎", lbbrk: "❲", lbrace: "{", lbrack: "[", lbrke: "⦋", lbrksld: "⦏", lbrkslu: "⦍", Lcaron: "Ľ", lcaron: "ľ", Lcedil: "Ļ", lcedil: "ļ", lceil: "⌈", lcub: "{", Lcy: "Л", lcy: "л", ldca: "⤶", ldquo: "“", ldquor: "„", ldrdhar: "⥧", ldrushar: "⥋", ldsh: "↲", le: "≤", lE: "≦", LeftAngleBracket: "⟨", LeftArrowBar: "⇤", leftarrow: "←", LeftArrow: "←", Leftarrow: "⇐", LeftArrowRightArrow: "⇆", leftarrowtail: "↢", LeftCeiling: "⌈", LeftDoubleBracket: "⟦", LeftDownTeeVector: "⥡", LeftDownVectorBar: "⥙", LeftDownVector: "⇃", LeftFloor: "⌊", leftharpoondown: "↽", leftharpoonup: "↼", leftleftarrows: "⇇", leftrightarrow: "↔", LeftRightArrow: "↔", Leftrightarrow: "⇔", leftrightarrows: "⇆", leftrightharpoons: "⇋", leftrightsquigarrow: "↭", LeftRightVector: "⥎", LeftTeeArrow: "↤", LeftTee: "⊣", LeftTeeVector: "⥚", leftthreetimes: "⋋", LeftTriangleBar: "⧏", LeftTriangle: "⊲", LeftTriangleEqual: "⊴", LeftUpDownVector: "⥑", LeftUpTeeVector: "⥠", LeftUpVectorBar: "⥘", LeftUpVector: "↿", LeftVectorBar: "⥒", LeftVector: "↼", lEg: "⪋", leg: "⋚", leq: "≤", leqq: "≦", leqslant: "⩽", lescc: "⪨", les: "⩽", lesdot: "⩿", lesdoto: "⪁", lesdotor: "⪃", lesg: "⋚︀", lesges: "⪓", lessapprox: "⪅", lessdot: "⋖", lesseqgtr: "⋚", lesseqqgtr: "⪋", LessEqualGreater: "⋚", LessFullEqual: "≦", LessGreater: "≶", lessgtr: "≶", LessLess: "⪡", lesssim: "≲", LessSlantEqual: "⩽", LessTilde: "≲", lfisht: "⥼", lfloor: "⌊", Lfr: "𝔏", lfr: "𝔩", lg: "≶", lgE: "⪑", lHar: "⥢", lhard: "↽", lharu: "↼", lharul: "⥪", lhblk: "▄", LJcy: "Љ", ljcy: "љ", llarr: "⇇", ll: "≪", Ll: "⋘", llcorner: "⌞", Lleftarrow: "⇚", llhard: "⥫", lltri: "◺", Lmidot: "Ŀ", lmidot: "ŀ", lmoustache: "⎰", lmoust: "⎰", lnap: "⪉", lnapprox: "⪉", lne: "⪇", lnE: "≨", lneq: "⪇", lneqq: "≨", lnsim: "⋦", loang: "⟬", loarr: "⇽", lobrk: "⟦", longleftarrow: "⟵", LongLeftArrow: "⟵", Longleftarrow: "⟸", longleftrightarrow: "⟷", LongLeftRightArrow: "⟷", Longleftrightarrow: "⟺", longmapsto: "⟼", longrightarrow: "⟶", LongRightArrow: "⟶", Longrightarrow: "⟹", looparrowleft: "↫", looparrowright: "↬", lopar: "⦅", Lopf: "𝕃", lopf: "𝕝", loplus: "⨭", lotimes: "⨴", lowast: "∗", lowbar: "_", LowerLeftArrow: "↙", LowerRightArrow: "↘", loz: "◊", lozenge: "◊", lozf: "⧫", lpar: "(", lparlt: "⦓", lrarr: "⇆", lrcorner: "⌟", lrhar: "⇋", lrhard: "⥭", lrm: "‎", lrtri: "⊿", lsaquo: "‹", lscr: "𝓁", Lscr: "ℒ", lsh: "↰", Lsh: "↰", lsim: "≲", lsime: "⪍", lsimg: "⪏", lsqb: "[", lsquo: "‘", lsquor: "‚", Lstrok: "Ł", lstrok: "ł", ltcc: "⪦", ltcir: "⩹", lt: "<", LT: "<", Lt: "≪", ltdot: "⋖", lthree: "⋋", ltimes: "⋉", ltlarr: "⥶", ltquest: "⩻", ltri: "◃", ltrie: "⊴", ltrif: "◂", ltrPar: "⦖", lurdshar: "⥊", luruhar: "⥦", lvertneqq: "≨︀", lvnE: "≨︀", macr: "¯", male: "♂", malt: "✠", maltese: "✠", Map: "⤅", map: "↦", mapsto: "↦", mapstodown: "↧", mapstoleft: "↤", mapstoup: "↥", marker: "▮", mcomma: "⨩", Mcy: "М", mcy: "м", mdash: "—", mDDot: "∺", measuredangle: "∡", MediumSpace: " ", Mellintrf: "ℳ", Mfr: "𝔐", mfr: "𝔪", mho: "℧", micro: "µ", midast: "*", midcir: "⫰", mid: "∣", middot: "·", minusb: "⊟", minus: "−", minusd: "∸", minusdu: "⨪", MinusPlus: "∓", mlcp: "⫛", mldr: "…", mnplus: "∓", models: "⊧", Mopf: "𝕄", mopf: "𝕞", mp: "∓", mscr: "𝓂", Mscr: "ℳ", mstpos: "∾", Mu: "Μ", mu: "μ", multimap: "⊸", mumap: "⊸", nabla: "∇", Nacute: "Ń", nacute: "ń", nang: "∠⃒", nap: "≉", napE: "⩰̸", napid: "≋̸", napos: "ŉ", napprox: "≉", natural: "♮", naturals: "ℕ", natur: "♮", nbsp: " ", nbump: "≎̸", nbumpe: "≏̸", ncap: "⩃", Ncaron: "Ň", ncaron: "ň", Ncedil: "Ņ", ncedil: "ņ", ncong: "≇", ncongdot: "⩭̸", ncup: "⩂", Ncy: "Н", ncy: "н", ndash: "–", nearhk: "⤤", nearr: "↗", neArr: "⇗", nearrow: "↗", ne: "≠", nedot: "≐̸", NegativeMediumSpace: "​", NegativeThickSpace: "​", NegativeThinSpace: "​", NegativeVeryThinSpace: "​", nequiv: "≢", nesear: "⤨", nesim: "≂̸", NestedGreaterGreater: "≫", NestedLessLess: "≪", NewLine: "\n", nexist: "∄", nexists: "∄", Nfr: "𝔑", nfr: "𝔫", ngE: "≧̸", nge: "≱", ngeq: "≱", ngeqq: "≧̸", ngeqslant: "⩾̸", nges: "⩾̸", nGg: "⋙̸", ngsim: "≵", nGt: "≫⃒", ngt: "≯", ngtr: "≯", nGtv: "≫̸", nharr: "↮", nhArr: "⇎", nhpar: "⫲", ni: "∋", nis: "⋼", nisd: "⋺", niv: "∋", NJcy: "Њ", njcy: "њ", nlarr: "↚", nlArr: "⇍", nldr: "‥", nlE: "≦̸", nle: "≰", nleftarrow: "↚", nLeftarrow: "⇍", nleftrightarrow: "↮", nLeftrightarrow: "⇎", nleq: "≰", nleqq: "≦̸", nleqslant: "⩽̸", nles: "⩽̸", nless: "≮", nLl: "⋘̸", nlsim: "≴", nLt: "≪⃒", nlt: "≮", nltri: "⋪", nltrie: "⋬", nLtv: "≪̸", nmid: "∤", NoBreak: "⁠", NonBreakingSpace: " ", nopf: "𝕟", Nopf: "ℕ", Not: "⫬", not: "¬", NotCongruent: "≢", NotCupCap: "≭", NotDoubleVerticalBar: "∦", NotElement: "∉", NotEqual: "≠", NotEqualTilde: "≂̸", NotExists: "∄", NotGreater: "≯", NotGreaterEqual: "≱", NotGreaterFullEqual: "≧̸", NotGreaterGreater: "≫̸", NotGreaterLess: "≹", NotGreaterSlantEqual: "⩾̸", NotGreaterTilde: "≵", NotHumpDownHump: "≎̸", NotHumpEqual: "≏̸", notin: "∉", notindot: "⋵̸", notinE: "⋹̸", notinva: "∉", notinvb: "⋷", notinvc: "⋶", NotLeftTriangleBar: "⧏̸", NotLeftTriangle: "⋪", NotLeftTriangleEqual: "⋬", NotLess: "≮", NotLessEqual: "≰", NotLessGreater: "≸", NotLessLess: "≪̸", NotLessSlantEqual: "⩽̸", NotLessTilde: "≴", NotNestedGreaterGreater: "⪢̸", NotNestedLessLess: "⪡̸", notni: "∌", notniva: "∌", notnivb: "⋾", notnivc: "⋽", NotPrecedes: "⊀", NotPrecedesEqual: "⪯̸", NotPrecedesSlantEqual: "⋠", NotReverseElement: "∌", NotRightTriangleBar: "⧐̸", NotRightTriangle: "⋫", NotRightTriangleEqual: "⋭", NotSquareSubset: "⊏̸", NotSquareSubsetEqual: "⋢", NotSquareSuperset: "⊐̸", NotSquareSupersetEqual: "⋣", NotSubset: "⊂⃒", NotSubsetEqual: "⊈", NotSucceeds: "⊁", NotSucceedsEqual: "⪰̸", NotSucceedsSlantEqual: "⋡", NotSucceedsTilde: "≿̸", NotSuperset: "⊃⃒", NotSupersetEqual: "⊉", NotTilde: "≁", NotTildeEqual: "≄", NotTildeFullEqual: "≇", NotTildeTilde: "≉", NotVerticalBar: "∤", nparallel: "∦", npar: "∦", nparsl: "⫽⃥", npart: "∂̸", npolint: "⨔", npr: "⊀", nprcue: "⋠", nprec: "⊀", npreceq: "⪯̸", npre: "⪯̸", nrarrc: "⤳̸", nrarr: "↛", nrArr: "⇏", nrarrw: "↝̸", nrightarrow: "↛", nRightarrow: "⇏", nrtri: "⋫", nrtrie: "⋭", nsc: "⊁", nsccue: "⋡", nsce: "⪰̸", Nscr: "𝒩", nscr: "𝓃", nshortmid: "∤", nshortparallel: "∦", nsim: "≁", nsime: "≄", nsimeq: "≄", nsmid: "∤", nspar: "∦", nsqsube: "⋢", nsqsupe: "⋣", nsub: "⊄", nsubE: "⫅̸", nsube: "⊈", nsubset: "⊂⃒", nsubseteq: "⊈", nsubseteqq: "⫅̸", nsucc: "⊁", nsucceq: "⪰̸", nsup: "⊅", nsupE: "⫆̸", nsupe: "⊉", nsupset: "⊃⃒", nsupseteq: "⊉", nsupseteqq: "⫆̸", ntgl: "≹", Ntilde: "Ñ", ntilde: "ñ", ntlg: "≸", ntriangleleft: "⋪", ntrianglelefteq: "⋬", ntriangleright: "⋫", ntrianglerighteq: "⋭", Nu: "Ν", nu: "ν", num: "#", numero: "№", numsp: " ", nvap: "≍⃒", nvdash: "⊬", nvDash: "⊭", nVdash: "⊮", nVDash: "⊯", nvge: "≥⃒", nvgt: ">⃒", nvHarr: "⤄", nvinfin: "⧞", nvlArr: "⤂", nvle: "≤⃒", nvlt: "<⃒", nvltrie: "⊴⃒", nvrArr: "⤃", nvrtrie: "⊵⃒", nvsim: "∼⃒", nwarhk: "⤣", nwarr: "↖", nwArr: "⇖", nwarrow: "↖", nwnear: "⤧", Oacute: "Ó", oacute: "ó", oast: "⊛", Ocirc: "Ô", ocirc: "ô", ocir: "⊚", Ocy: "О", ocy: "о", odash: "⊝", Odblac: "Ő", odblac: "ő", odiv: "⨸", odot: "⊙", odsold: "⦼", OElig: "Œ", oelig: "œ", ofcir: "⦿", Ofr: "𝔒", ofr: "𝔬", ogon: "˛", Ograve: "Ò", ograve: "ò", ogt: "⧁", ohbar: "⦵", ohm: "Ω", oint: "∮", olarr: "↺", olcir: "⦾", olcross: "⦻", oline: "‾", olt: "⧀", Omacr: "Ō", omacr: "ō", Omega: "Ω", omega: "ω", Omicron: "Ο", omicron: "ο", omid: "⦶", ominus: "⊖", Oopf: "𝕆", oopf: "𝕠", opar: "⦷", OpenCurlyDoubleQuote: "“", OpenCurlyQuote: "‘", operp: "⦹", oplus: "⊕", orarr: "↻", Or: "⩔", or: "∨", ord: "⩝", order: "ℴ", orderof: "ℴ", ordf: "ª", ordm: "º", origof: "⊶", oror: "⩖", orslope: "⩗", orv: "⩛", oS: "Ⓢ", Oscr: "𝒪", oscr: "ℴ", Oslash: "Ø", oslash: "ø", osol: "⊘", Otilde: "Õ", otilde: "õ", otimesas: "⨶", Otimes: "⨷", otimes: "⊗", Ouml: "Ö", ouml: "ö", ovbar: "⌽", OverBar: "‾", OverBrace: "⏞", OverBracket: "⎴", OverParenthesis: "⏜", para: "¶", parallel: "∥", par: "∥", parsim: "⫳", parsl: "⫽", part: "∂", PartialD: "∂", Pcy: "П", pcy: "п", percnt: "%", period: ".", permil: "‰", perp: "⊥", pertenk: "‱", Pfr: "𝔓", pfr: "𝔭", Phi: "Φ", phi: "φ", phiv: "ϕ", phmmat: "ℳ", phone: "☎", Pi: "Π", pi: "π", pitchfork: "⋔", piv: "ϖ", planck: "ℏ", planckh: "ℎ", plankv: "ℏ", plusacir: "⨣", plusb: "⊞", pluscir: "⨢", plus: "+", plusdo: "∔", plusdu: "⨥", pluse: "⩲", PlusMinus: "±", plusmn: "±", plussim: "⨦", plustwo: "⨧", pm: "±", Poincareplane: "ℌ", pointint: "⨕", popf: "𝕡", Popf: "ℙ", pound: "£", prap: "⪷", Pr: "⪻", pr: "≺", prcue: "≼", precapprox: "⪷", prec: "≺", preccurlyeq: "≼", Precedes: "≺", PrecedesEqual: "⪯", PrecedesSlantEqual: "≼", PrecedesTilde: "≾", preceq: "⪯", precnapprox: "⪹", precneqq: "⪵", precnsim: "⋨", pre: "⪯", prE: "⪳", precsim: "≾", prime: "′", Prime: "″", primes: "ℙ", prnap: "⪹", prnE: "⪵", prnsim: "⋨", prod: "∏", Product: "∏", profalar: "⌮", profline: "⌒", profsurf: "⌓", prop: "∝", Proportional: "∝", Proportion: "∷", propto: "∝", prsim: "≾", prurel: "⊰", Pscr: "𝒫", pscr: "𝓅", Psi: "Ψ", psi: "ψ", puncsp: " ", Qfr: "𝔔", qfr: "𝔮", qint: "⨌", qopf: "𝕢", Qopf: "ℚ", qprime: "⁗", Qscr: "𝒬", qscr: "𝓆", quaternions: "ℍ", quatint: "⨖", quest: "?", questeq: "≟", quot: '"', QUOT: '"', rAarr: "⇛", race: "∽̱", Racute: "Ŕ", racute: "ŕ", radic: "√", raemptyv: "⦳", rang: "⟩", Rang: "⟫", rangd: "⦒", range: "⦥", rangle: "⟩", raquo: "»", rarrap: "⥵", rarrb: "⇥", rarrbfs: "⤠", rarrc: "⤳", rarr: "→", Rarr: "↠", rArr: "⇒", rarrfs: "⤞", rarrhk: "↪", rarrlp: "↬", rarrpl: "⥅", rarrsim: "⥴", Rarrtl: "⤖", rarrtl: "↣", rarrw: "↝", ratail: "⤚", rAtail: "⤜", ratio: "∶", rationals: "ℚ", rbarr: "⤍", rBarr: "⤏", RBarr: "⤐", rbbrk: "❳", rbrace: "}", rbrack: "]", rbrke: "⦌", rbrksld: "⦎", rbrkslu: "⦐", Rcaron: "Ř", rcaron: "ř", Rcedil: "Ŗ", rcedil: "ŗ", rceil: "⌉", rcub: "}", Rcy: "Р", rcy: "р", rdca: "⤷", rdldhar: "⥩", rdquo: "”", rdquor: "”", rdsh: "↳", real: "ℜ", realine: "ℛ", realpart: "ℜ", reals: "ℝ", Re: "ℜ", rect: "▭", reg: "®", REG: "®", ReverseElement: "∋", ReverseEquilibrium: "⇋", ReverseUpEquilibrium: "⥯", rfisht: "⥽", rfloor: "⌋", rfr: "𝔯", Rfr: "ℜ", rHar: "⥤", rhard: "⇁", rharu: "⇀", rharul: "⥬", Rho: "Ρ", rho: "ρ", rhov: "ϱ", RightAngleBracket: "⟩", RightArrowBar: "⇥", rightarrow: "→", RightArrow: "→", Rightarrow: "⇒", RightArrowLeftArrow: "⇄", rightarrowtail: "↣", RightCeiling: "⌉", RightDoubleBracket: "⟧", RightDownTeeVector: "⥝", RightDownVectorBar: "⥕", RightDownVector: "⇂", RightFloor: "⌋", rightharpoondown: "⇁", rightharpoonup: "⇀", rightleftarrows: "⇄", rightleftharpoons: "⇌", rightrightarrows: "⇉", rightsquigarrow: "↝", RightTeeArrow: "↦", RightTee: "⊢", RightTeeVector: "⥛", rightthreetimes: "⋌", RightTriangleBar: "⧐", RightTriangle: "⊳", RightTriangleEqual: "⊵", RightUpDownVector: "⥏", RightUpTeeVector: "⥜", RightUpVectorBar: "⥔", RightUpVector: "↾", RightVectorBar: "⥓", RightVector: "⇀", ring: "˚", risingdotseq: "≓", rlarr: "⇄", rlhar: "⇌", rlm: "‏", rmoustache: "⎱", rmoust: "⎱", rnmid: "⫮", roang: "⟭", roarr: "⇾", robrk: "⟧", ropar: "⦆", ropf: "𝕣", Ropf: "ℝ", roplus: "⨮", rotimes: "⨵", RoundImplies: "⥰", rpar: ")", rpargt: "⦔", rppolint: "⨒", rrarr: "⇉", Rrightarrow: "⇛", rsaquo: "›", rscr: "𝓇", Rscr: "ℛ", rsh: "↱", Rsh: "↱", rsqb: "]", rsquo: "’", rsquor: "’", rthree: "⋌", rtimes: "⋊", rtri: "▹", rtrie: "⊵", rtrif: "▸", rtriltri: "⧎", RuleDelayed: "⧴", ruluhar: "⥨", rx: "℞", Sacute: "Ś", sacute: "ś", sbquo: "‚", scap: "⪸", Scaron: "Š", scaron: "š", Sc: "⪼", sc: "≻", sccue: "≽", sce: "⪰", scE: "⪴", Scedil: "Ş", scedil: "ş", Scirc: "Ŝ", scirc: "ŝ", scnap: "⪺", scnE: "⪶", scnsim: "⋩", scpolint: "⨓", scsim: "≿", Scy: "С", scy: "с", sdotb: "⊡", sdot: "⋅", sdote: "⩦", searhk: "⤥", searr: "↘", seArr: "⇘", searrow: "↘", sect: "§", semi: ";", seswar: "⤩", setminus: "∖", setmn: "∖", sext: "✶", Sfr: "𝔖", sfr: "𝔰", sfrown: "⌢", sharp: "♯", SHCHcy: "Щ", shchcy: "щ", SHcy: "Ш", shcy: "ш", ShortDownArrow: "↓", ShortLeftArrow: "←", shortmid: "∣", shortparallel: "∥", ShortRightArrow: "→", ShortUpArrow: "↑", shy: "­", Sigma: "Σ", sigma: "σ", sigmaf: "ς", sigmav: "ς", sim: "∼", simdot: "⩪", sime: "≃", simeq: "≃", simg: "⪞", simgE: "⪠", siml: "⪝", simlE: "⪟", simne: "≆", simplus: "⨤", simrarr: "⥲", slarr: "←", SmallCircle: "∘", smallsetminus: "∖", smashp: "⨳", smeparsl: "⧤", smid: "∣", smile: "⌣", smt: "⪪", smte: "⪬", smtes: "⪬︀", SOFTcy: "Ь", softcy: "ь", solbar: "⌿", solb: "⧄", sol: "/", Sopf: "𝕊", sopf: "𝕤", spades: "♠", spadesuit: "♠", spar: "∥", sqcap: "⊓", sqcaps: "⊓︀", sqcup: "⊔", sqcups: "⊔︀", Sqrt: "√", sqsub: "⊏", sqsube: "⊑", sqsubset: "⊏", sqsubseteq: "⊑", sqsup: "⊐", sqsupe: "⊒", sqsupset: "⊐", sqsupseteq: "⊒", square: "□", Square: "□", SquareIntersection: "⊓", SquareSubset: "⊏", SquareSubsetEqual: "⊑", SquareSuperset: "⊐", SquareSupersetEqual: "⊒", SquareUnion: "⊔", squarf: "▪", squ: "□", squf: "▪", srarr: "→", Sscr: "𝒮", sscr: "𝓈", ssetmn: "∖", ssmile: "⌣", sstarf: "⋆", Star: "⋆", star: "☆", starf: "★", straightepsilon: "ϵ", straightphi: "ϕ", strns: "¯", sub: "⊂", Sub: "⋐", subdot: "⪽", subE: "⫅", sube: "⊆", subedot: "⫃", submult: "⫁", subnE: "⫋", subne: "⊊", subplus: "⪿", subrarr: "⥹", subset: "⊂", Subset: "⋐", subseteq: "⊆", subseteqq: "⫅", SubsetEqual: "⊆", subsetneq: "⊊", subsetneqq: "⫋", subsim: "⫇", subsub: "⫕", subsup: "⫓", succapprox: "⪸", succ: "≻", succcurlyeq: "≽", Succeeds: "≻", SucceedsEqual: "⪰", SucceedsSlantEqual: "≽", SucceedsTilde: "≿", succeq: "⪰", succnapprox: "⪺", succneqq: "⪶", succnsim: "⋩", succsim: "≿", SuchThat: "∋", sum: "∑", Sum: "∑", sung: "♪", sup1: "¹", sup2: "²", sup3: "³", sup: "⊃", Sup: "⋑", supdot: "⪾", supdsub: "⫘", supE: "⫆", supe: "⊇", supedot: "⫄", Superset: "⊃", SupersetEqual: "⊇", suphsol: "⟉", suphsub: "⫗", suplarr: "⥻", supmult: "⫂", supnE: "⫌", supne: "⊋", supplus: "⫀", supset: "⊃", Supset: "⋑", supseteq: "⊇", supseteqq: "⫆", supsetneq: "⊋", supsetneqq: "⫌", supsim: "⫈", supsub: "⫔", supsup: "⫖", swarhk: "⤦", swarr: "↙", swArr: "⇙", swarrow: "↙", swnwar: "⤪", szlig: "ß", Tab: "	", target: "⌖", Tau: "Τ", tau: "τ", tbrk: "⎴", Tcaron: "Ť", tcaron: "ť", Tcedil: "Ţ", tcedil: "ţ", Tcy: "Т", tcy: "т", tdot: "⃛", telrec: "⌕", Tfr: "𝔗", tfr: "𝔱", there4: "∴", therefore: "∴", Therefore: "∴", Theta: "Θ", theta: "θ", thetasym: "ϑ", thetav: "ϑ", thickapprox: "≈", thicksim: "∼", ThickSpace: "  ", ThinSpace: " ", thinsp: " ", thkap: "≈", thksim: "∼", THORN: "Þ", thorn: "þ", tilde: "˜", Tilde: "∼", TildeEqual: "≃", TildeFullEqual: "≅", TildeTilde: "≈", timesbar: "⨱", timesb: "⊠", times: "×", timesd: "⨰", tint: "∭", toea: "⤨", topbot: "⌶", topcir: "⫱", top: "⊤", Topf: "𝕋", topf: "𝕥", topfork: "⫚", tosa: "⤩", tprime: "‴", trade: "™", TRADE: "™", triangle: "▵", triangledown: "▿", triangleleft: "◃", trianglelefteq: "⊴", triangleq: "≜", triangleright: "▹", trianglerighteq: "⊵", tridot: "◬", trie: "≜", triminus: "⨺", TripleDot: "⃛", triplus: "⨹", trisb: "⧍", tritime: "⨻", trpezium: "⏢", Tscr: "𝒯", tscr: "𝓉", TScy: "Ц", tscy: "ц", TSHcy: "Ћ", tshcy: "ћ", Tstrok: "Ŧ", tstrok: "ŧ", twixt: "≬", twoheadleftarrow: "↞", twoheadrightarrow: "↠", Uacute: "Ú", uacute: "ú", uarr: "↑", Uarr: "↟", uArr: "⇑", Uarrocir: "⥉", Ubrcy: "Ў", ubrcy: "ў", Ubreve: "Ŭ", ubreve: "ŭ", Ucirc: "Û", ucirc: "û", Ucy: "У", ucy: "у", udarr: "⇅", Udblac: "Ű", udblac: "ű", udhar: "⥮", ufisht: "⥾", Ufr: "𝔘", ufr: "𝔲", Ugrave: "Ù", ugrave: "ù", uHar: "⥣", uharl: "↿", uharr: "↾", uhblk: "▀", ulcorn: "⌜", ulcorner: "⌜", ulcrop: "⌏", ultri: "◸", Umacr: "Ū", umacr: "ū", uml: "¨", UnderBar: "_", UnderBrace: "⏟", UnderBracket: "⎵", UnderParenthesis: "⏝", Union: "⋃", UnionPlus: "⊎", Uogon: "Ų", uogon: "ų", Uopf: "𝕌", uopf: "𝕦", UpArrowBar: "⤒", uparrow: "↑", UpArrow: "↑", Uparrow: "⇑", UpArrowDownArrow: "⇅", updownarrow: "↕", UpDownArrow: "↕", Updownarrow: "⇕", UpEquilibrium: "⥮", upharpoonleft: "↿", upharpoonright: "↾", uplus: "⊎", UpperLeftArrow: "↖", UpperRightArrow: "↗", upsi: "υ", Upsi: "ϒ", upsih: "ϒ", Upsilon: "Υ", upsilon: "υ", UpTeeArrow: "↥", UpTee: "⊥", upuparrows: "⇈", urcorn: "⌝", urcorner: "⌝", urcrop: "⌎", Uring: "Ů", uring: "ů", urtri: "◹", Uscr: "𝒰", uscr: "𝓊", utdot: "⋰", Utilde: "Ũ", utilde: "ũ", utri: "▵", utrif: "▴", uuarr: "⇈", Uuml: "Ü", uuml: "ü", uwangle: "⦧", vangrt: "⦜", varepsilon: "ϵ", varkappa: "ϰ", varnothing: "∅", varphi: "ϕ", varpi: "ϖ", varpropto: "∝", varr: "↕", vArr: "⇕", varrho: "ϱ", varsigma: "ς", varsubsetneq: "⊊︀", varsubsetneqq: "⫋︀", varsupsetneq: "⊋︀", varsupsetneqq: "⫌︀", vartheta: "ϑ", vartriangleleft: "⊲", vartriangleright: "⊳", vBar: "⫨", Vbar: "⫫", vBarv: "⫩", Vcy: "В", vcy: "в", vdash: "⊢", vDash: "⊨", Vdash: "⊩", VDash: "⊫", Vdashl: "⫦", veebar: "⊻", vee: "∨", Vee: "⋁", veeeq: "≚", vellip: "⋮", verbar: "|", Verbar: "‖", vert: "|", Vert: "‖", VerticalBar: "∣", VerticalLine: "|", VerticalSeparator: "❘", VerticalTilde: "≀", VeryThinSpace: " ", Vfr: "𝔙", vfr: "𝔳", vltri: "⊲", vnsub: "⊂⃒", vnsup: "⊃⃒", Vopf: "𝕍", vopf: "𝕧", vprop: "∝", vrtri: "⊳", Vscr: "𝒱", vscr: "𝓋", vsubnE: "⫋︀", vsubne: "⊊︀", vsupnE: "⫌︀", vsupne: "⊋︀", Vvdash: "⊪", vzigzag: "⦚", Wcirc: "Ŵ", wcirc: "ŵ", wedbar: "⩟", wedge: "∧", Wedge: "⋀", wedgeq: "≙", weierp: "℘", Wfr: "𝔚", wfr: "𝔴", Wopf: "𝕎", wopf: "𝕨", wp: "℘", wr: "≀", wreath: "≀", Wscr: "𝒲", wscr: "𝓌", xcap: "⋂", xcirc: "◯", xcup: "⋃", xdtri: "▽", Xfr: "𝔛", xfr: "𝔵", xharr: "⟷", xhArr: "⟺", Xi: "Ξ", xi: "ξ", xlarr: "⟵", xlArr: "⟸", xmap: "⟼", xnis: "⋻", xodot: "⨀", Xopf: "𝕏", xopf: "𝕩", xoplus: "⨁", xotime: "⨂", xrarr: "⟶", xrArr: "⟹", Xscr: "𝒳", xscr: "𝓍", xsqcup: "⨆", xuplus: "⨄", xutri: "△", xvee: "⋁", xwedge: "⋀", Yacute: "Ý", yacute: "ý", YAcy: "Я", yacy: "я", Ycirc: "Ŷ", ycirc: "ŷ", Ycy: "Ы", ycy: "ы", yen: "¥", Yfr: "𝔜", yfr: "𝔶", YIcy: "Ї", yicy: "ї", Yopf: "𝕐", yopf: "𝕪", Yscr: "𝒴", yscr: "𝓎", YUcy: "Ю", yucy: "ю", yuml: "ÿ", Yuml: "Ÿ", Zacute: "Ź", zacute: "ź", Zcaron: "Ž", zcaron: "ž", Zcy: "З", zcy: "з", Zdot: "Ż", zdot: "ż", zeetrf: "ℨ", ZeroWidthSpace: "​", Zeta: "Ζ", zeta: "ζ", zfr: "𝔷", Zfr: "ℨ", ZHcy: "Ж", zhcy: "ж", zigrarr: "⇝", zopf: "𝕫", Zopf: "ℤ", Zscr: "𝒵", zscr: "𝓏", zwj: "‍", zwnj: "‌" };
  }
});
var require_entities2 = __commonJS2({
  "node_modules/markdown-it/lib/common/entities.js"(exports, module) {
    "use strict";
    module.exports = require_entities();
  }
});
var require_regex = __commonJS2({
  "node_modules/uc.micro/categories/P/regex.js"(exports, module) {
    module.exports = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
  }
});
var require_encode = __commonJS2({
  "node_modules/mdurl/encode.js"(exports, module) {
    "use strict";
    var encodeCache = {};
    function getEncodeCache(exclude) {
      var i6, ch, cache3 = encodeCache[exclude];
      if (cache3) {
        return cache3;
      }
      cache3 = encodeCache[exclude] = [];
      for (i6 = 0; i6 < 128; i6++) {
        ch = String.fromCharCode(i6);
        if (/^[0-9a-z]$/i.test(ch)) {
          cache3.push(ch);
        } else {
          cache3.push("%" + ("0" + i6.toString(16).toUpperCase()).slice(-2));
        }
      }
      for (i6 = 0; i6 < exclude.length; i6++) {
        cache3[exclude.charCodeAt(i6)] = exclude[i6];
      }
      return cache3;
    }
    function encode3(string3, exclude, keepEscaped) {
      var i6, l7, code22, nextCode, cache3, result = "";
      if (typeof exclude !== "string") {
        keepEscaped = exclude;
        exclude = encode3.defaultChars;
      }
      if (typeof keepEscaped === "undefined") {
        keepEscaped = true;
      }
      cache3 = getEncodeCache(exclude);
      for (i6 = 0, l7 = string3.length; i6 < l7; i6++) {
        code22 = string3.charCodeAt(i6);
        if (keepEscaped && code22 === 37 && i6 + 2 < l7) {
          if (/^[0-9a-f]{2}$/i.test(string3.slice(i6 + 1, i6 + 3))) {
            result += string3.slice(i6, i6 + 3);
            i6 += 2;
            continue;
          }
        }
        if (code22 < 128) {
          result += cache3[code22];
          continue;
        }
        if (code22 >= 55296 && code22 <= 57343) {
          if (code22 >= 55296 && code22 <= 56319 && i6 + 1 < l7) {
            nextCode = string3.charCodeAt(i6 + 1);
            if (nextCode >= 56320 && nextCode <= 57343) {
              result += encodeURIComponent(string3[i6] + string3[i6 + 1]);
              i6++;
              continue;
            }
          }
          result += "%EF%BF%BD";
          continue;
        }
        result += encodeURIComponent(string3[i6]);
      }
      return result;
    }
    encode3.defaultChars = ";/?:@&=+$,-_.!~*'()#";
    encode3.componentChars = "-_.!~*'()";
    module.exports = encode3;
  }
});
var require_decode = __commonJS2({
  "node_modules/mdurl/decode.js"(exports, module) {
    "use strict";
    var decodeCache = {};
    function getDecodeCache(exclude) {
      var i6, ch, cache3 = decodeCache[exclude];
      if (cache3) {
        return cache3;
      }
      cache3 = decodeCache[exclude] = [];
      for (i6 = 0; i6 < 128; i6++) {
        ch = String.fromCharCode(i6);
        cache3.push(ch);
      }
      for (i6 = 0; i6 < exclude.length; i6++) {
        ch = exclude.charCodeAt(i6);
        cache3[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
      }
      return cache3;
    }
    function decode2(string3, exclude) {
      var cache3;
      if (typeof exclude !== "string") {
        exclude = decode2.defaultChars;
      }
      cache3 = getDecodeCache(exclude);
      return string3.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
        var i6, l7, b1, b2, b3, b4, chr, result = "";
        for (i6 = 0, l7 = seq.length; i6 < l7; i6 += 3) {
          b1 = parseInt(seq.slice(i6 + 1, i6 + 3), 16);
          if (b1 < 128) {
            result += cache3[b1];
            continue;
          }
          if ((b1 & 224) === 192 && i6 + 3 < l7) {
            b2 = parseInt(seq.slice(i6 + 4, i6 + 6), 16);
            if ((b2 & 192) === 128) {
              chr = b1 << 6 & 1984 | b2 & 63;
              if (chr < 128) {
                result += "��";
              } else {
                result += String.fromCharCode(chr);
              }
              i6 += 3;
              continue;
            }
          }
          if ((b1 & 240) === 224 && i6 + 6 < l7) {
            b2 = parseInt(seq.slice(i6 + 4, i6 + 6), 16);
            b3 = parseInt(seq.slice(i6 + 7, i6 + 9), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128) {
              chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
              if (chr < 2048 || chr >= 55296 && chr <= 57343) {
                result += "���";
              } else {
                result += String.fromCharCode(chr);
              }
              i6 += 6;
              continue;
            }
          }
          if ((b1 & 248) === 240 && i6 + 9 < l7) {
            b2 = parseInt(seq.slice(i6 + 4, i6 + 6), 16);
            b3 = parseInt(seq.slice(i6 + 7, i6 + 9), 16);
            b4 = parseInt(seq.slice(i6 + 10, i6 + 12), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
              chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
              if (chr < 65536 || chr > 1114111) {
                result += "����";
              } else {
                chr -= 65536;
                result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
              }
              i6 += 9;
              continue;
            }
          }
          result += "�";
        }
        return result;
      });
    }
    decode2.defaultChars = ";/?:@&=+$,#";
    decode2.componentChars = "";
    module.exports = decode2;
  }
});
var require_format = __commonJS2({
  "node_modules/mdurl/format.js"(exports, module) {
    "use strict";
    module.exports = function format2(url) {
      var result = "";
      result += url.protocol || "";
      result += url.slashes ? "//" : "";
      result += url.auth ? url.auth + "@" : "";
      if (url.hostname && url.hostname.indexOf(":") !== -1) {
        result += "[" + url.hostname + "]";
      } else {
        result += url.hostname || "";
      }
      result += url.port ? ":" + url.port : "";
      result += url.pathname || "";
      result += url.search || "";
      result += url.hash || "";
      return result;
    };
  }
});
var require_parse = __commonJS2({
  "node_modules/mdurl/parse.js"(exports, module) {
    "use strict";
    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.pathname = null;
    }
    var protocolPattern = /^([a-z0-9.+-]+:)/i;
    var portPattern = /:[0-9]*$/;
    var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
    var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
    var autoEscape = ["'"].concat(unwise);
    var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
    var hostEndingChars = ["/", "?", "#"];
    var hostnameMaxLen = 255;
    var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    var hostlessProtocol = {
      "javascript": true,
      "javascript:": true
    };
    var slashedProtocol = {
      "http": true,
      "https": true,
      "ftp": true,
      "gopher": true,
      "file": true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    function urlParse(url, slashesDenoteHost) {
      if (url && url instanceof Url) {
        return url;
      }
      var u4 = new Url();
      u4.parse(url, slashesDenoteHost);
      return u4;
    }
    Url.prototype.parse = function(url, slashesDenoteHost) {
      var i6, l7, lowerProto, hec, slashes, rest = url;
      rest = rest.trim();
      if (!slashesDenoteHost && url.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
          }
          return this;
        }
      }
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        lowerProto = proto.toLowerCase();
        this.protocol = proto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (i6 = 0; i6 < hostEndingChars.length; i6++) {
          hec = rest.indexOf(hostEndingChars[i6]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = auth;
        }
        hostEnd = -1;
        for (i6 = 0; i6 < nonHostChars.length; i6++) {
          hec = rest.indexOf(nonHostChars[i6]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        if (hostEnd === -1) {
          hostEnd = rest.length;
        }
        if (rest[hostEnd - 1] === ":") {
          hostEnd--;
        }
        var host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost(host);
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (i6 = 0, l7 = hostparts.length; i6 < l7; i6++) {
            var part = hostparts[i6];
            if (!part) {
              continue;
            }
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j4 = 0, k2 = part.length; j4 < k2; j4++) {
                if (part.charCodeAt(j4) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j4];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i6);
                var notHost = hostparts.slice(i6 + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        }
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
        }
      }
      var hash2 = rest.indexOf("#");
      if (hash2 !== -1) {
        this.hash = rest.substr(hash2);
        rest = rest.slice(0, hash2);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        rest = rest.slice(0, qm);
      }
      if (rest) {
        this.pathname = rest;
      }
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "";
      }
      return this;
    };
    Url.prototype.parseHost = function(host) {
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) {
        this.hostname = host;
      }
    };
    module.exports = urlParse;
  }
});
var require_mdurl = __commonJS2({
  "node_modules/mdurl/index.js"(exports, module) {
    "use strict";
    module.exports.encode = require_encode();
    module.exports.decode = require_decode();
    module.exports.format = require_format();
    module.exports.parse = require_parse();
  }
});
var require_regex2 = __commonJS2({
  "node_modules/uc.micro/properties/Any/regex.js"(exports, module) {
    module.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  }
});
var require_regex3 = __commonJS2({
  "node_modules/uc.micro/categories/Cc/regex.js"(exports, module) {
    module.exports = /[\0-\x1F\x7F-\x9F]/;
  }
});
var require_regex4 = __commonJS2({
  "node_modules/uc.micro/categories/Cf/regex.js"(exports, module) {
    module.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
  }
});
var require_regex5 = __commonJS2({
  "node_modules/uc.micro/categories/Z/regex.js"(exports, module) {
    module.exports = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
  }
});
var require_uc = __commonJS2({
  "node_modules/uc.micro/index.js"(exports) {
    "use strict";
    exports.Any = require_regex2();
    exports.Cc = require_regex3();
    exports.Cf = require_regex4();
    exports.P = require_regex();
    exports.Z = require_regex5();
  }
});
var require_utils = __commonJS2({
  "node_modules/markdown-it/lib/common/utils.js"(exports) {
    "use strict";
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString2(obj) {
      return _class(obj) === "[object String]";
    }
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function has(object2, key) {
      return _hasOwnProperty.call(object2, key);
    }
    function assign3(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be object");
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function arrayReplaceAt(src, pos, newElements) {
      return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
    }
    function isValidEntityCode(c5) {
      if (c5 >= 55296 && c5 <= 57343) {
        return false;
      }
      if (c5 >= 64976 && c5 <= 65007) {
        return false;
      }
      if ((c5 & 65535) === 65535 || (c5 & 65535) === 65534) {
        return false;
      }
      if (c5 >= 0 && c5 <= 8) {
        return false;
      }
      if (c5 === 11) {
        return false;
      }
      if (c5 >= 14 && c5 <= 31) {
        return false;
      }
      if (c5 >= 127 && c5 <= 159) {
        return false;
      }
      if (c5 > 1114111) {
        return false;
      }
      return true;
    }
    function fromCodePoint4(c5) {
      if (c5 > 65535) {
        c5 -= 65536;
        var surrogate1 = 55296 + (c5 >> 10), surrogate2 = 56320 + (c5 & 1023);
        return String.fromCharCode(surrogate1, surrogate2);
      }
      return String.fromCharCode(c5);
    }
    var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
    var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
    var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
    var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;
    var entities = require_entities2();
    function replaceEntityPattern(match3, name2) {
      var code22 = 0;
      if (has(entities, name2)) {
        return entities[name2];
      }
      if (name2.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name2)) {
        code22 = name2[1].toLowerCase() === "x" ? parseInt(name2.slice(2), 16) : parseInt(name2.slice(1), 10);
        if (isValidEntityCode(code22)) {
          return fromCodePoint4(code22);
        }
      }
      return match3;
    }
    function unescapeMd(str) {
      if (str.indexOf("\\") < 0) {
        return str;
      }
      return str.replace(UNESCAPE_MD_RE, "$1");
    }
    function unescapeAll(str) {
      if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
        return str;
      }
      return str.replace(UNESCAPE_ALL_RE, function(match3, escaped, entity) {
        if (escaped) {
          return escaped;
        }
        return replaceEntityPattern(match3, entity);
      });
    }
    var HTML_ESCAPE_TEST_RE = /[&<>"]/;
    var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
    var HTML_REPLACEMENTS = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;"
    };
    function replaceUnsafeChar(ch) {
      return HTML_REPLACEMENTS[ch];
    }
    function escapeHtml2(str) {
      if (HTML_ESCAPE_TEST_RE.test(str)) {
        return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
      }
      return str;
    }
    var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
    function escapeRE(str) {
      return str.replace(REGEXP_ESCAPE_RE, "\\$&");
    }
    function isSpace(code22) {
      switch (code22) {
        case 9:
        case 32:
          return true;
      }
      return false;
    }
    function isWhiteSpace2(code22) {
      if (code22 >= 8192 && code22 <= 8202) {
        return true;
      }
      switch (code22) {
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 32:
        case 160:
        case 5760:
        case 8239:
        case 8287:
        case 12288:
          return true;
      }
      return false;
    }
    var UNICODE_PUNCT_RE = require_regex();
    function isPunctChar(ch) {
      return UNICODE_PUNCT_RE.test(ch);
    }
    function isMdAsciiPunct(ch) {
      switch (ch) {
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 124:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    function normalizeReference(str) {
      str = str.trim().replace(/\s+/g, " ");
      if ("ẞ".toLowerCase() === "Ṿ") {
        str = str.replace(/ẞ/g, "ß");
      }
      return str.toLowerCase().toUpperCase();
    }
    exports.lib = {};
    exports.lib.mdurl = require_mdurl();
    exports.lib.ucmicro = require_uc();
    exports.assign = assign3;
    exports.isString = isString2;
    exports.has = has;
    exports.unescapeMd = unescapeMd;
    exports.unescapeAll = unescapeAll;
    exports.isValidEntityCode = isValidEntityCode;
    exports.fromCodePoint = fromCodePoint4;
    exports.escapeHtml = escapeHtml2;
    exports.arrayReplaceAt = arrayReplaceAt;
    exports.isSpace = isSpace;
    exports.isWhiteSpace = isWhiteSpace2;
    exports.isMdAsciiPunct = isMdAsciiPunct;
    exports.isPunctChar = isPunctChar;
    exports.escapeRE = escapeRE;
    exports.normalizeReference = normalizeReference;
  }
});
var require_parse_link_label = __commonJS2({
  "node_modules/markdown-it/lib/helpers/parse_link_label.js"(exports, module) {
    "use strict";
    module.exports = function parseLinkLabel(state, start2, disableNested) {
      var level, found, marker, prevPos, labelEnd2 = -1, max22 = state.posMax, oldPos = state.pos;
      state.pos = start2 + 1;
      level = 1;
      while (state.pos < max22) {
        marker = state.src.charCodeAt(state.pos);
        if (marker === 93) {
          level--;
          if (level === 0) {
            found = true;
            break;
          }
        }
        prevPos = state.pos;
        state.md.inline.skipToken(state);
        if (marker === 91) {
          if (prevPos === state.pos - 1) {
            level++;
          } else if (disableNested) {
            state.pos = oldPos;
            return -1;
          }
        }
      }
      if (found) {
        labelEnd2 = state.pos;
      }
      state.pos = oldPos;
      return labelEnd2;
    };
  }
});
var require_parse_link_destination = __commonJS2({
  "node_modules/markdown-it/lib/helpers/parse_link_destination.js"(exports, module) {
    "use strict";
    var unescapeAll = require_utils().unescapeAll;
    module.exports = function parseLinkDestination(str, pos, max22) {
      var code22, level, lines = 0, start2 = pos, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (str.charCodeAt(pos) === 60) {
        pos++;
        while (pos < max22) {
          code22 = str.charCodeAt(pos);
          if (code22 === 10) {
            return result;
          }
          if (code22 === 60) {
            return result;
          }
          if (code22 === 62) {
            result.pos = pos + 1;
            result.str = unescapeAll(str.slice(start2 + 1, pos));
            result.ok = true;
            return result;
          }
          if (code22 === 92 && pos + 1 < max22) {
            pos += 2;
            continue;
          }
          pos++;
        }
        return result;
      }
      level = 0;
      while (pos < max22) {
        code22 = str.charCodeAt(pos);
        if (code22 === 32) {
          break;
        }
        if (code22 < 32 || code22 === 127) {
          break;
        }
        if (code22 === 92 && pos + 1 < max22) {
          if (str.charCodeAt(pos + 1) === 32) {
            break;
          }
          pos += 2;
          continue;
        }
        if (code22 === 40) {
          level++;
          if (level > 32) {
            return result;
          }
        }
        if (code22 === 41) {
          if (level === 0) {
            break;
          }
          level--;
        }
        pos++;
      }
      if (start2 === pos) {
        return result;
      }
      if (level !== 0) {
        return result;
      }
      result.str = unescapeAll(str.slice(start2, pos));
      result.lines = lines;
      result.pos = pos;
      result.ok = true;
      return result;
    };
  }
});
var require_parse_link_title = __commonJS2({
  "node_modules/markdown-it/lib/helpers/parse_link_title.js"(exports, module) {
    "use strict";
    var unescapeAll = require_utils().unescapeAll;
    module.exports = function parseLinkTitle(str, pos, max22) {
      var code22, marker, lines = 0, start2 = pos, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (pos >= max22) {
        return result;
      }
      marker = str.charCodeAt(pos);
      if (marker !== 34 && marker !== 39 && marker !== 40) {
        return result;
      }
      pos++;
      if (marker === 40) {
        marker = 41;
      }
      while (pos < max22) {
        code22 = str.charCodeAt(pos);
        if (code22 === marker) {
          result.pos = pos + 1;
          result.lines = lines;
          result.str = unescapeAll(str.slice(start2 + 1, pos));
          result.ok = true;
          return result;
        } else if (code22 === 40 && marker === 41) {
          return result;
        } else if (code22 === 10) {
          lines++;
        } else if (code22 === 92 && pos + 1 < max22) {
          pos++;
          if (str.charCodeAt(pos) === 10) {
            lines++;
          }
        }
        pos++;
      }
      return result;
    };
  }
});
var require_helpers = __commonJS2({
  "node_modules/markdown-it/lib/helpers/index.js"(exports) {
    "use strict";
    exports.parseLinkLabel = require_parse_link_label();
    exports.parseLinkDestination = require_parse_link_destination();
    exports.parseLinkTitle = require_parse_link_title();
  }
});
var require_renderer = __commonJS2({
  "node_modules/markdown-it/lib/renderer.js"(exports, module) {
    "use strict";
    var assign3 = require_utils().assign;
    var unescapeAll = require_utils().unescapeAll;
    var escapeHtml2 = require_utils().escapeHtml;
    var default_rules = {};
    default_rules.code_inline = function(tokens, idx, options, env, slf) {
      var token2 = tokens[idx];
      return "<code" + slf.renderAttrs(token2) + ">" + escapeHtml2(tokens[idx].content) + "</code>";
    };
    default_rules.code_block = function(tokens, idx, options, env, slf) {
      var token2 = tokens[idx];
      return "<pre" + slf.renderAttrs(token2) + "><code>" + escapeHtml2(tokens[idx].content) + "</code></pre>\n";
    };
    default_rules.fence = function(tokens, idx, options, env, slf) {
      var token2 = tokens[idx], info = token2.info ? unescapeAll(token2.info).trim() : "", langName = "", langAttrs = "", highlighted, i6, arr, tmpAttrs, tmpToken;
      if (info) {
        arr = info.split(/(\s+)/g);
        langName = arr[0];
        langAttrs = arr.slice(2).join("");
      }
      if (options.highlight) {
        highlighted = options.highlight(token2.content, langName, langAttrs) || escapeHtml2(token2.content);
      } else {
        highlighted = escapeHtml2(token2.content);
      }
      if (highlighted.indexOf("<pre") === 0) {
        return highlighted + "\n";
      }
      if (info) {
        i6 = token2.attrIndex("class");
        tmpAttrs = token2.attrs ? token2.attrs.slice() : [];
        if (i6 < 0) {
          tmpAttrs.push(["class", options.langPrefix + langName]);
        } else {
          tmpAttrs[i6] = tmpAttrs[i6].slice();
          tmpAttrs[i6][1] += " " + options.langPrefix + langName;
        }
        tmpToken = {
          attrs: tmpAttrs
        };
        return "<pre><code" + slf.renderAttrs(tmpToken) + ">" + highlighted + "</code></pre>\n";
      }
      return "<pre><code" + slf.renderAttrs(token2) + ">" + highlighted + "</code></pre>\n";
    };
    default_rules.image = function(tokens, idx, options, env, slf) {
      var token2 = tokens[idx];
      token2.attrs[token2.attrIndex("alt")][1] = slf.renderInlineAsText(token2.children, options, env);
      return slf.renderToken(tokens, idx, options);
    };
    default_rules.hardbreak = function(tokens, idx, options) {
      return options.xhtmlOut ? "<br />\n" : "<br>\n";
    };
    default_rules.softbreak = function(tokens, idx, options) {
      return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
    };
    default_rules.text = function(tokens, idx) {
      return escapeHtml2(tokens[idx].content);
    };
    default_rules.html_block = function(tokens, idx) {
      return tokens[idx].content;
    };
    default_rules.html_inline = function(tokens, idx) {
      return tokens[idx].content;
    };
    function Renderer() {
      this.rules = assign3({}, default_rules);
    }
    Renderer.prototype.renderAttrs = function renderAttrs(token2) {
      var i6, l7, result;
      if (!token2.attrs) {
        return "";
      }
      result = "";
      for (i6 = 0, l7 = token2.attrs.length; i6 < l7; i6++) {
        result += " " + escapeHtml2(token2.attrs[i6][0]) + '="' + escapeHtml2(token2.attrs[i6][1]) + '"';
      }
      return result;
    };
    Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
      var nextToken, result = "", needLf = false, token2 = tokens[idx];
      if (token2.hidden) {
        return "";
      }
      if (token2.block && token2.nesting !== -1 && idx && tokens[idx - 1].hidden) {
        result += "\n";
      }
      result += (token2.nesting === -1 ? "</" : "<") + token2.tag;
      result += this.renderAttrs(token2);
      if (token2.nesting === 0 && options.xhtmlOut) {
        result += " /";
      }
      if (token2.block) {
        needLf = true;
        if (token2.nesting === 1) {
          if (idx + 1 < tokens.length) {
            nextToken = tokens[idx + 1];
            if (nextToken.type === "inline" || nextToken.hidden) {
              needLf = false;
            } else if (nextToken.nesting === -1 && nextToken.tag === token2.tag) {
              needLf = false;
            }
          }
        }
      }
      result += needLf ? ">\n" : ">";
      return result;
    };
    Renderer.prototype.renderInline = function(tokens, options, env) {
      var type2, result = "", rules = this.rules;
      for (var i6 = 0, len = tokens.length; i6 < len; i6++) {
        type2 = tokens[i6].type;
        if (typeof rules[type2] !== "undefined") {
          result += rules[type2](tokens, i6, options, env, this);
        } else {
          result += this.renderToken(tokens, i6, options);
        }
      }
      return result;
    };
    Renderer.prototype.renderInlineAsText = function(tokens, options, env) {
      var result = "";
      for (var i6 = 0, len = tokens.length; i6 < len; i6++) {
        if (tokens[i6].type === "text") {
          result += tokens[i6].content;
        } else if (tokens[i6].type === "image") {
          result += this.renderInlineAsText(tokens[i6].children, options, env);
        } else if (tokens[i6].type === "softbreak") {
          result += "\n";
        }
      }
      return result;
    };
    Renderer.prototype.render = function(tokens, options, env) {
      var i6, len, type2, result = "", rules = this.rules;
      for (i6 = 0, len = tokens.length; i6 < len; i6++) {
        type2 = tokens[i6].type;
        if (type2 === "inline") {
          result += this.renderInline(tokens[i6].children, options, env);
        } else if (typeof rules[type2] !== "undefined") {
          result += rules[tokens[i6].type](tokens, i6, options, env, this);
        } else {
          result += this.renderToken(tokens, i6, options, env);
        }
      }
      return result;
    };
    module.exports = Renderer;
  }
});
var require_ruler = __commonJS2({
  "node_modules/markdown-it/lib/ruler.js"(exports, module) {
    "use strict";
    function Ruler() {
      this.__rules__ = [];
      this.__cache__ = null;
    }
    Ruler.prototype.__find__ = function(name2) {
      for (var i6 = 0; i6 < this.__rules__.length; i6++) {
        if (this.__rules__[i6].name === name2) {
          return i6;
        }
      }
      return -1;
    };
    Ruler.prototype.__compile__ = function() {
      var self2 = this;
      var chains = [""];
      self2.__rules__.forEach(function(rule) {
        if (!rule.enabled) {
          return;
        }
        rule.alt.forEach(function(altName) {
          if (chains.indexOf(altName) < 0) {
            chains.push(altName);
          }
        });
      });
      self2.__cache__ = {};
      chains.forEach(function(chain) {
        self2.__cache__[chain] = [];
        self2.__rules__.forEach(function(rule) {
          if (!rule.enabled) {
            return;
          }
          if (chain && rule.alt.indexOf(chain) < 0) {
            return;
          }
          self2.__cache__[chain].push(rule.fn);
        });
      });
    };
    Ruler.prototype.at = function(name2, fn2, options) {
      var index3 = this.__find__(name2);
      var opt = options || {};
      if (index3 === -1) {
        throw new Error("Parser rule not found: " + name2);
      }
      this.__rules__[index3].fn = fn2;
      this.__rules__[index3].alt = opt.alt || [];
      this.__cache__ = null;
    };
    Ruler.prototype.before = function(beforeName, ruleName, fn2, options) {
      var index3 = this.__find__(beforeName);
      var opt = options || {};
      if (index3 === -1) {
        throw new Error("Parser rule not found: " + beforeName);
      }
      this.__rules__.splice(index3, 0, {
        name: ruleName,
        enabled: true,
        fn: fn2,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.after = function(afterName, ruleName, fn2, options) {
      var index3 = this.__find__(afterName);
      var opt = options || {};
      if (index3 === -1) {
        throw new Error("Parser rule not found: " + afterName);
      }
      this.__rules__.splice(index3 + 1, 0, {
        name: ruleName,
        enabled: true,
        fn: fn2,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.push = function(ruleName, fn2, options) {
      var opt = options || {};
      this.__rules__.push({
        name: ruleName,
        enabled: true,
        fn: fn2,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.enable = function(list22, ignoreInvalid) {
      if (!Array.isArray(list22)) {
        list22 = [list22];
      }
      var result = [];
      list22.forEach(function(name2) {
        var idx = this.__find__(name2);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name2);
        }
        this.__rules__[idx].enabled = true;
        result.push(name2);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler.prototype.enableOnly = function(list22, ignoreInvalid) {
      if (!Array.isArray(list22)) {
        list22 = [list22];
      }
      this.__rules__.forEach(function(rule) {
        rule.enabled = false;
      });
      this.enable(list22, ignoreInvalid);
    };
    Ruler.prototype.disable = function(list22, ignoreInvalid) {
      if (!Array.isArray(list22)) {
        list22 = [list22];
      }
      var result = [];
      list22.forEach(function(name2) {
        var idx = this.__find__(name2);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name2);
        }
        this.__rules__[idx].enabled = false;
        result.push(name2);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler.prototype.getRules = function(chainName) {
      if (this.__cache__ === null) {
        this.__compile__();
      }
      return this.__cache__[chainName] || [];
    };
    module.exports = Ruler;
  }
});
var require_normalize = __commonJS2({
  "node_modules/markdown-it/lib/rules_core/normalize.js"(exports, module) {
    "use strict";
    var NEWLINES_RE = /\r\n?|\n/g;
    var NULL_RE = /\0/g;
    module.exports = function normalize2(state) {
      var str;
      str = state.src.replace(NEWLINES_RE, "\n");
      str = str.replace(NULL_RE, "�");
      state.src = str;
    };
  }
});
var require_block = __commonJS2({
  "node_modules/markdown-it/lib/rules_core/block.js"(exports, module) {
    "use strict";
    module.exports = function block42(state) {
      var token2;
      if (state.inlineMode) {
        token2 = new state.Token("inline", "", 0);
        token2.content = state.src;
        token2.map = [0, 1];
        token2.children = [];
        state.tokens.push(token2);
      } else {
        state.md.block.parse(state.src, state.md, state.env, state.tokens);
      }
    };
  }
});
var require_inline = __commonJS2({
  "node_modules/markdown-it/lib/rules_core/inline.js"(exports, module) {
    "use strict";
    module.exports = function inline4(state) {
      var tokens = state.tokens, tok, i6, l7;
      for (i6 = 0, l7 = tokens.length; i6 < l7; i6++) {
        tok = tokens[i6];
        if (tok.type === "inline") {
          state.md.inline.parse(tok.content, state.md, state.env, tok.children);
        }
      }
    };
  }
});
var require_linkify = __commonJS2({
  "node_modules/markdown-it/lib/rules_core/linkify.js"(exports, module) {
    "use strict";
    var arrayReplaceAt = require_utils().arrayReplaceAt;
    function isLinkOpen(str) {
      return /^<a[>\s]/i.test(str);
    }
    function isLinkClose(str) {
      return /^<\/a\s*>/i.test(str);
    }
    module.exports = function linkify(state) {
      var i6, j4, l7, tokens, token2, currentToken, nodes, ln3, text22, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state.tokens, links;
      if (!state.md.options.linkify) {
        return;
      }
      for (j4 = 0, l7 = blockTokens.length; j4 < l7; j4++) {
        if (blockTokens[j4].type !== "inline" || !state.md.linkify.pretest(blockTokens[j4].content)) {
          continue;
        }
        tokens = blockTokens[j4].children;
        htmlLinkLevel = 0;
        for (i6 = tokens.length - 1; i6 >= 0; i6--) {
          currentToken = tokens[i6];
          if (currentToken.type === "link_close") {
            i6--;
            while (tokens[i6].level !== currentToken.level && tokens[i6].type !== "link_open") {
              i6--;
            }
            continue;
          }
          if (currentToken.type === "html_inline") {
            if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
              htmlLinkLevel--;
            }
            if (isLinkClose(currentToken.content)) {
              htmlLinkLevel++;
            }
          }
          if (htmlLinkLevel > 0) {
            continue;
          }
          if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
            text22 = currentToken.content;
            links = state.md.linkify.match(text22);
            nodes = [];
            level = currentToken.level;
            lastPos = 0;
            for (ln3 = 0; ln3 < links.length; ln3++) {
              url = links[ln3].url;
              fullUrl = state.md.normalizeLink(url);
              if (!state.md.validateLink(fullUrl)) {
                continue;
              }
              urlText = links[ln3].text;
              if (!links[ln3].schema) {
                urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
              } else if (links[ln3].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
                urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
              } else {
                urlText = state.md.normalizeLinkText(urlText);
              }
              pos = links[ln3].index;
              if (pos > lastPos) {
                token2 = new state.Token("text", "", 0);
                token2.content = text22.slice(lastPos, pos);
                token2.level = level;
                nodes.push(token2);
              }
              token2 = new state.Token("link_open", "a", 1);
              token2.attrs = [["href", fullUrl]];
              token2.level = level++;
              token2.markup = "linkify";
              token2.info = "auto";
              nodes.push(token2);
              token2 = new state.Token("text", "", 0);
              token2.content = urlText;
              token2.level = level;
              nodes.push(token2);
              token2 = new state.Token("link_close", "a", -1);
              token2.level = --level;
              token2.markup = "linkify";
              token2.info = "auto";
              nodes.push(token2);
              lastPos = links[ln3].lastIndex;
            }
            if (lastPos < text22.length) {
              token2 = new state.Token("text", "", 0);
              token2.content = text22.slice(lastPos);
              token2.level = level;
              nodes.push(token2);
            }
            blockTokens[j4].children = tokens = arrayReplaceAt(tokens, i6, nodes);
          }
        }
      }
    };
  }
});
var require_replacements = __commonJS2({
  "node_modules/markdown-it/lib/rules_core/replacements.js"(exports, module) {
    "use strict";
    var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
    var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;
    var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
    var SCOPED_ABBR = {
      c: "©",
      r: "®",
      p: "§",
      tm: "™"
    };
    function replaceFn(match3, name2) {
      return SCOPED_ABBR[name2.toLowerCase()];
    }
    function replace_scoped(inlineTokens) {
      var i6, token2, inside_autolink = 0;
      for (i6 = inlineTokens.length - 1; i6 >= 0; i6--) {
        token2 = inlineTokens[i6];
        if (token2.type === "text" && !inside_autolink) {
          token2.content = token2.content.replace(SCOPED_ABBR_RE, replaceFn);
        }
        if (token2.type === "link_open" && token2.info === "auto") {
          inside_autolink--;
        }
        if (token2.type === "link_close" && token2.info === "auto") {
          inside_autolink++;
        }
      }
    }
    function replace_rare(inlineTokens) {
      var i6, token2, inside_autolink = 0;
      for (i6 = inlineTokens.length - 1; i6 >= 0; i6--) {
        token2 = inlineTokens[i6];
        if (token2.type === "text" && !inside_autolink) {
          if (RARE_RE.test(token2.content)) {
            token2.content = token2.content.replace(/\+-/g, "±").replace(/\.{2,}/g, "…").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1—").replace(/(^|\s)--(?=\s|$)/mg, "$1–").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1–");
          }
        }
        if (token2.type === "link_open" && token2.info === "auto") {
          inside_autolink--;
        }
        if (token2.type === "link_close" && token2.info === "auto") {
          inside_autolink++;
        }
      }
    }
    module.exports = function replace2(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline") {
          continue;
        }
        if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
          replace_scoped(state.tokens[blkIdx].children);
        }
        if (RARE_RE.test(state.tokens[blkIdx].content)) {
          replace_rare(state.tokens[blkIdx].children);
        }
      }
    };
  }
});
var require_smartquotes = __commonJS2({
  "node_modules/markdown-it/lib/rules_core/smartquotes.js"(exports, module) {
    "use strict";
    var isWhiteSpace2 = require_utils().isWhiteSpace;
    var isPunctChar = require_utils().isPunctChar;
    var isMdAsciiPunct = require_utils().isMdAsciiPunct;
    var QUOTE_TEST_RE = /['"]/;
    var QUOTE_RE = /['"]/g;
    var APOSTROPHE = "’";
    function replaceAt(str, index3, ch) {
      return str.substr(0, index3) + ch + str.substr(index3 + 1);
    }
    function process_inlines(tokens, state) {
      var i6, token2, text22, t5, pos, max22, thisLevel, item2, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j4, isSingle, stack, openQuote, closeQuote;
      stack = [];
      for (i6 = 0; i6 < tokens.length; i6++) {
        token2 = tokens[i6];
        thisLevel = tokens[i6].level;
        for (j4 = stack.length - 1; j4 >= 0; j4--) {
          if (stack[j4].level <= thisLevel) {
            break;
          }
        }
        stack.length = j4 + 1;
        if (token2.type !== "text") {
          continue;
        }
        text22 = token2.content;
        pos = 0;
        max22 = text22.length;
        OUTER:
          while (pos < max22) {
            QUOTE_RE.lastIndex = pos;
            t5 = QUOTE_RE.exec(text22);
            if (!t5) {
              break;
            }
            canOpen = canClose = true;
            pos = t5.index + 1;
            isSingle = t5[0] === "'";
            lastChar = 32;
            if (t5.index - 1 >= 0) {
              lastChar = text22.charCodeAt(t5.index - 1);
            } else {
              for (j4 = i6 - 1; j4 >= 0; j4--) {
                if (tokens[j4].type === "softbreak" || tokens[j4].type === "hardbreak")
                  break;
                if (!tokens[j4].content)
                  continue;
                lastChar = tokens[j4].content.charCodeAt(tokens[j4].content.length - 1);
                break;
              }
            }
            nextChar = 32;
            if (pos < max22) {
              nextChar = text22.charCodeAt(pos);
            } else {
              for (j4 = i6 + 1; j4 < tokens.length; j4++) {
                if (tokens[j4].type === "softbreak" || tokens[j4].type === "hardbreak")
                  break;
                if (!tokens[j4].content)
                  continue;
                nextChar = tokens[j4].content.charCodeAt(0);
                break;
              }
            }
            isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
            isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
            isLastWhiteSpace = isWhiteSpace2(lastChar);
            isNextWhiteSpace = isWhiteSpace2(nextChar);
            if (isNextWhiteSpace) {
              canOpen = false;
            } else if (isNextPunctChar) {
              if (!(isLastWhiteSpace || isLastPunctChar)) {
                canOpen = false;
              }
            }
            if (isLastWhiteSpace) {
              canClose = false;
            } else if (isLastPunctChar) {
              if (!(isNextWhiteSpace || isNextPunctChar)) {
                canClose = false;
              }
            }
            if (nextChar === 34 && t5[0] === '"') {
              if (lastChar >= 48 && lastChar <= 57) {
                canClose = canOpen = false;
              }
            }
            if (canOpen && canClose) {
              canOpen = isLastPunctChar;
              canClose = isNextPunctChar;
            }
            if (!canOpen && !canClose) {
              if (isSingle) {
                token2.content = replaceAt(token2.content, t5.index, APOSTROPHE);
              }
              continue;
            }
            if (canClose) {
              for (j4 = stack.length - 1; j4 >= 0; j4--) {
                item2 = stack[j4];
                if (stack[j4].level < thisLevel) {
                  break;
                }
                if (item2.single === isSingle && stack[j4].level === thisLevel) {
                  item2 = stack[j4];
                  if (isSingle) {
                    openQuote = state.md.options.quotes[2];
                    closeQuote = state.md.options.quotes[3];
                  } else {
                    openQuote = state.md.options.quotes[0];
                    closeQuote = state.md.options.quotes[1];
                  }
                  token2.content = replaceAt(token2.content, t5.index, closeQuote);
                  tokens[item2.token].content = replaceAt(tokens[item2.token].content, item2.pos, openQuote);
                  pos += closeQuote.length - 1;
                  if (item2.token === i6) {
                    pos += openQuote.length - 1;
                  }
                  text22 = token2.content;
                  max22 = text22.length;
                  stack.length = j4;
                  continue OUTER;
                }
              }
            }
            if (canOpen) {
              stack.push({
                token: i6,
                pos: t5.index,
                single: isSingle,
                level: thisLevel
              });
            } else if (canClose && isSingle) {
              token2.content = replaceAt(token2.content, t5.index, APOSTROPHE);
            }
          }
      }
    }
    module.exports = function smartquotes(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
          continue;
        }
        process_inlines(state.tokens[blkIdx].children, state);
      }
    };
  }
});
var require_token = __commonJS2({
  "node_modules/markdown-it/lib/token.js"(exports, module) {
    "use strict";
    function Token2(type2, tag2, nesting) {
      this.type = type2;
      this.tag = tag2;
      this.attrs = null;
      this.map = null;
      this.nesting = nesting;
      this.level = 0;
      this.children = null;
      this.content = "";
      this.markup = "";
      this.info = "";
      this.meta = null;
      this.block = false;
      this.hidden = false;
    }
    Token2.prototype.attrIndex = function attrIndex(name2) {
      var attrs, i6, len;
      if (!this.attrs) {
        return -1;
      }
      attrs = this.attrs;
      for (i6 = 0, len = attrs.length; i6 < len; i6++) {
        if (attrs[i6][0] === name2) {
          return i6;
        }
      }
      return -1;
    };
    Token2.prototype.attrPush = function attrPush(attrData) {
      if (this.attrs) {
        this.attrs.push(attrData);
      } else {
        this.attrs = [attrData];
      }
    };
    Token2.prototype.attrSet = function attrSet(name2, value2) {
      var idx = this.attrIndex(name2), attrData = [name2, value2];
      if (idx < 0) {
        this.attrPush(attrData);
      } else {
        this.attrs[idx] = attrData;
      }
    };
    Token2.prototype.attrGet = function attrGet(name2) {
      var idx = this.attrIndex(name2), value2 = null;
      if (idx >= 0) {
        value2 = this.attrs[idx][1];
      }
      return value2;
    };
    Token2.prototype.attrJoin = function attrJoin(name2, value2) {
      var idx = this.attrIndex(name2);
      if (idx < 0) {
        this.attrPush([name2, value2]);
      } else {
        this.attrs[idx][1] = this.attrs[idx][1] + " " + value2;
      }
    };
    module.exports = Token2;
  }
});
var require_state_core = __commonJS2({
  "node_modules/markdown-it/lib/rules_core/state_core.js"(exports, module) {
    "use strict";
    var Token2 = require_token();
    function StateCore(src, md, env) {
      this.src = src;
      this.env = env;
      this.tokens = [];
      this.inlineMode = false;
      this.md = md;
    }
    StateCore.prototype.Token = Token2;
    module.exports = StateCore;
  }
});
var require_parser_core = __commonJS2({
  "node_modules/markdown-it/lib/parser_core.js"(exports, module) {
    "use strict";
    var Ruler = require_ruler();
    var _rules = [
      ["normalize", require_normalize()],
      ["block", require_block()],
      ["inline", require_inline()],
      ["linkify", require_linkify()],
      ["replacements", require_replacements()],
      ["smartquotes", require_smartquotes()]
    ];
    function Core() {
      this.ruler = new Ruler();
      for (var i6 = 0; i6 < _rules.length; i6++) {
        this.ruler.push(_rules[i6][0], _rules[i6][1]);
      }
    }
    Core.prototype.process = function(state) {
      var i6, l7, rules;
      rules = this.ruler.getRules("");
      for (i6 = 0, l7 = rules.length; i6 < l7; i6++) {
        rules[i6](state);
      }
    };
    Core.prototype.State = require_state_core();
    module.exports = Core;
  }
});
var require_table = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/table.js"(exports, module) {
    "use strict";
    var isSpace = require_utils().isSpace;
    function getLine2(state, line2) {
      var pos = state.bMarks[line2] + state.tShift[line2], max22 = state.eMarks[line2];
      return state.src.substr(pos, max22 - pos);
    }
    function escapedSplit(str) {
      var result = [], pos = 0, max22 = str.length, ch, isEscaped = false, lastPos = 0, current = "";
      ch = str.charCodeAt(pos);
      while (pos < max22) {
        if (ch === 124) {
          if (!isEscaped) {
            result.push(current + str.substring(lastPos, pos));
            current = "";
            lastPos = pos + 1;
          } else {
            current += str.substring(lastPos, pos - 1);
            lastPos = pos;
          }
        }
        isEscaped = ch === 92;
        pos++;
        ch = str.charCodeAt(pos);
      }
      result.push(current + str.substring(lastPos));
      return result;
    }
    module.exports = function table3(state, startLine, endLine, silent) {
      var ch, lineText, pos, i6, l7, nextLine, columns, columnCount, token2, aligns, t5, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;
      if (startLine + 2 > endLine) {
        return false;
      }
      nextLine = startLine + 1;
      if (state.sCount[nextLine] < state.blkIndent) {
        return false;
      }
      if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent >= 4) {
        return false;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      firstCh = state.src.charCodeAt(pos++);
      if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
        return false;
      }
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      secondCh = state.src.charCodeAt(pos++);
      if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace(secondCh)) {
        return false;
      }
      if (firstCh === 45 && isSpace(secondCh)) {
        return false;
      }
      while (pos < state.eMarks[nextLine]) {
        ch = state.src.charCodeAt(pos);
        if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {
          return false;
        }
        pos++;
      }
      lineText = getLine2(state, startLine + 1);
      columns = lineText.split("|");
      aligns = [];
      for (i6 = 0; i6 < columns.length; i6++) {
        t5 = columns[i6].trim();
        if (!t5) {
          if (i6 === 0 || i6 === columns.length - 1) {
            continue;
          } else {
            return false;
          }
        }
        if (!/^:?-+:?$/.test(t5)) {
          return false;
        }
        if (t5.charCodeAt(t5.length - 1) === 58) {
          aligns.push(t5.charCodeAt(0) === 58 ? "center" : "right");
        } else if (t5.charCodeAt(0) === 58) {
          aligns.push("left");
        } else {
          aligns.push("");
        }
      }
      lineText = getLine2(state, startLine).trim();
      if (lineText.indexOf("|") === -1) {
        return false;
      }
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      columns = escapedSplit(lineText);
      if (columns.length && columns[0] === "")
        columns.shift();
      if (columns.length && columns[columns.length - 1] === "")
        columns.pop();
      columnCount = columns.length;
      if (columnCount === 0 || columnCount !== aligns.length) {
        return false;
      }
      if (silent) {
        return true;
      }
      oldParentType = state.parentType;
      state.parentType = "table";
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      token2 = state.push("table_open", "table", 1);
      token2.map = tableLines = [startLine, 0];
      token2 = state.push("thead_open", "thead", 1);
      token2.map = [startLine, startLine + 1];
      token2 = state.push("tr_open", "tr", 1);
      token2.map = [startLine, startLine + 1];
      for (i6 = 0; i6 < columns.length; i6++) {
        token2 = state.push("th_open", "th", 1);
        if (aligns[i6]) {
          token2.attrs = [["style", "text-align:" + aligns[i6]]];
        }
        token2 = state.push("inline", "", 0);
        token2.content = columns[i6].trim();
        token2.children = [];
        token2 = state.push("th_close", "th", -1);
      }
      token2 = state.push("tr_close", "tr", -1);
      token2 = state.push("thead_close", "thead", -1);
      for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        terminate = false;
        for (i6 = 0, l7 = terminatorRules.length; i6 < l7; i6++) {
          if (terminatorRules[i6](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        lineText = getLine2(state, nextLine).trim();
        if (!lineText) {
          break;
        }
        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent >= 4) {
          break;
        }
        columns = escapedSplit(lineText);
        if (columns.length && columns[0] === "")
          columns.shift();
        if (columns.length && columns[columns.length - 1] === "")
          columns.pop();
        if (nextLine === startLine + 2) {
          token2 = state.push("tbody_open", "tbody", 1);
          token2.map = tbodyLines = [startLine + 2, 0];
        }
        token2 = state.push("tr_open", "tr", 1);
        token2.map = [nextLine, nextLine + 1];
        for (i6 = 0; i6 < columnCount; i6++) {
          token2 = state.push("td_open", "td", 1);
          if (aligns[i6]) {
            token2.attrs = [["style", "text-align:" + aligns[i6]]];
          }
          token2 = state.push("inline", "", 0);
          token2.content = columns[i6] ? columns[i6].trim() : "";
          token2.children = [];
          token2 = state.push("td_close", "td", -1);
        }
        token2 = state.push("tr_close", "tr", -1);
      }
      if (tbodyLines) {
        token2 = state.push("tbody_close", "tbody", -1);
        tbodyLines[1] = nextLine;
      }
      token2 = state.push("table_close", "table", -1);
      tableLines[1] = nextLine;
      state.parentType = oldParentType;
      state.line = nextLine;
      return true;
    };
  }
});
var require_code = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/code.js"(exports, module) {
    "use strict";
    module.exports = function code22(state, startLine, endLine) {
      if (state.md.options.allowIndentation) {
        return false;
      }
      var nextLine, last2, token2;
      if (state.sCount[startLine] - state.blkIndent < 4) {
        return false;
      }
      last2 = nextLine = startLine + 1;
      while (nextLine < endLine) {
        if (state.isEmpty(nextLine)) {
          nextLine++;
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          nextLine++;
          last2 = nextLine;
          continue;
        }
        break;
      }
      state.line = last2;
      token2 = state.push("code_block", "code", 0);
      token2.content = state.getLines(startLine, last2, 4 + state.blkIndent, false) + "\n";
      token2.map = [startLine, state.line];
      return true;
    };
  }
});
var require_fence = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/fence.js"(exports, module) {
    "use strict";
    module.exports = function fence3(state, startLine, endLine, silent) {
      var marker, len, params2, nextLine, mem, token2, markup, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max22 = state.eMarks[startLine];
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (pos + 3 > max22) {
        return false;
      }
      marker = state.src.charCodeAt(pos);
      if (marker !== 126 && marker !== 96) {
        return false;
      }
      mem = pos;
      pos = state.skipChars(pos, marker);
      len = pos - mem;
      if (len < 3) {
        return false;
      }
      markup = state.src.slice(mem, pos);
      params2 = state.src.slice(pos, max22);
      if (marker === 96) {
        if (params2.indexOf(String.fromCharCode(marker)) >= 0) {
          return false;
        }
      }
      if (silent) {
        return true;
      }
      nextLine = startLine;
      for (; ; ) {
        nextLine++;
        if (nextLine >= endLine) {
          break;
        }
        pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
        max22 = state.eMarks[nextLine];
        if (pos < max22 && state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.src.charCodeAt(pos) !== marker) {
          continue;
        }
        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent >= 4) {
          continue;
        }
        pos = state.skipChars(pos, marker);
        if (pos - mem < len) {
          continue;
        }
        pos = state.skipSpaces(pos);
        if (pos < max22) {
          continue;
        }
        haveEndMarker = true;
        break;
      }
      len = state.sCount[startLine];
      state.line = nextLine + (haveEndMarker ? 1 : 0);
      token2 = state.push("fence", "code", 0);
      token2.info = params2;
      token2.content = state.getLines(startLine + 1, nextLine, len, true);
      token2.markup = markup;
      token2.map = [startLine, state.line];
      return true;
    };
  }
});
var require_blockquote = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/blockquote.js"(exports, module) {
    "use strict";
    var isSpace = require_utils().isSpace;
    module.exports = function blockquote2(state, startLine, endLine, silent) {
      var adjustTab, ch, i6, initial, l7, lastLineEmpty, lines, nextLine, offset, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token2, isOutdented, oldLineMax = state.lineMax, pos = state.bMarks[startLine] + state.tShift[startLine], max22 = state.eMarks[startLine];
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos++) !== 62) {
        return false;
      }
      if (silent) {
        return true;
      }
      initial = offset = state.sCount[startLine] + 1;
      if (state.src.charCodeAt(pos) === 32) {
        pos++;
        initial++;
        offset++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state.src.charCodeAt(pos) === 9) {
        spaceAfterMarker = true;
        if ((state.bsCount[startLine] + offset) % 4 === 3) {
          pos++;
          initial++;
          offset++;
          adjustTab = false;
        } else {
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }
      oldBMarks = [state.bMarks[startLine]];
      state.bMarks[startLine] = pos;
      while (pos < max22) {
        ch = state.src.charCodeAt(pos);
        if (isSpace(ch)) {
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }
        pos++;
      }
      oldBSCount = [state.bsCount[startLine]];
      state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);
      lastLineEmpty = pos >= max22;
      oldSCount = [state.sCount[startLine]];
      state.sCount[startLine] = offset - initial;
      oldTShift = [state.tShift[startLine]];
      state.tShift[startLine] = pos - state.bMarks[startLine];
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      oldParentType = state.parentType;
      state.parentType = "blockquote";
      for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
        isOutdented = state.sCount[nextLine] < state.blkIndent;
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max22 = state.eMarks[nextLine];
        if (pos >= max22) {
          break;
        }
        if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
          initial = offset = state.sCount[nextLine] + 1;
          if (state.src.charCodeAt(pos) === 32) {
            pos++;
            initial++;
            offset++;
            adjustTab = false;
            spaceAfterMarker = true;
          } else if (state.src.charCodeAt(pos) === 9) {
            spaceAfterMarker = true;
            if ((state.bsCount[nextLine] + offset) % 4 === 3) {
              pos++;
              initial++;
              offset++;
              adjustTab = false;
            } else {
              adjustTab = true;
            }
          } else {
            spaceAfterMarker = false;
          }
          oldBMarks.push(state.bMarks[nextLine]);
          state.bMarks[nextLine] = pos;
          while (pos < max22) {
            ch = state.src.charCodeAt(pos);
            if (isSpace(ch)) {
              if (ch === 9) {
                offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
              } else {
                offset++;
              }
            } else {
              break;
            }
            pos++;
          }
          lastLineEmpty = pos >= max22;
          oldBSCount.push(state.bsCount[nextLine]);
          state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
          oldSCount.push(state.sCount[nextLine]);
          state.sCount[nextLine] = offset - initial;
          oldTShift.push(state.tShift[nextLine]);
          state.tShift[nextLine] = pos - state.bMarks[nextLine];
          continue;
        }
        if (lastLineEmpty) {
          break;
        }
        terminate = false;
        for (i6 = 0, l7 = terminatorRules.length; i6 < l7; i6++) {
          if (terminatorRules[i6](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          state.lineMax = nextLine;
          if (state.blkIndent !== 0) {
            oldBMarks.push(state.bMarks[nextLine]);
            oldBSCount.push(state.bsCount[nextLine]);
            oldTShift.push(state.tShift[nextLine]);
            oldSCount.push(state.sCount[nextLine]);
            state.sCount[nextLine] -= state.blkIndent;
          }
          break;
        }
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] = -1;
      }
      oldIndent = state.blkIndent;
      state.blkIndent = 0;
      token2 = state.push("blockquote_open", "blockquote", 1);
      token2.markup = ">";
      token2.map = lines = [startLine, 0];
      state.md.block.tokenize(state, startLine, nextLine);
      token2 = state.push("blockquote_close", "blockquote", -1);
      token2.markup = ">";
      state.lineMax = oldLineMax;
      state.parentType = oldParentType;
      lines[1] = state.line;
      for (i6 = 0; i6 < oldTShift.length; i6++) {
        state.bMarks[i6 + startLine] = oldBMarks[i6];
        state.tShift[i6 + startLine] = oldTShift[i6];
        state.sCount[i6 + startLine] = oldSCount[i6];
        state.bsCount[i6 + startLine] = oldBSCount[i6];
      }
      state.blkIndent = oldIndent;
      return true;
    };
  }
});
var require_hr = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/hr.js"(exports, module) {
    "use strict";
    var isSpace = require_utils().isSpace;
    module.exports = function hr2(state, startLine, endLine, silent) {
      var marker, cnt, ch, token2, pos = state.bMarks[startLine] + state.tShift[startLine], max22 = state.eMarks[startLine];
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      marker = state.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 95) {
        return false;
      }
      cnt = 1;
      while (pos < max22) {
        ch = state.src.charCodeAt(pos++);
        if (ch !== marker && !isSpace(ch)) {
          return false;
        }
        if (ch === marker) {
          cnt++;
        }
      }
      if (cnt < 3) {
        return false;
      }
      if (silent) {
        return true;
      }
      state.line = startLine + 1;
      token2 = state.push("hr", "hr", 0);
      token2.map = [startLine, state.line];
      token2.markup = Array(cnt + 1).join(String.fromCharCode(marker));
      return true;
    };
  }
});
var require_list = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/list.js"(exports, module) {
    "use strict";
    var isSpace = require_utils().isSpace;
    function skipBulletListMarker(state, startLine) {
      var marker, pos, max22, ch;
      pos = state.bMarks[startLine] + state.tShift[startLine];
      max22 = state.eMarks[startLine];
      marker = state.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 43) {
        return -1;
      }
      if (pos < max22) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function skipOrderedListMarker(state, startLine) {
      var ch, start2 = state.bMarks[startLine] + state.tShift[startLine], pos = start2, max22 = state.eMarks[startLine];
      if (pos + 1 >= max22) {
        return -1;
      }
      ch = state.src.charCodeAt(pos++);
      if (ch < 48 || ch > 57) {
        return -1;
      }
      for (; ; ) {
        if (pos >= max22) {
          return -1;
        }
        ch = state.src.charCodeAt(pos++);
        if (ch >= 48 && ch <= 57) {
          if (pos - start2 >= 10) {
            return -1;
          }
          continue;
        }
        if (ch === 41 || ch === 46) {
          break;
        }
        return -1;
      }
      if (pos < max22) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function markTightParagraphs(state, idx) {
      var i6, l7, level = state.level + 2;
      for (i6 = idx + 2, l7 = state.tokens.length - 2; i6 < l7; i6++) {
        if (state.tokens[i6].level === level && state.tokens[i6].type === "paragraph_open") {
          state.tokens[i6 + 2].hidden = true;
          state.tokens[i6].hidden = true;
          i6 += 2;
        }
      }
    }
    module.exports = function list22(state, startLine, endLine, silent) {
      var ch, contentStart, i6, indent2, indentAfterMarker, initial, isOrdered, itemLines, l7, listLines, listTokIdx, markerCharCode, markerValue, max22, nextLine, offset, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start2, terminate, terminatorRules, token2, isTerminatingParagraph = false, tight = true;
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (!state.md.options.allowIndentation && state.listIndent >= 0 && state.sCount[startLine] - state.listIndent >= 4 && state.sCount[startLine] < state.blkIndent) {
        return false;
      }
      if (silent && state.parentType === "paragraph") {
        if (state.sCount[startLine] >= state.blkIndent) {
          isTerminatingParagraph = true;
        }
      }
      if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
        isOrdered = true;
        start2 = state.bMarks[startLine] + state.tShift[startLine];
        markerValue = Number(state.src.slice(start2, posAfterMarker - 1));
        if (isTerminatingParagraph && markerValue !== 1)
          return false;
      } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
        isOrdered = false;
      } else {
        return false;
      }
      if (isTerminatingParagraph) {
        if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine])
          return false;
      }
      markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
      if (silent) {
        return true;
      }
      listTokIdx = state.tokens.length;
      if (isOrdered) {
        token2 = state.push("ordered_list_open", "ol", 1);
        if (markerValue !== 1) {
          token2.attrs = [["start", markerValue]];
        }
      } else {
        token2 = state.push("bullet_list_open", "ul", 1);
      }
      token2.map = listLines = [startLine, 0];
      token2.markup = String.fromCharCode(markerCharCode);
      nextLine = startLine;
      prevEmptyEnd = false;
      terminatorRules = state.md.block.ruler.getRules("list");
      oldParentType = state.parentType;
      state.parentType = "list";
      while (nextLine < endLine) {
        pos = posAfterMarker;
        max22 = state.eMarks[nextLine];
        initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);
        while (pos < max22) {
          ch = state.src.charCodeAt(pos);
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[nextLine]) % 4;
          } else if (ch === 32) {
            offset++;
          } else {
            break;
          }
          pos++;
        }
        contentStart = pos;
        if (contentStart >= max22) {
          indentAfterMarker = 1;
        } else {
          indentAfterMarker = offset - initial;
        }
        if (!state.md.options.allowIndentation && indentAfterMarker > 4) {
          indentAfterMarker = 1;
        }
        indent2 = initial + indentAfterMarker;
        token2 = state.push("list_item_open", "li", 1);
        token2.markup = String.fromCharCode(markerCharCode);
        token2.map = itemLines = [startLine, 0];
        if (isOrdered) {
          token2.info = state.src.slice(start2, posAfterMarker - 1);
        }
        oldTight = state.tight;
        oldTShift = state.tShift[startLine];
        oldSCount = state.sCount[startLine];
        oldListIndent = state.listIndent;
        state.listIndent = state.blkIndent;
        state.blkIndent = indent2;
        state.tight = true;
        state.tShift[startLine] = contentStart - state.bMarks[startLine];
        state.sCount[startLine] = offset;
        if (contentStart >= max22 && state.isEmpty(startLine + 1)) {
          state.line = Math.min(state.line + 2, endLine);
        } else {
          state.md.block.tokenize(state, startLine, endLine, true);
        }
        if (!state.tight || prevEmptyEnd) {
          tight = false;
        }
        prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);
        state.blkIndent = state.listIndent;
        state.listIndent = oldListIndent;
        state.tShift[startLine] = oldTShift;
        state.sCount[startLine] = oldSCount;
        state.tight = oldTight;
        token2 = state.push("list_item_close", "li", -1);
        token2.markup = String.fromCharCode(markerCharCode);
        nextLine = startLine = state.line;
        itemLines[1] = nextLine;
        contentStart = state.bMarks[startLine];
        if (nextLine >= endLine) {
          break;
        }
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
          break;
        }
        terminate = false;
        for (i6 = 0, l7 = terminatorRules.length; i6 < l7; i6++) {
          if (terminatorRules[i6](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        if (isOrdered) {
          posAfterMarker = skipOrderedListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
          start2 = state.bMarks[nextLine] + state.tShift[nextLine];
        } else {
          posAfterMarker = skipBulletListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
        }
        if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
          break;
        }
      }
      if (isOrdered) {
        token2 = state.push("ordered_list_close", "ol", -1);
      } else {
        token2 = state.push("bullet_list_close", "ul", -1);
      }
      token2.markup = String.fromCharCode(markerCharCode);
      listLines[1] = nextLine;
      state.line = nextLine;
      state.parentType = oldParentType;
      if (tight) {
        markTightParagraphs(state, listTokIdx);
      }
      return true;
    };
  }
});
var require_reference = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/reference.js"(exports, module) {
    "use strict";
    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module.exports = function reference(state, startLine, _endLine, silent) {
      var ch, destEndPos, destEndLineNo, endLine, href, i6, l7, label, labelEnd2, oldParentType, res, start2, str, terminate, terminatorRules, title, lines = 0, pos = state.bMarks[startLine] + state.tShift[startLine], max22 = state.eMarks[startLine], nextLine = startLine + 1;
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 91) {
        return false;
      }
      while (++pos < max22) {
        if (state.src.charCodeAt(pos) === 93 && state.src.charCodeAt(pos - 1) !== 92) {
          if (pos + 1 === max22) {
            return false;
          }
          if (state.src.charCodeAt(pos + 1) !== 58) {
            return false;
          }
          break;
        }
      }
      endLine = state.lineMax;
      terminatorRules = state.md.block.ruler.getRules("reference");
      oldParentType = state.parentType;
      state.parentType = "reference";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i6 = 0, l7 = terminatorRules.length; i6 < l7; i6++) {
          if (terminatorRules[i6](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      max22 = str.length;
      for (pos = 1; pos < max22; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 91) {
          return false;
        } else if (ch === 93) {
          labelEnd2 = pos;
          break;
        } else if (ch === 10) {
          lines++;
        } else if (ch === 92) {
          pos++;
          if (pos < max22 && str.charCodeAt(pos) === 10) {
            lines++;
          }
        }
      }
      if (labelEnd2 < 0 || str.charCodeAt(labelEnd2 + 1) !== 58) {
        return false;
      }
      for (pos = labelEnd2 + 2; pos < max22; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace(ch)) {
        } else {
          break;
        }
      }
      res = state.md.helpers.parseLinkDestination(str, pos, max22);
      if (!res.ok) {
        return false;
      }
      href = state.md.normalizeLink(res.str);
      if (!state.md.validateLink(href)) {
        return false;
      }
      pos = res.pos;
      lines += res.lines;
      destEndPos = pos;
      destEndLineNo = lines;
      start2 = pos;
      for (; pos < max22; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace(ch)) {
        } else {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(str, pos, max22);
      if (pos < max22 && start2 !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        lines += res.lines;
      } else {
        title = "";
        pos = destEndPos;
        lines = destEndLineNo;
      }
      while (pos < max22) {
        ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
      if (pos < max22 && str.charCodeAt(pos) !== 10) {
        if (title) {
          title = "";
          pos = destEndPos;
          lines = destEndLineNo;
          while (pos < max22) {
            ch = str.charCodeAt(pos);
            if (!isSpace(ch)) {
              break;
            }
            pos++;
          }
        }
      }
      if (pos < max22 && str.charCodeAt(pos) !== 10) {
        return false;
      }
      label = normalizeReference(str.slice(1, labelEnd2));
      if (!label) {
        return false;
      }
      if (silent) {
        return true;
      }
      if (typeof state.env.references === "undefined") {
        state.env.references = {};
      }
      if (typeof state.env.references[label] === "undefined") {
        state.env.references[label] = { title, href };
      }
      state.parentType = oldParentType;
      state.line = startLine + lines + 1;
      return true;
    };
  }
});
var require_html_blocks = __commonJS2({
  "node_modules/markdown-it/lib/common/html_blocks.js"(exports, module) {
    "use strict";
    module.exports = [
      "address",
      "article",
      "aside",
      "base",
      "basefont",
      "blockquote",
      "body",
      "caption",
      "center",
      "col",
      "colgroup",
      "dd",
      "details",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "frame",
      "frameset",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hr",
      "html",
      "iframe",
      "legend",
      "li",
      "link",
      "main",
      "menu",
      "menuitem",
      "nav",
      "noframes",
      "ol",
      "optgroup",
      "option",
      "p",
      "param",
      "section",
      "source",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "title",
      "tr",
      "track",
      "ul"
    ];
  }
});
var require_html_re = __commonJS2({
  "node_modules/markdown-it/lib/common/html_re.js"(exports, module) {
    "use strict";
    var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
    var unquoted = "[^\"'=<>`\\x00-\\x20]+";
    var single_quoted = "'[^']*'";
    var double_quoted = '"[^"]*"';
    var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
    var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
    var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
    var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
    var comment22 = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
    var processing = "<[?][\\s\\S]*?[?]>";
    var declaration2 = "<![A-Z]+\\s+[^>]*>";
    var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
    var HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment22 + "|" + processing + "|" + declaration2 + "|" + cdata + ")");
    var HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
    module.exports.HTML_TAG_RE = HTML_TAG_RE;
    module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;
  }
});
var require_html_block = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/html_block.js"(exports, module) {
    "use strict";
    var block_names = require_html_blocks();
    var HTML_OPEN_CLOSE_TAG_RE = require_html_re().HTML_OPEN_CLOSE_TAG_RE;
    var HTML_SEQUENCES = [
      [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
      [/^<!--/, /-->/, true],
      [/^<\?/, /\?>/, true],
      [/^<![A-Z]/, />/, true],
      [/^<!\[CDATA\[/, /\]\]>/, true],
      [new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
      [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
    ];
    module.exports = function html_block(state, startLine, endLine, silent) {
      var i6, nextLine, token2, lineText, pos = state.bMarks[startLine] + state.tShift[startLine], max22 = state.eMarks[startLine];
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (!state.md.options.html) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      lineText = state.src.slice(pos, max22);
      for (i6 = 0; i6 < HTML_SEQUENCES.length; i6++) {
        if (HTML_SEQUENCES[i6][0].test(lineText)) {
          break;
        }
      }
      if (i6 === HTML_SEQUENCES.length) {
        return false;
      }
      if (silent) {
        return HTML_SEQUENCES[i6][2];
      }
      nextLine = startLine + 1;
      if (!HTML_SEQUENCES[i6][1].test(lineText)) {
        for (; nextLine < endLine; nextLine++) {
          if (state.sCount[nextLine] < state.blkIndent) {
            break;
          }
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max22 = state.eMarks[nextLine];
          lineText = state.src.slice(pos, max22);
          if (HTML_SEQUENCES[i6][1].test(lineText)) {
            if (lineText.length !== 0) {
              nextLine++;
            }
            break;
          }
        }
      }
      state.line = nextLine;
      token2 = state.push("html_block", "", 0);
      token2.map = [startLine, nextLine];
      token2.content = state.getLines(startLine, nextLine, state.blkIndent, true);
      return true;
    };
  }
});
var require_heading = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/heading.js"(exports, module) {
    "use strict";
    var isSpace = require_utils().isSpace;
    module.exports = function heading2(state, startLine, endLine, silent) {
      var ch, level, tmp, token2, pos = state.bMarks[startLine] + state.tShift[startLine], max22 = state.eMarks[startLine];
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      ch = state.src.charCodeAt(pos);
      if (ch !== 35 || pos >= max22) {
        return false;
      }
      level = 1;
      ch = state.src.charCodeAt(++pos);
      while (ch === 35 && pos < max22 && level <= 6) {
        level++;
        ch = state.src.charCodeAt(++pos);
      }
      if (level > 6 || pos < max22 && !isSpace(ch)) {
        return false;
      }
      if (silent) {
        return true;
      }
      max22 = state.skipSpacesBack(max22, pos);
      tmp = state.skipCharsBack(max22, 35, pos);
      if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
        max22 = tmp;
      }
      state.line = startLine + 1;
      token2 = state.push("heading_open", "h" + String(level), 1);
      token2.markup = "########".slice(0, level);
      token2.map = [startLine, state.line];
      token2 = state.push("inline", "", 0);
      token2.content = state.src.slice(pos, max22).trim();
      token2.map = [startLine, state.line];
      token2.children = [];
      token2 = state.push("heading_close", "h" + String(level), -1);
      token2.markup = "########".slice(0, level);
      return true;
    };
  }
});
var require_lheading = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/lheading.js"(exports, module) {
    "use strict";
    module.exports = function lheading(state, startLine, endLine) {
      var content3, terminate, i6, l7, token2, pos, max22, level, marker, nextLine = startLine + 1, oldParentType, terminatorRules = state.md.block.ruler.getRules("paragraph");
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] >= state.blkIndent) {
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max22 = state.eMarks[nextLine];
          if (pos < max22) {
            marker = state.src.charCodeAt(pos);
            if (marker === 45 || marker === 61) {
              pos = state.skipChars(pos, marker);
              pos = state.skipSpaces(pos);
              if (pos >= max22) {
                level = marker === 61 ? 1 : 2;
                break;
              }
            }
          }
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i6 = 0, l7 = terminatorRules.length; i6 < l7; i6++) {
          if (terminatorRules[i6](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      if (!level) {
        return false;
      }
      content3 = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine + 1;
      token2 = state.push("heading_open", "h" + String(level), 1);
      token2.markup = String.fromCharCode(marker);
      token2.map = [startLine, state.line];
      token2 = state.push("inline", "", 0);
      token2.content = content3;
      token2.map = [startLine, state.line - 1];
      token2.children = [];
      token2 = state.push("heading_close", "h" + String(level), -1);
      token2.markup = String.fromCharCode(marker);
      state.parentType = oldParentType;
      return true;
    };
  }
});
var require_paragraph = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/paragraph.js"(exports, module) {
    "use strict";
    module.exports = function paragraph2(state, startLine) {
      var content3, terminate, i6, l7, token2, oldParentType, nextLine = startLine + 1, terminatorRules = state.md.block.ruler.getRules("paragraph"), endLine = state.lineMax;
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i6 = 0, l7 = terminatorRules.length; i6 < l7; i6++) {
          if (terminatorRules[i6](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      content3 = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine;
      token2 = state.push("paragraph_open", "p", 1);
      token2.map = [startLine, state.line];
      token2 = state.push("inline", "", 0);
      token2.content = content3;
      token2.map = [startLine, state.line];
      token2.children = [];
      token2 = state.push("paragraph_close", "p", -1);
      state.parentType = oldParentType;
      return true;
    };
  }
});
var require_state_block = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/state_block.js"(exports, module) {
    "use strict";
    var Token2 = require_token();
    var isSpace = require_utils().isSpace;
    function StateBlock(src, md, env, tokens) {
      var ch, s22, start2, pos, len, indent2, offset, indent_found;
      this.src = src;
      this.md = md;
      this.env = env;
      this.tokens = tokens;
      this.bMarks = [];
      this.eMarks = [];
      this.tShift = [];
      this.sCount = [];
      this.bsCount = [];
      this.blkIndent = 0;
      this.line = 0;
      this.lineMax = 0;
      this.tight = false;
      this.ddIndent = -1;
      this.listIndent = -1;
      this.parentType = "root";
      this.level = 0;
      this.result = "";
      s22 = this.src;
      indent_found = false;
      for (start2 = pos = indent2 = offset = 0, len = s22.length; pos < len; pos++) {
        ch = s22.charCodeAt(pos);
        if (!indent_found) {
          if (isSpace(ch)) {
            indent2++;
            if (ch === 9) {
              offset += 4 - offset % 4;
            } else {
              offset++;
            }
            continue;
          } else {
            indent_found = true;
          }
        }
        if (ch === 10 || pos === len - 1) {
          if (ch !== 10) {
            pos++;
          }
          this.bMarks.push(start2);
          this.eMarks.push(pos);
          this.tShift.push(indent2);
          this.sCount.push(offset);
          this.bsCount.push(0);
          indent_found = false;
          indent2 = 0;
          offset = 0;
          start2 = pos + 1;
        }
      }
      this.bMarks.push(s22.length);
      this.eMarks.push(s22.length);
      this.tShift.push(0);
      this.sCount.push(0);
      this.bsCount.push(0);
      this.lineMax = this.bMarks.length - 1;
    }
    StateBlock.prototype.push = function(type2, tag2, nesting) {
      var token2 = new Token2(type2, tag2, nesting);
      token2.block = true;
      if (nesting < 0)
        this.level--;
      token2.level = this.level;
      if (nesting > 0)
        this.level++;
      this.tokens.push(token2);
      return token2;
    };
    StateBlock.prototype.isEmpty = function isEmpty2(line2) {
      return this.bMarks[line2] + this.tShift[line2] >= this.eMarks[line2];
    };
    StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from4) {
      for (var max22 = this.lineMax; from4 < max22; from4++) {
        if (this.bMarks[from4] + this.tShift[from4] < this.eMarks[from4]) {
          break;
        }
      }
      return from4;
    };
    StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
      var ch;
      for (var max22 = this.src.length; pos < max22; pos++) {
        ch = this.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min3) {
      if (pos <= min3) {
        return pos;
      }
      while (pos > min3) {
        if (!isSpace(this.src.charCodeAt(--pos))) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipChars = function skipChars(pos, code22) {
      for (var max22 = this.src.length; pos < max22; pos++) {
        if (this.src.charCodeAt(pos) !== code22) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code22, min3) {
      if (pos <= min3) {
        return pos;
      }
      while (pos > min3) {
        if (code22 !== this.src.charCodeAt(--pos)) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.getLines = function getLines(begin, end, indent2, keepLastLF) {
      var i6, lineIndent, ch, first, last2, queue, lineStart, line2 = begin;
      if (begin >= end) {
        return "";
      }
      queue = new Array(end - begin);
      for (i6 = 0; line2 < end; line2++, i6++) {
        lineIndent = 0;
        lineStart = first = this.bMarks[line2];
        if (line2 + 1 < end || keepLastLF) {
          last2 = this.eMarks[line2] + 1;
        } else {
          last2 = this.eMarks[line2];
        }
        while (first < last2 && lineIndent < indent2) {
          ch = this.src.charCodeAt(first);
          if (isSpace(ch)) {
            if (ch === 9) {
              lineIndent += 4 - (lineIndent + this.bsCount[line2]) % 4;
            } else {
              lineIndent++;
            }
          } else if (first - lineStart < this.tShift[line2]) {
            lineIndent++;
          } else {
            break;
          }
          first++;
        }
        if (lineIndent > indent2) {
          queue[i6] = new Array(lineIndent - indent2 + 1).join(" ") + this.src.slice(first, last2);
        } else {
          queue[i6] = this.src.slice(first, last2);
        }
      }
      return queue.join("");
    };
    StateBlock.prototype.Token = Token2;
    module.exports = StateBlock;
  }
});
var require_parser_block = __commonJS2({
  "node_modules/markdown-it/lib/parser_block.js"(exports, module) {
    "use strict";
    var Ruler = require_ruler();
    var _rules = [
      ["table", require_table(), ["paragraph", "reference"]],
      ["code", require_code()],
      ["fence", require_fence(), ["paragraph", "reference", "blockquote", "list"]],
      ["blockquote", require_blockquote(), ["paragraph", "reference", "blockquote", "list"]],
      ["hr", require_hr(), ["paragraph", "reference", "blockquote", "list"]],
      ["list", require_list(), ["paragraph", "reference", "blockquote"]],
      ["reference", require_reference()],
      ["html_block", require_html_block(), ["paragraph", "reference", "blockquote"]],
      ["heading", require_heading(), ["paragraph", "reference", "blockquote"]],
      ["lheading", require_lheading()],
      ["paragraph", require_paragraph()]
    ];
    function ParserBlock() {
      this.ruler = new Ruler();
      for (var i6 = 0; i6 < _rules.length; i6++) {
        this.ruler.push(_rules[i6][0], _rules[i6][1], { alt: (_rules[i6][2] || []).slice() });
      }
    }
    ParserBlock.prototype.tokenize = function(state, startLine, endLine) {
      var ok3, i6, rules = this.ruler.getRules(""), len = rules.length, line2 = startLine, hasEmptyLines = false, maxNesting = state.md.options.maxNesting;
      while (line2 < endLine) {
        state.line = line2 = state.skipEmptyLines(line2);
        if (line2 >= endLine) {
          break;
        }
        if (state.sCount[line2] < state.blkIndent) {
          break;
        }
        if (state.level >= maxNesting) {
          state.line = endLine;
          break;
        }
        for (i6 = 0; i6 < len; i6++) {
          ok3 = rules[i6](state, line2, endLine, false);
          if (ok3) {
            break;
          }
        }
        state.tight = !hasEmptyLines;
        if (state.isEmpty(state.line - 1)) {
          hasEmptyLines = true;
        }
        line2 = state.line;
        if (line2 < endLine && state.isEmpty(line2)) {
          hasEmptyLines = true;
          line2++;
          state.line = line2;
        }
      }
    };
    ParserBlock.prototype.parse = function(src, md, env, outTokens) {
      var state;
      if (!src) {
        return;
      }
      state = new this.State(src, md, env, outTokens);
      this.tokenize(state, state.line, state.lineMax);
    };
    ParserBlock.prototype.State = require_state_block();
    module.exports = ParserBlock;
  }
});
var require_text = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/text.js"(exports, module) {
    "use strict";
    function isTerminatorChar(ch) {
      switch (ch) {
        case 10:
        case 33:
        case 35:
        case 36:
        case 37:
        case 38:
        case 42:
        case 43:
        case 45:
        case 58:
        case 60:
        case 61:
        case 62:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    module.exports = function text22(state, silent) {
      var pos = state.pos;
      while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
        pos++;
      }
      if (pos === state.pos) {
        return false;
      }
      if (!silent) {
        state.pending += state.src.slice(state.pos, pos);
      }
      state.pos = pos;
      return true;
    };
  }
});
var require_newline = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/newline.js"(exports, module) {
    "use strict";
    var isSpace = require_utils().isSpace;
    module.exports = function newline(state, silent) {
      var pmax, max22, ws, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 10) {
        return false;
      }
      pmax = state.pending.length - 1;
      max22 = state.posMax;
      if (!silent) {
        if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
          if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
            ws = pmax - 1;
            while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32)
              ws--;
            state.pending = state.pending.slice(0, ws);
            state.push("hardbreak", "br", 0);
          } else {
            state.pending = state.pending.slice(0, -1);
            state.push("softbreak", "br", 0);
          }
        } else {
          state.push("softbreak", "br", 0);
        }
      }
      pos++;
      while (pos < max22 && isSpace(state.src.charCodeAt(pos))) {
        pos++;
      }
      state.pos = pos;
      return true;
    };
  }
});
var require_escape = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/escape.js"(exports, module) {
    "use strict";
    var isSpace = require_utils().isSpace;
    var ESCAPED = [];
    for (i6 = 0; i6 < 256; i6++) {
      ESCAPED.push(0);
    }
    var i6;
    "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
      ESCAPED[ch.charCodeAt(0)] = 1;
    });
    module.exports = function escape3(state, silent) {
      var ch, pos = state.pos, max22 = state.posMax;
      if (state.src.charCodeAt(pos) !== 92) {
        return false;
      }
      pos++;
      if (pos < max22) {
        ch = state.src.charCodeAt(pos);
        if (ch < 256 && ESCAPED[ch] !== 0) {
          if (!silent) {
            state.pending += state.src[pos];
          }
          state.pos += 2;
          return true;
        }
        if (ch === 10) {
          if (!silent) {
            state.push("hardbreak", "br", 0);
          }
          pos++;
          while (pos < max22) {
            ch = state.src.charCodeAt(pos);
            if (!isSpace(ch)) {
              break;
            }
            pos++;
          }
          state.pos = pos;
          return true;
        }
      }
      if (!silent) {
        state.pending += "\\";
      }
      state.pos++;
      return true;
    };
  }
});
var require_backticks = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/backticks.js"(exports, module) {
    "use strict";
    module.exports = function backtick(state, silent) {
      var start2, max22, marker, token2, matchStart, matchEnd, openerLength, closerLength, pos = state.pos, ch = state.src.charCodeAt(pos);
      if (ch !== 96) {
        return false;
      }
      start2 = pos;
      pos++;
      max22 = state.posMax;
      while (pos < max22 && state.src.charCodeAt(pos) === 96) {
        pos++;
      }
      marker = state.src.slice(start2, pos);
      openerLength = marker.length;
      if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start2) {
        if (!silent)
          state.pending += marker;
        state.pos += openerLength;
        return true;
      }
      matchStart = matchEnd = pos;
      while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
        matchEnd = matchStart + 1;
        while (matchEnd < max22 && state.src.charCodeAt(matchEnd) === 96) {
          matchEnd++;
        }
        closerLength = matchEnd - matchStart;
        if (closerLength === openerLength) {
          if (!silent) {
            token2 = state.push("code_inline", "code", 0);
            token2.markup = marker;
            token2.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
          }
          state.pos = matchEnd;
          return true;
        }
        state.backticks[closerLength] = matchStart;
      }
      state.backticksScanned = true;
      if (!silent)
        state.pending += marker;
      state.pos += openerLength;
      return true;
    };
  }
});
var require_strikethrough = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/strikethrough.js"(exports, module) {
    "use strict";
    module.exports.tokenize = function strikethrough(state, silent) {
      var i6, scanned, token2, len, ch, start2 = state.pos, marker = state.src.charCodeAt(start2);
      if (silent) {
        return false;
      }
      if (marker !== 126) {
        return false;
      }
      scanned = state.scanDelims(state.pos, true);
      len = scanned.length;
      ch = String.fromCharCode(marker);
      if (len < 2) {
        return false;
      }
      if (len % 2) {
        token2 = state.push("text", "", 0);
        token2.content = ch;
        len--;
      }
      for (i6 = 0; i6 < len; i6 += 2) {
        token2 = state.push("text", "", 0);
        token2.content = ch + ch;
        state.delimiters.push({
          marker,
          length: 0,
          token: state.tokens.length - 1,
          end: -1,
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess(state, delimiters) {
      var i6, j4, startDelim, endDelim, token2, loneMarkers = [], max22 = delimiters.length;
      for (i6 = 0; i6 < max22; i6++) {
        startDelim = delimiters[i6];
        if (startDelim.marker !== 126) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        token2 = state.tokens[startDelim.token];
        token2.type = "s_open";
        token2.tag = "s";
        token2.nesting = 1;
        token2.markup = "~~";
        token2.content = "";
        token2 = state.tokens[endDelim.token];
        token2.type = "s_close";
        token2.tag = "s";
        token2.nesting = -1;
        token2.markup = "~~";
        token2.content = "";
        if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
          loneMarkers.push(endDelim.token - 1);
        }
      }
      while (loneMarkers.length) {
        i6 = loneMarkers.pop();
        j4 = i6 + 1;
        while (j4 < state.tokens.length && state.tokens[j4].type === "s_close") {
          j4++;
        }
        j4--;
        if (i6 !== j4) {
          token2 = state.tokens[j4];
          state.tokens[j4] = state.tokens[i6];
          state.tokens[i6] = token2;
        }
      }
    }
    module.exports.postProcess = function strikethrough(state) {
      var curr, tokens_meta = state.tokens_meta, max22 = state.tokens_meta.length;
      postProcess(state, state.delimiters);
      for (curr = 0; curr < max22; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});
var require_emphasis = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/emphasis.js"(exports, module) {
    "use strict";
    module.exports.tokenize = function emphasis(state, silent) {
      var i6, scanned, token2, start2 = state.pos, marker = state.src.charCodeAt(start2);
      if (silent) {
        return false;
      }
      if (marker !== 95 && marker !== 42) {
        return false;
      }
      scanned = state.scanDelims(state.pos, marker === 42);
      for (i6 = 0; i6 < scanned.length; i6++) {
        token2 = state.push("text", "", 0);
        token2.content = String.fromCharCode(marker);
        state.delimiters.push({
          marker,
          length: scanned.length,
          token: state.tokens.length - 1,
          end: -1,
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess(state, delimiters) {
      var i6, startDelim, endDelim, token2, ch, isStrong, max22 = delimiters.length;
      for (i6 = max22 - 1; i6 >= 0; i6--) {
        startDelim = delimiters[i6];
        if (startDelim.marker !== 95 && startDelim.marker !== 42) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        isStrong = i6 > 0 && delimiters[i6 - 1].end === startDelim.end + 1 && delimiters[i6 - 1].marker === startDelim.marker && delimiters[i6 - 1].token === startDelim.token - 1 && delimiters[startDelim.end + 1].token === endDelim.token + 1;
        ch = String.fromCharCode(startDelim.marker);
        token2 = state.tokens[startDelim.token];
        token2.type = isStrong ? "strong_open" : "em_open";
        token2.tag = isStrong ? "strong" : "em";
        token2.nesting = 1;
        token2.markup = isStrong ? ch + ch : ch;
        token2.content = "";
        token2 = state.tokens[endDelim.token];
        token2.type = isStrong ? "strong_close" : "em_close";
        token2.tag = isStrong ? "strong" : "em";
        token2.nesting = -1;
        token2.markup = isStrong ? ch + ch : ch;
        token2.content = "";
        if (isStrong) {
          state.tokens[delimiters[i6 - 1].token].content = "";
          state.tokens[delimiters[startDelim.end + 1].token].content = "";
          i6--;
        }
      }
    }
    module.exports.postProcess = function emphasis(state) {
      var curr, tokens_meta = state.tokens_meta, max22 = state.tokens_meta.length;
      postProcess(state, state.delimiters);
      for (curr = 0; curr < max22; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});
var require_link = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/link.js"(exports, module) {
    "use strict";
    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module.exports = function link2(state, silent) {
      var attrs, code22, label, labelEnd2, labelStart, pos, res, ref, token2, href = "", title = "", oldPos = state.pos, max22 = state.posMax, start2 = state.pos, parseReference = true;
      if (state.src.charCodeAt(state.pos) !== 91) {
        return false;
      }
      labelStart = state.pos + 1;
      labelEnd2 = state.md.helpers.parseLinkLabel(state, state.pos, true);
      if (labelEnd2 < 0) {
        return false;
      }
      pos = labelEnd2 + 1;
      if (pos < max22 && state.src.charCodeAt(pos) === 40) {
        parseReference = false;
        pos++;
        for (; pos < max22; pos++) {
          code22 = state.src.charCodeAt(pos);
          if (!isSpace(code22) && code22 !== 10) {
            break;
          }
        }
        if (pos >= max22) {
          return false;
        }
        start2 = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
          start2 = pos;
          for (; pos < max22; pos++) {
            code22 = state.src.charCodeAt(pos);
            if (!isSpace(code22) && code22 !== 10) {
              break;
            }
          }
          res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
          if (pos < max22 && start2 !== pos && res.ok) {
            title = res.str;
            pos = res.pos;
            for (; pos < max22; pos++) {
              code22 = state.src.charCodeAt(pos);
              if (!isSpace(code22) && code22 !== 10) {
                break;
              }
            }
          }
        }
        if (pos >= max22 || state.src.charCodeAt(pos) !== 41) {
          parseReference = true;
        }
        pos++;
      }
      if (parseReference) {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max22 && state.src.charCodeAt(pos) === 91) {
          start2 = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start2, pos++);
          } else {
            pos = labelEnd2 + 1;
          }
        } else {
          pos = labelEnd2 + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd2);
        }
        ref = state.env.references[normalizeReference(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        state.pos = labelStart;
        state.posMax = labelEnd2;
        token2 = state.push("link_open", "a", 1);
        token2.attrs = attrs = [["href", href]];
        if (title) {
          attrs.push(["title", title]);
        }
        state.md.inline.tokenize(state);
        token2 = state.push("link_close", "a", -1);
      }
      state.pos = pos;
      state.posMax = max22;
      return true;
    };
  }
});
var require_image = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/image.js"(exports, module) {
    "use strict";
    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module.exports = function image2(state, silent) {
      var attrs, code22, content3, label, labelEnd2, labelStart, pos, ref, res, title, token2, tokens, start2, href = "", oldPos = state.pos, max22 = state.posMax;
      if (state.src.charCodeAt(state.pos) !== 33) {
        return false;
      }
      if (state.src.charCodeAt(state.pos + 1) !== 91) {
        return false;
      }
      labelStart = state.pos + 2;
      labelEnd2 = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
      if (labelEnd2 < 0) {
        return false;
      }
      pos = labelEnd2 + 1;
      if (pos < max22 && state.src.charCodeAt(pos) === 40) {
        pos++;
        for (; pos < max22; pos++) {
          code22 = state.src.charCodeAt(pos);
          if (!isSpace(code22) && code22 !== 10) {
            break;
          }
        }
        if (pos >= max22) {
          return false;
        }
        start2 = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
        }
        start2 = pos;
        for (; pos < max22; pos++) {
          code22 = state.src.charCodeAt(pos);
          if (!isSpace(code22) && code22 !== 10) {
            break;
          }
        }
        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max22 && start2 !== pos && res.ok) {
          title = res.str;
          pos = res.pos;
          for (; pos < max22; pos++) {
            code22 = state.src.charCodeAt(pos);
            if (!isSpace(code22) && code22 !== 10) {
              break;
            }
          }
        } else {
          title = "";
        }
        if (pos >= max22 || state.src.charCodeAt(pos) !== 41) {
          state.pos = oldPos;
          return false;
        }
        pos++;
      } else {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max22 && state.src.charCodeAt(pos) === 91) {
          start2 = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start2, pos++);
          } else {
            pos = labelEnd2 + 1;
          }
        } else {
          pos = labelEnd2 + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd2);
        }
        ref = state.env.references[normalizeReference(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        content3 = state.src.slice(labelStart, labelEnd2);
        state.md.inline.parse(content3, state.md, state.env, tokens = []);
        token2 = state.push("image", "img", 0);
        token2.attrs = attrs = [["src", href], ["alt", ""]];
        token2.children = tokens;
        token2.content = content3;
        if (title) {
          attrs.push(["title", title]);
        }
      }
      state.pos = pos;
      state.posMax = max22;
      return true;
    };
  }
});
var require_autolink = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/autolink.js"(exports, module) {
    "use strict";
    var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
    var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
    module.exports = function autolink2(state, silent) {
      var url, fullUrl, token2, ch, start2, max22, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      start2 = state.pos;
      max22 = state.posMax;
      for (; ; ) {
        if (++pos >= max22)
          return false;
        ch = state.src.charCodeAt(pos);
        if (ch === 60)
          return false;
        if (ch === 62)
          break;
      }
      url = state.src.slice(start2 + 1, pos);
      if (AUTOLINK_RE.test(url)) {
        fullUrl = state.md.normalizeLink(url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token2 = state.push("link_open", "a", 1);
          token2.attrs = [["href", fullUrl]];
          token2.markup = "autolink";
          token2.info = "auto";
          token2 = state.push("text", "", 0);
          token2.content = state.md.normalizeLinkText(url);
          token2 = state.push("link_close", "a", -1);
          token2.markup = "autolink";
          token2.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      if (EMAIL_RE.test(url)) {
        fullUrl = state.md.normalizeLink("mailto:" + url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token2 = state.push("link_open", "a", 1);
          token2.attrs = [["href", fullUrl]];
          token2.markup = "autolink";
          token2.info = "auto";
          token2 = state.push("text", "", 0);
          token2.content = state.md.normalizeLinkText(url);
          token2 = state.push("link_close", "a", -1);
          token2.markup = "autolink";
          token2.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      return false;
    };
  }
});
var require_html_inline = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/html_inline.js"(exports, module) {
    "use strict";
    var HTML_TAG_RE = require_html_re().HTML_TAG_RE;
    function isLetter2(ch) {
      var lc = ch | 32;
      return lc >= 97 && lc <= 122;
    }
    module.exports = function html_inline(state, silent) {
      var ch, match3, max22, token2, pos = state.pos;
      if (!state.md.options.html) {
        return false;
      }
      max22 = state.posMax;
      if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max22) {
        return false;
      }
      ch = state.src.charCodeAt(pos + 1);
      if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter2(ch)) {
        return false;
      }
      match3 = state.src.slice(pos).match(HTML_TAG_RE);
      if (!match3) {
        return false;
      }
      if (!silent) {
        token2 = state.push("html_inline", "", 0);
        token2.content = state.src.slice(pos, pos + match3[0].length);
      }
      state.pos += match3[0].length;
      return true;
    };
  }
});
var require_entity = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/entity.js"(exports, module) {
    "use strict";
    var entities = require_entities2();
    var has = require_utils().has;
    var isValidEntityCode = require_utils().isValidEntityCode;
    var fromCodePoint4 = require_utils().fromCodePoint;
    var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
    var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
    module.exports = function entity(state, silent) {
      var ch, code22, match3, pos = state.pos, max22 = state.posMax;
      if (state.src.charCodeAt(pos) !== 38) {
        return false;
      }
      if (pos + 1 < max22) {
        ch = state.src.charCodeAt(pos + 1);
        if (ch === 35) {
          match3 = state.src.slice(pos).match(DIGITAL_RE);
          if (match3) {
            if (!silent) {
              code22 = match3[1][0].toLowerCase() === "x" ? parseInt(match3[1].slice(1), 16) : parseInt(match3[1], 10);
              state.pending += isValidEntityCode(code22) ? fromCodePoint4(code22) : fromCodePoint4(65533);
            }
            state.pos += match3[0].length;
            return true;
          }
        } else {
          match3 = state.src.slice(pos).match(NAMED_RE);
          if (match3) {
            if (has(entities, match3[1])) {
              if (!silent) {
                state.pending += entities[match3[1]];
              }
              state.pos += match3[0].length;
              return true;
            }
          }
        }
      }
      if (!silent) {
        state.pending += "&";
      }
      state.pos++;
      return true;
    };
  }
});
var require_balance_pairs = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/balance_pairs.js"(exports, module) {
    "use strict";
    function processDelimiters(state, delimiters) {
      var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max22 = delimiters.length;
      if (!max22)
        return;
      var headerIdx = 0;
      var lastTokenIdx = -2;
      var jumps = [];
      for (closerIdx = 0; closerIdx < max22; closerIdx++) {
        closer = delimiters[closerIdx];
        jumps.push(0);
        if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
          headerIdx = closerIdx;
        }
        lastTokenIdx = closer.token;
        closer.length = closer.length || 0;
        if (!closer.close)
          continue;
        if (!openersBottom.hasOwnProperty(closer.marker)) {
          openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
        }
        minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
        openerIdx = headerIdx - jumps[headerIdx] - 1;
        newMinOpenerIdx = openerIdx;
        for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
          opener = delimiters[openerIdx];
          if (opener.marker !== closer.marker)
            continue;
          if (opener.open && opener.end < 0) {
            isOddMatch = false;
            if (opener.close || closer.open) {
              if ((opener.length + closer.length) % 3 === 0) {
                if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
                  isOddMatch = true;
                }
              }
            }
            if (!isOddMatch) {
              lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
              jumps[closerIdx] = closerIdx - openerIdx + lastJump;
              jumps[openerIdx] = lastJump;
              closer.open = false;
              opener.end = closerIdx;
              opener.close = false;
              newMinOpenerIdx = -1;
              lastTokenIdx = -2;
              break;
            }
          }
        }
        if (newMinOpenerIdx !== -1) {
          openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
        }
      }
    }
    module.exports = function link_pairs(state) {
      var curr, tokens_meta = state.tokens_meta, max22 = state.tokens_meta.length;
      processDelimiters(state, state.delimiters);
      for (curr = 0; curr < max22; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          processDelimiters(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});
var require_text_collapse = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/text_collapse.js"(exports, module) {
    "use strict";
    module.exports = function text_collapse(state) {
      var curr, last2, level = 0, tokens = state.tokens, max22 = state.tokens.length;
      for (curr = last2 = 0; curr < max22; curr++) {
        if (tokens[curr].nesting < 0)
          level--;
        tokens[curr].level = level;
        if (tokens[curr].nesting > 0)
          level++;
        if (tokens[curr].type === "text" && curr + 1 < max22 && tokens[curr + 1].type === "text") {
          tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
        } else {
          if (curr !== last2) {
            tokens[last2] = tokens[curr];
          }
          last2++;
        }
      }
      if (curr !== last2) {
        tokens.length = last2;
      }
    };
  }
});
var require_state_inline = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/state_inline.js"(exports, module) {
    "use strict";
    var Token2 = require_token();
    var isWhiteSpace2 = require_utils().isWhiteSpace;
    var isPunctChar = require_utils().isPunctChar;
    var isMdAsciiPunct = require_utils().isMdAsciiPunct;
    function StateInline(src, md, env, outTokens) {
      this.src = src;
      this.env = env;
      this.md = md;
      this.tokens = outTokens;
      this.tokens_meta = Array(outTokens.length);
      this.pos = 0;
      this.posMax = this.src.length;
      this.level = 0;
      this.pending = "";
      this.pendingLevel = 0;
      this.cache = {};
      this.delimiters = [];
      this._prev_delimiters = [];
      this.backticks = {};
      this.backticksScanned = false;
    }
    StateInline.prototype.pushPending = function() {
      var token2 = new Token2("text", "", 0);
      token2.content = this.pending;
      token2.level = this.pendingLevel;
      this.tokens.push(token2);
      this.pending = "";
      return token2;
    };
    StateInline.prototype.push = function(type2, tag2, nesting) {
      if (this.pending) {
        this.pushPending();
      }
      var token2 = new Token2(type2, tag2, nesting);
      var token_meta = null;
      if (nesting < 0) {
        this.level--;
        this.delimiters = this._prev_delimiters.pop();
      }
      token2.level = this.level;
      if (nesting > 0) {
        this.level++;
        this._prev_delimiters.push(this.delimiters);
        this.delimiters = [];
        token_meta = { delimiters: this.delimiters };
      }
      this.pendingLevel = this.level;
      this.tokens.push(token2);
      this.tokens_meta.push(token_meta);
      return token2;
    };
    StateInline.prototype.scanDelims = function(start2, canSplitWord) {
      var pos = start2, lastChar, nextChar, count, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max22 = this.posMax, marker = this.src.charCodeAt(start2);
      lastChar = start2 > 0 ? this.src.charCodeAt(start2 - 1) : 32;
      while (pos < max22 && this.src.charCodeAt(pos) === marker) {
        pos++;
      }
      count = pos - start2;
      nextChar = pos < max22 ? this.src.charCodeAt(pos) : 32;
      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
      isLastWhiteSpace = isWhiteSpace2(lastChar);
      isNextWhiteSpace = isWhiteSpace2(nextChar);
      if (isNextWhiteSpace) {
        left_flanking = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          left_flanking = false;
        }
      }
      if (isLastWhiteSpace) {
        right_flanking = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          right_flanking = false;
        }
      }
      if (!canSplitWord) {
        can_open = left_flanking && (!right_flanking || isLastPunctChar);
        can_close = right_flanking && (!left_flanking || isNextPunctChar);
      } else {
        can_open = left_flanking;
        can_close = right_flanking;
      }
      return {
        can_open,
        can_close,
        length: count
      };
    };
    StateInline.prototype.Token = Token2;
    module.exports = StateInline;
  }
});
var require_parser_inline = __commonJS2({
  "node_modules/markdown-it/lib/parser_inline.js"(exports, module) {
    "use strict";
    var Ruler = require_ruler();
    var _rules = [
      ["text", require_text()],
      ["newline", require_newline()],
      ["escape", require_escape()],
      ["backticks", require_backticks()],
      ["strikethrough", require_strikethrough().tokenize],
      ["emphasis", require_emphasis().tokenize],
      ["link", require_link()],
      ["image", require_image()],
      ["autolink", require_autolink()],
      ["html_inline", require_html_inline()],
      ["entity", require_entity()]
    ];
    var _rules2 = [
      ["balance_pairs", require_balance_pairs()],
      ["strikethrough", require_strikethrough().postProcess],
      ["emphasis", require_emphasis().postProcess],
      ["text_collapse", require_text_collapse()]
    ];
    function ParserInline() {
      var i6;
      this.ruler = new Ruler();
      for (i6 = 0; i6 < _rules.length; i6++) {
        this.ruler.push(_rules[i6][0], _rules[i6][1]);
      }
      this.ruler2 = new Ruler();
      for (i6 = 0; i6 < _rules2.length; i6++) {
        this.ruler2.push(_rules2[i6][0], _rules2[i6][1]);
      }
    }
    ParserInline.prototype.skipToken = function(state) {
      var ok3, i6, pos = state.pos, rules = this.ruler.getRules(""), len = rules.length, maxNesting = state.md.options.maxNesting, cache3 = state.cache;
      if (typeof cache3[pos] !== "undefined") {
        state.pos = cache3[pos];
        return;
      }
      if (state.level < maxNesting) {
        for (i6 = 0; i6 < len; i6++) {
          state.level++;
          ok3 = rules[i6](state, true);
          state.level--;
          if (ok3) {
            break;
          }
        }
      } else {
        state.pos = state.posMax;
      }
      if (!ok3) {
        state.pos++;
      }
      cache3[pos] = state.pos;
    };
    ParserInline.prototype.tokenize = function(state) {
      var ok3, i6, rules = this.ruler.getRules(""), len = rules.length, end = state.posMax, maxNesting = state.md.options.maxNesting;
      while (state.pos < end) {
        if (state.level < maxNesting) {
          for (i6 = 0; i6 < len; i6++) {
            ok3 = rules[i6](state, false);
            if (ok3) {
              break;
            }
          }
        }
        if (ok3) {
          if (state.pos >= end) {
            break;
          }
          continue;
        }
        state.pending += state.src[state.pos++];
      }
      if (state.pending) {
        state.pushPending();
      }
    };
    ParserInline.prototype.parse = function(str, md, env, outTokens) {
      var i6, rules, len;
      var state = new this.State(str, md, env, outTokens);
      this.tokenize(state);
      rules = this.ruler2.getRules("");
      len = rules.length;
      for (i6 = 0; i6 < len; i6++) {
        rules[i6](state);
      }
    };
    ParserInline.prototype.State = require_state_inline();
    module.exports = ParserInline;
  }
});
var require_re = __commonJS2({
  "node_modules/linkify-it/lib/re.js"(exports, module) {
    "use strict";
    module.exports = function(opts) {
      var re = {};
      re.src_Any = require_regex2().source;
      re.src_Cc = require_regex3().source;
      re.src_Z = require_regex5().source;
      re.src_P = require_regex().source;
      re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join("|");
      re.src_ZCc = [re.src_Z, re.src_Cc].join("|");
      var text_separators = "[><｜]";
      re.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re.src_ZPCc + ")" + re.src_Any + ")";
      re.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
      re.src_auth = "(?:(?:(?!" + re.src_ZCc + "|[@/\\[\\]()]).)+@)?";
      re.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
      re.src_host_terminator = "(?=$|" + text_separators + "|" + re.src_ZPCc + ")(?!-|_|:\\d|\\.-|\\.(?!$|" + re.src_ZPCc + "))";
      re.src_path = "(?:[/?#](?:(?!" + re.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re.src_ZCc + "|[']).)+\\'|\\'(?=" + re.src_pseudo_letter + "|[-]).|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re.src_ZCc + "|[.]).|" + (opts && opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + re.src_ZCc + ").|;(?!" + re.src_ZCc + ").|\\!+(?!" + re.src_ZCc + "|[!]).|\\?(?!" + re.src_ZCc + "|[?]).)+|\\/)?";
      re.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
      re.src_xn = "xn--[a-z0-9\\-]{1,59}";
      re.src_domain_root = "(?:" + re.src_xn + "|" + re.src_pseudo_letter + "{1,63})";
      re.src_domain = "(?:" + re.src_xn + "|(?:" + re.src_pseudo_letter + ")|(?:" + re.src_pseudo_letter + "(?:-|" + re.src_pseudo_letter + "){0,61}" + re.src_pseudo_letter + "))";
      re.src_host = "(?:(?:(?:(?:" + re.src_domain + ")\\.)*" + re.src_domain + "))";
      re.tpl_host_fuzzy = "(?:" + re.src_ip4 + "|(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%)))";
      re.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))";
      re.src_host_strict = re.src_host + re.src_host_terminator;
      re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
      re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
      re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re.src_ZPCc + "|>|$))";
      re.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re.src_ZCc + ")(" + re.src_email_name + "@" + re.tpl_host_fuzzy_strict + ")";
      re.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + re.src_ZPCc + "))((?![$+<=>^`|｜])" + re.tpl_host_port_fuzzy_strict + re.src_path + ")";
      re.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + re.src_ZPCc + "))((?![$+<=>^`|｜])" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ")";
      return re;
    };
  }
});
var require_linkify_it = __commonJS2({
  "node_modules/linkify-it/index.js"(exports, module) {
    "use strict";
    function assign3(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString2(obj) {
      return _class(obj) === "[object String]";
    }
    function isObject2(obj) {
      return _class(obj) === "[object Object]";
    }
    function isRegExp(obj) {
      return _class(obj) === "[object RegExp]";
    }
    function isFunction2(obj) {
      return _class(obj) === "[object Function]";
    }
    function escapeRE(str) {
      return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
    }
    var defaultOptions = {
      fuzzyLink: true,
      fuzzyEmail: true,
      fuzzyIP: false
    };
    function isOptionsObj(obj) {
      return Object.keys(obj || {}).reduce(function(acc, k2) {
        return acc || defaultOptions.hasOwnProperty(k2);
      }, false);
    }
    var defaultSchemas = {
      "http:": {
        validate: function(text22, pos, self2) {
          var tail = text22.slice(pos);
          if (!self2.re.http) {
            self2.re.http = new RegExp("^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path, "i");
          }
          if (self2.re.http.test(tail)) {
            return tail.match(self2.re.http)[0].length;
          }
          return 0;
        }
      },
      "https:": "http:",
      "ftp:": "http:",
      "//": {
        validate: function(text22, pos, self2) {
          var tail = text22.slice(pos);
          if (!self2.re.no_http) {
            self2.re.no_http = new RegExp("^" + self2.re.src_auth + "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path, "i");
          }
          if (self2.re.no_http.test(tail)) {
            if (pos >= 3 && text22[pos - 3] === ":") {
              return 0;
            }
            if (pos >= 3 && text22[pos - 3] === "/") {
              return 0;
            }
            return tail.match(self2.re.no_http)[0].length;
          }
          return 0;
        }
      },
      "mailto:": {
        validate: function(text22, pos, self2) {
          var tail = text22.slice(pos);
          if (!self2.re.mailto) {
            self2.re.mailto = new RegExp("^" + self2.re.src_email_name + "@" + self2.re.src_host_strict, "i");
          }
          if (self2.re.mailto.test(tail)) {
            return tail.match(self2.re.mailto)[0].length;
          }
          return 0;
        }
      }
    };
    var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
    var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф".split("|");
    function resetScanCache(self2) {
      self2.__index__ = -1;
      self2.__text_cache__ = "";
    }
    function createValidator(re) {
      return function(text22, pos) {
        var tail = text22.slice(pos);
        if (re.test(tail)) {
          return tail.match(re)[0].length;
        }
        return 0;
      };
    }
    function createNormalizer() {
      return function(match3, self2) {
        self2.normalize(match3);
      };
    }
    function compile3(self2) {
      var re = self2.re = require_re()(self2.__opts__);
      var tlds = self2.__tlds__.slice();
      self2.onCompile();
      if (!self2.__tlds_replaced__) {
        tlds.push(tlds_2ch_src_re);
      }
      tlds.push(re.src_xn);
      re.src_tlds = tlds.join("|");
      function untpl(tpl) {
        return tpl.replace("%TLDS%", re.src_tlds);
      }
      re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), "i");
      re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), "i");
      re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), "i");
      re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), "i");
      var aliases = [];
      self2.__compiled__ = {};
      function schemaError(name2, val) {
        throw new Error('(LinkifyIt) Invalid schema "' + name2 + '": ' + val);
      }
      Object.keys(self2.__schemas__).forEach(function(name2) {
        var val = self2.__schemas__[name2];
        if (val === null) {
          return;
        }
        var compiled = { validate: null, link: null };
        self2.__compiled__[name2] = compiled;
        if (isObject2(val)) {
          if (isRegExp(val.validate)) {
            compiled.validate = createValidator(val.validate);
          } else if (isFunction2(val.validate)) {
            compiled.validate = val.validate;
          } else {
            schemaError(name2, val);
          }
          if (isFunction2(val.normalize)) {
            compiled.normalize = val.normalize;
          } else if (!val.normalize) {
            compiled.normalize = createNormalizer();
          } else {
            schemaError(name2, val);
          }
          return;
        }
        if (isString2(val)) {
          aliases.push(name2);
          return;
        }
        schemaError(name2, val);
      });
      aliases.forEach(function(alias) {
        if (!self2.__compiled__[self2.__schemas__[alias]]) {
          return;
        }
        self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
        self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
      });
      self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
      var slist = Object.keys(self2.__compiled__).filter(function(name2) {
        return name2.length > 0 && self2.__compiled__[name2];
      }).map(escapeRE).join("|");
      self2.re.schema_test = RegExp("(^|(?!_)(?:[><｜]|" + re.src_ZPCc + "))(" + slist + ")", "i");
      self2.re.schema_search = RegExp("(^|(?!_)(?:[><｜]|" + re.src_ZPCc + "))(" + slist + ")", "ig");
      self2.re.pretest = RegExp("(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@", "i");
      resetScanCache(self2);
    }
    function Match(self2, shift) {
      var start2 = self2.__index__, end = self2.__last_index__, text22 = self2.__text_cache__.slice(start2, end);
      this.schema = self2.__schema__.toLowerCase();
      this.index = start2 + shift;
      this.lastIndex = end + shift;
      this.raw = text22;
      this.text = text22;
      this.url = text22;
    }
    function createMatch(self2, shift) {
      var match3 = new Match(self2, shift);
      self2.__compiled__[match3.schema].normalize(match3, self2);
      return match3;
    }
    function LinkifyIt(schemas, options) {
      if (!(this instanceof LinkifyIt)) {
        return new LinkifyIt(schemas, options);
      }
      if (!options) {
        if (isOptionsObj(schemas)) {
          options = schemas;
          schemas = {};
        }
      }
      this.__opts__ = assign3({}, defaultOptions, options);
      this.__index__ = -1;
      this.__last_index__ = -1;
      this.__schema__ = "";
      this.__text_cache__ = "";
      this.__schemas__ = assign3({}, defaultSchemas, schemas);
      this.__compiled__ = {};
      this.__tlds__ = tlds_default;
      this.__tlds_replaced__ = false;
      this.re = {};
      compile3(this);
    }
    LinkifyIt.prototype.add = function add2(schema, definition2) {
      this.__schemas__[schema] = definition2;
      compile3(this);
      return this;
    };
    LinkifyIt.prototype.set = function set2(options) {
      this.__opts__ = assign3(this.__opts__, options);
      return this;
    };
    LinkifyIt.prototype.test = function test(text22) {
      this.__text_cache__ = text22;
      this.__index__ = -1;
      if (!text22.length) {
        return false;
      }
      var m3, ml, me, len, shift, next2, re, tld_pos, at_pos;
      if (this.re.schema_test.test(text22)) {
        re = this.re.schema_search;
        re.lastIndex = 0;
        while ((m3 = re.exec(text22)) !== null) {
          len = this.testSchemaAt(text22, m3[2], re.lastIndex);
          if (len) {
            this.__schema__ = m3[2];
            this.__index__ = m3.index + m3[1].length;
            this.__last_index__ = m3.index + m3[0].length + len;
            break;
          }
        }
      }
      if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
        tld_pos = text22.search(this.re.host_fuzzy_test);
        if (tld_pos >= 0) {
          if (this.__index__ < 0 || tld_pos < this.__index__) {
            if ((ml = text22.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
              shift = ml.index + ml[1].length;
              if (this.__index__ < 0 || shift < this.__index__) {
                this.__schema__ = "";
                this.__index__ = shift;
                this.__last_index__ = ml.index + ml[0].length;
              }
            }
          }
        }
      }
      if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
        at_pos = text22.indexOf("@");
        if (at_pos >= 0) {
          if ((me = text22.match(this.re.email_fuzzy)) !== null) {
            shift = me.index + me[1].length;
            next2 = me.index + me[0].length;
            if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next2 > this.__last_index__) {
              this.__schema__ = "mailto:";
              this.__index__ = shift;
              this.__last_index__ = next2;
            }
          }
        }
      }
      return this.__index__ >= 0;
    };
    LinkifyIt.prototype.pretest = function pretest(text22) {
      return this.re.pretest.test(text22);
    };
    LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text22, schema, pos) {
      if (!this.__compiled__[schema.toLowerCase()]) {
        return 0;
      }
      return this.__compiled__[schema.toLowerCase()].validate(text22, pos, this);
    };
    LinkifyIt.prototype.match = function match3(text22) {
      var shift = 0, result = [];
      if (this.__index__ >= 0 && this.__text_cache__ === text22) {
        result.push(createMatch(this, shift));
        shift = this.__last_index__;
      }
      var tail = shift ? text22.slice(shift) : text22;
      while (this.test(tail)) {
        result.push(createMatch(this, shift));
        tail = tail.slice(this.__last_index__);
        shift += this.__last_index__;
      }
      if (result.length) {
        return result;
      }
      return null;
    };
    LinkifyIt.prototype.tlds = function tlds(list22, keepOld) {
      list22 = Array.isArray(list22) ? list22 : [list22];
      if (!keepOld) {
        this.__tlds__ = list22.slice();
        this.__tlds_replaced__ = true;
        compile3(this);
        return this;
      }
      this.__tlds__ = this.__tlds__.concat(list22).sort().filter(function(el, idx, arr) {
        return el !== arr[idx - 1];
      }).reverse();
      compile3(this);
      return this;
    };
    LinkifyIt.prototype.normalize = function normalize2(match3) {
      if (!match3.schema) {
        match3.url = "http://" + match3.url;
      }
      if (match3.schema === "mailto:" && !/^mailto:/i.test(match3.url)) {
        match3.url = "mailto:" + match3.url;
      }
    };
    LinkifyIt.prototype.onCompile = function onCompile() {
    };
    module.exports = LinkifyIt;
  }
});
var require_punycode = __commonJS2({
  "node_modules/punycode/punycode.js"(exports, module) {
    "use strict";
    var maxInt = 2147483647;
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128;
    var delimiter2 = "-";
    var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\0-\x7E]/;
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    var errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    var baseMinusTMin = base - tMin;
    var floor3 = Math.floor;
    var stringFromCharCode = String.fromCharCode;
    function error22(type2) {
      throw new RangeError(errors[type2]);
    }
    function map4(array, fn2) {
      const result = [];
      let length4 = array.length;
      while (length4--) {
        result[length4] = fn2(array[length4]);
      }
      return result;
    }
    function mapDomain(string3, fn2) {
      const parts = string3.split("@");
      let result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        string3 = parts[1];
      }
      string3 = string3.replace(regexSeparators, ".");
      const labels = string3.split(".");
      const encoded = map4(labels, fn2).join(".");
      return result + encoded;
    }
    function ucs2decode(string3) {
      const output = [];
      let counter2 = 0;
      const length4 = string3.length;
      while (counter2 < length4) {
        const value2 = string3.charCodeAt(counter2++);
        if (value2 >= 55296 && value2 <= 56319 && counter2 < length4) {
          const extra = string3.charCodeAt(counter2++);
          if ((extra & 64512) == 56320) {
            output.push(((value2 & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value2);
            counter2--;
          }
        } else {
          output.push(value2);
        }
      }
      return output;
    }
    var ucs2encode = (array) => String.fromCodePoint(...array);
    var basicToDigit = function(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    };
    var digitToBasic = function(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    var adapt = function(delta, numPoints, firstTime) {
      let k2 = 0;
      delta = firstTime ? floor3(delta / damp) : delta >> 1;
      delta += floor3(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k2 += base) {
        delta = floor3(delta / baseMinusTMin);
      }
      return floor3(k2 + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    var decode2 = function(input) {
      const output = [];
      const inputLength = input.length;
      let i6 = 0;
      let n6 = initialN;
      let bias = initialBias;
      let basic = input.lastIndexOf(delimiter2);
      if (basic < 0) {
        basic = 0;
      }
      for (let j4 = 0; j4 < basic; ++j4) {
        if (input.charCodeAt(j4) >= 128) {
          error22("not-basic");
        }
        output.push(input.charCodeAt(j4));
      }
      for (let index3 = basic > 0 ? basic + 1 : 0; index3 < inputLength; ) {
        let oldi = i6;
        for (let w2 = 1, k2 = base; ; k2 += base) {
          if (index3 >= inputLength) {
            error22("invalid-input");
          }
          const digit = basicToDigit(input.charCodeAt(index3++));
          if (digit >= base || digit > floor3((maxInt - i6) / w2)) {
            error22("overflow");
          }
          i6 += digit * w2;
          const t5 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
          if (digit < t5) {
            break;
          }
          const baseMinusT = base - t5;
          if (w2 > floor3(maxInt / baseMinusT)) {
            error22("overflow");
          }
          w2 *= baseMinusT;
        }
        const out = output.length + 1;
        bias = adapt(i6 - oldi, out, oldi == 0);
        if (floor3(i6 / out) > maxInt - n6) {
          error22("overflow");
        }
        n6 += floor3(i6 / out);
        i6 %= out;
        output.splice(i6++, 0, n6);
      }
      return String.fromCodePoint(...output);
    };
    var encode3 = function(input) {
      const output = [];
      input = ucs2decode(input);
      let inputLength = input.length;
      let n6 = initialN;
      let delta = 0;
      let bias = initialBias;
      for (const currentValue of input) {
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      let basicLength = output.length;
      let handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter2);
      }
      while (handledCPCount < inputLength) {
        let m3 = maxInt;
        for (const currentValue of input) {
          if (currentValue >= n6 && currentValue < m3) {
            m3 = currentValue;
          }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m3 - n6 > floor3((maxInt - delta) / handledCPCountPlusOne)) {
          error22("overflow");
        }
        delta += (m3 - n6) * handledCPCountPlusOne;
        n6 = m3;
        for (const currentValue of input) {
          if (currentValue < n6 && ++delta > maxInt) {
            error22("overflow");
          }
          if (currentValue == n6) {
            let q2 = delta;
            for (let k2 = base; ; k2 += base) {
              const t5 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
              if (q2 < t5) {
                break;
              }
              const qMinusT = q2 - t5;
              const baseMinusT = base - t5;
              output.push(stringFromCharCode(digitToBasic(t5 + qMinusT % baseMinusT, 0)));
              q2 = floor3(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q2, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n6;
      }
      return output.join("");
    };
    var toUnicode = function(input) {
      return mapDomain(input, function(string3) {
        return regexPunycode.test(string3) ? decode2(string3.slice(4).toLowerCase()) : string3;
      });
    };
    var toASCII = function(input) {
      return mapDomain(input, function(string3) {
        return regexNonASCII.test(string3) ? "xn--" + encode3(string3) : string3;
      });
    };
    var punycode = {
      "version": "2.1.0",
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode2,
      "encode": encode3,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    module.exports = punycode;
  }
});
var require_default = __commonJS2({
  "node_modules/markdown-it/lib/presets/default.js"(exports, module) {
    "use strict";
    module.exports = {
      options: {
        html: false,
        xhtmlOut: false,
        breaks: false,
        langPrefix: "language-",
        linkify: false,
        typographer: false,
        quotes: "“”‘’",
        highlight: null,
        maxNesting: 100
      },
      components: {
        core: {},
        block: {},
        inline: {}
      }
    };
  }
});
var require_zero = __commonJS2({
  "node_modules/markdown-it/lib/presets/zero.js"(exports, module) {
    "use strict";
    module.exports = {
      options: {
        html: false,
        xhtmlOut: false,
        breaks: false,
        langPrefix: "language-",
        linkify: false,
        typographer: false,
        quotes: "“”‘’",
        highlight: null,
        maxNesting: 20
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline"
          ]
        },
        block: {
          rules: [
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "text"
          ],
          rules2: [
            "balance_pairs",
            "text_collapse"
          ]
        }
      }
    };
  }
});
var require_commonmark = __commonJS2({
  "node_modules/markdown-it/lib/presets/commonmark.js"(exports, module) {
    "use strict";
    module.exports = {
      options: {
        html: true,
        xhtmlOut: true,
        breaks: false,
        langPrefix: "language-",
        linkify: false,
        typographer: false,
        quotes: "“”‘’",
        highlight: null,
        maxNesting: 20
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline"
          ]
        },
        block: {
          rules: [
            "blockquote",
            "code",
            "fence",
            "heading",
            "hr",
            "html_block",
            "lheading",
            "list",
            "reference",
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "autolink",
            "backticks",
            "emphasis",
            "entity",
            "escape",
            "html_inline",
            "image",
            "link",
            "newline",
            "text"
          ],
          rules2: [
            "balance_pairs",
            "emphasis",
            "text_collapse"
          ]
        }
      }
    };
  }
});
var require_lib = __commonJS2({
  "node_modules/markdown-it/lib/index.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var helpers = require_helpers();
    var Renderer = require_renderer();
    var ParserCore = require_parser_core();
    var ParserBlock = require_parser_block();
    var ParserInline = require_parser_inline();
    var LinkifyIt = require_linkify_it();
    var mdurl = require_mdurl();
    var punycode = require_punycode();
    var config3 = {
      default: require_default(),
      zero: require_zero(),
      commonmark: require_commonmark()
    };
    var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
    var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
    function validateLink(url) {
      var str = url.trim().toLowerCase();
      return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
    }
    var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
    function normalizeLink(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toASCII(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.encode(mdurl.format(parsed));
    }
    function normalizeLinkText(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toUnicode(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + "%");
    }
    function MarkdownIt3(presetName, options) {
      if (!(this instanceof MarkdownIt3)) {
        return new MarkdownIt3(presetName, options);
      }
      if (!options) {
        if (!utils.isString(presetName)) {
          options = presetName || {};
          presetName = "default";
        }
      }
      this.inline = new ParserInline();
      this.block = new ParserBlock();
      this.core = new ParserCore();
      this.renderer = new Renderer();
      this.linkify = new LinkifyIt();
      this.validateLink = validateLink;
      this.normalizeLink = normalizeLink;
      this.normalizeLinkText = normalizeLinkText;
      this.utils = utils;
      this.helpers = utils.assign({}, helpers);
      this.options = {};
      this.configure(presetName);
      if (options) {
        this.set(options);
      }
    }
    MarkdownIt3.prototype.set = function(options) {
      utils.assign(this.options, options);
      return this;
    };
    MarkdownIt3.prototype.configure = function(presets) {
      var self2 = this, presetName;
      if (utils.isString(presets)) {
        presetName = presets;
        presets = config3[presetName];
        if (!presets) {
          throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
        }
      }
      if (!presets) {
        throw new Error("Wrong `markdown-it` preset, can't be empty");
      }
      if (presets.options) {
        self2.set(presets.options);
      }
      if (presets.components) {
        Object.keys(presets.components).forEach(function(name2) {
          if (presets.components[name2].rules) {
            self2[name2].ruler.enableOnly(presets.components[name2].rules);
          }
          if (presets.components[name2].rules2) {
            self2[name2].ruler2.enableOnly(presets.components[name2].rules2);
          }
        });
      }
      return this;
    };
    MarkdownIt3.prototype.enable = function(list22, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list22)) {
        list22 = [list22];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.enable(list22, true));
      }, this);
      result = result.concat(this.inline.ruler2.enable(list22, true));
      var missed = list22.filter(function(name2) {
        return result.indexOf(name2) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt3.prototype.disable = function(list22, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list22)) {
        list22 = [list22];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.disable(list22, true));
      }, this);
      result = result.concat(this.inline.ruler2.disable(list22, true));
      var missed = list22.filter(function(name2) {
        return result.indexOf(name2) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt3.prototype.use = function(plugin4) {
      var args2 = [this].concat(Array.prototype.slice.call(arguments, 1));
      plugin4.apply(plugin4, args2);
      return this;
    };
    MarkdownIt3.prototype.parse = function(src, env) {
      if (typeof src !== "string") {
        throw new Error("Input data should be a String");
      }
      var state = new this.core.State(src, this, env);
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt3.prototype.render = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parse(src, env), this.options, env);
    };
    MarkdownIt3.prototype.parseInline = function(src, env) {
      var state = new this.core.State(src, this, env);
      state.inlineMode = true;
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt3.prototype.renderInline = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parseInline(src, env), this.options, env);
    };
    module.exports = MarkdownIt3;
  }
});
var require_markdown_it = __commonJS2({
  "node_modules/markdown-it/index.js"(exports, module) {
    "use strict";
    module.exports = require_lib();
  }
});
var base_exports = {};
__export2(base_exports, {
  getAstValues: () => getAstValues,
  isAst: () => isAst,
  isFunction: () => isFunction,
  isVariable: () => isVariable,
  resolve: () => resolve
});
function isAst(value2) {
  return !!(value2 == null ? void 0 : value2.$$mdtype);
}
function isFunction(value2) {
  return !!((value2 == null ? void 0 : value2.$$mdtype) === "Function");
}
function isVariable(value2) {
  return !!((value2 == null ? void 0 : value2.$$mdtype) === "Variable");
}
function* getAstValues(value2) {
  if (value2 == null || typeof value2 !== "object")
    return;
  if (Array.isArray(value2))
    for (const v6 of value2)
      yield* getAstValues(v6);
  if (isAst(value2))
    yield value2;
  if (Object.getPrototypeOf(value2) !== Object.prototype)
    return;
  for (const v6 of Object.values(value2))
    yield* getAstValues(v6);
}
function resolve(value2, config3 = {}) {
  if (value2 == null || typeof value2 !== "object")
    return value2;
  if (Array.isArray(value2))
    return value2.map((item2) => resolve(item2, config3));
  if (isAst(value2) && (value2 == null ? void 0 : value2.resolve) instanceof Function)
    return value2.resolve(config3);
  if (Object.getPrototypeOf(value2) !== Object.prototype)
    return value2;
  const output = {};
  for (const [k2, v6] of Object.entries(value2))
    output[k2] = resolve(v6, config3);
  return output;
}
var Tag = class {
  constructor(name2 = "div", attributes = {}, children = []) {
    this.$$mdtype = "Tag";
    this.name = name2;
    this.attributes = attributes;
    this.children = children;
  }
};
Tag.isTag = (tag2) => {
  return !!((tag2 == null ? void 0 : tag2.$$mdtype) === "Tag");
};
var Class = class {
  validate(value2, _config, key) {
    if (typeof value2 === "string" || typeof value2 === "object")
      return [];
    return [
      {
        id: "attribute-type-invalid",
        level: "error",
        message: `Attribute '${key}' must be type 'string | object'`
      }
    ];
  }
  transform(value2) {
    if (!value2 || typeof value2 === "string")
      return value2;
    const classes = [];
    for (const [k2, v6] of Object.entries(value2 ?? {}))
      if (v6)
        classes.push(k2);
    return classes.join(" ");
  }
};
var Id = class {
  validate(value2) {
    if (typeof value2 === "string" && value2.match(/^[a-zA-Z]/))
      return [];
    return [
      {
        id: "attribute-value-invalid",
        level: "error",
        message: "The 'id' attribute must start with a letter"
      }
    ];
  }
};
var import_tag = __toModule(require_tag());
var Variable = class {
  constructor(path3 = []) {
    this.$$mdtype = "Variable";
    this.path = path3;
  }
  resolve({ variables } = {}) {
    return variables instanceof Function ? variables(this.path) : this.path.reduce((obj = {}, key) => obj[key], variables);
  }
};
var Function2 = class {
  constructor(name2, parameters) {
    this.$$mdtype = "Function";
    this.name = name2;
    this.parameters = parameters;
  }
  resolve(config3 = {}) {
    var _a3, _b;
    const fn2 = (_a3 = config3 == null ? void 0 : config3.functions) == null ? void 0 : _a3[this.name];
    if (!fn2)
      return null;
    const parameters = resolve(this.parameters, config3);
    return (_b = fn2.transform) == null ? void 0 : _b.call(fn2, parameters, config3);
  }
};
var STATES;
(function(STATES2) {
  STATES2[STATES2["normal"] = 0] = "normal";
  STATES2[STATES2["string"] = 1] = "string";
  STATES2[STATES2["escape"] = 2] = "escape";
})(STATES || (STATES = {}));
var OPEN = "{%";
var CLOSE = "%}";
var IDENTIFIER_REGEX = /^[a-zA-Z0-9_-]+$/;
function isIdentifier(s22) {
  return typeof s22 === "string" && IDENTIFIER_REGEX.test(s22);
}
function isPromise(a3) {
  return a3 && typeof a3 === "object" && typeof a3.then === "function";
}
function findTagEnd(content3, start2 = 0) {
  let state = 0;
  for (let pos = start2; pos < content3.length; pos++) {
    const char2 = content3[pos];
    switch (state) {
      case 1:
        switch (char2) {
          case '"':
            state = 0;
            break;
          case "\\":
            state = 2;
            break;
        }
        break;
      case 2:
        state = 1;
        break;
      case 0:
        if (char2 === '"')
          state = 1;
        else if (content3.startsWith(CLOSE, pos))
          return pos;
    }
  }
  return null;
}
function parseTag(content3, line2, contentStart) {
  try {
    return (0, import_tag.parse)(content3, { Variable, Function: Function2 });
  } catch (error22) {
    if (!(error22 instanceof import_tag.SyntaxError))
      throw error22;
    const {
      message,
      location: { start: start2, end }
    } = error22;
    const location2 = {
      start: { line: line2, character: start2.offset + contentStart },
      end: { line: line2 + 1, character: end.offset + contentStart }
    };
    return { type: "error", meta: { error: { message, location: location2 } } };
  }
}
function parseTags(content3, firstLine = 0) {
  let line2 = firstLine + 1;
  const output = [];
  let start2 = 0;
  for (let pos = 0; pos < content3.length; pos++) {
    if (content3[pos] === "\n") {
      line2++;
      continue;
    }
    if (!content3.startsWith(OPEN, pos))
      continue;
    const end = findTagEnd(content3, pos);
    if (end == null) {
      pos = pos + OPEN.length;
      continue;
    }
    const text22 = content3.slice(pos, end + CLOSE.length);
    const inner = content3.slice(pos + OPEN.length, end);
    const lineStart = content3.lastIndexOf("\n", pos);
    const lineEnd = content3.indexOf("\n", end);
    const lineContent = content3.slice(lineStart, lineEnd);
    const tag2 = parseTag(inner.trim(), line2, pos - lineStart);
    const precedingTextEnd = lineContent.trim() === text22 ? lineStart : pos;
    const precedingText = content3.slice(start2, precedingTextEnd);
    output.push({
      type: "text",
      start: start2,
      end: pos - 1,
      content: precedingText
    });
    output.push({
      map: [line2, line2 + 1],
      position: {
        start: pos - lineStart,
        end: pos - lineStart + text22.length
      },
      start: pos,
      end: pos + text22.length - 1,
      info: text22,
      ...tag2
    });
    start2 = end + CLOSE.length;
    pos = start2 - 1;
  }
  output.push({
    type: "text",
    start: start2,
    end: content3.length - 1,
    content: content3.slice(start2)
  });
  return output;
}
var globalAttributes = {
  class: { type: Class, render: true },
  id: { type: Id, render: true }
};
var transformer_default = {
  findSchema(node22, { nodes = {}, tags = {} } = {}) {
    return node22.tag ? tags[node22.tag] : nodes[node22.type];
  },
  attributes(node22, config3 = {}) {
    const schema = this.findSchema(node22, config3) ?? {};
    const output = {};
    const attrs = { ...globalAttributes, ...schema.attributes };
    for (const [key, attr] of Object.entries(attrs)) {
      if (attr.render == false)
        continue;
      const name2 = typeof attr.render === "string" ? attr.render : key;
      let value2 = node22.attributes[key];
      if (typeof attr.type === "function") {
        const instance = new attr.type();
        if (instance.transform) {
          value2 = instance.transform(value2, config3);
        }
      }
      value2 = value2 === void 0 ? attr.default : value2;
      if (value2 === void 0)
        continue;
      output[name2] = value2;
    }
    if (schema.slots) {
      for (const [key, slot2] of Object.entries(schema.slots)) {
        if (slot2.render === false)
          continue;
        const name2 = typeof slot2.render === "string" ? slot2.render : key;
        if (node22.slots[key])
          output[name2] = this.node(node22.slots[key], config3);
      }
    }
    return output;
  },
  children(node22, config3 = {}) {
    const children = node22.children.flatMap((child) => this.node(child, config3));
    if (children.some(isPromise)) {
      return Promise.all(children);
    }
    return children;
  },
  node(node22, config3 = {}) {
    const schema = this.findSchema(node22, config3) ?? {};
    if (schema && schema.transform instanceof Function)
      return schema.transform(node22, config3);
    const children = this.children(node22, config3);
    if (!schema || !schema.render)
      return children;
    const attributes = this.attributes(node22, config3);
    if (isPromise(attributes) || isPromise(children)) {
      return Promise.all([attributes, children]).then((values3) => new Tag(schema.render, ...values3));
    }
    return new Tag(schema.render, attributes, children);
  }
};
var Node2 = class {
  constructor(type2 = "node", attributes = {}, children = [], tag2) {
    this.$$mdtype = "Node";
    this.errors = [];
    this.lines = [];
    this.inline = false;
    this.attributes = attributes;
    this.children = children;
    this.type = type2;
    this.tag = tag2;
    this.annotations = [];
    this.slots = {};
  }
  *walk() {
    for (const child of [...Object.values(this.slots), ...this.children]) {
      yield child;
      yield* child.walk();
    }
  }
  push(node22) {
    this.children.push(node22);
  }
  resolve(config3 = {}) {
    return Object.assign(new Node2(), this, {
      children: this.children.map((child) => child.resolve(config3)),
      attributes: resolve(this.attributes, config3),
      slots: Object.fromEntries(Object.entries(this.slots).map(([name2, slot2]) => [
        name2,
        slot2.resolve(config3)
      ]))
    });
  }
  findSchema(config3 = {}) {
    return transformer_default.findSchema(this, config3);
  }
  transformAttributes(config3 = {}) {
    return transformer_default.attributes(this, config3);
  }
  transformChildren(config3) {
    return transformer_default.children(this, config3);
  }
  transform(config3) {
    return transformer_default.node(this, config3);
  }
};
var AstTypes = {
  Function: Function2,
  Node: Node2,
  Variable
};
function reviver(_2, value2) {
  if (!value2)
    return value2;
  const klass = AstTypes[value2.$$mdtype];
  return klass ? Object.assign(new klass(), value2) : value2;
}
function fromJSON(text22) {
  return JSON.parse(text22, reviver);
}
var ast_default = {
  ...AstTypes,
  ...base_exports,
  fromJSON
};
var SPACE = " ";
var SEP = ", ";
var NL = "\n";
var OL = ".";
var UL = "-";
var MAX_TAG_OPENING_WIDTH = 80;
var WRAPPING_TYPES = ["strong", "em", "s"];
var max = (a3, b2) => Math.max(a3, b2);
var increment = (o5, n6 = 2) => ({
  ...o5,
  indent: (o5.indent || 0) + n6
});
function* formatChildren(a3, options) {
  for (const child of a3.children) {
    yield* formatValue(child, options);
  }
}
function* formatInline(g4) {
  yield [...g4].join("").trim();
}
function* formatTableRow(items) {
  yield `| ${items.join(" | ")} |`;
}
function formatScalar(v6) {
  if (v6 === void 0) {
    return void 0;
  }
  if (ast_default.isAst(v6)) {
    return format(v6);
  }
  if (v6 === null) {
    return "null";
  }
  if (Array.isArray(v6)) {
    return "[" + v6.map(formatScalar).join(SEP) + "]";
  }
  if (typeof v6 === "object") {
    return "{" + Object.entries(v6).map(([key, value2]) => `${isIdentifier(key) ? key : `"${key}"`}: ${formatScalar(value2)}`).join(SEP) + "}";
  }
  return JSON.stringify(v6);
}
function formatAnnotationValue(a3) {
  const formattedValue = formatScalar(a3.value);
  if (formattedValue === void 0)
    return void 0;
  if (a3.name === "primary")
    return formattedValue;
  if (a3.name === "id" && typeof a3.value === "string" && isIdentifier(a3.value))
    return "#" + a3.value;
  if (a3.type === "class" && isIdentifier(a3.name))
    return "." + a3.name;
  return `${a3.name}=${formattedValue}`;
}
function* formatAttributes(n6) {
  for (const [key, value2] of Object.entries(n6.attributes)) {
    if (key === "class" && typeof value2 === "object" && !ast_default.isAst(value2))
      for (const name2 of Object.keys(value2)) {
        yield formatAnnotationValue({ type: "class", name: name2, value: value2 });
      }
    else
      yield formatAnnotationValue({ type: "attribute", name: key, value: value2 });
  }
}
function* formatAnnotations(n6) {
  if (n6.annotations.length) {
    yield OPEN + SPACE;
    yield n6.annotations.map(formatAnnotationValue).join(SPACE);
    yield SPACE + CLOSE;
  }
}
function* formatVariable(v6) {
  yield "$";
  yield v6.path.map((p5, i6) => {
    if (i6 === 0)
      return p5;
    if (isIdentifier(p5))
      return "." + p5;
    if (typeof p5 === "number")
      return `[${p5}]`;
    return `["${p5}"]`;
  }).join("");
}
function* formatFunction(f6) {
  yield f6.name;
  yield "(";
  yield Object.values(f6.parameters).map(formatScalar).join(SEP);
  yield ")";
}
function* trimStart(g4) {
  let n6;
  do {
    const { value: value2, done } = g4.next();
    if (done)
      return;
    n6 = value2.trimStart();
  } while (!n6.length);
  yield n6;
  yield* g4;
}
function* escapeMarkdownCharacters(s22, characters2) {
  yield s22.replace(characters2, "\\$&").replace(new RegExp(" ", "g"), "&nbsp;");
}
function* formatNode(n6, o5 = {}) {
  const no = { ...o5, parent: n6 };
  const indent2 = SPACE.repeat(no.indent || 0);
  switch (n6.type) {
    case "document": {
      if (n6.attributes.frontmatter && n6.attributes.frontmatter.length) {
        yield "---" + NL + n6.attributes.frontmatter + NL + "---" + NL + NL;
      }
      yield* trimStart(formatChildren(n6, no));
      break;
    }
    case "heading": {
      yield NL;
      yield indent2;
      yield "#".repeat(n6.attributes.level || 1);
      yield SPACE;
      yield* trimStart(formatChildren(n6, no));
      yield* formatAnnotations(n6);
      yield NL;
      break;
    }
    case "paragraph": {
      yield NL;
      yield* formatChildren(n6, no);
      yield* formatAnnotations(n6);
      yield NL;
      break;
    }
    case "inline": {
      yield indent2;
      yield* formatChildren(n6, no);
      break;
    }
    case "image": {
      yield "!";
      yield "[";
      yield* formatValue(n6.attributes.alt, no);
      yield "]";
      yield "(";
      yield* typeof n6.attributes.src === "string" ? escapeMarkdownCharacters(n6.attributes.src, /[()]/) : formatValue(n6.attributes.src, no);
      if (n6.attributes.title) {
        yield SPACE + `"${n6.attributes.title}"`;
      }
      yield ")";
      break;
    }
    case "link": {
      yield "[";
      yield* formatChildren(n6, no);
      yield "]";
      yield "(";
      yield* typeof n6.attributes.href === "string" ? escapeMarkdownCharacters(n6.attributes.href, /[()]/g) : formatValue(n6.attributes.href, no);
      if (n6.attributes.title) {
        yield SPACE + `"${n6.attributes.title}"`;
      }
      yield ")";
      break;
    }
    case "text": {
      const { content: content3 } = n6.attributes;
      if (ast_default.isAst(content3)) {
        yield OPEN + SPACE;
        yield* formatValue(content3, no);
        yield SPACE + CLOSE;
      } else {
        if (o5.parent && WRAPPING_TYPES.includes(o5.parent.type)) {
          yield* escapeMarkdownCharacters(content3, /[*_~]/g);
        } else {
          yield* escapeMarkdownCharacters(content3, /^[*>#]/);
        }
      }
      break;
    }
    case "blockquote": {
      const prefix4 = ">" + SPACE;
      yield n6.children.map((child) => format(child, no).trimStart()).map((d5) => NL + indent2 + prefix4 + d5).join(indent2 + prefix4);
      break;
    }
    case "hr": {
      yield NL;
      yield indent2;
      yield "---";
      yield NL;
      break;
    }
    case "fence": {
      yield NL;
      yield indent2;
      const innerFence = n6.attributes.content.match(/`{3,}/g) || [];
      const innerFenceLength = innerFence.map((s22) => s22.length).reduce(max, 0);
      const boundary = "`".repeat(innerFenceLength ? innerFenceLength + 1 : 3);
      yield boundary;
      if (n6.attributes.language)
        yield n6.attributes.language;
      if (n6.annotations.length)
        yield SPACE;
      yield* formatAnnotations(n6);
      yield NL;
      yield indent2;
      yield n6.attributes.content.split(NL).join(NL + indent2);
      yield boundary;
      yield NL;
      break;
    }
    case "tag": {
      if (!n6.inline) {
        yield NL;
        yield indent2;
      }
      const open = OPEN + SPACE;
      const attributes = [...formatAttributes(n6)].filter((v6) => v6 !== void 0);
      const tag2 = [open + n6.tag, ...attributes];
      const inlineTag = tag2.join(SPACE);
      const isLongTagOpening = inlineTag.length + open.length * 2 > (o5.maxTagOpeningWidth || MAX_TAG_OPENING_WIDTH);
      yield (!n6.inline && isLongTagOpening ? tag2.join(NL + SPACE.repeat(open.length) + indent2) : inlineTag) + SPACE + (n6.children.length ? "" : "/") + CLOSE;
      if (n6.children.length) {
        yield* formatChildren(n6, no.allowIndentation ? increment(no) : no);
        if (!n6.inline) {
          yield indent2;
        }
        yield OPEN + SPACE + "/" + n6.tag + SPACE + CLOSE;
      }
      if (!n6.inline) {
        yield NL;
      }
      break;
    }
    case "list": {
      const isLoose = n6.children.some((n22) => n22.children.some((c5) => c5.type === "paragraph"));
      for (let i6 = 0; i6 < n6.children.length; i6++) {
        const prefix4 = n6.attributes.ordered ? `${i6 === 0 ? n6.attributes.start ?? "1" : "1"}${n6.attributes.marker ?? OL}` : n6.attributes.marker ?? UL;
        let d5 = format(n6.children[i6], increment(no, prefix4.length + 1));
        if (!isLoose || i6 === n6.children.length - 1) {
          d5 = d5.trim();
        }
        yield NL + indent2 + prefix4 + " " + d5;
      }
      yield NL;
      break;
    }
    case "item": {
      for (let i6 = 0; i6 < n6.children.length; i6++) {
        yield* formatValue(n6.children[i6], no);
        if (i6 === 0)
          yield* formatAnnotations(n6);
      }
      break;
    }
    case "strong": {
      yield n6.attributes.marker ?? "**";
      yield* formatInline(formatChildren(n6, no));
      yield n6.attributes.marker ?? "**";
      break;
    }
    case "em": {
      yield n6.attributes.marker ?? "*";
      yield* formatInline(formatChildren(n6, no));
      yield n6.attributes.marker ?? "*";
      break;
    }
    case "code": {
      yield "`";
      yield* formatInline(formatValue(n6.attributes.content, no));
      yield "`";
      break;
    }
    case "s": {
      yield "~~";
      yield* formatInline(formatChildren(n6, no));
      yield "~~";
      break;
    }
    case "hardbreak": {
      yield "\\" + NL;
      yield indent2;
      break;
    }
    case "softbreak": {
      yield NL;
      yield indent2;
      break;
    }
    case "table": {
      const table3 = [...formatChildren(n6, increment(no))];
      if (o5.parent && o5.parent.type === "tag" && o5.parent.tag === "table") {
        for (let i6 = 0; i6 < table3.length; i6++) {
          const row = table3[i6];
          if (typeof row === "string") {
            if (row.trim().length) {
              yield NL;
              yield row;
            }
          } else {
            if (i6 !== 0) {
              yield NL;
              yield indent2 + "---";
            }
            for (const d5 of row) {
              yield NL + indent2 + UL + " " + d5;
            }
          }
        }
        yield NL;
      } else {
        const widths = [];
        for (const row of table3) {
          for (let i6 = 0; i6 < row.length; i6++) {
            widths[i6] = widths[i6] ? Math.max(widths[i6], row[i6].length) : row[i6].length;
          }
        }
        const [head, ...rows] = table3;
        yield NL;
        yield* formatTableRow(head.map((cell2, i6) => cell2 + SPACE.repeat(widths[i6] - cell2.length)));
        yield NL;
        yield* formatTableRow(head.map((cell2, i6) => "-".repeat(widths[i6])));
        yield NL;
        for (const row of rows) {
          yield* formatTableRow(row.map((cell2, i6) => cell2 + SPACE.repeat(widths[i6] - cell2.length)));
          yield NL;
        }
      }
      break;
    }
    case "thead": {
      const [head] = [...formatChildren(n6, no)];
      yield head || [];
      break;
    }
    case "tr": {
      yield [...formatChildren(n6, no)];
      break;
    }
    case "td":
    case "th": {
      yield [...formatChildren(n6, no), ...formatAnnotations(n6)].join("").trim();
      break;
    }
    case "tbody": {
      yield* formatChildren(n6, no);
      break;
    }
    case "comment": {
      yield "<!-- " + n6.attributes.content + " -->\n";
      break;
    }
    case "error":
    case "node":
      break;
  }
}
function* formatValue(v6, o5 = {}) {
  switch (typeof v6) {
    case "undefined":
      break;
    case "boolean":
    case "number":
    case "string": {
      yield v6.toString();
      break;
    }
    case "object": {
      if (v6 === null)
        break;
      if (Array.isArray(v6)) {
        for (const n6 of v6)
          yield* formatValue(n6, o5);
        break;
      }
      switch (v6.$$mdtype) {
        case "Function": {
          yield* formatFunction(v6);
          break;
        }
        case "Node":
          yield* formatNode(v6, o5);
          break;
        case "Variable": {
          yield* formatVariable(v6);
          break;
        }
        default:
          throw new Error(`Unimplemented: "${v6.$$mdtype}"`);
      }
      break;
    }
  }
}
function format(v6, options) {
  let doc2 = "";
  for (const s22 of formatValue(v6, options))
    doc2 += s22;
  return doc2.trimStart();
}
function truthy(value2) {
  return value2 !== false && value2 !== void 0 && value2 !== null;
}
function renderConditions(node22) {
  const conditions = [
    { condition: node22.attributes.primary, children: [] }
  ];
  for (const child of node22.children) {
    if (child.type === "tag" && child.tag === "else")
      conditions.push({
        condition: "primary" in child.attributes ? child.attributes.primary : true,
        children: []
      });
    else
      conditions[conditions.length - 1].children.push(child);
  }
  return conditions;
}
var tagIf = {
  attributes: {
    primary: { type: Object, render: false }
  },
  transform(node22, config3) {
    const conditions = renderConditions(node22);
    for (const { condition, children } of conditions)
      if (truthy(condition)) {
        const nodes = children.flatMap((child) => child.transform(config3));
        if (nodes.some(isPromise)) {
          return Promise.all(nodes).then((nodes2) => nodes2.flat());
        }
        return nodes;
      }
    return [];
  }
};
var tagElse = {
  selfClosing: true,
  attributes: {
    primary: { type: Object, render: false }
  }
};
var and = {
  transform(parameters) {
    return Object.values(parameters).every((x4) => truthy(x4));
  }
};
var or = {
  transform(parameters) {
    return Object.values(parameters).find((x4) => truthy(x4)) !== void 0;
  }
};
var not = {
  parameters: {
    0: { required: true }
  },
  transform(parameters) {
    return !truthy(parameters[0]);
  }
};
var equals = {
  transform(parameters) {
    const values3 = Object.values(parameters);
    return values3.every((v6) => v6 === values3[0]);
  }
};
var debug = {
  transform(parameters) {
    return JSON.stringify(parameters[0], null, 2);
  }
};
var defaultFn = {
  transform(parameters) {
    return parameters[0] === void 0 ? parameters[1] : parameters[0];
  }
};
var functions_default = { and, or, not, equals, default: defaultFn, debug };
function convertToRow(node22, cellType = "td") {
  node22.type = "tr";
  node22.attributes = {};
  for (const cell2 of node22.children)
    cell2.type = cellType;
  return node22;
}
function transform(document22) {
  for (const node22 of document22.walk()) {
    if (node22.type !== "tag" || node22.tag !== "table")
      continue;
    const [first, ...rest] = node22.children;
    if (!first || first.type === "table")
      continue;
    const table3 = new ast_default.Node("table", node22.attributes, [
      new ast_default.Node("thead"),
      new ast_default.Node("tbody")
    ]);
    const [thead2, tbody2] = table3.children;
    if (first.type === "list")
      thead2.push(convertToRow(first, "th"));
    for (const row of rest) {
      if (row.type === "list")
        convertToRow(row);
      else if (row.type === "tag" && row.tag === "if") {
        const children = [];
        for (const child of row.children) {
          if (child.type === "hr")
            continue;
          if (child.type === "list")
            convertToRow(child);
          children.push(child);
        }
        row.children = children;
      } else
        continue;
      tbody2.push(row);
    }
    node22.children = [table3];
  }
}
var transforms_default = [transform];
var mappings = {
  ordered_list: "list",
  bullet_list: "list",
  code_inline: "code",
  list_item: "item",
  variable: "text"
};
function annotate(node22, attributes) {
  for (const attribute of attributes) {
    node22.annotations.push(attribute);
    const { name: name2, value: value2, type: type2 } = attribute;
    if (type2 === "attribute") {
      if (node22.attributes[name2] !== void 0)
        node22.errors.push({
          id: "duplicate-attribute",
          level: "warning",
          message: `Attribute '${name2}' already set`
        });
      node22.attributes[name2] = value2;
    } else if (type2 === "class")
      if (node22.attributes.class)
        node22.attributes.class[name2] = value2;
      else
        node22.attributes.class = { [name2]: value2 };
  }
}
function handleAttrs(token2, type2) {
  switch (type2) {
    case "heading":
      return { level: Number(token2.tag.replace("h", "")) };
    case "list": {
      const attrs = token2.attrs ? Object.fromEntries(token2.attrs) : void 0;
      const ordered = token2.type.startsWith("ordered");
      return ordered && (attrs == null ? void 0 : attrs.start) ? { ordered: true, start: attrs.start, marker: token2.markup } : { ordered, marker: token2.markup };
    }
    case "link": {
      const attrs = Object.fromEntries(token2.attrs);
      return attrs.title ? { href: attrs.href, title: attrs.title } : { href: attrs.href };
    }
    case "image": {
      const attrs = Object.fromEntries(token2.attrs);
      return attrs.title ? { alt: token2.content, src: attrs.src, title: attrs.title } : { alt: token2.content, src: attrs.src };
    }
    case "em":
    case "strong":
      return { marker: token2.markup };
    case "text":
    case "code":
    case "comment":
      return { content: (token2.meta || {}).variable || token2.content };
    case "fence": {
      const [language] = token2.info.split(" ", 1);
      return language === "" || language === OPEN ? { content: token2.content } : { content: token2.content, language };
    }
    case "td":
    case "th": {
      if (token2.attrs) {
        const attrs = Object.fromEntries(token2.attrs);
        let align;
        if (attrs.style) {
          if (attrs.style.includes("left")) {
            align = "left";
          } else if (attrs.style.includes("center")) {
            align = "center";
          } else if (attrs.style.includes("right")) {
            align = "right";
          }
        }
        if (align) {
          return { align };
        }
      }
      return {};
    }
    default:
      return {};
  }
}
function handleToken(token2, nodes, file, handleSlots, addLocation, inlineParent) {
  if (token2.type === "frontmatter") {
    nodes[0].attributes.frontmatter = token2.content;
    return;
  }
  if (token2.hidden || token2.type === "text" && token2.content === "")
    return;
  const errors = token2.errors || [];
  const parent = nodes[nodes.length - 1];
  const { tag: tag2, attributes, error: error22 } = token2.meta || {};
  if (token2.type === "annotation") {
    if (inlineParent)
      return annotate(inlineParent, attributes);
    return parent.errors.push({
      id: "no-inline-annotations",
      level: "error",
      message: `Can't apply inline annotations to '${parent.type}'`
    });
  }
  let typeName = token2.type.replace(/_(open|close)$/, "");
  if (mappings[typeName])
    typeName = mappings[typeName];
  if (typeName === "error") {
    const { message, location: location2 } = error22;
    errors.push({ id: "parse-error", level: "critical", message, location: location2 });
  }
  if (token2.nesting < 0) {
    if (parent.type === typeName && parent.tag === tag2) {
      if (parent.lines && token2.map)
        parent.lines.push(...token2.map);
      return nodes.pop();
    }
    errors.push({
      id: "missing-opening",
      level: "critical",
      message: `Node '${typeName}' is missing opening`
    });
  }
  const attrs = handleAttrs(token2, typeName);
  const node22 = new Node2(typeName, attrs, void 0, tag2 || void 0);
  const { position: position3 = {} } = token2;
  node22.errors = errors;
  if (addLocation !== false) {
    node22.lines = token2.map || parent.lines || [];
    node22.location = {
      file,
      start: {
        line: node22.lines[0],
        character: position3.start
      },
      end: {
        line: node22.lines[1],
        character: position3.end
      }
    };
  }
  if (inlineParent)
    node22.inline = true;
  if (attributes && ["tag", "fence", "image"].includes(typeName))
    annotate(node22, attributes);
  if (handleSlots && tag2 === "slot" && typeof node22.attributes.primary === "string")
    parent.slots[node22.attributes.primary] = node22;
  else
    parent.push(node22);
  if (token2.nesting > 0)
    nodes.push(node22);
  if (!Array.isArray(token2.children))
    return;
  if (node22.type === "inline")
    inlineParent = parent;
  nodes.push(node22);
  const isLeafNode = typeName === "image";
  if (!isLeafNode) {
    for (const child of token2.children)
      handleToken(child, nodes, file, handleSlots, addLocation, inlineParent);
  }
  nodes.pop();
}
function parser(tokens, args2) {
  const doc2 = new Node2("document");
  const nodes = [doc2];
  if (typeof args2 === "string")
    args2 = { file: args2 };
  for (const token2 of tokens)
    handleToken(token2, nodes, args2 == null ? void 0 : args2.file, args2 == null ? void 0 : args2.slots, args2 == null ? void 0 : args2.location);
  if (nodes.length > 1)
    for (const node22 of nodes.slice(1))
      node22.errors.push({
        id: "missing-closing",
        level: "critical",
        message: `Node '${node22.tag || node22.type}' is missing closing`
      });
  for (const transform3 of transforms_default)
    transform3(doc2);
  return doc2;
}
var schema_exports = {};
__export2(schema_exports, {
  blockquote: () => blockquote,
  code: () => code,
  comment: () => comment,
  document: () => document2,
  em: () => em,
  error: () => error,
  fence: () => fence,
  hardbreak: () => hardbreak,
  heading: () => heading,
  hr: () => hr,
  image: () => image,
  inline: () => inline,
  item: () => item,
  link: () => link,
  list: () => list,
  node: () => node,
  paragraph: () => paragraph,
  s: () => s,
  softbreak: () => softbreak,
  strong: () => strong,
  table: () => table,
  tbody: () => tbody,
  td: () => td,
  text: () => text,
  th: () => th,
  thead: () => thead,
  tr: () => tr
});
var document2 = {
  render: "article",
  children: [
    "heading",
    "paragraph",
    "image",
    "table",
    "tag",
    "fence",
    "blockquote",
    "comment",
    "list",
    "hr"
  ],
  attributes: {
    frontmatter: { render: false }
  }
};
var heading = {
  children: ["inline"],
  attributes: {
    level: { type: Number, render: false, required: true }
  },
  transform(node22, config3) {
    return new Tag(`h${node22.attributes["level"]}`, node22.transformAttributes(config3), node22.transformChildren(config3));
  }
};
var paragraph = {
  render: "p",
  children: ["inline"]
};
var image = {
  render: "img",
  attributes: {
    src: { type: String, required: true },
    alt: { type: String },
    title: { type: String }
  }
};
var fence = {
  render: "pre",
  attributes: {
    content: { type: String, render: false, required: true },
    language: { type: String, render: "data-language" },
    process: { type: Boolean, render: false, default: true }
  },
  transform(node22, config3) {
    const attributes = node22.transformAttributes(config3);
    const children = node22.children.length ? node22.transformChildren(config3) : [node22.attributes.content];
    return new Tag("pre", attributes, children);
  }
};
var blockquote = {
  render: "blockquote",
  children: [
    "heading",
    "paragraph",
    "image",
    "table",
    "tag",
    "fence",
    "blockquote",
    "list",
    "hr"
  ]
};
var item = {
  render: "li",
  children: [
    "inline",
    "heading",
    "paragraph",
    "image",
    "table",
    "tag",
    "fence",
    "blockquote",
    "list",
    "hr"
  ]
};
var list = {
  children: ["item"],
  attributes: {
    ordered: { type: Boolean, render: false, required: true },
    start: { type: Number },
    marker: { type: String, render: false }
  },
  transform(node22, config3) {
    return new Tag(node22.attributes.ordered ? "ol" : "ul", node22.transformAttributes(config3), node22.transformChildren(config3));
  }
};
var hr = {
  render: "hr"
};
var table = {
  render: "table"
};
var td = {
  render: "td",
  children: [
    "inline",
    "heading",
    "paragraph",
    "image",
    "table",
    "tag",
    "fence",
    "blockquote",
    "list",
    "hr"
  ],
  attributes: {
    align: { type: String },
    colspan: { type: Number, render: "colSpan" },
    rowspan: { type: Number, render: "rowSpan" }
  }
};
var th = {
  render: "th",
  attributes: {
    width: { type: Number },
    align: { type: String },
    colspan: { type: Number, render: "colSpan" },
    rowspan: { type: Number, render: "rowSpan" }
  }
};
var tr = {
  render: "tr",
  children: ["th", "td"]
};
var tbody = {
  render: "tbody",
  children: ["tr", "tag"]
};
var thead = {
  render: "thead",
  children: ["tr"]
};
var strong = {
  render: "strong",
  children: ["em", "s", "link", "code", "text", "tag"],
  attributes: {
    marker: { type: String, render: false }
  }
};
var em = {
  render: "em",
  children: ["strong", "s", "link", "code", "text", "tag"],
  attributes: {
    marker: { type: String, render: false }
  }
};
var s = {
  render: "s",
  children: ["strong", "em", "link", "code", "text", "tag"]
};
var inline = {
  children: [
    "strong",
    "em",
    "s",
    "code",
    "text",
    "tag",
    "link",
    "image",
    "hardbreak",
    "softbreak",
    "comment"
  ]
};
var link = {
  render: "a",
  children: ["strong", "em", "s", "code", "text", "tag"],
  attributes: {
    href: { type: String, required: true },
    title: { type: String }
  }
};
var code = {
  render: "code",
  attributes: {
    content: { type: String, render: false, required: true }
  },
  transform(node22, config3) {
    const attributes = node22.transformAttributes(config3);
    return new Tag("code", attributes, [node22.attributes.content]);
  }
};
var text = {
  attributes: {
    content: { type: String, required: true }
  },
  transform(node22) {
    return node22.attributes.content;
  }
};
var hardbreak = {
  render: "br"
};
var softbreak = {
  transform() {
    return " ";
  }
};
var comment = {
  attributes: {
    content: { type: String, required: true }
  }
};
var error = {};
var node = {};
var import_markdown_it = __toModule(require_markdown_it());
var { escapeHtml } = (0, import_markdown_it.default)().utils;
var voidElements = /* @__PURE__ */ new Set([
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render(node22) {
  if (typeof node22 === "string" || typeof node22 === "number")
    return escapeHtml(String(node22));
  if (Array.isArray(node22))
    return node22.map(render).join("");
  if (node22 === null || typeof node22 !== "object" || !Tag.isTag(node22))
    return "";
  const { name: name2, attributes, children = [] } = node22;
  if (!name2)
    return render(children);
  let output = `<${name2}`;
  for (const [k2, v6] of Object.entries(attributes ?? {}))
    output += ` ${k2.toLowerCase()}="${escapeHtml(String(v6))}"`;
  output += ">";
  if (voidElements.has(name2))
    return output;
  if (children.length)
    output += render(children);
  output += `</${name2}>`;
  return output;
}
function tagName(name2, components) {
  return typeof name2 !== "string" ? name2 : name2[0] !== name2[0].toUpperCase() ? name2 : components instanceof Function ? components(name2) : components[name2];
}
function dynamic(node22, React13, { components = {} } = {}) {
  function deepRender2(value2) {
    if (value2 == null || typeof value2 !== "object")
      return value2;
    if (Array.isArray(value2))
      return value2.map((item2) => deepRender2(item2));
    if (value2.$$mdtype === "Tag")
      return render3(value2);
    if (typeof value2 !== "object")
      return value2;
    const output = {};
    for (const [k2, v6] of Object.entries(value2))
      output[k2] = deepRender2(v6);
    return output;
  }
  function render3(node32) {
    if (Array.isArray(node32))
      return React13.createElement(React13.Fragment, null, ...node32.map(render3));
    if (node32 === null || typeof node32 !== "object" || !Tag.isTag(node32))
      return node32;
    const {
      name: name2,
      attributes: { class: className, ...attrs } = {},
      children = []
    } = node32;
    if (className)
      attrs.className = className;
    return React13.createElement(tagName(name2, components), Object.keys(attrs).length == 0 ? null : deepRender2(attrs), ...children.map(render3));
  }
  return render3(node22);
}
function tagName2(name2, components) {
  return typeof name2 !== "string" ? "Fragment" : name2[0] !== name2[0].toUpperCase() ? name2 : components instanceof Function ? components(name2) : components[name2];
}
function renderArray(children) {
  return children.map(render2).join(", ");
}
function deepRender(value2) {
  if (value2 == null || typeof value2 !== "object")
    return JSON.stringify(value2);
  if (Array.isArray(value2))
    return `[${value2.map((item2) => deepRender(item2)).join(", ")}]`;
  if (value2.$$mdtype === "Tag")
    return render2(value2);
  if (typeof value2 !== "object")
    return JSON.stringify(value2);
  const object2 = Object.entries(value2).map(([k2, v6]) => [JSON.stringify(k2), deepRender(v6)].join(": ")).join(", ");
  return `{${object2}}`;
}
function render2(node22) {
  if (Array.isArray(node22))
    return `React.createElement(React.Fragment, null, ${renderArray(node22)})`;
  if (node22 === null || typeof node22 !== "object" || !Tag.isTag(node22))
    return JSON.stringify(node22);
  const {
    name: name2,
    attributes: { class: className, ...attrs } = {},
    children = []
  } = node22;
  if (className)
    attrs.className = className;
  return `React.createElement(
    tagName(${JSON.stringify(name2)}, components),
    ${Object.keys(attrs).length == 0 ? "null" : deepRender(attrs)},
    ${renderArray(children)})`;
}
function reactStatic(node22) {
  return `
  (({components = {}} = {}) => {
    ${tagName2}
    return ${render2(node22)};
  })
`;
}
var renderers_default = { html: render, react: dynamic, reactStatic };
var PartialFile = class {
  validate(file, config3) {
    const { partials = {} } = config3;
    const partial2 = partials[file];
    if (!partial2)
      return [
        {
          id: "attribute-value-invalid",
          level: "error",
          message: `Partial \`${file}\` not found. The 'file' attribute must be set in \`config.partials\``
        }
      ];
    return [];
  }
};
var partial = {
  inline: false,
  selfClosing: true,
  attributes: {
    file: { type: PartialFile, render: false, required: true },
    variables: { type: Object, render: false }
  },
  transform(node22, config3) {
    const { partials = {} } = config3;
    const { file, variables } = node22.attributes;
    const partial2 = partials[file];
    if (!partial2)
      return null;
    const scopedConfig = {
      ...config3,
      variables: {
        ...config3.variables,
        ...variables,
        ["$$partial:filename"]: file
      }
    };
    const transformChildren = (part) => part.resolve(scopedConfig).transformChildren(scopedConfig);
    return Array.isArray(partial2) ? partial2.flatMap(transformChildren) : transformChildren(partial2);
  }
};
var table2 = {
  children: ["table"],
  inline: false
};
var slot = {
  attributes: {
    primary: { type: String, required: true }
  }
};
var tags_default = {
  else: tagElse,
  if: tagIf,
  partial,
  slot,
  table: table2
};
var import_lib = __toModule(require_lib());
var import_tag7 = __toModule(require_tag());
function createToken(state, content3, contentStart) {
  try {
    const { type: type2, meta, nesting = 0 } = (0, import_tag7.parse)(content3, { Variable, Function: Function2 });
    const token2 = state.push(type2, "", nesting);
    token2.info = content3;
    token2.meta = meta;
    if (!state.delimiters) {
      state.delimiters = [];
    }
    return token2;
  } catch (error22) {
    if (!(error22 instanceof import_tag7.SyntaxError))
      throw error22;
    const {
      message,
      location: { start: start2, end }
    } = error22;
    const location2 = contentStart ? {
      start: { offset: start2.offset + contentStart },
      end: { offset: end.offset + contentStart }
    } : null;
    const token2 = state.push("error", "", 0);
    token2.meta = { error: { message, location: location2 } };
    return token2;
  }
}
function block(state, startLine, endLine, silent) {
  const start2 = state.bMarks[startLine] + state.tShift[startLine];
  const finish = state.eMarks[startLine];
  if (!state.src.startsWith(OPEN, start2))
    return false;
  const tagEnd = findTagEnd(state.src, start2);
  const lastPossible = state.src.slice(0, finish).trim().length;
  if (!tagEnd || tagEnd < lastPossible - CLOSE.length)
    return false;
  const contentStart = start2 + OPEN.length;
  const content3 = state.src.slice(contentStart, tagEnd).trim();
  const lines = state.src.slice(start2, tagEnd + CLOSE.length).split("\n").length;
  if (content3[0] === "$")
    return false;
  if (silent)
    return true;
  const token2 = createToken(state, content3, contentStart);
  token2.map = [startLine, startLine + lines];
  state.line += lines;
  return true;
}
function inline2(state, silent) {
  if (!state.src.startsWith(OPEN, state.pos))
    return false;
  const tagEnd = findTagEnd(state.src, state.pos);
  if (!tagEnd)
    return false;
  const content3 = state.src.slice(state.pos + OPEN.length, tagEnd);
  if (!silent)
    createToken(state, content3.trim());
  state.pos = tagEnd + CLOSE.length;
  return true;
}
function core(state) {
  var _a3, _b;
  let token2;
  for (token2 of state.tokens) {
    if (token2.type !== "fence")
      continue;
    if (token2.info.includes(OPEN)) {
      const start2 = token2.info.indexOf(OPEN);
      const end = findTagEnd(token2.info, start2);
      const content3 = token2.info.slice(start2 + OPEN.length, end);
      try {
        const { meta } = (0, import_tag7.parse)(content3.trim(), { Variable, Function: Function2 });
        token2.meta = meta;
      } catch (error22) {
        if (!(error22 instanceof import_tag7.SyntaxError))
          throw error22;
        if (!token2.errors)
          token2.errors = [];
        token2.errors.push({
          id: "fence-tag-error",
          level: "error",
          message: `Syntax error in fence tag: ${error22.message}`
        });
      }
    }
    if ((_b = (_a3 = token2 == null ? void 0 : token2.meta) == null ? void 0 : _a3.attributes) == null ? void 0 : _b.find((attr) => attr.name === "process" && !attr.value))
      continue;
    token2.children = parseTags(token2.content, token2.map[0]);
  }
}
function plugin(md) {
  md.block.ruler.before("paragraph", "annotations", block, {
    alt: ["paragraph", "blockquote"]
  });
  md.inline.ruler.push("containers", inline2);
  md.core.ruler.push("annotations", core);
}
var fence2 = "---";
function getLine(state, n6) {
  return state.src.slice(state.bMarks[n6], state.eMarks[n6]).trim();
}
function findClose(state, endLine) {
  for (let line2 = 1; line2 < endLine; line2++)
    if (getLine(state, line2) === fence2)
      return line2;
}
function block2(state, startLine, endLine, silent) {
  if (startLine != 0 || getLine(state, 0) != fence2)
    return false;
  const close = findClose(state, endLine);
  if (!close)
    return false;
  if (silent)
    return true;
  const token2 = state.push("frontmatter", "", 0);
  token2.content = state.src.slice(state.eMarks[0], state.bMarks[close]).trim();
  token2.map = [0, close];
  token2.hidden = true;
  state.line = close + 1;
  return true;
}
function plugin2(md) {
  md.block.ruler.before("hr", "frontmatter", block2);
}
var OPEN2 = "<!--";
var CLOSE2 = "-->";
function block3(state, startLine, endLine, silent) {
  const start2 = state.bMarks[startLine] + state.tShift[startLine];
  if (!state.src.startsWith(OPEN2, start2))
    return false;
  const close = state.src.indexOf(CLOSE2, start2);
  if (!close)
    return false;
  if (silent)
    return true;
  const content3 = state.src.slice(start2 + OPEN2.length, close);
  const lines = content3.split("\n").length;
  const token2 = state.push("comment", "", 0);
  token2.content = content3.trim();
  token2.map = [startLine, startLine + lines];
  state.line += lines;
  return true;
}
function inline3(state, silent) {
  if (!state.src.startsWith(OPEN2, state.pos))
    return false;
  const close = state.src.indexOf(CLOSE2, state.pos);
  if (!close)
    return false;
  if (silent)
    return true;
  const content3 = state.src.slice(state.pos + OPEN2.length, close);
  const token2 = state.push("comment", "", 0);
  token2.content = content3.trim();
  state.pos = close + CLOSE2.length;
  return true;
}
function plugin3(md) {
  md.block.ruler.before("table", "comment", block3, { alt: ["paragraph"] });
  md.inline.ruler.push("comment", inline3);
}
var Tokenizer = class {
  constructor(config3 = {}) {
    this.parser = new import_lib.default(config3);
    this.parser.use(plugin, "annotations", {});
    this.parser.use(plugin2, "frontmatter", {});
    this.parser.disable([
      "lheading",
      "code"
    ]);
    if (config3.allowComments)
      this.parser.use(plugin3, "comments", {});
  }
  tokenize(content3) {
    return this.parser.parse(content3.toString(), {});
  }
};
var TypeMappings = {
  String,
  Number,
  Array,
  Object,
  Boolean
};
function validateType(type2, value2, config3, key) {
  var _a3, _b;
  if (!type2)
    return true;
  if (ast_default.isFunction(value2) && ((_a3 = config3.validation) == null ? void 0 : _a3.validateFunctions)) {
    const schema = (_b = config3.functions) == null ? void 0 : _b[value2.name];
    return !(schema == null ? void 0 : schema.returns) ? true : Array.isArray(schema.returns) ? schema.returns.find((t5) => t5 === type2) !== void 0 : schema.returns === type2;
  }
  if (ast_default.isAst(value2))
    return true;
  if (Array.isArray(type2))
    return type2.some((t5) => validateType(t5, value2, config3, key));
  if (typeof type2 === "string")
    type2 = TypeMappings[type2];
  if (typeof type2 === "function") {
    const instance = new type2();
    if (instance.validate) {
      return instance.validate(value2, config3, key);
    }
  }
  return value2 != null && value2.constructor === type2;
}
function typeToString(type2) {
  if (typeof type2 === "string")
    return type2;
  if (Array.isArray(type2))
    return type2.map(typeToString).join(" | ");
  return type2.name;
}
function validateFunction(fn2, config3) {
  var _a3, _b;
  const schema = (_a3 = config3.functions) == null ? void 0 : _a3[fn2.name];
  const errors = [];
  if (!schema)
    return [
      {
        id: "function-undefined",
        level: "critical",
        message: `Undefined function: '${fn2.name}'`
      }
    ];
  if (schema.validate)
    errors.push(...schema.validate(fn2, config3));
  if (schema.parameters) {
    for (const [key, value2] of Object.entries(fn2.parameters)) {
      const param = (_b = schema.parameters) == null ? void 0 : _b[key];
      if (!param) {
        errors.push({
          id: "parameter-undefined",
          level: "error",
          message: `Invalid parameter: '${key}'`
        });
        continue;
      }
      if (ast_default.isAst(value2) && !ast_default.isFunction(value2))
        continue;
      if (param.type) {
        const valid = validateType(param.type, value2, config3, key);
        if (valid === false) {
          errors.push({
            id: "parameter-type-invalid",
            level: "error",
            message: `Parameter '${key}' of '${fn2.name}' must be type of '${typeToString(param.type)}'`
          });
        } else if (Array.isArray(valid)) {
          errors.push(...valid);
        }
      }
    }
  }
  for (const [key, { required }] of Object.entries(schema.parameters ?? {}))
    if (required && fn2.parameters[key] === void 0)
      errors.push({
        id: "parameter-missing-required",
        level: "error",
        message: `Missing required parameter: '${key}'`
      });
  return errors;
}
function displayMatches(matches, n6) {
  if (matches.length <= n6)
    return JSON.stringify(matches);
  const items = matches.slice(0, n6).map((item2) => JSON.stringify(item2));
  return `[${items.join(",")}, ... ${matches.length - n6} more]`;
}
function validator(node22, config3) {
  var _a3, _b;
  const schema = node22.findSchema(config3);
  const errors = [...node22.errors || []];
  if (!schema) {
    errors.push({
      id: node22.tag ? "tag-undefined" : "node-undefined",
      level: "critical",
      message: node22.tag ? `Undefined tag: '${node22.tag}'` : `Undefined node: '${node22.type}'`
    });
    return errors;
  }
  if (schema.inline != void 0 && node22.inline !== schema.inline)
    errors.push({
      id: "tag-placement-invalid",
      level: "critical",
      message: `'${node22.tag}' tag should be ${schema.inline ? "inline" : "block"}`
    });
  if (schema.selfClosing && node22.children.length > 0)
    errors.push({
      id: "tag-selfclosing-has-children",
      level: "critical",
      message: `'${node22.tag}' tag should be self-closing`
    });
  const attributes = {
    ...globalAttributes,
    ...schema.attributes
  };
  for (const key of Object.keys(node22.slots)) {
    const slot2 = (_a3 = schema.slots) == null ? void 0 : _a3[key];
    if (!slot2)
      errors.push({
        id: "slot-undefined",
        level: "error",
        message: `Invalid slot: '${key}'`
      });
  }
  for (let [key, value2] of Object.entries(node22.attributes)) {
    const attrib = attributes[key];
    if (!attrib) {
      errors.push({
        id: "attribute-undefined",
        level: "error",
        message: `Invalid attribute: '${key}'`
      });
      continue;
    }
    let { type: type2, matches, errorLevel } = attrib;
    if (ast_default.isAst(value2)) {
      if (ast_default.isFunction(value2) && ((_b = config3.validation) == null ? void 0 : _b.validateFunctions))
        errors.push(...validateFunction(value2, config3));
      else if (ast_default.isVariable(value2) && config3.variables) {
        let missing = false;
        let variables = config3.variables;
        for (const key2 of value2.path) {
          if (!Object.prototype.hasOwnProperty.call(variables, key2)) {
            missing = true;
            break;
          }
          variables = variables[key2];
        }
        if (missing) {
          errors.push({
            id: "variable-undefined",
            level: "error",
            message: `Undefined variable: '${value2.path.join(".")}'`
          });
        }
      } else
        continue;
    }
    value2 = value2;
    if (type2) {
      const valid = validateType(type2, value2, config3, key);
      if (valid === false) {
        errors.push({
          id: "attribute-type-invalid",
          level: errorLevel || "error",
          message: `Attribute '${key}' must be type of '${typeToString(type2)}'`
        });
      }
      if (Array.isArray(valid)) {
        errors.push(...valid);
      }
    }
    if (typeof matches === "function")
      matches = matches(config3);
    if (Array.isArray(matches) && !matches.includes(value2))
      errors.push({
        id: "attribute-value-invalid",
        level: errorLevel || "error",
        message: `Attribute '${key}' must match one of ${displayMatches(matches, 8)}. Got '${value2}' instead.`
      });
    if (matches instanceof RegExp && !matches.test(value2))
      errors.push({
        id: "attribute-value-invalid",
        level: errorLevel || "error",
        message: `Attribute '${key}' must match ${matches}. Got '${value2}' instead.`
      });
    if (typeof attrib.validate === "function") {
      const attribErrors = attrib.validate(value2, config3, key);
      if (Array.isArray(attribErrors))
        errors.push(...attribErrors);
    }
  }
  for (const [key, { required }] of Object.entries(attributes))
    if (required && node22.attributes[key] === void 0)
      errors.push({
        id: "attribute-missing-required",
        level: "error",
        message: `Missing required attribute: '${key}'`
      });
  if (schema.slots) {
    for (const [key, { required }] of Object.entries(schema.slots))
      if (required && node22.slots[key] === void 0)
        errors.push({
          id: "slot-missing-required",
          level: "error",
          message: `Missing required slot: '${key}'`
        });
  }
  for (const { type: type2 } of node22.children) {
    if (schema.children && type2 !== "error" && !schema.children.includes(type2))
      errors.push({
        id: "child-invalid",
        level: "warning",
        message: `Can't nest '${type2}' in '${node22.tag || node22.type}'`
      });
  }
  if (schema.validate) {
    const schemaErrors = schema.validate(node22, config3);
    if (isPromise(schemaErrors)) {
      return schemaErrors.then((e6) => errors.concat(e6));
    }
    errors.push(...schemaErrors);
  }
  return errors;
}
function* walkWithParents(node22, parents = []) {
  yield [node22, parents];
  for (const child of [...Object.values(node22.slots), ...node22.children])
    yield* walkWithParents(child, [...parents, node22]);
}
function validateTree(content3, config3) {
  const output = [...walkWithParents(content3)].map(([node22, parents]) => {
    const { type: type2, lines, location: location2 } = node22;
    const updatedConfig = {
      ...config3,
      validation: { ...config3.validation, parents }
    };
    const errors = validator(node22, updatedConfig);
    if (isPromise(errors)) {
      return errors.then((e6) => e6.map((error22) => ({ type: type2, lines, location: location2, error: error22 })));
    }
    return errors.map((error22) => ({ type: type2, lines, location: location2, error: error22 }));
  });
  if (output.some(isPromise)) {
    return Promise.all(output).then((o5) => o5.flat());
  }
  return output.flat();
}
var tokenizer = new Tokenizer();
function mergeConfig(config3 = {}) {
  return {
    ...config3,
    tags: {
      ...tags_default,
      ...config3.tags
    },
    nodes: {
      ...schema_exports,
      ...config3.nodes
    },
    functions: {
      ...functions_default,
      ...config3.functions
    }
  };
}
function parse3(content3, args2) {
  if (typeof content3 === "string")
    content3 = tokenizer.tokenize(content3);
  return parser(content3, args2);
}
function resolve2(content3, config3) {
  if (Array.isArray(content3))
    return content3.flatMap((child) => child.resolve(config3));
  return content3.resolve(config3);
}
function transform2(nodes, options) {
  const config3 = mergeConfig(options);
  const content3 = resolve2(nodes, config3);
  if (Array.isArray(content3))
    return content3.flatMap((child) => child.transform(config3));
  return content3.transform(config3);
}
function validate(content3, options) {
  const config3 = mergeConfig(options);
  return validateTree(content3, config3);
}
function createElement(name2, attributes = {}, ...children) {
  return { name: name2, attributes, children };
}
var Markdoc = class {
  constructor(config3) {
    this.parse = parse3;
    this.resolve = (content3) => resolve2(content3, this.config);
    this.transform = (content3) => transform2(content3, this.config);
    this.validate = (content3) => validate(content3, this.config);
    this.config = config3;
  }
};
Markdoc.nodes = schema_exports;
Markdoc.tags = tags_default;
Markdoc.functions = functions_default;
Markdoc.globalAttributes = globalAttributes;
Markdoc.renderers = renderers_default;
Markdoc.transforms = transforms_default;
Markdoc.Ast = ast_default;
Markdoc.Tag = Tag;
Markdoc.Tokenizer = Tokenizer;
Markdoc.parseTags = parseTags;
Markdoc.transformer = transformer_default;
Markdoc.validator = validator;
Markdoc.parse = parse3;
Markdoc.transform = transform2;
Markdoc.validate = validate;
Markdoc.createElement = createElement;
Markdoc.truthy = truthy;
Markdoc.format = format;

// node_modules/is-plain-object/dist/is-plain-object.mjs
function isObject(o5) {
  return Object.prototype.toString.call(o5) === "[object Object]";
}
function isPlainObject(o5) {
  var ctor, prot;
  if (isObject(o5) === false)
    return false;
  ctor = o5.constructor;
  if (ctor === void 0)
    return true;
  prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
}

// node_modules/immer/dist/immer.esm.mjs
function n(n6) {
  for (var r7 = arguments.length, t5 = Array(r7 > 1 ? r7 - 1 : 0), e6 = 1; e6 < r7; e6++)
    t5[e6 - 1] = arguments[e6];
  if (true) {
    var i6 = Y[n6], o5 = i6 ? "function" == typeof i6 ? i6.apply(null, t5) : i6 : "unknown error nr: " + n6;
    throw Error("[Immer] " + o5);
  }
  throw Error("[Immer] minified error nr: " + n6 + (t5.length ? " " + t5.map(function(n7) {
    return "'" + n7 + "'";
  }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function r(n6) {
  return !!n6 && !!n6[Q];
}
function t(n6) {
  var r7;
  return !!n6 && (function(n7) {
    if (!n7 || "object" != typeof n7)
      return false;
    var r8 = Object.getPrototypeOf(n7);
    if (null === r8)
      return true;
    var t5 = Object.hasOwnProperty.call(r8, "constructor") && r8.constructor;
    return t5 === Object || "function" == typeof t5 && Function.toString.call(t5) === Z;
  }(n6) || Array.isArray(n6) || !!n6[L] || !!(null === (r7 = n6.constructor) || void 0 === r7 ? void 0 : r7[L]) || s2(n6) || v(n6));
}
function i(n6, r7, t5) {
  void 0 === t5 && (t5 = false), 0 === o(n6) ? (t5 ? Object.keys : nn)(n6).forEach(function(e6) {
    t5 && "symbol" == typeof e6 || r7(e6, n6[e6], n6);
  }) : n6.forEach(function(t6, e6) {
    return r7(e6, t6, n6);
  });
}
function o(n6) {
  var r7 = n6[Q];
  return r7 ? r7.i > 3 ? r7.i - 4 : r7.i : Array.isArray(n6) ? 1 : s2(n6) ? 2 : v(n6) ? 3 : 0;
}
function u(n6, r7) {
  return 2 === o(n6) ? n6.has(r7) : Object.prototype.hasOwnProperty.call(n6, r7);
}
function a(n6, r7) {
  return 2 === o(n6) ? n6.get(r7) : n6[r7];
}
function f(n6, r7, t5) {
  var e6 = o(n6);
  2 === e6 ? n6.set(r7, t5) : 3 === e6 ? n6.add(t5) : n6[r7] = t5;
}
function c(n6, r7) {
  return n6 === r7 ? 0 !== n6 || 1 / n6 == 1 / r7 : n6 != n6 && r7 != r7;
}
function s2(n6) {
  return X && n6 instanceof Map;
}
function v(n6) {
  return q && n6 instanceof Set;
}
function p(n6) {
  return n6.o || n6.t;
}
function l(n6) {
  if (Array.isArray(n6))
    return Array.prototype.slice.call(n6);
  var r7 = rn(n6);
  delete r7[Q];
  for (var t5 = nn(r7), e6 = 0; e6 < t5.length; e6++) {
    var i6 = t5[e6], o5 = r7[i6];
    false === o5.writable && (o5.writable = true, o5.configurable = true), (o5.get || o5.set) && (r7[i6] = { configurable: true, writable: true, enumerable: o5.enumerable, value: n6[i6] });
  }
  return Object.create(Object.getPrototypeOf(n6), r7);
}
function d(n6, e6) {
  return void 0 === e6 && (e6 = false), y(n6) || r(n6) || !t(n6) || (o(n6) > 1 && (n6.set = n6.add = n6.clear = n6.delete = h), Object.freeze(n6), e6 && i(n6, function(n7, r7) {
    return d(r7, true);
  }, true)), n6;
}
function h() {
  n(2);
}
function y(n6) {
  return null == n6 || "object" != typeof n6 || Object.isFrozen(n6);
}
function b(r7) {
  var t5 = tn[r7];
  return t5 || n(18, r7), t5;
}
function _() {
  return U || n(0), U;
}
function j(n6, r7) {
  r7 && (b("Patches"), n6.u = [], n6.s = [], n6.v = r7);
}
function g(n6) {
  O(n6), n6.p.forEach(S), n6.p = null;
}
function O(n6) {
  n6 === U && (U = n6.l);
}
function w(n6) {
  return U = { p: [], l: U, h: n6, m: true, _: 0 };
}
function S(n6) {
  var r7 = n6[Q];
  0 === r7.i || 1 === r7.i ? r7.j() : r7.g = true;
}
function P(r7, e6) {
  e6._ = e6.p.length;
  var i6 = e6.p[0], o5 = void 0 !== r7 && r7 !== i6;
  return e6.h.O || b("ES5").S(e6, r7, o5), o5 ? (i6[Q].P && (g(e6), n(4)), t(r7) && (r7 = M(e6, r7), e6.l || x(e6, r7)), e6.u && b("Patches").M(i6[Q].t, r7, e6.u, e6.s)) : r7 = M(e6, i6, []), g(e6), e6.u && e6.v(e6.u, e6.s), r7 !== H ? r7 : void 0;
}
function M(n6, r7, t5) {
  if (y(r7))
    return r7;
  var e6 = r7[Q];
  if (!e6)
    return i(r7, function(i6, o6) {
      return A(n6, e6, r7, i6, o6, t5);
    }, true), r7;
  if (e6.A !== n6)
    return r7;
  if (!e6.P)
    return x(n6, e6.t, true), e6.t;
  if (!e6.I) {
    e6.I = true, e6.A._--;
    var o5 = 4 === e6.i || 5 === e6.i ? e6.o = l(e6.k) : e6.o, u4 = o5, a3 = false;
    3 === e6.i && (u4 = new Set(o5), o5.clear(), a3 = true), i(u4, function(r8, i6) {
      return A(n6, e6, o5, r8, i6, t5, a3);
    }), x(n6, o5, false), t5 && n6.u && b("Patches").N(e6, t5, n6.u, n6.s);
  }
  return e6.o;
}
function A(e6, i6, o5, a3, c5, s4, v6) {
  if (c5 === o5 && n(5), r(c5)) {
    var p5 = M(e6, c5, s4 && i6 && 3 !== i6.i && !u(i6.R, a3) ? s4.concat(a3) : void 0);
    if (f(o5, a3, p5), !r(p5))
      return;
    e6.m = false;
  } else
    v6 && o5.add(c5);
  if (t(c5) && !y(c5)) {
    if (!e6.h.D && e6._ < 1)
      return;
    M(e6, c5), i6 && i6.A.l || x(e6, c5);
  }
}
function x(n6, r7, t5) {
  void 0 === t5 && (t5 = false), !n6.l && n6.h.D && n6.m && d(r7, t5);
}
function z2(n6, r7) {
  var t5 = n6[Q];
  return (t5 ? p(t5) : n6)[r7];
}
function I(n6, r7) {
  if (r7 in n6)
    for (var t5 = Object.getPrototypeOf(n6); t5; ) {
      var e6 = Object.getOwnPropertyDescriptor(t5, r7);
      if (e6)
        return e6;
      t5 = Object.getPrototypeOf(t5);
    }
}
function k(n6) {
  n6.P || (n6.P = true, n6.l && k(n6.l));
}
function E(n6) {
  n6.o || (n6.o = l(n6.t));
}
function N(n6, r7, t5) {
  var e6 = s2(r7) ? b("MapSet").F(r7, t5) : v(r7) ? b("MapSet").T(r7, t5) : n6.O ? function(n7, r8) {
    var t6 = Array.isArray(n7), e7 = { i: t6 ? 1 : 0, A: r8 ? r8.A : _(), P: false, I: false, R: {}, l: r8, t: n7, k: null, o: null, j: null, C: false }, i6 = e7, o5 = en;
    t6 && (i6 = [e7], o5 = on);
    var u4 = Proxy.revocable(i6, o5), a3 = u4.revoke, f6 = u4.proxy;
    return e7.k = f6, e7.j = a3, f6;
  }(r7, t5) : b("ES5").J(r7, t5);
  return (t5 ? t5.A : _()).p.push(e6), e6;
}
function R(e6) {
  return r(e6) || n(22, e6), function n6(r7) {
    if (!t(r7))
      return r7;
    var e7, u4 = r7[Q], c5 = o(r7);
    if (u4) {
      if (!u4.P && (u4.i < 4 || !b("ES5").K(u4)))
        return u4.t;
      u4.I = true, e7 = D(r7, c5), u4.I = false;
    } else
      e7 = D(r7, c5);
    return i(e7, function(r8, t5) {
      u4 && a(u4.t, r8) === t5 || f(e7, r8, n6(t5));
    }), 3 === c5 ? new Set(e7) : e7;
  }(e6);
}
function D(n6, r7) {
  switch (r7) {
    case 2:
      return new Map(n6);
    case 3:
      return Array.from(n6);
  }
  return l(n6);
}
var G;
var U;
var W = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x");
var X = "undefined" != typeof Map;
var q = "undefined" != typeof Set;
var B = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect;
var H = W ? Symbol.for("immer-nothing") : ((G = {})["immer-nothing"] = true, G);
var L = W ? Symbol.for("immer-draftable") : "__$immer_draftable";
var Q = W ? Symbol.for("immer-state") : "__$immer_state";
var Y = { 0: "Illegal state", 1: "Immer drafts cannot have computed properties", 2: "This object has been frozen and should not be mutated", 3: function(n6) {
  return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + n6;
}, 4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.", 5: "Immer forbids circular references", 6: "The first or second argument to `produce` must be a function", 7: "The third argument to `produce` must be a function or undefined", 8: "First argument to `createDraft` must be a plain object, an array, or an immerable object", 9: "First argument to `finishDraft` must be a draft returned by `createDraft`", 10: "The given draft is already finalized", 11: "Object.defineProperty() cannot be used on an Immer draft", 12: "Object.setPrototypeOf() cannot be used on an Immer draft", 13: "Immer only supports deleting array indices", 14: "Immer only supports setting array indices and the 'length' property", 15: function(n6) {
  return "Cannot apply patch, path doesn't resolve: " + n6;
}, 16: 'Sets cannot have "replace" patches.', 17: function(n6) {
  return "Unsupported patch operation: " + n6;
}, 18: function(n6) {
  return "The plugin for '" + n6 + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + n6 + "()` when initializing your application.";
}, 20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available", 21: function(n6) {
  return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + n6 + "'";
}, 22: function(n6) {
  return "'current' expects a draft, got: " + n6;
}, 23: function(n6) {
  return "'original' expects a draft, got: " + n6;
}, 24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed" };
var Z = "" + Object.prototype.constructor;
var nn = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(n6) {
  return Object.getOwnPropertyNames(n6).concat(Object.getOwnPropertySymbols(n6));
} : Object.getOwnPropertyNames;
var rn = Object.getOwnPropertyDescriptors || function(n6) {
  var r7 = {};
  return nn(n6).forEach(function(t5) {
    r7[t5] = Object.getOwnPropertyDescriptor(n6, t5);
  }), r7;
};
var tn = {};
var en = { get: function(n6, r7) {
  if (r7 === Q)
    return n6;
  var e6 = p(n6);
  if (!u(e6, r7))
    return function(n7, r8, t5) {
      var e7, i7 = I(r8, t5);
      return i7 ? "value" in i7 ? i7.value : null === (e7 = i7.get) || void 0 === e7 ? void 0 : e7.call(n7.k) : void 0;
    }(n6, e6, r7);
  var i6 = e6[r7];
  return n6.I || !t(i6) ? i6 : i6 === z2(n6.t, r7) ? (E(n6), n6.o[r7] = N(n6.A.h, i6, n6)) : i6;
}, has: function(n6, r7) {
  return r7 in p(n6);
}, ownKeys: function(n6) {
  return Reflect.ownKeys(p(n6));
}, set: function(n6, r7, t5) {
  var e6 = I(p(n6), r7);
  if (null == e6 ? void 0 : e6.set)
    return e6.set.call(n6.k, t5), true;
  if (!n6.P) {
    var i6 = z2(p(n6), r7), o5 = null == i6 ? void 0 : i6[Q];
    if (o5 && o5.t === t5)
      return n6.o[r7] = t5, n6.R[r7] = false, true;
    if (c(t5, i6) && (void 0 !== t5 || u(n6.t, r7)))
      return true;
    E(n6), k(n6);
  }
  return n6.o[r7] === t5 && (void 0 !== t5 || r7 in n6.o) || Number.isNaN(t5) && Number.isNaN(n6.o[r7]) || (n6.o[r7] = t5, n6.R[r7] = true), true;
}, deleteProperty: function(n6, r7) {
  return void 0 !== z2(n6.t, r7) || r7 in n6.t ? (n6.R[r7] = false, E(n6), k(n6)) : delete n6.R[r7], n6.o && delete n6.o[r7], true;
}, getOwnPropertyDescriptor: function(n6, r7) {
  var t5 = p(n6), e6 = Reflect.getOwnPropertyDescriptor(t5, r7);
  return e6 ? { writable: true, configurable: 1 !== n6.i || "length" !== r7, enumerable: e6.enumerable, value: t5[r7] } : e6;
}, defineProperty: function() {
  n(11);
}, getPrototypeOf: function(n6) {
  return Object.getPrototypeOf(n6.t);
}, setPrototypeOf: function() {
  n(12);
} };
var on = {};
i(en, function(n6, r7) {
  on[n6] = function() {
    return arguments[0] = arguments[0][0], r7.apply(this, arguments);
  };
}), on.deleteProperty = function(r7, t5) {
  return isNaN(parseInt(t5)) && n(13), on.set.call(this, r7, t5, void 0);
}, on.set = function(r7, t5, e6) {
  return "length" !== t5 && isNaN(parseInt(t5)) && n(14), en.set.call(this, r7[0], t5, e6, r7[0]);
};
var un = function() {
  function e6(r7) {
    var e7 = this;
    this.O = B, this.D = true, this.produce = function(r8, i7, o5) {
      if ("function" == typeof r8 && "function" != typeof i7) {
        var u4 = i7;
        i7 = r8;
        var a3 = e7;
        return function(n6) {
          var r9 = this;
          void 0 === n6 && (n6 = u4);
          for (var t5 = arguments.length, e8 = Array(t5 > 1 ? t5 - 1 : 0), o6 = 1; o6 < t5; o6++)
            e8[o6 - 1] = arguments[o6];
          return a3.produce(n6, function(n7) {
            var t6;
            return (t6 = i7).call.apply(t6, [r9, n7].concat(e8));
          });
        };
      }
      var f6;
      if ("function" != typeof i7 && n(6), void 0 !== o5 && "function" != typeof o5 && n(7), t(r8)) {
        var c5 = w(e7), s4 = N(e7, r8, void 0), v6 = true;
        try {
          f6 = i7(s4), v6 = false;
        } finally {
          v6 ? g(c5) : O(c5);
        }
        return "undefined" != typeof Promise && f6 instanceof Promise ? f6.then(function(n6) {
          return j(c5, o5), P(n6, c5);
        }, function(n6) {
          throw g(c5), n6;
        }) : (j(c5, o5), P(f6, c5));
      }
      if (!r8 || "object" != typeof r8) {
        if (void 0 === (f6 = i7(r8)) && (f6 = r8), f6 === H && (f6 = void 0), e7.D && d(f6, true), o5) {
          var p5 = [], l7 = [];
          b("Patches").M(r8, f6, p5, l7), o5(p5, l7);
        }
        return f6;
      }
      n(21, r8);
    }, this.produceWithPatches = function(n6, r8) {
      if ("function" == typeof n6)
        return function(r9) {
          for (var t6 = arguments.length, i8 = Array(t6 > 1 ? t6 - 1 : 0), o6 = 1; o6 < t6; o6++)
            i8[o6 - 1] = arguments[o6];
          return e7.produceWithPatches(r9, function(r10) {
            return n6.apply(void 0, [r10].concat(i8));
          });
        };
      var t5, i7, o5 = e7.produce(n6, r8, function(n7, r9) {
        t5 = n7, i7 = r9;
      });
      return "undefined" != typeof Promise && o5 instanceof Promise ? o5.then(function(n7) {
        return [n7, t5, i7];
      }) : [o5, t5, i7];
    }, "boolean" == typeof (null == r7 ? void 0 : r7.useProxies) && this.setUseProxies(r7.useProxies), "boolean" == typeof (null == r7 ? void 0 : r7.autoFreeze) && this.setAutoFreeze(r7.autoFreeze);
  }
  var i6 = e6.prototype;
  return i6.createDraft = function(e7) {
    t(e7) || n(8), r(e7) && (e7 = R(e7));
    var i7 = w(this), o5 = N(this, e7, void 0);
    return o5[Q].C = true, O(i7), o5;
  }, i6.finishDraft = function(r7, t5) {
    var e7 = r7 && r7[Q];
    e7 && e7.C || n(9), e7.I && n(10);
    var i7 = e7.A;
    return j(i7, t5), P(void 0, i7);
  }, i6.setAutoFreeze = function(n6) {
    this.D = n6;
  }, i6.setUseProxies = function(r7) {
    r7 && !B && n(20), this.O = r7;
  }, i6.applyPatches = function(n6, t5) {
    var e7;
    for (e7 = t5.length - 1; e7 >= 0; e7--) {
      var i7 = t5[e7];
      if (0 === i7.path.length && "replace" === i7.op) {
        n6 = i7.value;
        break;
      }
    }
    e7 > -1 && (t5 = t5.slice(e7 + 1));
    var o5 = b("Patches").$;
    return r(n6) ? o5(n6, t5) : this.produce(n6, function(n7) {
      return o5(n7, t5);
    });
  }, e6;
}();
var an = new un();
var fn = an.produce;
var cn = an.produceWithPatches.bind(an);
var sn = an.setAutoFreeze.bind(an);
var vn = an.setUseProxies.bind(an);
var pn = an.applyPatches.bind(an);
var ln = an.createDraft.bind(an);
var dn = an.finishDraft.bind(an);

// node_modules/slate/dist/index.es.js
function _defineProperty(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}
var DIRTY_PATHS = /* @__PURE__ */ new WeakMap();
var DIRTY_PATH_KEYS = /* @__PURE__ */ new WeakMap();
var FLUSHING = /* @__PURE__ */ new WeakMap();
var NORMALIZING = /* @__PURE__ */ new WeakMap();
var PATH_REFS = /* @__PURE__ */ new WeakMap();
var POINT_REFS = /* @__PURE__ */ new WeakMap();
var RANGE_REFS = /* @__PURE__ */ new WeakMap();
function ownKeys$9(object2, enumerableOnly) {
  var keys3 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$9(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6] != null ? arguments[i6] : {};
    if (i6 % 2) {
      ownKeys$9(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var createEditor = () => {
  var editor = {
    children: [],
    operations: [],
    selection: null,
    marks: null,
    isInline: () => false,
    isVoid: () => false,
    markableVoid: () => false,
    onChange: () => {
    },
    apply: (op) => {
      for (var ref of Editor.pathRefs(editor)) {
        PathRef.transform(ref, op);
      }
      for (var _ref of Editor.pointRefs(editor)) {
        PointRef.transform(_ref, op);
      }
      for (var _ref2 of Editor.rangeRefs(editor)) {
        RangeRef.transform(_ref2, op);
      }
      var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];
      var oldDirtyPathKeys = DIRTY_PATH_KEYS.get(editor) || /* @__PURE__ */ new Set();
      var dirtyPaths;
      var dirtyPathKeys;
      var add2 = (path4) => {
        if (path4) {
          var key = path4.join(",");
          if (!dirtyPathKeys.has(key)) {
            dirtyPathKeys.add(key);
            dirtyPaths.push(path4);
          }
        }
      };
      if (Path.operationCanTransformPath(op)) {
        dirtyPaths = [];
        dirtyPathKeys = /* @__PURE__ */ new Set();
        for (var path3 of oldDirtyPaths) {
          var newPath = Path.transform(path3, op);
          add2(newPath);
        }
      } else {
        dirtyPaths = oldDirtyPaths;
        dirtyPathKeys = oldDirtyPathKeys;
      }
      var newDirtyPaths = editor.getDirtyPaths(op);
      for (var _path of newDirtyPaths) {
        add2(_path);
      }
      DIRTY_PATHS.set(editor, dirtyPaths);
      DIRTY_PATH_KEYS.set(editor, dirtyPathKeys);
      Transforms.transform(editor, op);
      editor.operations.push(op);
      Editor.normalize(editor, {
        operation: op
      });
      if (op.type === "set_selection") {
        editor.marks = null;
      }
      if (!FLUSHING.get(editor)) {
        FLUSHING.set(editor, true);
        Promise.resolve().then(() => {
          FLUSHING.set(editor, false);
          editor.onChange({
            operation: op
          });
          editor.operations = [];
        });
      }
    },
    addMark: (key, value2) => {
      var {
        selection,
        markableVoid
      } = editor;
      if (selection) {
        var match3 = (node4, path3) => {
          if (!Text.isText(node4)) {
            return false;
          }
          var [parentNode2, parentPath] = Editor.parent(editor, path3);
          return !editor.isVoid(parentNode2) || editor.markableVoid(parentNode2);
        };
        var expandedSelection = Range.isExpanded(selection);
        var markAcceptingVoidSelected = false;
        if (!expandedSelection) {
          var [selectedNode, selectedPath] = Editor.node(editor, selection);
          if (selectedNode && match3(selectedNode, selectedPath)) {
            var [parentNode] = Editor.parent(editor, selectedPath);
            markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);
          }
        }
        if (expandedSelection || markAcceptingVoidSelected) {
          Transforms.setNodes(editor, {
            [key]: value2
          }, {
            match: match3,
            split: true,
            voids: true
          });
        } else {
          var marks = _objectSpread$9(_objectSpread$9({}, Editor.marks(editor) || {}), {}, {
            [key]: value2
          });
          editor.marks = marks;
          if (!FLUSHING.get(editor)) {
            editor.onChange();
          }
        }
      }
    },
    deleteBackward: (unit) => {
      var {
        selection
      } = editor;
      if (selection && Range.isCollapsed(selection)) {
        Transforms.delete(editor, {
          unit,
          reverse: true
        });
      }
    },
    deleteForward: (unit) => {
      var {
        selection
      } = editor;
      if (selection && Range.isCollapsed(selection)) {
        Transforms.delete(editor, {
          unit
        });
      }
    },
    deleteFragment: (direction) => {
      var {
        selection
      } = editor;
      if (selection && Range.isExpanded(selection)) {
        Transforms.delete(editor, {
          reverse: direction === "backward"
        });
      }
    },
    getFragment: () => {
      var {
        selection
      } = editor;
      if (selection) {
        return Node3.fragment(editor, selection);
      }
      return [];
    },
    insertBreak: () => {
      Transforms.splitNodes(editor, {
        always: true
      });
    },
    insertSoftBreak: () => {
      Transforms.splitNodes(editor, {
        always: true
      });
    },
    insertFragment: (fragment) => {
      Transforms.insertFragment(editor, fragment);
    },
    insertNode: (node4) => {
      Transforms.insertNodes(editor, node4);
    },
    insertText: (text7) => {
      var {
        selection,
        marks
      } = editor;
      if (selection) {
        if (marks) {
          var node4 = _objectSpread$9({
            text: text7
          }, marks);
          Transforms.insertNodes(editor, node4);
        } else {
          Transforms.insertText(editor, text7);
        }
        editor.marks = null;
      }
    },
    normalizeNode: (entry) => {
      var [node4, path3] = entry;
      if (Text.isText(node4)) {
        return;
      }
      if (Element2.isElement(node4) && node4.children.length === 0) {
        var child = {
          text: ""
        };
        Transforms.insertNodes(editor, child, {
          at: path3.concat(0),
          voids: true
        });
        return;
      }
      var shouldHaveInlines = Editor.isEditor(node4) ? false : Element2.isElement(node4) && (editor.isInline(node4) || node4.children.length === 0 || Text.isText(node4.children[0]) || editor.isInline(node4.children[0]));
      var n6 = 0;
      for (var i6 = 0; i6 < node4.children.length; i6++, n6++) {
        var currentNode = Node3.get(editor, path3);
        if (Text.isText(currentNode))
          continue;
        var _child = node4.children[i6];
        var prev2 = currentNode.children[n6 - 1];
        var isLast = i6 === node4.children.length - 1;
        var isInlineOrText = Text.isText(_child) || Element2.isElement(_child) && editor.isInline(_child);
        if (isInlineOrText !== shouldHaveInlines) {
          Transforms.removeNodes(editor, {
            at: path3.concat(n6),
            voids: true
          });
          n6--;
        } else if (Element2.isElement(_child)) {
          if (editor.isInline(_child)) {
            if (prev2 == null || !Text.isText(prev2)) {
              var newChild = {
                text: ""
              };
              Transforms.insertNodes(editor, newChild, {
                at: path3.concat(n6),
                voids: true
              });
              n6++;
            } else if (isLast) {
              var _newChild = {
                text: ""
              };
              Transforms.insertNodes(editor, _newChild, {
                at: path3.concat(n6 + 1),
                voids: true
              });
              n6++;
            }
          }
        } else {
          if (prev2 != null && Text.isText(prev2)) {
            if (Text.equals(_child, prev2, {
              loose: true
            })) {
              Transforms.mergeNodes(editor, {
                at: path3.concat(n6),
                voids: true
              });
              n6--;
            } else if (prev2.text === "") {
              Transforms.removeNodes(editor, {
                at: path3.concat(n6 - 1),
                voids: true
              });
              n6--;
            } else if (_child.text === "") {
              Transforms.removeNodes(editor, {
                at: path3.concat(n6),
                voids: true
              });
              n6--;
            }
          }
        }
      }
    },
    removeMark: (key) => {
      var {
        selection
      } = editor;
      if (selection) {
        var match3 = (node4, path3) => {
          if (!Text.isText(node4)) {
            return false;
          }
          var [parentNode2, parentPath] = Editor.parent(editor, path3);
          return !editor.isVoid(parentNode2) || editor.markableVoid(parentNode2);
        };
        var expandedSelection = Range.isExpanded(selection);
        var markAcceptingVoidSelected = false;
        if (!expandedSelection) {
          var [selectedNode, selectedPath] = Editor.node(editor, selection);
          if (selectedNode && match3(selectedNode, selectedPath)) {
            var [parentNode] = Editor.parent(editor, selectedPath);
            markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);
          }
        }
        if (expandedSelection || markAcceptingVoidSelected) {
          Transforms.unsetNodes(editor, key, {
            match: match3,
            split: true,
            voids: true
          });
        } else {
          var marks = _objectSpread$9({}, Editor.marks(editor) || {});
          delete marks[key];
          editor.marks = marks;
          if (!FLUSHING.get(editor)) {
            editor.onChange();
          }
        }
      }
    },
    /**
     * Get the "dirty" paths generated from an operation.
     */
    getDirtyPaths: (op) => {
      switch (op.type) {
        case "insert_text":
        case "remove_text":
        case "set_node": {
          var {
            path: path3
          } = op;
          return Path.levels(path3);
        }
        case "insert_node": {
          var {
            node: node4,
            path: _path2
          } = op;
          var levels2 = Path.levels(_path2);
          var descendants = Text.isText(node4) ? [] : Array.from(Node3.nodes(node4), (_ref3) => {
            var [, p6] = _ref3;
            return _path2.concat(p6);
          });
          return [...levels2, ...descendants];
        }
        case "merge_node": {
          var {
            path: _path3
          } = op;
          var ancestors = Path.ancestors(_path3);
          var previousPath = Path.previous(_path3);
          return [...ancestors, previousPath];
        }
        case "move_node": {
          var {
            path: _path4,
            newPath
          } = op;
          if (Path.equals(_path4, newPath)) {
            return [];
          }
          var oldAncestors = [];
          var newAncestors = [];
          for (var ancestor of Path.ancestors(_path4)) {
            var p5 = Path.transform(ancestor, op);
            oldAncestors.push(p5);
          }
          for (var _ancestor of Path.ancestors(newPath)) {
            var _p = Path.transform(_ancestor, op);
            newAncestors.push(_p);
          }
          var newParent = newAncestors[newAncestors.length - 1];
          var newIndex = newPath[newPath.length - 1];
          var resultPath = newParent.concat(newIndex);
          return [...oldAncestors, ...newAncestors, resultPath];
        }
        case "remove_node": {
          var {
            path: _path5
          } = op;
          var _ancestors = Path.ancestors(_path5);
          return [..._ancestors];
        }
        case "split_node": {
          var {
            path: _path6
          } = op;
          var _levels = Path.levels(_path6);
          var nextPath = Path.next(_path6);
          return [..._levels, nextPath];
        }
        default: {
          return [];
        }
      }
    },
    shouldNormalize: (_ref4) => {
      var {
        iteration,
        initialDirtyPathsLength
      } = _ref4;
      var maxIterations = initialDirtyPathsLength * 42;
      if (iteration > maxIterations) {
        throw new Error("Could not completely normalize the editor after ".concat(maxIterations, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state."));
      }
      return true;
    }
  };
  return editor;
};
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i6;
  for (i6 = 0; i6 < sourceKeys.length; i6++) {
    key = sourceKeys[i6];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i6;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i6 = 0; i6 < sourceSymbolKeys.length; i6++) {
      key = sourceSymbolKeys[i6];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
var getCharacterDistance = function getCharacterDistance2(str) {
  var isRTL = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var isLTR = !isRTL;
  var codepoints = isRTL ? codepointsIteratorRTL(str) : str;
  var left = CodepointType.None;
  var right = CodepointType.None;
  var distance = 0;
  var gb11 = null;
  var gb12Or13 = null;
  for (var char2 of codepoints) {
    var code3 = char2.codePointAt(0);
    if (!code3)
      break;
    var type2 = getCodepointType(char2, code3);
    [left, right] = isLTR ? [right, type2] : [type2, left];
    if (intersects(left, CodepointType.ZWJ) && intersects(right, CodepointType.ExtPict)) {
      if (isLTR) {
        gb11 = endsWithEmojiZWJ(str.substring(0, distance));
      } else {
        gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance));
      }
      if (!gb11)
        break;
    }
    if (intersects(left, CodepointType.RI) && intersects(right, CodepointType.RI)) {
      if (gb12Or13 !== null) {
        gb12Or13 = !gb12Or13;
      } else {
        if (isLTR) {
          gb12Or13 = true;
        } else {
          gb12Or13 = endsWithOddNumberOfRIs(str.substring(0, str.length - distance));
        }
      }
      if (!gb12Or13)
        break;
    }
    if (left !== CodepointType.None && right !== CodepointType.None && isBoundaryPair(left, right)) {
      break;
    }
    distance += char2.length;
  }
  return distance || 1;
};
var SPACE2 = /\s/;
var PUNCTUATION = /[\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
var CHAMELEON = /['\u2018\u2019]/;
var getWordDistance = function getWordDistance2(text7) {
  var isRTL = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var dist = 0;
  var started = false;
  while (text7.length > 0) {
    var charDist = getCharacterDistance(text7, isRTL);
    var [char2, remaining] = splitByCharacterDistance(text7, charDist, isRTL);
    if (isWordCharacter(char2, remaining, isRTL)) {
      started = true;
      dist += charDist;
    } else if (!started) {
      dist += charDist;
    } else {
      break;
    }
    text7 = remaining;
  }
  return dist;
};
var splitByCharacterDistance = (str, dist, isRTL) => {
  if (isRTL) {
    var at = str.length - dist;
    return [str.slice(at, str.length), str.slice(0, at)];
  }
  return [str.slice(0, dist), str.slice(dist)];
};
var isWordCharacter = function isWordCharacter2(char2, remaining) {
  var isRTL = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (SPACE2.test(char2)) {
    return false;
  }
  if (CHAMELEON.test(char2)) {
    var charDist = getCharacterDistance(remaining, isRTL);
    var [nextChar, nextRemaining] = splitByCharacterDistance(remaining, charDist, isRTL);
    if (isWordCharacter2(nextChar, nextRemaining, isRTL)) {
      return true;
    }
  }
  if (PUNCTUATION.test(char2)) {
    return false;
  }
  return true;
};
var codepointsIteratorRTL = function* codepointsIteratorRTL2(str) {
  var end = str.length - 1;
  for (var i6 = 0; i6 < str.length; i6++) {
    var char1 = str.charAt(end - i6);
    if (isLowSurrogate(char1.charCodeAt(0))) {
      var char2 = str.charAt(end - i6 - 1);
      if (isHighSurrogate(char2.charCodeAt(0))) {
        yield char2 + char1;
        i6++;
        continue;
      }
    }
    yield char1;
  }
};
var isHighSurrogate = (charCode) => {
  return charCode >= 55296 && charCode <= 56319;
};
var isLowSurrogate = (charCode) => {
  return charCode >= 56320 && charCode <= 57343;
};
var CodepointType;
(function(CodepointType2) {
  CodepointType2[CodepointType2["None"] = 0] = "None";
  CodepointType2[CodepointType2["Extend"] = 1] = "Extend";
  CodepointType2[CodepointType2["ZWJ"] = 2] = "ZWJ";
  CodepointType2[CodepointType2["RI"] = 4] = "RI";
  CodepointType2[CodepointType2["Prepend"] = 8] = "Prepend";
  CodepointType2[CodepointType2["SpacingMark"] = 16] = "SpacingMark";
  CodepointType2[CodepointType2["L"] = 32] = "L";
  CodepointType2[CodepointType2["V"] = 64] = "V";
  CodepointType2[CodepointType2["T"] = 128] = "T";
  CodepointType2[CodepointType2["LV"] = 256] = "LV";
  CodepointType2[CodepointType2["LVT"] = 512] = "LVT";
  CodepointType2[CodepointType2["ExtPict"] = 1024] = "ExtPict";
  CodepointType2[CodepointType2["Any"] = 2048] = "Any";
})(CodepointType || (CodepointType = {}));
var reExtend = /^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1AC0\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])$/;
var rePrepend = /^(?:[\u0600-\u0605\u06DD\u070F\u0890\u0891\u08E2\u0D4E]|\uD804[\uDCBD\uDCCD\uDDC2\uDDC3]|\uD806[\uDD3F\uDD41\uDE3A\uDE84-\uDE89]|\uD807\uDD46)$/;
var reSpacingMark = /^(?:[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0D02\u0D03\u0D3F\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D82\u0D83\u0DD0\u0DD1\u0DD8-\u0DDE\u0DF2\u0DF3\u0E33\u0EB3\u0F3E\u0F3F\u0F7F\u1031\u103B\u103C\u1056\u1057\u1084\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A6D-\u1A72\u1B04\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB1\uDCB2\uDCB9\uDCBB\uDCBC\uDCBE\uDCC1\uDDB0\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD31-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD66\uDD6D])$/;
var reL = /^[\u1100-\u115F\uA960-\uA97C]$/;
var reV = /^[\u1160-\u11A7\uD7B0-\uD7C6]$/;
var reT = /^[\u11A8-\u11FF\uD7CB-\uD7FB]$/;
var reLV = /^[\uAC00\uAC1C\uAC38\uAC54\uAC70\uAC8C\uACA8\uACC4\uACE0\uACFC\uAD18\uAD34\uAD50\uAD6C\uAD88\uADA4\uADC0\uADDC\uADF8\uAE14\uAE30\uAE4C\uAE68\uAE84\uAEA0\uAEBC\uAED8\uAEF4\uAF10\uAF2C\uAF48\uAF64\uAF80\uAF9C\uAFB8\uAFD4\uAFF0\uB00C\uB028\uB044\uB060\uB07C\uB098\uB0B4\uB0D0\uB0EC\uB108\uB124\uB140\uB15C\uB178\uB194\uB1B0\uB1CC\uB1E8\uB204\uB220\uB23C\uB258\uB274\uB290\uB2AC\uB2C8\uB2E4\uB300\uB31C\uB338\uB354\uB370\uB38C\uB3A8\uB3C4\uB3E0\uB3FC\uB418\uB434\uB450\uB46C\uB488\uB4A4\uB4C0\uB4DC\uB4F8\uB514\uB530\uB54C\uB568\uB584\uB5A0\uB5BC\uB5D8\uB5F4\uB610\uB62C\uB648\uB664\uB680\uB69C\uB6B8\uB6D4\uB6F0\uB70C\uB728\uB744\uB760\uB77C\uB798\uB7B4\uB7D0\uB7EC\uB808\uB824\uB840\uB85C\uB878\uB894\uB8B0\uB8CC\uB8E8\uB904\uB920\uB93C\uB958\uB974\uB990\uB9AC\uB9C8\uB9E4\uBA00\uBA1C\uBA38\uBA54\uBA70\uBA8C\uBAA8\uBAC4\uBAE0\uBAFC\uBB18\uBB34\uBB50\uBB6C\uBB88\uBBA4\uBBC0\uBBDC\uBBF8\uBC14\uBC30\uBC4C\uBC68\uBC84\uBCA0\uBCBC\uBCD8\uBCF4\uBD10\uBD2C\uBD48\uBD64\uBD80\uBD9C\uBDB8\uBDD4\uBDF0\uBE0C\uBE28\uBE44\uBE60\uBE7C\uBE98\uBEB4\uBED0\uBEEC\uBF08\uBF24\uBF40\uBF5C\uBF78\uBF94\uBFB0\uBFCC\uBFE8\uC004\uC020\uC03C\uC058\uC074\uC090\uC0AC\uC0C8\uC0E4\uC100\uC11C\uC138\uC154\uC170\uC18C\uC1A8\uC1C4\uC1E0\uC1FC\uC218\uC234\uC250\uC26C\uC288\uC2A4\uC2C0\uC2DC\uC2F8\uC314\uC330\uC34C\uC368\uC384\uC3A0\uC3BC\uC3D8\uC3F4\uC410\uC42C\uC448\uC464\uC480\uC49C\uC4B8\uC4D4\uC4F0\uC50C\uC528\uC544\uC560\uC57C\uC598\uC5B4\uC5D0\uC5EC\uC608\uC624\uC640\uC65C\uC678\uC694\uC6B0\uC6CC\uC6E8\uC704\uC720\uC73C\uC758\uC774\uC790\uC7AC\uC7C8\uC7E4\uC800\uC81C\uC838\uC854\uC870\uC88C\uC8A8\uC8C4\uC8E0\uC8FC\uC918\uC934\uC950\uC96C\uC988\uC9A4\uC9C0\uC9DC\uC9F8\uCA14\uCA30\uCA4C\uCA68\uCA84\uCAA0\uCABC\uCAD8\uCAF4\uCB10\uCB2C\uCB48\uCB64\uCB80\uCB9C\uCBB8\uCBD4\uCBF0\uCC0C\uCC28\uCC44\uCC60\uCC7C\uCC98\uCCB4\uCCD0\uCCEC\uCD08\uCD24\uCD40\uCD5C\uCD78\uCD94\uCDB0\uCDCC\uCDE8\uCE04\uCE20\uCE3C\uCE58\uCE74\uCE90\uCEAC\uCEC8\uCEE4\uCF00\uCF1C\uCF38\uCF54\uCF70\uCF8C\uCFA8\uCFC4\uCFE0\uCFFC\uD018\uD034\uD050\uD06C\uD088\uD0A4\uD0C0\uD0DC\uD0F8\uD114\uD130\uD14C\uD168\uD184\uD1A0\uD1BC\uD1D8\uD1F4\uD210\uD22C\uD248\uD264\uD280\uD29C\uD2B8\uD2D4\uD2F0\uD30C\uD328\uD344\uD360\uD37C\uD398\uD3B4\uD3D0\uD3EC\uD408\uD424\uD440\uD45C\uD478\uD494\uD4B0\uD4CC\uD4E8\uD504\uD520\uD53C\uD558\uD574\uD590\uD5AC\uD5C8\uD5E4\uD600\uD61C\uD638\uD654\uD670\uD68C\uD6A8\uD6C4\uD6E0\uD6FC\uD718\uD734\uD750\uD76C\uD788]$/;
var reLVT = /^[\uAC01-\uAC1B\uAC1D-\uAC37\uAC39-\uAC53\uAC55-\uAC6F\uAC71-\uAC8B\uAC8D-\uACA7\uACA9-\uACC3\uACC5-\uACDF\uACE1-\uACFB\uACFD-\uAD17\uAD19-\uAD33\uAD35-\uAD4F\uAD51-\uAD6B\uAD6D-\uAD87\uAD89-\uADA3\uADA5-\uADBF\uADC1-\uADDB\uADDD-\uADF7\uADF9-\uAE13\uAE15-\uAE2F\uAE31-\uAE4B\uAE4D-\uAE67\uAE69-\uAE83\uAE85-\uAE9F\uAEA1-\uAEBB\uAEBD-\uAED7\uAED9-\uAEF3\uAEF5-\uAF0F\uAF11-\uAF2B\uAF2D-\uAF47\uAF49-\uAF63\uAF65-\uAF7F\uAF81-\uAF9B\uAF9D-\uAFB7\uAFB9-\uAFD3\uAFD5-\uAFEF\uAFF1-\uB00B\uB00D-\uB027\uB029-\uB043\uB045-\uB05F\uB061-\uB07B\uB07D-\uB097\uB099-\uB0B3\uB0B5-\uB0CF\uB0D1-\uB0EB\uB0ED-\uB107\uB109-\uB123\uB125-\uB13F\uB141-\uB15B\uB15D-\uB177\uB179-\uB193\uB195-\uB1AF\uB1B1-\uB1CB\uB1CD-\uB1E7\uB1E9-\uB203\uB205-\uB21F\uB221-\uB23B\uB23D-\uB257\uB259-\uB273\uB275-\uB28F\uB291-\uB2AB\uB2AD-\uB2C7\uB2C9-\uB2E3\uB2E5-\uB2FF\uB301-\uB31B\uB31D-\uB337\uB339-\uB353\uB355-\uB36F\uB371-\uB38B\uB38D-\uB3A7\uB3A9-\uB3C3\uB3C5-\uB3DF\uB3E1-\uB3FB\uB3FD-\uB417\uB419-\uB433\uB435-\uB44F\uB451-\uB46B\uB46D-\uB487\uB489-\uB4A3\uB4A5-\uB4BF\uB4C1-\uB4DB\uB4DD-\uB4F7\uB4F9-\uB513\uB515-\uB52F\uB531-\uB54B\uB54D-\uB567\uB569-\uB583\uB585-\uB59F\uB5A1-\uB5BB\uB5BD-\uB5D7\uB5D9-\uB5F3\uB5F5-\uB60F\uB611-\uB62B\uB62D-\uB647\uB649-\uB663\uB665-\uB67F\uB681-\uB69B\uB69D-\uB6B7\uB6B9-\uB6D3\uB6D5-\uB6EF\uB6F1-\uB70B\uB70D-\uB727\uB729-\uB743\uB745-\uB75F\uB761-\uB77B\uB77D-\uB797\uB799-\uB7B3\uB7B5-\uB7CF\uB7D1-\uB7EB\uB7ED-\uB807\uB809-\uB823\uB825-\uB83F\uB841-\uB85B\uB85D-\uB877\uB879-\uB893\uB895-\uB8AF\uB8B1-\uB8CB\uB8CD-\uB8E7\uB8E9-\uB903\uB905-\uB91F\uB921-\uB93B\uB93D-\uB957\uB959-\uB973\uB975-\uB98F\uB991-\uB9AB\uB9AD-\uB9C7\uB9C9-\uB9E3\uB9E5-\uB9FF\uBA01-\uBA1B\uBA1D-\uBA37\uBA39-\uBA53\uBA55-\uBA6F\uBA71-\uBA8B\uBA8D-\uBAA7\uBAA9-\uBAC3\uBAC5-\uBADF\uBAE1-\uBAFB\uBAFD-\uBB17\uBB19-\uBB33\uBB35-\uBB4F\uBB51-\uBB6B\uBB6D-\uBB87\uBB89-\uBBA3\uBBA5-\uBBBF\uBBC1-\uBBDB\uBBDD-\uBBF7\uBBF9-\uBC13\uBC15-\uBC2F\uBC31-\uBC4B\uBC4D-\uBC67\uBC69-\uBC83\uBC85-\uBC9F\uBCA1-\uBCBB\uBCBD-\uBCD7\uBCD9-\uBCF3\uBCF5-\uBD0F\uBD11-\uBD2B\uBD2D-\uBD47\uBD49-\uBD63\uBD65-\uBD7F\uBD81-\uBD9B\uBD9D-\uBDB7\uBDB9-\uBDD3\uBDD5-\uBDEF\uBDF1-\uBE0B\uBE0D-\uBE27\uBE29-\uBE43\uBE45-\uBE5F\uBE61-\uBE7B\uBE7D-\uBE97\uBE99-\uBEB3\uBEB5-\uBECF\uBED1-\uBEEB\uBEED-\uBF07\uBF09-\uBF23\uBF25-\uBF3F\uBF41-\uBF5B\uBF5D-\uBF77\uBF79-\uBF93\uBF95-\uBFAF\uBFB1-\uBFCB\uBFCD-\uBFE7\uBFE9-\uC003\uC005-\uC01F\uC021-\uC03B\uC03D-\uC057\uC059-\uC073\uC075-\uC08F\uC091-\uC0AB\uC0AD-\uC0C7\uC0C9-\uC0E3\uC0E5-\uC0FF\uC101-\uC11B\uC11D-\uC137\uC139-\uC153\uC155-\uC16F\uC171-\uC18B\uC18D-\uC1A7\uC1A9-\uC1C3\uC1C5-\uC1DF\uC1E1-\uC1FB\uC1FD-\uC217\uC219-\uC233\uC235-\uC24F\uC251-\uC26B\uC26D-\uC287\uC289-\uC2A3\uC2A5-\uC2BF\uC2C1-\uC2DB\uC2DD-\uC2F7\uC2F9-\uC313\uC315-\uC32F\uC331-\uC34B\uC34D-\uC367\uC369-\uC383\uC385-\uC39F\uC3A1-\uC3BB\uC3BD-\uC3D7\uC3D9-\uC3F3\uC3F5-\uC40F\uC411-\uC42B\uC42D-\uC447\uC449-\uC463\uC465-\uC47F\uC481-\uC49B\uC49D-\uC4B7\uC4B9-\uC4D3\uC4D5-\uC4EF\uC4F1-\uC50B\uC50D-\uC527\uC529-\uC543\uC545-\uC55F\uC561-\uC57B\uC57D-\uC597\uC599-\uC5B3\uC5B5-\uC5CF\uC5D1-\uC5EB\uC5ED-\uC607\uC609-\uC623\uC625-\uC63F\uC641-\uC65B\uC65D-\uC677\uC679-\uC693\uC695-\uC6AF\uC6B1-\uC6CB\uC6CD-\uC6E7\uC6E9-\uC703\uC705-\uC71F\uC721-\uC73B\uC73D-\uC757\uC759-\uC773\uC775-\uC78F\uC791-\uC7AB\uC7AD-\uC7C7\uC7C9-\uC7E3\uC7E5-\uC7FF\uC801-\uC81B\uC81D-\uC837\uC839-\uC853\uC855-\uC86F\uC871-\uC88B\uC88D-\uC8A7\uC8A9-\uC8C3\uC8C5-\uC8DF\uC8E1-\uC8FB\uC8FD-\uC917\uC919-\uC933\uC935-\uC94F\uC951-\uC96B\uC96D-\uC987\uC989-\uC9A3\uC9A5-\uC9BF\uC9C1-\uC9DB\uC9DD-\uC9F7\uC9F9-\uCA13\uCA15-\uCA2F\uCA31-\uCA4B\uCA4D-\uCA67\uCA69-\uCA83\uCA85-\uCA9F\uCAA1-\uCABB\uCABD-\uCAD7\uCAD9-\uCAF3\uCAF5-\uCB0F\uCB11-\uCB2B\uCB2D-\uCB47\uCB49-\uCB63\uCB65-\uCB7F\uCB81-\uCB9B\uCB9D-\uCBB7\uCBB9-\uCBD3\uCBD5-\uCBEF\uCBF1-\uCC0B\uCC0D-\uCC27\uCC29-\uCC43\uCC45-\uCC5F\uCC61-\uCC7B\uCC7D-\uCC97\uCC99-\uCCB3\uCCB5-\uCCCF\uCCD1-\uCCEB\uCCED-\uCD07\uCD09-\uCD23\uCD25-\uCD3F\uCD41-\uCD5B\uCD5D-\uCD77\uCD79-\uCD93\uCD95-\uCDAF\uCDB1-\uCDCB\uCDCD-\uCDE7\uCDE9-\uCE03\uCE05-\uCE1F\uCE21-\uCE3B\uCE3D-\uCE57\uCE59-\uCE73\uCE75-\uCE8F\uCE91-\uCEAB\uCEAD-\uCEC7\uCEC9-\uCEE3\uCEE5-\uCEFF\uCF01-\uCF1B\uCF1D-\uCF37\uCF39-\uCF53\uCF55-\uCF6F\uCF71-\uCF8B\uCF8D-\uCFA7\uCFA9-\uCFC3\uCFC5-\uCFDF\uCFE1-\uCFFB\uCFFD-\uD017\uD019-\uD033\uD035-\uD04F\uD051-\uD06B\uD06D-\uD087\uD089-\uD0A3\uD0A5-\uD0BF\uD0C1-\uD0DB\uD0DD-\uD0F7\uD0F9-\uD113\uD115-\uD12F\uD131-\uD14B\uD14D-\uD167\uD169-\uD183\uD185-\uD19F\uD1A1-\uD1BB\uD1BD-\uD1D7\uD1D9-\uD1F3\uD1F5-\uD20F\uD211-\uD22B\uD22D-\uD247\uD249-\uD263\uD265-\uD27F\uD281-\uD29B\uD29D-\uD2B7\uD2B9-\uD2D3\uD2D5-\uD2EF\uD2F1-\uD30B\uD30D-\uD327\uD329-\uD343\uD345-\uD35F\uD361-\uD37B\uD37D-\uD397\uD399-\uD3B3\uD3B5-\uD3CF\uD3D1-\uD3EB\uD3ED-\uD407\uD409-\uD423\uD425-\uD43F\uD441-\uD45B\uD45D-\uD477\uD479-\uD493\uD495-\uD4AF\uD4B1-\uD4CB\uD4CD-\uD4E7\uD4E9-\uD503\uD505-\uD51F\uD521-\uD53B\uD53D-\uD557\uD559-\uD573\uD575-\uD58F\uD591-\uD5AB\uD5AD-\uD5C7\uD5C9-\uD5E3\uD5E5-\uD5FF\uD601-\uD61B\uD61D-\uD637\uD639-\uD653\uD655-\uD66F\uD671-\uD68B\uD68D-\uD6A7\uD6A9-\uD6C3\uD6C5-\uD6DF\uD6E1-\uD6FB\uD6FD-\uD717\uD719-\uD733\uD735-\uD74F\uD751-\uD76B\uD76D-\uD787\uD789-\uD7A3]$/;
var reExtPict = /^(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])$/;
var getCodepointType = (char2, code3) => {
  var type2 = CodepointType.Any;
  if (char2.search(reExtend) !== -1) {
    type2 |= CodepointType.Extend;
  }
  if (code3 === 8205) {
    type2 |= CodepointType.ZWJ;
  }
  if (code3 >= 127462 && code3 <= 127487) {
    type2 |= CodepointType.RI;
  }
  if (char2.search(rePrepend) !== -1) {
    type2 |= CodepointType.Prepend;
  }
  if (char2.search(reSpacingMark) !== -1) {
    type2 |= CodepointType.SpacingMark;
  }
  if (char2.search(reL) !== -1) {
    type2 |= CodepointType.L;
  }
  if (char2.search(reV) !== -1) {
    type2 |= CodepointType.V;
  }
  if (char2.search(reT) !== -1) {
    type2 |= CodepointType.T;
  }
  if (char2.search(reLV) !== -1) {
    type2 |= CodepointType.LV;
  }
  if (char2.search(reLVT) !== -1) {
    type2 |= CodepointType.LVT;
  }
  if (char2.search(reExtPict) !== -1) {
    type2 |= CodepointType.ExtPict;
  }
  return type2;
};
function intersects(x4, y4) {
  return (x4 & y4) !== 0;
}
var NonBoundaryPairs = [
  // GB6
  [CodepointType.L, CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT],
  // GB7
  [CodepointType.LV | CodepointType.V, CodepointType.V | CodepointType.T],
  // GB8
  [CodepointType.LVT | CodepointType.T, CodepointType.T],
  // GB9
  [CodepointType.Any, CodepointType.Extend | CodepointType.ZWJ],
  // GB9a
  [CodepointType.Any, CodepointType.SpacingMark],
  // GB9b
  [CodepointType.Prepend, CodepointType.Any],
  // GB11
  [CodepointType.ZWJ, CodepointType.ExtPict],
  // GB12 and GB13
  [CodepointType.RI, CodepointType.RI]
];
function isBoundaryPair(left, right) {
  return NonBoundaryPairs.findIndex((r7) => intersects(left, r7[0]) && intersects(right, r7[1])) === -1;
}
var endingEmojiZWJ = /(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1AC0\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])*\u200D$/;
var endsWithEmojiZWJ = (str) => {
  return str.search(endingEmojiZWJ) !== -1;
};
var endingRIs = /(?:\uD83C[\uDDE6-\uDDFF])+$/g;
var endsWithOddNumberOfRIs = (str) => {
  var match3 = str.match(endingRIs);
  if (match3 === null) {
    return false;
  } else {
    var numRIs = match3[0].length / 2;
    return numRIs % 2 === 1;
  }
};
var isElement = (value2) => {
  return isPlainObject(value2) && Node3.isNodeList(value2.children) && !Editor.isEditor(value2);
};
var Element2 = {
  /**
   * Check if a value implements the 'Ancestor' interface.
   */
  isAncestor(value2) {
    return isPlainObject(value2) && Node3.isNodeList(value2.children);
  },
  /**
   * Check if a value implements the `Element` interface.
   */
  isElement,
  /**
   * Check if a value is an array of `Element` objects.
   */
  isElementList(value2) {
    return Array.isArray(value2) && value2.every((val) => Element2.isElement(val));
  },
  /**
   * Check if a set of props is a partial of Element.
   */
  isElementProps(props) {
    return props.children !== void 0;
  },
  /**
   * Check if a value implements the `Element` interface and has elementKey with selected value.
   * Default it check to `type` key value
   */
  isElementType: function isElementType(value2, elementVal) {
    var elementKey = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return isElement(value2) && value2[elementKey] === elementVal;
  },
  /**
   * Check if an element matches set of properties.
   *
   * Note: this checks custom properties, and it does not ensure that any
   * children are equivalent.
   */
  matches(element4, props) {
    for (var key in props) {
      if (key === "children") {
        continue;
      }
      if (element4[key] !== props[key]) {
        return false;
      }
    }
    return true;
  }
};
var _excluded$4 = ["text"];
var _excluded2$3 = ["text"];
function ownKeys$8(object2, enumerableOnly) {
  var keys3 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$8(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6] != null ? arguments[i6] : {};
    if (i6 % 2) {
      ownKeys$8(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$8(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var IS_EDITOR_CACHE = /* @__PURE__ */ new WeakMap();
var Editor = {
  /**
   * Get the ancestor above a location in the document.
   */
  above(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      voids = false,
      mode = "lowest",
      at = editor.selection,
      match: match3
    } = options;
    if (!at) {
      return;
    }
    var path3 = Editor.path(editor, at);
    var reverse = mode === "lowest";
    for (var [n6, p5] of Editor.levels(editor, {
      at: path3,
      voids,
      match: match3,
      reverse
    })) {
      if (Text.isText(n6))
        continue;
      if (Range.isRange(at)) {
        if (Path.isAncestor(p5, at.anchor.path) && Path.isAncestor(p5, at.focus.path)) {
          return [n6, p5];
        }
      } else {
        if (!Path.equals(path3, p5)) {
          return [n6, p5];
        }
      }
    }
  },
  /**
   * Add a custom property to the leaf text nodes in the current selection.
   *
   * If the selection is currently collapsed, the marks will be added to the
   * `editor.marks` property instead, and applied when text is inserted next.
   */
  addMark(editor, key, value2) {
    editor.addMark(key, value2);
  },
  /**
   * Get the point after a location.
   */
  after(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var anchor = Editor.point(editor, at, {
      edge: "end"
    });
    var focus = Editor.end(editor, []);
    var range = {
      anchor,
      focus
    };
    var {
      distance = 1
    } = options;
    var d5 = 0;
    var target;
    for (var p5 of Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {
      at: range
    }))) {
      if (d5 > distance) {
        break;
      }
      if (d5 !== 0) {
        target = p5;
      }
      d5++;
    }
    return target;
  },
  /**
   * Get the point before a location.
   */
  before(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var anchor = Editor.start(editor, []);
    var focus = Editor.point(editor, at, {
      edge: "start"
    });
    var range = {
      anchor,
      focus
    };
    var {
      distance = 1
    } = options;
    var d5 = 0;
    var target;
    for (var p5 of Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {
      at: range,
      reverse: true
    }))) {
      if (d5 > distance) {
        break;
      }
      if (d5 !== 0) {
        target = p5;
      }
      d5++;
    }
    return target;
  },
  /**
   * Delete content in the editor backward from the current selection.
   */
  deleteBackward(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      unit = "character"
    } = options;
    editor.deleteBackward(unit);
  },
  /**
   * Delete content in the editor forward from the current selection.
   */
  deleteForward(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      unit = "character"
    } = options;
    editor.deleteForward(unit);
  },
  /**
   * Delete the content in the current selection.
   */
  deleteFragment(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      direction = "forward"
    } = options;
    editor.deleteFragment(direction);
  },
  /**
   * Get the start and end points of a location.
   */
  edges(editor, at) {
    return [Editor.start(editor, at), Editor.end(editor, at)];
  },
  /**
   * Get the end point of a location.
   */
  end(editor, at) {
    return Editor.point(editor, at, {
      edge: "end"
    });
  },
  /**
   * Get the first node at a location.
   */
  first(editor, at) {
    var path3 = Editor.path(editor, at, {
      edge: "start"
    });
    return Editor.node(editor, path3);
  },
  /**
   * Get the fragment at a location.
   */
  fragment(editor, at) {
    var range = Editor.range(editor, at);
    var fragment = Node3.fragment(editor, range);
    return fragment;
  },
  /**
   * Check if a node has block children.
   */
  hasBlocks(editor, element4) {
    return element4.children.some((n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6));
  },
  /**
   * Check if a node has inline and text children.
   */
  hasInlines(editor, element4) {
    return element4.children.some((n6) => Text.isText(n6) || Editor.isInline(editor, n6));
  },
  /**
   * Check if a node has text children.
   */
  hasTexts(editor, element4) {
    return element4.children.every((n6) => Text.isText(n6));
  },
  /**
   * Insert a block break at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertBreak(editor) {
    editor.insertBreak();
  },
  /**
   * Insert a soft break at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertSoftBreak(editor) {
    editor.insertSoftBreak();
  },
  /**
   * Insert a fragment at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertFragment(editor, fragment) {
    editor.insertFragment(fragment);
  },
  /**
   * Insert a node at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertNode(editor, node4) {
    editor.insertNode(node4);
  },
  /**
   * Insert text at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertText(editor, text7) {
    editor.insertText(text7);
  },
  /**
   * Check if a value is a block `Element` object.
   */
  isBlock(editor, value2) {
    return !editor.isInline(value2);
  },
  /**
   * Check if a value is an `Editor` object.
   */
  isEditor(value2) {
    var cachedIsEditor = IS_EDITOR_CACHE.get(value2);
    if (cachedIsEditor !== void 0) {
      return cachedIsEditor;
    }
    if (!isPlainObject(value2)) {
      return false;
    }
    var isEditor = typeof value2.addMark === "function" && typeof value2.apply === "function" && typeof value2.deleteBackward === "function" && typeof value2.deleteForward === "function" && typeof value2.deleteFragment === "function" && typeof value2.insertBreak === "function" && typeof value2.insertSoftBreak === "function" && typeof value2.insertFragment === "function" && typeof value2.insertNode === "function" && typeof value2.insertText === "function" && typeof value2.isInline === "function" && typeof value2.isVoid === "function" && typeof value2.normalizeNode === "function" && typeof value2.onChange === "function" && typeof value2.removeMark === "function" && typeof value2.getDirtyPaths === "function" && (value2.marks === null || isPlainObject(value2.marks)) && (value2.selection === null || Range.isRange(value2.selection)) && Node3.isNodeList(value2.children) && Operation.isOperationList(value2.operations);
    IS_EDITOR_CACHE.set(value2, isEditor);
    return isEditor;
  },
  /**
   * Check if a point is the end point of a location.
   */
  isEnd(editor, point3, at) {
    var end = Editor.end(editor, at);
    return Point.equals(point3, end);
  },
  /**
   * Check if a point is an edge of a location.
   */
  isEdge(editor, point3, at) {
    return Editor.isStart(editor, point3, at) || Editor.isEnd(editor, point3, at);
  },
  /**
   * Check if an element is empty, accounting for void nodes.
   */
  isEmpty(editor, element4) {
    var {
      children
    } = element4;
    var [first] = children;
    return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === "" && !editor.isVoid(element4);
  },
  /**
   * Check if a value is an inline `Element` object.
   */
  isInline(editor, value2) {
    return editor.isInline(value2);
  },
  /**
   * Check if the editor is currently normalizing after each operation.
   */
  isNormalizing(editor) {
    var isNormalizing = NORMALIZING.get(editor);
    return isNormalizing === void 0 ? true : isNormalizing;
  },
  /**
   * Check if a point is the start point of a location.
   */
  isStart(editor, point3, at) {
    if (point3.offset !== 0) {
      return false;
    }
    var start2 = Editor.start(editor, at);
    return Point.equals(point3, start2);
  },
  /**
   * Check if a value is a void `Element` object.
   */
  isVoid(editor, value2) {
    return editor.isVoid(value2);
  },
  /**
   * Get the last node at a location.
   */
  last(editor, at) {
    var path3 = Editor.path(editor, at, {
      edge: "end"
    });
    return Editor.node(editor, path3);
  },
  /**
   * Get the leaf text node at a location.
   */
  leaf(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var path3 = Editor.path(editor, at, options);
    var node4 = Node3.leaf(editor, path3);
    return [node4, path3];
  },
  /**
   * Iterate through all of the levels at a location.
   */
  *levels(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      at = editor.selection,
      reverse = false,
      voids = false
    } = options;
    var {
      match: match3
    } = options;
    if (match3 == null) {
      match3 = () => true;
    }
    if (!at) {
      return;
    }
    var levels2 = [];
    var path3 = Editor.path(editor, at);
    for (var [n6, p5] of Node3.levels(editor, path3)) {
      if (!match3(n6, p5)) {
        continue;
      }
      levels2.push([n6, p5]);
      if (!voids && Element2.isElement(n6) && Editor.isVoid(editor, n6)) {
        break;
      }
    }
    if (reverse) {
      levels2.reverse();
    }
    yield* levels2;
  },
  /**
   * Get the marks that would be added to text at the current selection.
   */
  marks(editor) {
    var {
      marks,
      selection
    } = editor;
    if (!selection) {
      return null;
    }
    if (marks) {
      return marks;
    }
    if (Range.isExpanded(selection)) {
      var [match3] = Editor.nodes(editor, {
        match: Text.isText
      });
      if (match3) {
        var [_node] = match3;
        var _rest = _objectWithoutProperties(_node, _excluded$4);
        return _rest;
      } else {
        return {};
      }
    }
    var {
      anchor
    } = selection;
    var {
      path: path3
    } = anchor;
    var [node4] = Editor.leaf(editor, path3);
    if (anchor.offset === 0) {
      var prev2 = Editor.previous(editor, {
        at: path3,
        match: Text.isText
      });
      var markedVoid = Editor.above(editor, {
        match: (n6) => Element2.isElement(n6) && Editor.isVoid(editor, n6) && editor.markableVoid(n6)
      });
      if (!markedVoid) {
        var block5 = Editor.above(editor, {
          match: (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6)
        });
        if (prev2 && block5) {
          var [prevNode, prevPath] = prev2;
          var [, blockPath] = block5;
          if (Path.isAncestor(blockPath, prevPath)) {
            node4 = prevNode;
          }
        }
      }
    }
    var rest = _objectWithoutProperties(node4, _excluded2$3);
    return rest;
  },
  /**
   * Get the matching node in the branch of the document after a location.
   */
  next(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      mode = "lowest",
      voids = false
    } = options;
    var {
      match: match3,
      at = editor.selection
    } = options;
    if (!at) {
      return;
    }
    var pointAfterLocation = Editor.after(editor, at, {
      voids
    });
    if (!pointAfterLocation)
      return;
    var [, to] = Editor.last(editor, []);
    var span = [pointAfterLocation.path, to];
    if (Path.isPath(at) && at.length === 0) {
      throw new Error("Cannot get the next node from the root node!");
    }
    if (match3 == null) {
      if (Path.isPath(at)) {
        var [parent] = Editor.parent(editor, at);
        match3 = (n6) => parent.children.includes(n6);
      } else {
        match3 = () => true;
      }
    }
    var [next2] = Editor.nodes(editor, {
      at: span,
      match: match3,
      mode,
      voids
    });
    return next2;
  },
  /**
   * Get the node at a location.
   */
  node(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var path3 = Editor.path(editor, at, options);
    var node4 = Node3.get(editor, path3);
    return [node4, path3];
  },
  /**
   * Iterate through all of the nodes in the Editor.
   */
  *nodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      at = editor.selection,
      mode = "all",
      universal = false,
      reverse = false,
      voids = false
    } = options;
    var {
      match: match3
    } = options;
    if (!match3) {
      match3 = () => true;
    }
    if (!at) {
      return;
    }
    var from4;
    var to;
    if (Span.isSpan(at)) {
      from4 = at[0];
      to = at[1];
    } else {
      var first = Editor.path(editor, at, {
        edge: "start"
      });
      var last2 = Editor.path(editor, at, {
        edge: "end"
      });
      from4 = reverse ? last2 : first;
      to = reverse ? first : last2;
    }
    var nodeEntries = Node3.nodes(editor, {
      reverse,
      from: from4,
      to,
      pass: (_ref) => {
        var [n6] = _ref;
        return voids ? false : Element2.isElement(n6) && Editor.isVoid(editor, n6);
      }
    });
    var matches = [];
    var hit;
    for (var [node4, path3] of nodeEntries) {
      var isLower = hit && Path.compare(path3, hit[1]) === 0;
      if (mode === "highest" && isLower) {
        continue;
      }
      if (!match3(node4, path3)) {
        if (universal && !isLower && Text.isText(node4)) {
          return;
        } else {
          continue;
        }
      }
      if (mode === "lowest" && isLower) {
        hit = [node4, path3];
        continue;
      }
      var emit = mode === "lowest" ? hit : [node4, path3];
      if (emit) {
        if (universal) {
          matches.push(emit);
        } else {
          yield emit;
        }
      }
      hit = [node4, path3];
    }
    if (mode === "lowest" && hit) {
      if (universal) {
        matches.push(hit);
      } else {
        yield hit;
      }
    }
    if (universal) {
      yield* matches;
    }
  },
  /**
   * Normalize any dirty objects in the editor.
   */
  normalize(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      force = false,
      operation
    } = options;
    var getDirtyPaths = (editor2) => {
      return DIRTY_PATHS.get(editor2) || [];
    };
    var getDirtyPathKeys = (editor2) => {
      return DIRTY_PATH_KEYS.get(editor2) || /* @__PURE__ */ new Set();
    };
    var popDirtyPath = (editor2) => {
      var path3 = getDirtyPaths(editor2).pop();
      var key = path3.join(",");
      getDirtyPathKeys(editor2).delete(key);
      return path3;
    };
    if (!Editor.isNormalizing(editor)) {
      return;
    }
    if (force) {
      var allPaths = Array.from(Node3.nodes(editor), (_ref2) => {
        var [, p5] = _ref2;
        return p5;
      });
      var allPathKeys = new Set(allPaths.map((p5) => p5.join(",")));
      DIRTY_PATHS.set(editor, allPaths);
      DIRTY_PATH_KEYS.set(editor, allPathKeys);
    }
    if (getDirtyPaths(editor).length === 0) {
      return;
    }
    Editor.withoutNormalizing(editor, () => {
      for (var dirtyPath of getDirtyPaths(editor)) {
        if (Node3.has(editor, dirtyPath)) {
          var entry = Editor.node(editor, dirtyPath);
          var [node4, _2] = entry;
          if (Element2.isElement(node4) && node4.children.length === 0) {
            editor.normalizeNode(entry, {
              operation
            });
          }
        }
      }
      var dirtyPaths = getDirtyPaths(editor);
      var initialDirtyPathsLength = dirtyPaths.length;
      var iteration = 0;
      while (dirtyPaths.length !== 0) {
        if (!editor.shouldNormalize({
          dirtyPaths,
          iteration,
          initialDirtyPathsLength,
          operation
        })) {
          return;
        }
        var _dirtyPath = popDirtyPath(editor);
        if (Node3.has(editor, _dirtyPath)) {
          var _entry = Editor.node(editor, _dirtyPath);
          editor.normalizeNode(_entry, {
            operation
          });
        }
        iteration++;
        dirtyPaths = getDirtyPaths(editor);
      }
    });
  },
  /**
   * Get the parent node of a location.
   */
  parent(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var path3 = Editor.path(editor, at, options);
    var parentPath = Path.parent(path3);
    var entry = Editor.node(editor, parentPath);
    return entry;
  },
  /**
   * Get the path of a location.
   */
  path(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      depth,
      edge
    } = options;
    if (Path.isPath(at)) {
      if (edge === "start") {
        var [, firstPath] = Node3.first(editor, at);
        at = firstPath;
      } else if (edge === "end") {
        var [, lastPath] = Node3.last(editor, at);
        at = lastPath;
      }
    }
    if (Range.isRange(at)) {
      if (edge === "start") {
        at = Range.start(at);
      } else if (edge === "end") {
        at = Range.end(at);
      } else {
        at = Path.common(at.anchor.path, at.focus.path);
      }
    }
    if (Point.isPoint(at)) {
      at = at.path;
    }
    if (depth != null) {
      at = at.slice(0, depth);
    }
    return at;
  },
  hasPath(editor, path3) {
    return Node3.has(editor, path3);
  },
  /**
   * Create a mutable ref for a `Path` object, which will stay in sync as new
   * operations are applied to the editor.
   */
  pathRef(editor, path3) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      affinity = "forward"
    } = options;
    var ref = {
      current: path3,
      affinity,
      unref() {
        var {
          current
        } = ref;
        var pathRefs = Editor.pathRefs(editor);
        pathRefs.delete(ref);
        ref.current = null;
        return current;
      }
    };
    var refs = Editor.pathRefs(editor);
    refs.add(ref);
    return ref;
  },
  /**
   * Get the set of currently tracked path refs of the editor.
   */
  pathRefs(editor) {
    var refs = PATH_REFS.get(editor);
    if (!refs) {
      refs = /* @__PURE__ */ new Set();
      PATH_REFS.set(editor, refs);
    }
    return refs;
  },
  /**
   * Get the start or end point of a location.
   */
  point(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      edge = "start"
    } = options;
    if (Path.isPath(at)) {
      var path3;
      if (edge === "end") {
        var [, lastPath] = Node3.last(editor, at);
        path3 = lastPath;
      } else {
        var [, firstPath] = Node3.first(editor, at);
        path3 = firstPath;
      }
      var node4 = Node3.get(editor, path3);
      if (!Text.isText(node4)) {
        throw new Error("Cannot get the ".concat(edge, " point in the node at path [").concat(at, "] because it has no ").concat(edge, " text node."));
      }
      return {
        path: path3,
        offset: edge === "end" ? node4.text.length : 0
      };
    }
    if (Range.isRange(at)) {
      var [start2, end] = Range.edges(at);
      return edge === "start" ? start2 : end;
    }
    return at;
  },
  /**
   * Create a mutable ref for a `Point` object, which will stay in sync as new
   * operations are applied to the editor.
   */
  pointRef(editor, point3) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      affinity = "forward"
    } = options;
    var ref = {
      current: point3,
      affinity,
      unref() {
        var {
          current
        } = ref;
        var pointRefs = Editor.pointRefs(editor);
        pointRefs.delete(ref);
        ref.current = null;
        return current;
      }
    };
    var refs = Editor.pointRefs(editor);
    refs.add(ref);
    return ref;
  },
  /**
   * Get the set of currently tracked point refs of the editor.
   */
  pointRefs(editor) {
    var refs = POINT_REFS.get(editor);
    if (!refs) {
      refs = /* @__PURE__ */ new Set();
      POINT_REFS.set(editor, refs);
    }
    return refs;
  },
  /**
   * Return all the positions in `at` range where a `Point` can be placed.
   *
   * By default, moves forward by individual offsets at a time, but
   * the `unit` option can be used to to move by character, word, line, or block.
   *
   * The `reverse` option can be used to change iteration direction.
   *
   * Note: By default void nodes are treated as a single point and iteration
   * will not happen inside their content unless you pass in true for the
   * `voids` option, then iteration will occur.
   */
  *positions(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      at = editor.selection,
      unit = "offset",
      reverse = false,
      voids = false
    } = options;
    if (!at) {
      return;
    }
    var range = Editor.range(editor, at);
    var [start2, end] = Range.edges(range);
    var first = reverse ? end : start2;
    var isNewBlock = false;
    var blockText = "";
    var distance = 0;
    var leafTextRemaining = 0;
    var leafTextOffset = 0;
    for (var [node4, path3] of Editor.nodes(editor, {
      at,
      reverse,
      voids
    })) {
      if (Element2.isElement(node4)) {
        if (!voids && editor.isVoid(node4)) {
          yield Editor.start(editor, path3);
          continue;
        }
        if (editor.isInline(node4))
          continue;
        if (Editor.hasInlines(editor, node4)) {
          var e6 = Path.isAncestor(path3, end.path) ? end : Editor.end(editor, path3);
          var s4 = Path.isAncestor(path3, start2.path) ? start2 : Editor.start(editor, path3);
          blockText = Editor.string(editor, {
            anchor: s4,
            focus: e6
          }, {
            voids
          });
          isNewBlock = true;
        }
      }
      if (Text.isText(node4)) {
        var isFirst = Path.equals(path3, first.path);
        if (isFirst) {
          leafTextRemaining = reverse ? first.offset : node4.text.length - first.offset;
          leafTextOffset = first.offset;
        } else {
          leafTextRemaining = node4.text.length;
          leafTextOffset = reverse ? leafTextRemaining : 0;
        }
        if (isFirst || isNewBlock || unit === "offset") {
          yield {
            path: path3,
            offset: leafTextOffset
          };
          isNewBlock = false;
        }
        while (true) {
          if (distance === 0) {
            if (blockText === "")
              break;
            distance = calcDistance(blockText, unit, reverse);
            blockText = splitByCharacterDistance(blockText, distance, reverse)[1];
          }
          leafTextOffset = reverse ? leafTextOffset - distance : leafTextOffset + distance;
          leafTextRemaining = leafTextRemaining - distance;
          if (leafTextRemaining < 0) {
            distance = -leafTextRemaining;
            break;
          }
          distance = 0;
          yield {
            path: path3,
            offset: leafTextOffset
          };
        }
      }
    }
    function calcDistance(text7, unit2, reverse2) {
      if (unit2 === "character") {
        return getCharacterDistance(text7, reverse2);
      } else if (unit2 === "word") {
        return getWordDistance(text7, reverse2);
      } else if (unit2 === "line" || unit2 === "block") {
        return text7.length;
      }
      return 1;
    }
  },
  /**
   * Get the matching node in the branch of the document before a location.
   */
  previous(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      mode = "lowest",
      voids = false
    } = options;
    var {
      match: match3,
      at = editor.selection
    } = options;
    if (!at) {
      return;
    }
    var pointBeforeLocation = Editor.before(editor, at, {
      voids
    });
    if (!pointBeforeLocation) {
      return;
    }
    var [, to] = Editor.first(editor, []);
    var span = [pointBeforeLocation.path, to];
    if (Path.isPath(at) && at.length === 0) {
      throw new Error("Cannot get the previous node from the root node!");
    }
    if (match3 == null) {
      if (Path.isPath(at)) {
        var [parent] = Editor.parent(editor, at);
        match3 = (n6) => parent.children.includes(n6);
      } else {
        match3 = () => true;
      }
    }
    var [previous3] = Editor.nodes(editor, {
      reverse: true,
      at: span,
      match: match3,
      mode,
      voids
    });
    return previous3;
  },
  /**
   * Get a range of a location.
   */
  range(editor, at, to) {
    if (Range.isRange(at) && !to) {
      return at;
    }
    var start2 = Editor.start(editor, at);
    var end = Editor.end(editor, to || at);
    return {
      anchor: start2,
      focus: end
    };
  },
  /**
   * Create a mutable ref for a `Range` object, which will stay in sync as new
   * operations are applied to the editor.
   */
  rangeRef(editor, range) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      affinity = "forward"
    } = options;
    var ref = {
      current: range,
      affinity,
      unref() {
        var {
          current
        } = ref;
        var rangeRefs = Editor.rangeRefs(editor);
        rangeRefs.delete(ref);
        ref.current = null;
        return current;
      }
    };
    var refs = Editor.rangeRefs(editor);
    refs.add(ref);
    return ref;
  },
  /**
   * Get the set of currently tracked range refs of the editor.
   */
  rangeRefs(editor) {
    var refs = RANGE_REFS.get(editor);
    if (!refs) {
      refs = /* @__PURE__ */ new Set();
      RANGE_REFS.set(editor, refs);
    }
    return refs;
  },
  /**
   * Remove a custom property from all of the leaf text nodes in the current
   * selection.
   *
   * If the selection is currently collapsed, the removal will be stored on
   * `editor.marks` and applied to the text inserted next.
   */
  removeMark(editor, key) {
    editor.removeMark(key);
  },
  /**
   * Manually set if the editor should currently be normalizing.
   *
   * Note: Using this incorrectly can leave the editor in an invalid state.
   *
   */
  setNormalizing(editor, isNormalizing) {
    NORMALIZING.set(editor, isNormalizing);
  },
  /**
   * Get the start point of a location.
   */
  start(editor, at) {
    return Editor.point(editor, at, {
      edge: "start"
    });
  },
  /**
   * Get the text string content of a location.
   *
   * Note: by default the text of void nodes is considered to be an empty
   * string, regardless of content, unless you pass in true for the voids option
   */
  string(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      voids = false
    } = options;
    var range = Editor.range(editor, at);
    var [start2, end] = Range.edges(range);
    var text7 = "";
    for (var [node4, path3] of Editor.nodes(editor, {
      at: range,
      match: Text.isText,
      voids
    })) {
      var t5 = node4.text;
      if (Path.equals(path3, end.path)) {
        t5 = t5.slice(0, end.offset);
      }
      if (Path.equals(path3, start2.path)) {
        t5 = t5.slice(start2.offset);
      }
      text7 += t5;
    }
    return text7;
  },
  /**
   * Convert a range into a non-hanging one.
   */
  unhangRange(editor, range) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      voids = false
    } = options;
    var [start2, end] = Range.edges(range);
    if (start2.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range) || Path.hasPrevious(end.path)) {
      return range;
    }
    var endBlock = Editor.above(editor, {
      at: end,
      match: (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6),
      voids
    });
    var blockPath = endBlock ? endBlock[1] : [];
    var first = Editor.start(editor, start2);
    var before = {
      anchor: first,
      focus: end
    };
    var skip = true;
    for (var [node4, path3] of Editor.nodes(editor, {
      at: before,
      match: Text.isText,
      reverse: true,
      voids
    })) {
      if (skip) {
        skip = false;
        continue;
      }
      if (node4.text !== "" || Path.isBefore(path3, blockPath)) {
        end = {
          path: path3,
          offset: node4.text.length
        };
        break;
      }
    }
    return {
      anchor: start2,
      focus: end
    };
  },
  /**
   * Match a void node in the current branch of the editor.
   */
  void(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return Editor.above(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {
      match: (n6) => Element2.isElement(n6) && Editor.isVoid(editor, n6)
    }));
  },
  /**
   * Call a function, deferring normalization until after it completes.
   */
  withoutNormalizing(editor, fn2) {
    var value2 = Editor.isNormalizing(editor);
    Editor.setNormalizing(editor, false);
    try {
      fn2();
    } finally {
      Editor.setNormalizing(editor, value2);
    }
    Editor.normalize(editor);
  }
};
var Span = {
  /**
   * Check if a value implements the `Span` interface.
   */
  isSpan(value2) {
    return Array.isArray(value2) && value2.length === 2 && value2.every(Path.isPath);
  }
};
var _excluded$3 = ["children"];
var _excluded2$2 = ["text"];
var IS_NODE_LIST_CACHE = /* @__PURE__ */ new WeakMap();
var Node3 = {
  /**
   * Get the node at a specific path, asserting that it's an ancestor node.
   */
  ancestor(root, path3) {
    var node4 = Node3.get(root, path3);
    if (Text.isText(node4)) {
      throw new Error("Cannot get the ancestor node at path [".concat(path3, "] because it refers to a text node instead: ").concat(Scrubber.stringify(node4)));
    }
    return node4;
  },
  /**
   * Return a generator of all the ancestor nodes above a specific path.
   *
   * By default the order is top-down, from highest to lowest ancestor in
   * the tree, but you can pass the `reverse: true` option to go bottom-up.
   */
  *ancestors(root, path3) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    for (var p5 of Path.ancestors(path3, options)) {
      var n6 = Node3.ancestor(root, p5);
      var entry = [n6, p5];
      yield entry;
    }
  },
  /**
   * Get the child of a node at a specific index.
   */
  child(root, index3) {
    if (Text.isText(root)) {
      throw new Error("Cannot get the child of a text node: ".concat(Scrubber.stringify(root)));
    }
    var c5 = root.children[index3];
    if (c5 == null) {
      throw new Error("Cannot get child at index `".concat(index3, "` in node: ").concat(Scrubber.stringify(root)));
    }
    return c5;
  },
  /**
   * Iterate over the children of a node at a specific path.
   */
  *children(root, path3) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      reverse = false
    } = options;
    var ancestor = Node3.ancestor(root, path3);
    var {
      children
    } = ancestor;
    var index3 = reverse ? children.length - 1 : 0;
    while (reverse ? index3 >= 0 : index3 < children.length) {
      var child = Node3.child(ancestor, index3);
      var childPath = path3.concat(index3);
      yield [child, childPath];
      index3 = reverse ? index3 - 1 : index3 + 1;
    }
  },
  /**
   * Get an entry for the common ancesetor node of two paths.
   */
  common(root, path3, another) {
    var p5 = Path.common(path3, another);
    var n6 = Node3.get(root, p5);
    return [n6, p5];
  },
  /**
   * Get the node at a specific path, asserting that it's a descendant node.
   */
  descendant(root, path3) {
    var node4 = Node3.get(root, path3);
    if (Editor.isEditor(node4)) {
      throw new Error("Cannot get the descendant node at path [".concat(path3, "] because it refers to the root editor node instead: ").concat(Scrubber.stringify(node4)));
    }
    return node4;
  },
  /**
   * Return a generator of all the descendant node entries inside a root node.
   */
  *descendants(root) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    for (var [node4, path3] of Node3.nodes(root, options)) {
      if (path3.length !== 0) {
        yield [node4, path3];
      }
    }
  },
  /**
   * Return a generator of all the element nodes inside a root node. Each iteration
   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the
   * root node is an element it will be included in the iteration as well.
   */
  *elements(root) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    for (var [node4, path3] of Node3.nodes(root, options)) {
      if (Element2.isElement(node4)) {
        yield [node4, path3];
      }
    }
  },
  /**
   * Extract props from a Node.
   */
  extractProps(node4) {
    if (Element2.isAncestor(node4)) {
      var properties = _objectWithoutProperties(node4, _excluded$3);
      return properties;
    } else {
      var properties = _objectWithoutProperties(node4, _excluded2$2);
      return properties;
    }
  },
  /**
   * Get the first node entry in a root node from a path.
   */
  first(root, path3) {
    var p5 = path3.slice();
    var n6 = Node3.get(root, p5);
    while (n6) {
      if (Text.isText(n6) || n6.children.length === 0) {
        break;
      } else {
        n6 = n6.children[0];
        p5.push(0);
      }
    }
    return [n6, p5];
  },
  /**
   * Get the sliced fragment represented by a range inside a root node.
   */
  fragment(root, range) {
    if (Text.isText(root)) {
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Scrubber.stringify(root)));
    }
    var newRoot = fn({
      children: root.children
    }, (r7) => {
      var [start2, end] = Range.edges(range);
      var nodeEntries = Node3.nodes(r7, {
        reverse: true,
        pass: (_ref) => {
          var [, path4] = _ref;
          return !Range.includes(range, path4);
        }
      });
      for (var [, path3] of nodeEntries) {
        if (!Range.includes(range, path3)) {
          var parent = Node3.parent(r7, path3);
          var index3 = path3[path3.length - 1];
          parent.children.splice(index3, 1);
        }
        if (Path.equals(path3, end.path)) {
          var leaf = Node3.leaf(r7, path3);
          leaf.text = leaf.text.slice(0, end.offset);
        }
        if (Path.equals(path3, start2.path)) {
          var _leaf = Node3.leaf(r7, path3);
          _leaf.text = _leaf.text.slice(start2.offset);
        }
      }
      if (Editor.isEditor(r7)) {
        r7.selection = null;
      }
    });
    return newRoot.children;
  },
  /**
   * Get the descendant node referred to by a specific path. If the path is an
   * empty array, it refers to the root node itself.
   */
  get(root, path3) {
    var node4 = root;
    for (var i6 = 0; i6 < path3.length; i6++) {
      var p5 = path3[i6];
      if (Text.isText(node4) || !node4.children[p5]) {
        throw new Error("Cannot find a descendant at path [".concat(path3, "] in node: ").concat(Scrubber.stringify(root)));
      }
      node4 = node4.children[p5];
    }
    return node4;
  },
  /**
   * Check if a descendant node exists at a specific path.
   */
  has(root, path3) {
    var node4 = root;
    for (var i6 = 0; i6 < path3.length; i6++) {
      var p5 = path3[i6];
      if (Text.isText(node4) || !node4.children[p5]) {
        return false;
      }
      node4 = node4.children[p5];
    }
    return true;
  },
  /**
   * Check if a value implements the `Node` interface.
   */
  isNode(value2) {
    return Text.isText(value2) || Element2.isElement(value2) || Editor.isEditor(value2);
  },
  /**
   * Check if a value is a list of `Node` objects.
   */
  isNodeList(value2) {
    if (!Array.isArray(value2)) {
      return false;
    }
    var cachedResult = IS_NODE_LIST_CACHE.get(value2);
    if (cachedResult !== void 0) {
      return cachedResult;
    }
    var isNodeList = value2.every((val) => Node3.isNode(val));
    IS_NODE_LIST_CACHE.set(value2, isNodeList);
    return isNodeList;
  },
  /**
   * Get the last node entry in a root node from a path.
   */
  last(root, path3) {
    var p5 = path3.slice();
    var n6 = Node3.get(root, p5);
    while (n6) {
      if (Text.isText(n6) || n6.children.length === 0) {
        break;
      } else {
        var i6 = n6.children.length - 1;
        n6 = n6.children[i6];
        p5.push(i6);
      }
    }
    return [n6, p5];
  },
  /**
   * Get the node at a specific path, ensuring it's a leaf text node.
   */
  leaf(root, path3) {
    var node4 = Node3.get(root, path3);
    if (!Text.isText(node4)) {
      throw new Error("Cannot get the leaf node at path [".concat(path3, "] because it refers to a non-leaf node: ").concat(Scrubber.stringify(node4)));
    }
    return node4;
  },
  /**
   * Return a generator of the in a branch of the tree, from a specific path.
   *
   * By default the order is top-down, from highest to lowest node in the tree,
   * but you can pass the `reverse: true` option to go bottom-up.
   */
  *levels(root, path3) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    for (var p5 of Path.levels(path3, options)) {
      var n6 = Node3.get(root, p5);
      yield [n6, p5];
    }
  },
  /**
   * Check if a node matches a set of props.
   */
  matches(node4, props) {
    return Element2.isElement(node4) && Element2.isElementProps(props) && Element2.matches(node4, props) || Text.isText(node4) && Text.isTextProps(props) && Text.matches(node4, props);
  },
  /**
   * Return a generator of all the node entries of a root node. Each entry is
   * returned as a `[Node, Path]` tuple, with the path referring to the node's
   * position inside the root node.
   */
  *nodes(root) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      pass,
      reverse = false
    } = options;
    var {
      from: from4 = [],
      to
    } = options;
    var visited = /* @__PURE__ */ new Set();
    var p5 = [];
    var n6 = root;
    while (true) {
      if (to && (reverse ? Path.isBefore(p5, to) : Path.isAfter(p5, to))) {
        break;
      }
      if (!visited.has(n6)) {
        yield [n6, p5];
      }
      if (!visited.has(n6) && !Text.isText(n6) && n6.children.length !== 0 && (pass == null || pass([n6, p5]) === false)) {
        visited.add(n6);
        var nextIndex = reverse ? n6.children.length - 1 : 0;
        if (Path.isAncestor(p5, from4)) {
          nextIndex = from4[p5.length];
        }
        p5 = p5.concat(nextIndex);
        n6 = Node3.get(root, p5);
        continue;
      }
      if (p5.length === 0) {
        break;
      }
      if (!reverse) {
        var newPath = Path.next(p5);
        if (Node3.has(root, newPath)) {
          p5 = newPath;
          n6 = Node3.get(root, p5);
          continue;
        }
      }
      if (reverse && p5[p5.length - 1] !== 0) {
        var _newPath = Path.previous(p5);
        p5 = _newPath;
        n6 = Node3.get(root, p5);
        continue;
      }
      p5 = Path.parent(p5);
      n6 = Node3.get(root, p5);
      visited.add(n6);
    }
  },
  /**
   * Get the parent of a node at a specific path.
   */
  parent(root, path3) {
    var parentPath = Path.parent(path3);
    var p5 = Node3.get(root, parentPath);
    if (Text.isText(p5)) {
      throw new Error("Cannot get the parent of path [".concat(path3, "] because it does not exist in the root."));
    }
    return p5;
  },
  /**
   * Get the concatenated text string of a node's content.
   *
   * Note that this will not include spaces or line breaks between block nodes.
   * It is not a user-facing string, but a string for performing offset-related
   * computations for a node.
   */
  string(node4) {
    if (Text.isText(node4)) {
      return node4.text;
    } else {
      return node4.children.map(Node3.string).join("");
    }
  },
  /**
   * Return a generator of all leaf text nodes in a root node.
   */
  *texts(root) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    for (var [node4, path3] of Node3.nodes(root, options)) {
      if (Text.isText(node4)) {
        yield [node4, path3];
      }
    }
  }
};
function ownKeys$7(object2, enumerableOnly) {
  var keys3 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$7(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6] != null ? arguments[i6] : {};
    if (i6 % 2) {
      ownKeys$7(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$7(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Operation = {
  /**
   * Check if a value is a `NodeOperation` object.
   */
  isNodeOperation(value2) {
    return Operation.isOperation(value2) && value2.type.endsWith("_node");
  },
  /**
   * Check if a value is an `Operation` object.
   */
  isOperation(value2) {
    if (!isPlainObject(value2)) {
      return false;
    }
    switch (value2.type) {
      case "insert_node":
        return Path.isPath(value2.path) && Node3.isNode(value2.node);
      case "insert_text":
        return typeof value2.offset === "number" && typeof value2.text === "string" && Path.isPath(value2.path);
      case "merge_node":
        return typeof value2.position === "number" && Path.isPath(value2.path) && isPlainObject(value2.properties);
      case "move_node":
        return Path.isPath(value2.path) && Path.isPath(value2.newPath);
      case "remove_node":
        return Path.isPath(value2.path) && Node3.isNode(value2.node);
      case "remove_text":
        return typeof value2.offset === "number" && typeof value2.text === "string" && Path.isPath(value2.path);
      case "set_node":
        return Path.isPath(value2.path) && isPlainObject(value2.properties) && isPlainObject(value2.newProperties);
      case "set_selection":
        return value2.properties === null && Range.isRange(value2.newProperties) || value2.newProperties === null && Range.isRange(value2.properties) || isPlainObject(value2.properties) && isPlainObject(value2.newProperties);
      case "split_node":
        return Path.isPath(value2.path) && typeof value2.position === "number" && isPlainObject(value2.properties);
      default:
        return false;
    }
  },
  /**
   * Check if a value is a list of `Operation` objects.
   */
  isOperationList(value2) {
    return Array.isArray(value2) && value2.every((val) => Operation.isOperation(val));
  },
  /**
   * Check if a value is a `SelectionOperation` object.
   */
  isSelectionOperation(value2) {
    return Operation.isOperation(value2) && value2.type.endsWith("_selection");
  },
  /**
   * Check if a value is a `TextOperation` object.
   */
  isTextOperation(value2) {
    return Operation.isOperation(value2) && value2.type.endsWith("_text");
  },
  /**
   * Invert an operation, returning a new operation that will exactly undo the
   * original when applied.
   */
  inverse(op) {
    switch (op.type) {
      case "insert_node": {
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          type: "remove_node"
        });
      }
      case "insert_text": {
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          type: "remove_text"
        });
      }
      case "merge_node": {
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          type: "split_node",
          path: Path.previous(op.path)
        });
      }
      case "move_node": {
        var {
          newPath,
          path: path3
        } = op;
        if (Path.equals(newPath, path3)) {
          return op;
        }
        if (Path.isSibling(path3, newPath)) {
          return _objectSpread$7(_objectSpread$7({}, op), {}, {
            path: newPath,
            newPath: path3
          });
        }
        var inversePath = Path.transform(path3, op);
        var inverseNewPath = Path.transform(Path.next(path3), op);
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          path: inversePath,
          newPath: inverseNewPath
        });
      }
      case "remove_node": {
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          type: "insert_node"
        });
      }
      case "remove_text": {
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          type: "insert_text"
        });
      }
      case "set_node": {
        var {
          properties,
          newProperties
        } = op;
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          properties: newProperties,
          newProperties: properties
        });
      }
      case "set_selection": {
        var {
          properties: _properties,
          newProperties: _newProperties
        } = op;
        if (_properties == null) {
          return _objectSpread$7(_objectSpread$7({}, op), {}, {
            properties: _newProperties,
            newProperties: null
          });
        } else if (_newProperties == null) {
          return _objectSpread$7(_objectSpread$7({}, op), {}, {
            properties: null,
            newProperties: _properties
          });
        } else {
          return _objectSpread$7(_objectSpread$7({}, op), {}, {
            properties: _newProperties,
            newProperties: _properties
          });
        }
      }
      case "split_node": {
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          type: "merge_node",
          path: Path.next(op.path)
        });
      }
    }
  }
};
var Path = {
  /**
   * Get a list of ancestor paths for a given path.
   *
   * The paths are sorted from shallowest to deepest ancestor. However, if the
   * `reverse: true` option is passed, they are reversed.
   */
  ancestors(path3) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      reverse = false
    } = options;
    var paths = Path.levels(path3, options);
    if (reverse) {
      paths = paths.slice(1);
    } else {
      paths = paths.slice(0, -1);
    }
    return paths;
  },
  /**
   * Get the common ancestor path of two paths.
   */
  common(path3, another) {
    var common = [];
    for (var i6 = 0; i6 < path3.length && i6 < another.length; i6++) {
      var av = path3[i6];
      var bv = another[i6];
      if (av !== bv) {
        break;
      }
      common.push(av);
    }
    return common;
  },
  /**
   * Compare a path to another, returning an integer indicating whether the path
   * was before, at, or after the other.
   *
   * Note: Two paths of unequal length can still receive a `0` result if one is
   * directly above or below the other. If you want exact matching, use
   * [[Path.equals]] instead.
   */
  compare(path3, another) {
    var min3 = Math.min(path3.length, another.length);
    for (var i6 = 0; i6 < min3; i6++) {
      if (path3[i6] < another[i6])
        return -1;
      if (path3[i6] > another[i6])
        return 1;
    }
    return 0;
  },
  /**
   * Check if a path ends after one of the indexes in another.
   */
  endsAfter(path3, another) {
    var i6 = path3.length - 1;
    var as = path3.slice(0, i6);
    var bs = another.slice(0, i6);
    var av = path3[i6];
    var bv = another[i6];
    return Path.equals(as, bs) && av > bv;
  },
  /**
   * Check if a path ends at one of the indexes in another.
   */
  endsAt(path3, another) {
    var i6 = path3.length;
    var as = path3.slice(0, i6);
    var bs = another.slice(0, i6);
    return Path.equals(as, bs);
  },
  /**
   * Check if a path ends before one of the indexes in another.
   */
  endsBefore(path3, another) {
    var i6 = path3.length - 1;
    var as = path3.slice(0, i6);
    var bs = another.slice(0, i6);
    var av = path3[i6];
    var bv = another[i6];
    return Path.equals(as, bs) && av < bv;
  },
  /**
   * Check if a path is exactly equal to another.
   */
  equals(path3, another) {
    return path3.length === another.length && path3.every((n6, i6) => n6 === another[i6]);
  },
  /**
   * Check if the path of previous sibling node exists
   */
  hasPrevious(path3) {
    return path3[path3.length - 1] > 0;
  },
  /**
   * Check if a path is after another.
   */
  isAfter(path3, another) {
    return Path.compare(path3, another) === 1;
  },
  /**
   * Check if a path is an ancestor of another.
   */
  isAncestor(path3, another) {
    return path3.length < another.length && Path.compare(path3, another) === 0;
  },
  /**
   * Check if a path is before another.
   */
  isBefore(path3, another) {
    return Path.compare(path3, another) === -1;
  },
  /**
   * Check if a path is a child of another.
   */
  isChild(path3, another) {
    return path3.length === another.length + 1 && Path.compare(path3, another) === 0;
  },
  /**
   * Check if a path is equal to or an ancestor of another.
   */
  isCommon(path3, another) {
    return path3.length <= another.length && Path.compare(path3, another) === 0;
  },
  /**
   * Check if a path is a descendant of another.
   */
  isDescendant(path3, another) {
    return path3.length > another.length && Path.compare(path3, another) === 0;
  },
  /**
   * Check if a path is the parent of another.
   */
  isParent(path3, another) {
    return path3.length + 1 === another.length && Path.compare(path3, another) === 0;
  },
  /**
   * Check is a value implements the `Path` interface.
   */
  isPath(value2) {
    return Array.isArray(value2) && (value2.length === 0 || typeof value2[0] === "number");
  },
  /**
   * Check if a path is a sibling of another.
   */
  isSibling(path3, another) {
    if (path3.length !== another.length) {
      return false;
    }
    var as = path3.slice(0, -1);
    var bs = another.slice(0, -1);
    var al = path3[path3.length - 1];
    var bl = another[another.length - 1];
    return al !== bl && Path.equals(as, bs);
  },
  /**
   * Get a list of paths at every level down to a path. Note: this is the same
   * as `Path.ancestors`, but including the path itself.
   *
   * The paths are sorted from shallowest to deepest. However, if the `reverse:
   * true` option is passed, they are reversed.
   */
  levels(path3) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      reverse = false
    } = options;
    var list3 = [];
    for (var i6 = 0; i6 <= path3.length; i6++) {
      list3.push(path3.slice(0, i6));
    }
    if (reverse) {
      list3.reverse();
    }
    return list3;
  },
  /**
   * Given a path, get the path to the next sibling node.
   */
  next(path3) {
    if (path3.length === 0) {
      throw new Error("Cannot get the next path of a root path [".concat(path3, "], because it has no next index."));
    }
    var last2 = path3[path3.length - 1];
    return path3.slice(0, -1).concat(last2 + 1);
  },
  /**
   * Returns whether this operation can affect paths or not. Used as an
   * optimization when updating dirty paths during normalization
   *
   * NOTE: This *must* be kept in sync with the implementation of 'transform'
   * below
   */
  operationCanTransformPath(operation) {
    switch (operation.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return true;
      default:
        return false;
    }
  },
  /**
   * Given a path, return a new path referring to the parent node above it.
   */
  parent(path3) {
    if (path3.length === 0) {
      throw new Error("Cannot get the parent path of the root path [".concat(path3, "]."));
    }
    return path3.slice(0, -1);
  },
  /**
   * Given a path, get the path to the previous sibling node.
   */
  previous(path3) {
    if (path3.length === 0) {
      throw new Error("Cannot get the previous path of a root path [".concat(path3, "], because it has no previous index."));
    }
    var last2 = path3[path3.length - 1];
    if (last2 <= 0) {
      throw new Error("Cannot get the previous path of a first child path [".concat(path3, "] because it would result in a negative index."));
    }
    return path3.slice(0, -1).concat(last2 - 1);
  },
  /**
   * Get a path relative to an ancestor.
   */
  relative(path3, ancestor) {
    if (!Path.isAncestor(ancestor, path3) && !Path.equals(path3, ancestor)) {
      throw new Error("Cannot get the relative path of [".concat(path3, "] inside ancestor [").concat(ancestor, "], because it is not above or equal to the path."));
    }
    return path3.slice(ancestor.length);
  },
  /**
   * Transform a path by an operation.
   */
  transform(path3, operation) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!path3)
      return null;
    var p5 = [...path3];
    var {
      affinity = "forward"
    } = options;
    if (path3.length === 0) {
      return p5;
    }
    switch (operation.type) {
      case "insert_node": {
        var {
          path: op
        } = operation;
        if (Path.equals(op, p5) || Path.endsBefore(op, p5) || Path.isAncestor(op, p5)) {
          p5[op.length - 1] += 1;
        }
        break;
      }
      case "remove_node": {
        var {
          path: _op
        } = operation;
        if (Path.equals(_op, p5) || Path.isAncestor(_op, p5)) {
          return null;
        } else if (Path.endsBefore(_op, p5)) {
          p5[_op.length - 1] -= 1;
        }
        break;
      }
      case "merge_node": {
        var {
          path: _op2,
          position: position3
        } = operation;
        if (Path.equals(_op2, p5) || Path.endsBefore(_op2, p5)) {
          p5[_op2.length - 1] -= 1;
        } else if (Path.isAncestor(_op2, p5)) {
          p5[_op2.length - 1] -= 1;
          p5[_op2.length] += position3;
        }
        break;
      }
      case "split_node": {
        var {
          path: _op3,
          position: _position
        } = operation;
        if (Path.equals(_op3, p5)) {
          if (affinity === "forward") {
            p5[p5.length - 1] += 1;
          } else if (affinity === "backward")
            ;
          else {
            return null;
          }
        } else if (Path.endsBefore(_op3, p5)) {
          p5[_op3.length - 1] += 1;
        } else if (Path.isAncestor(_op3, p5) && path3[_op3.length] >= _position) {
          p5[_op3.length - 1] += 1;
          p5[_op3.length] -= _position;
        }
        break;
      }
      case "move_node": {
        var {
          path: _op4,
          newPath: onp
        } = operation;
        if (Path.equals(_op4, onp)) {
          return p5;
        }
        if (Path.isAncestor(_op4, p5) || Path.equals(_op4, p5)) {
          var copy3 = onp.slice();
          if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {
            copy3[_op4.length - 1] -= 1;
          }
          return copy3.concat(p5.slice(_op4.length));
        } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p5) || Path.equals(onp, p5))) {
          if (Path.endsBefore(_op4, p5)) {
            p5[_op4.length - 1] -= 1;
          } else {
            p5[_op4.length - 1] += 1;
          }
        } else if (Path.endsBefore(onp, p5) || Path.equals(onp, p5) || Path.isAncestor(onp, p5)) {
          if (Path.endsBefore(_op4, p5)) {
            p5[_op4.length - 1] -= 1;
          }
          p5[onp.length - 1] += 1;
        } else if (Path.endsBefore(_op4, p5)) {
          if (Path.equals(onp, p5)) {
            p5[onp.length - 1] += 1;
          }
          p5[_op4.length - 1] -= 1;
        }
        break;
      }
    }
    return p5;
  }
};
var PathRef = {
  /**
   * Transform the path ref's current value by an operation.
   */
  transform(ref, op) {
    var {
      current,
      affinity
    } = ref;
    if (current == null) {
      return;
    }
    var path3 = Path.transform(current, op, {
      affinity
    });
    ref.current = path3;
    if (path3 == null) {
      ref.unref();
    }
  }
};
function ownKeys$6(object2, enumerableOnly) {
  var keys3 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$6(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6] != null ? arguments[i6] : {};
    if (i6 % 2) {
      ownKeys$6(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$6(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Point = {
  /**
   * Compare a point to another, returning an integer indicating whether the
   * point was before, at, or after the other.
   */
  compare(point3, another) {
    var result = Path.compare(point3.path, another.path);
    if (result === 0) {
      if (point3.offset < another.offset)
        return -1;
      if (point3.offset > another.offset)
        return 1;
      return 0;
    }
    return result;
  },
  /**
   * Check if a point is after another.
   */
  isAfter(point3, another) {
    return Point.compare(point3, another) === 1;
  },
  /**
   * Check if a point is before another.
   */
  isBefore(point3, another) {
    return Point.compare(point3, another) === -1;
  },
  /**
   * Check if a point is exactly equal to another.
   */
  equals(point3, another) {
    return point3.offset === another.offset && Path.equals(point3.path, another.path);
  },
  /**
   * Check if a value implements the `Point` interface.
   */
  isPoint(value2) {
    return isPlainObject(value2) && typeof value2.offset === "number" && Path.isPath(value2.path);
  },
  /**
   * Transform a point by an operation.
   */
  transform(point3, op) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return fn(point3, (p5) => {
      if (p5 === null) {
        return null;
      }
      var {
        affinity = "forward"
      } = options;
      var {
        path: path3,
        offset
      } = p5;
      switch (op.type) {
        case "insert_node":
        case "move_node": {
          p5.path = Path.transform(path3, op, options);
          break;
        }
        case "insert_text": {
          if (Path.equals(op.path, path3) && (op.offset < offset || op.offset === offset && affinity === "forward")) {
            p5.offset += op.text.length;
          }
          break;
        }
        case "merge_node": {
          if (Path.equals(op.path, path3)) {
            p5.offset += op.position;
          }
          p5.path = Path.transform(path3, op, options);
          break;
        }
        case "remove_text": {
          if (Path.equals(op.path, path3) && op.offset <= offset) {
            p5.offset -= Math.min(offset - op.offset, op.text.length);
          }
          break;
        }
        case "remove_node": {
          if (Path.equals(op.path, path3) || Path.isAncestor(op.path, path3)) {
            return null;
          }
          p5.path = Path.transform(path3, op, options);
          break;
        }
        case "split_node": {
          if (Path.equals(op.path, path3)) {
            if (op.position === offset && affinity == null) {
              return null;
            } else if (op.position < offset || op.position === offset && affinity === "forward") {
              p5.offset -= op.position;
              p5.path = Path.transform(path3, op, _objectSpread$6(_objectSpread$6({}, options), {}, {
                affinity: "forward"
              }));
            }
          } else {
            p5.path = Path.transform(path3, op, options);
          }
          break;
        }
      }
    });
  }
};
var PointRef = {
  /**
   * Transform the point ref's current value by an operation.
   */
  transform(ref, op) {
    var {
      current,
      affinity
    } = ref;
    if (current == null) {
      return;
    }
    var point3 = Point.transform(current, op, {
      affinity
    });
    ref.current = point3;
    if (point3 == null) {
      ref.unref();
    }
  }
};
var _excluded$2 = ["anchor", "focus"];
function ownKeys$5(object2, enumerableOnly) {
  var keys3 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$5(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6] != null ? arguments[i6] : {};
    if (i6 % 2) {
      ownKeys$5(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$5(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Range = {
  /**
   * Get the start and end points of a range, in the order in which they appear
   * in the document.
   */
  edges(range) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      reverse = false
    } = options;
    var {
      anchor,
      focus
    } = range;
    return Range.isBackward(range) === reverse ? [anchor, focus] : [focus, anchor];
  },
  /**
   * Get the end point of a range.
   */
  end(range) {
    var [, end] = Range.edges(range);
    return end;
  },
  /**
   * Check if a range is exactly equal to another.
   */
  equals(range, another) {
    return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);
  },
  /**
   * Check if a range includes a path, a point or part of another range.
   */
  includes(range, target) {
    if (Range.isRange(target)) {
      if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {
        return true;
      }
      var [rs, re] = Range.edges(range);
      var [ts, te] = Range.edges(target);
      return Point.isBefore(rs, ts) && Point.isAfter(re, te);
    }
    var [start2, end] = Range.edges(range);
    var isAfterStart = false;
    var isBeforeEnd = false;
    if (Point.isPoint(target)) {
      isAfterStart = Point.compare(target, start2) >= 0;
      isBeforeEnd = Point.compare(target, end) <= 0;
    } else {
      isAfterStart = Path.compare(target, start2.path) >= 0;
      isBeforeEnd = Path.compare(target, end.path) <= 0;
    }
    return isAfterStart && isBeforeEnd;
  },
  /**
   * Get the intersection of a range with another.
   */
  intersection(range, another) {
    var rest = _objectWithoutProperties(range, _excluded$2);
    var [s1, e1] = Range.edges(range);
    var [s22, e22] = Range.edges(another);
    var start2 = Point.isBefore(s1, s22) ? s22 : s1;
    var end = Point.isBefore(e1, e22) ? e1 : e22;
    if (Point.isBefore(end, start2)) {
      return null;
    } else {
      return _objectSpread$5({
        anchor: start2,
        focus: end
      }, rest);
    }
  },
  /**
   * Check if a range is backward, meaning that its anchor point appears in the
   * document _after_ its focus point.
   */
  isBackward(range) {
    var {
      anchor,
      focus
    } = range;
    return Point.isAfter(anchor, focus);
  },
  /**
   * Check if a range is collapsed, meaning that both its anchor and focus
   * points refer to the exact same position in the document.
   */
  isCollapsed(range) {
    var {
      anchor,
      focus
    } = range;
    return Point.equals(anchor, focus);
  },
  /**
   * Check if a range is expanded.
   *
   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.
   */
  isExpanded(range) {
    return !Range.isCollapsed(range);
  },
  /**
   * Check if a range is forward.
   *
   * This is the opposite of [[Range.isBackward]] and is provided for legibility.
   */
  isForward(range) {
    return !Range.isBackward(range);
  },
  /**
   * Check if a value implements the [[Range]] interface.
   */
  isRange(value2) {
    return isPlainObject(value2) && Point.isPoint(value2.anchor) && Point.isPoint(value2.focus);
  },
  /**
   * Iterate through all of the point entries in a range.
   */
  *points(range) {
    yield [range.anchor, "anchor"];
    yield [range.focus, "focus"];
  },
  /**
   * Get the start point of a range.
   */
  start(range) {
    var [start2] = Range.edges(range);
    return start2;
  },
  /**
   * Transform a range by an operation.
   */
  transform(range, op) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return fn(range, (r7) => {
      if (r7 === null) {
        return null;
      }
      var {
        affinity = "inward"
      } = options;
      var affinityAnchor;
      var affinityFocus;
      if (affinity === "inward") {
        var isCollapsed = Range.isCollapsed(r7);
        if (Range.isForward(r7)) {
          affinityAnchor = "forward";
          affinityFocus = isCollapsed ? affinityAnchor : "backward";
        } else {
          affinityAnchor = "backward";
          affinityFocus = isCollapsed ? affinityAnchor : "forward";
        }
      } else if (affinity === "outward") {
        if (Range.isForward(r7)) {
          affinityAnchor = "backward";
          affinityFocus = "forward";
        } else {
          affinityAnchor = "forward";
          affinityFocus = "backward";
        }
      } else {
        affinityAnchor = affinity;
        affinityFocus = affinity;
      }
      var anchor = Point.transform(r7.anchor, op, {
        affinity: affinityAnchor
      });
      var focus = Point.transform(r7.focus, op, {
        affinity: affinityFocus
      });
      if (!anchor || !focus) {
        return null;
      }
      r7.anchor = anchor;
      r7.focus = focus;
    });
  }
};
var RangeRef = {
  /**
   * Transform the range ref's current value by an operation.
   */
  transform(ref, op) {
    var {
      current,
      affinity
    } = ref;
    if (current == null) {
      return;
    }
    var path3 = Range.transform(current, op, {
      affinity
    });
    ref.current = path3;
    if (path3 == null) {
      ref.unref();
    }
  }
};
var _scrubber = void 0;
var Scrubber = {
  setScrubber(scrubber) {
    _scrubber = scrubber;
  },
  stringify(value2) {
    return JSON.stringify(value2, _scrubber);
  }
};
var isDeepEqual = (node4, another) => {
  for (var key in node4) {
    var a3 = node4[key];
    var b2 = another[key];
    if (isPlainObject(a3) && isPlainObject(b2)) {
      if (!isDeepEqual(a3, b2))
        return false;
    } else if (Array.isArray(a3) && Array.isArray(b2)) {
      if (a3.length !== b2.length)
        return false;
      for (var i6 = 0; i6 < a3.length; i6++) {
        if (a3[i6] !== b2[i6])
          return false;
      }
    } else if (a3 !== b2) {
      return false;
    }
  }
  for (var _key in another) {
    if (node4[_key] === void 0 && another[_key] !== void 0) {
      return false;
    }
  }
  return true;
};
var _excluded$1 = ["text"];
var _excluded2$1 = ["anchor", "focus"];
function ownKeys$4(object2, enumerableOnly) {
  var keys3 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$4(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6] != null ? arguments[i6] : {};
    if (i6 % 2) {
      ownKeys$4(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$4(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Text = {
  /**
   * Check if two text nodes are equal.
   *
   * When loose is set, the text is not compared. This is
   * used to check whether sibling text nodes can be merged.
   */
  equals(text7, another) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      loose = false
    } = options;
    function omitText(obj) {
      var rest = _objectWithoutProperties(obj, _excluded$1);
      return rest;
    }
    return isDeepEqual(loose ? omitText(text7) : text7, loose ? omitText(another) : another);
  },
  /**
   * Check if a value implements the `Text` interface.
   */
  isText(value2) {
    return isPlainObject(value2) && typeof value2.text === "string";
  },
  /**
   * Check if a value is a list of `Text` objects.
   */
  isTextList(value2) {
    return Array.isArray(value2) && value2.every((val) => Text.isText(val));
  },
  /**
   * Check if some props are a partial of Text.
   */
  isTextProps(props) {
    return props.text !== void 0;
  },
  /**
   * Check if an text matches set of properties.
   *
   * Note: this is for matching custom properties, and it does not ensure that
   * the `text` property are two nodes equal.
   */
  matches(text7, props) {
    for (var key in props) {
      if (key === "text") {
        continue;
      }
      if (!text7.hasOwnProperty(key) || text7[key] !== props[key]) {
        return false;
      }
    }
    return true;
  },
  /**
   * Get the leaves for a text node given decorations.
   */
  decorations(node4, decorations) {
    var leaves = [_objectSpread$4({}, node4)];
    for (var dec of decorations) {
      var rest = _objectWithoutProperties(dec, _excluded2$1);
      var [start2, end] = Range.edges(dec);
      var next2 = [];
      var leafEnd = 0;
      var decorationStart = start2.offset;
      var decorationEnd = end.offset;
      for (var leaf of leaves) {
        var {
          length: length4
        } = leaf.text;
        var leafStart = leafEnd;
        leafEnd += length4;
        if (decorationStart <= leafStart && leafEnd <= decorationEnd) {
          Object.assign(leaf, rest);
          next2.push(leaf);
          continue;
        }
        if (decorationStart !== decorationEnd && (decorationStart === leafEnd || decorationEnd === leafStart) || decorationStart > leafEnd || decorationEnd < leafStart || decorationEnd === leafStart && leafStart !== 0) {
          next2.push(leaf);
          continue;
        }
        var middle = leaf;
        var before = void 0;
        var after = void 0;
        if (decorationEnd < leafEnd) {
          var off = decorationEnd - leafStart;
          after = _objectSpread$4(_objectSpread$4({}, middle), {}, {
            text: middle.text.slice(off)
          });
          middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {
            text: middle.text.slice(0, off)
          });
        }
        if (decorationStart > leafStart) {
          var _off = decorationStart - leafStart;
          before = _objectSpread$4(_objectSpread$4({}, middle), {}, {
            text: middle.text.slice(0, _off)
          });
          middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {
            text: middle.text.slice(_off)
          });
        }
        Object.assign(middle, rest);
        if (before) {
          next2.push(before);
        }
        next2.push(middle);
        if (after) {
          next2.push(after);
        }
      }
      leaves = next2;
    }
    return leaves;
  }
};
function ownKeys$3(object2, enumerableOnly) {
  var keys3 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$3(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6] != null ? arguments[i6] : {};
    if (i6 % 2) {
      ownKeys$3(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var applyToDraft = (editor, selection, op) => {
  switch (op.type) {
    case "insert_node": {
      var {
        path: path3,
        node: node4
      } = op;
      var parent = Node3.parent(editor, path3);
      var index3 = path3[path3.length - 1];
      if (index3 > parent.children.length) {
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(path3, "] because the destination is past the end of the node."));
      }
      parent.children.splice(index3, 0, node4);
      if (selection) {
        for (var [point3, key] of Range.points(selection)) {
          selection[key] = Point.transform(point3, op);
        }
      }
      break;
    }
    case "insert_text": {
      var {
        path: _path,
        offset,
        text: text7
      } = op;
      if (text7.length === 0)
        break;
      var _node = Node3.leaf(editor, _path);
      var before = _node.text.slice(0, offset);
      var after = _node.text.slice(offset);
      _node.text = before + text7 + after;
      if (selection) {
        for (var [_point, _key] of Range.points(selection)) {
          selection[_key] = Point.transform(_point, op);
        }
      }
      break;
    }
    case "merge_node": {
      var {
        path: _path2
      } = op;
      var _node2 = Node3.get(editor, _path2);
      var prevPath = Path.previous(_path2);
      var prev2 = Node3.get(editor, prevPath);
      var _parent2 = Node3.parent(editor, _path2);
      var _index = _path2[_path2.length - 1];
      if (Text.isText(_node2) && Text.isText(prev2)) {
        prev2.text += _node2.text;
      } else if (!Text.isText(_node2) && !Text.isText(prev2)) {
        prev2.children.push(..._node2.children);
      } else {
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(_path2, "] to nodes of different interfaces: ").concat(Scrubber.stringify(_node2), " ").concat(Scrubber.stringify(prev2)));
      }
      _parent2.children.splice(_index, 1);
      if (selection) {
        for (var [_point2, _key2] of Range.points(selection)) {
          selection[_key2] = Point.transform(_point2, op);
        }
      }
      break;
    }
    case "move_node": {
      var {
        path: _path3,
        newPath
      } = op;
      if (Path.isAncestor(_path3, newPath)) {
        throw new Error("Cannot move a path [".concat(_path3, "] to new path [").concat(newPath, "] because the destination is inside itself."));
      }
      var _node3 = Node3.get(editor, _path3);
      var _parent22 = Node3.parent(editor, _path3);
      var _index2 = _path3[_path3.length - 1];
      _parent22.children.splice(_index2, 1);
      var truePath = Path.transform(_path3, op);
      var newParent = Node3.get(editor, Path.parent(truePath));
      var newIndex = truePath[truePath.length - 1];
      newParent.children.splice(newIndex, 0, _node3);
      if (selection) {
        for (var [_point3, _key3] of Range.points(selection)) {
          selection[_key3] = Point.transform(_point3, op);
        }
      }
      break;
    }
    case "remove_node": {
      var {
        path: _path4
      } = op;
      var _index3 = _path4[_path4.length - 1];
      var _parent3 = Node3.parent(editor, _path4);
      _parent3.children.splice(_index3, 1);
      if (selection) {
        for (var [_point4, _key4] of Range.points(selection)) {
          var result = Point.transform(_point4, op);
          if (selection != null && result != null) {
            selection[_key4] = result;
          } else {
            var _prev = void 0;
            var next2 = void 0;
            for (var [n6, p5] of Node3.texts(editor)) {
              if (Path.compare(p5, _path4) === -1) {
                _prev = [n6, p5];
              } else {
                next2 = [n6, p5];
                break;
              }
            }
            var preferNext = false;
            if (_prev && next2) {
              if (Path.equals(next2[1], _path4)) {
                preferNext = !Path.hasPrevious(next2[1]);
              } else {
                preferNext = Path.common(_prev[1], _path4).length < Path.common(next2[1], _path4).length;
              }
            }
            if (_prev && !preferNext) {
              _point4.path = _prev[1];
              _point4.offset = _prev[0].text.length;
            } else if (next2) {
              _point4.path = next2[1];
              _point4.offset = 0;
            } else {
              selection = null;
            }
          }
        }
      }
      break;
    }
    case "remove_text": {
      var {
        path: _path5,
        offset: _offset,
        text: _text
      } = op;
      if (_text.length === 0)
        break;
      var _node4 = Node3.leaf(editor, _path5);
      var _before = _node4.text.slice(0, _offset);
      var _after = _node4.text.slice(_offset + _text.length);
      _node4.text = _before + _after;
      if (selection) {
        for (var [_point5, _key5] of Range.points(selection)) {
          selection[_key5] = Point.transform(_point5, op);
        }
      }
      break;
    }
    case "set_node": {
      var {
        path: _path6,
        properties,
        newProperties
      } = op;
      if (_path6.length === 0) {
        throw new Error("Cannot set properties on the root node!");
      }
      var _node5 = Node3.get(editor, _path6);
      for (var _key6 in newProperties) {
        if (_key6 === "children" || _key6 === "text") {
          throw new Error('Cannot set the "'.concat(_key6, '" property of nodes!'));
        }
        var value2 = newProperties[_key6];
        if (value2 == null) {
          delete _node5[_key6];
        } else {
          _node5[_key6] = value2;
        }
      }
      for (var _key7 in properties) {
        if (!newProperties.hasOwnProperty(_key7)) {
          delete _node5[_key7];
        }
      }
      break;
    }
    case "set_selection": {
      var {
        newProperties: _newProperties
      } = op;
      if (_newProperties == null) {
        selection = _newProperties;
      } else {
        if (selection == null) {
          if (!Range.isRange(_newProperties)) {
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Scrubber.stringify(_newProperties), " when there is no current selection."));
          }
          selection = _objectSpread$3({}, _newProperties);
        }
        for (var _key8 in _newProperties) {
          var _value = _newProperties[_key8];
          if (_value == null) {
            if (_key8 === "anchor" || _key8 === "focus") {
              throw new Error('Cannot remove the "'.concat(_key8, '" selection property'));
            }
            delete selection[_key8];
          } else {
            selection[_key8] = _value;
          }
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: _path7,
        position: position3,
        properties: _properties
      } = op;
      if (_path7.length === 0) {
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(_path7, "] because the root node cannot be split."));
      }
      var _node6 = Node3.get(editor, _path7);
      var _parent4 = Node3.parent(editor, _path7);
      var _index4 = _path7[_path7.length - 1];
      var newNode;
      if (Text.isText(_node6)) {
        var _before2 = _node6.text.slice(0, position3);
        var _after2 = _node6.text.slice(position3);
        _node6.text = _before2;
        newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {
          text: _after2
        });
      } else {
        var _before3 = _node6.children.slice(0, position3);
        var _after3 = _node6.children.slice(position3);
        _node6.children = _before3;
        newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {
          children: _after3
        });
      }
      _parent4.children.splice(_index4 + 1, 0, newNode);
      if (selection) {
        for (var [_point6, _key9] of Range.points(selection)) {
          selection[_key9] = Point.transform(_point6, op);
        }
      }
      break;
    }
  }
  return selection;
};
var GeneralTransforms = {
  /**
   * Transform the editor by an operation.
   */
  transform(editor, op) {
    editor.children = ln(editor.children);
    var selection = editor.selection && ln(editor.selection);
    try {
      selection = applyToDraft(editor, selection, op);
    } finally {
      editor.children = dn(editor.children);
      if (selection) {
        editor.selection = r(selection) ? dn(selection) : selection;
      } else {
        editor.selection = null;
      }
    }
  }
};
var _excluded = ["text"];
var _excluded2 = ["children"];
function ownKeys$2(object2, enumerableOnly) {
  var keys3 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$2(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6] != null ? arguments[i6] : {};
    if (i6 % 2) {
      ownKeys$2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var NodeTransforms = {
  /**
   * Insert nodes at a specific location in the Editor.
   */
  insertNodes(editor, nodes) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        hanging = false,
        voids = false,
        mode = "lowest"
      } = options;
      var {
        at,
        match: match3,
        select
      } = options;
      if (Node3.isNode(nodes)) {
        nodes = [nodes];
      }
      if (nodes.length === 0) {
        return;
      }
      var [node4] = nodes;
      if (!at) {
        if (editor.selection) {
          at = editor.selection;
        } else if (editor.children.length > 0) {
          at = Editor.end(editor, []);
        } else {
          at = [0];
        }
        select = true;
      }
      if (select == null) {
        select = false;
      }
      if (Range.isRange(at)) {
        if (!hanging) {
          at = Editor.unhangRange(editor, at, {
            voids
          });
        }
        if (Range.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var [, end] = Range.edges(at);
          var pointRef = Editor.pointRef(editor, end);
          Transforms.delete(editor, {
            at
          });
          at = pointRef.unref();
        }
      }
      if (Point.isPoint(at)) {
        if (match3 == null) {
          if (Text.isText(node4)) {
            match3 = (n6) => Text.isText(n6);
          } else if (editor.isInline(node4)) {
            match3 = (n6) => Text.isText(n6) || Editor.isInline(editor, n6);
          } else {
            match3 = (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6);
          }
        }
        var [entry] = Editor.nodes(editor, {
          at: at.path,
          match: match3,
          mode,
          voids
        });
        if (entry) {
          var [, _matchPath] = entry;
          var pathRef = Editor.pathRef(editor, _matchPath);
          var isAtEnd = Editor.isEnd(editor, at, _matchPath);
          Transforms.splitNodes(editor, {
            at,
            match: match3,
            mode,
            voids
          });
          var path3 = pathRef.unref();
          at = isAtEnd ? Path.next(path3) : path3;
        } else {
          return;
        }
      }
      var parentPath = Path.parent(at);
      var index3 = at[at.length - 1];
      if (!voids && Editor.void(editor, {
        at: parentPath
      })) {
        return;
      }
      for (var _node of nodes) {
        var _path = parentPath.concat(index3);
        index3++;
        editor.apply({
          type: "insert_node",
          path: _path,
          node: _node
        });
        at = Path.next(at);
      }
      at = Path.previous(at);
      if (select) {
        var point3 = Editor.end(editor, at);
        if (point3) {
          Transforms.select(editor, point3);
        }
      }
    });
  },
  /**
   * Lift nodes at a specific location upwards in the document tree, splitting
   * their parent in two if necessary.
   */
  liftNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        at = editor.selection,
        mode = "lowest",
        voids = false
      } = options;
      var {
        match: match3
      } = options;
      if (match3 == null) {
        match3 = Path.isPath(at) ? matchPath(editor, at) : (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6);
      }
      if (!at) {
        return;
      }
      var matches = Editor.nodes(editor, {
        at,
        match: match3,
        mode,
        voids
      });
      var pathRefs = Array.from(matches, (_ref) => {
        var [, p5] = _ref;
        return Editor.pathRef(editor, p5);
      });
      for (var pathRef of pathRefs) {
        var path3 = pathRef.unref();
        if (path3.length < 2) {
          throw new Error("Cannot lift node at a path [".concat(path3, "] because it has a depth of less than `2`."));
        }
        var parentNodeEntry = Editor.node(editor, Path.parent(path3));
        var [parent, parentPath] = parentNodeEntry;
        var index3 = path3[path3.length - 1];
        var {
          length: length4
        } = parent.children;
        if (length4 === 1) {
          var toPath = Path.next(parentPath);
          Transforms.moveNodes(editor, {
            at: path3,
            to: toPath,
            voids
          });
          Transforms.removeNodes(editor, {
            at: parentPath,
            voids
          });
        } else if (index3 === 0) {
          Transforms.moveNodes(editor, {
            at: path3,
            to: parentPath,
            voids
          });
        } else if (index3 === length4 - 1) {
          var _toPath = Path.next(parentPath);
          Transforms.moveNodes(editor, {
            at: path3,
            to: _toPath,
            voids
          });
        } else {
          var splitPath = Path.next(path3);
          var _toPath2 = Path.next(parentPath);
          Transforms.splitNodes(editor, {
            at: splitPath,
            voids
          });
          Transforms.moveNodes(editor, {
            at: path3,
            to: _toPath2,
            voids
          });
        }
      }
    });
  },
  /**
   * Merge a node at a location with the previous node of the same depth,
   * removing any empty containing nodes after the merge if necessary.
   */
  mergeNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        match: match3,
        at = editor.selection
      } = options;
      var {
        hanging = false,
        voids = false,
        mode = "lowest"
      } = options;
      if (!at) {
        return;
      }
      if (match3 == null) {
        if (Path.isPath(at)) {
          var [parent] = Editor.parent(editor, at);
          match3 = (n6) => parent.children.includes(n6);
        } else {
          match3 = (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6);
        }
      }
      if (!hanging && Range.isRange(at)) {
        at = Editor.unhangRange(editor, at, {
          voids
        });
      }
      if (Range.isRange(at)) {
        if (Range.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var [, end] = Range.edges(at);
          var pointRef = Editor.pointRef(editor, end);
          Transforms.delete(editor, {
            at
          });
          at = pointRef.unref();
          if (options.at == null) {
            Transforms.select(editor, at);
          }
        }
      }
      var [current] = Editor.nodes(editor, {
        at,
        match: match3,
        voids,
        mode
      });
      var prev2 = Editor.previous(editor, {
        at,
        match: match3,
        voids,
        mode
      });
      if (!current || !prev2) {
        return;
      }
      var [node4, path3] = current;
      var [prevNode, prevPath] = prev2;
      if (path3.length === 0 || prevPath.length === 0) {
        return;
      }
      var newPath = Path.next(prevPath);
      var commonPath = Path.common(path3, prevPath);
      var isPreviousSibling = Path.isSibling(path3, prevPath);
      var levels2 = Array.from(Editor.levels(editor, {
        at: path3
      }), (_ref2) => {
        var [n6] = _ref2;
        return n6;
      }).slice(commonPath.length).slice(0, -1);
      var emptyAncestor = Editor.above(editor, {
        at: path3,
        mode: "highest",
        match: (n6) => levels2.includes(n6) && hasSingleChildNest(editor, n6)
      });
      var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);
      var properties;
      var position3;
      if (Text.isText(node4) && Text.isText(prevNode)) {
        var rest = _objectWithoutProperties(node4, _excluded);
        position3 = prevNode.text.length;
        properties = rest;
      } else if (Element2.isElement(node4) && Element2.isElement(prevNode)) {
        var rest = _objectWithoutProperties(node4, _excluded2);
        position3 = prevNode.children.length;
        properties = rest;
      } else {
        throw new Error("Cannot merge the node at path [".concat(path3, "] with the previous sibling because it is not the same kind: ").concat(Scrubber.stringify(node4), " ").concat(Scrubber.stringify(prevNode)));
      }
      if (!isPreviousSibling) {
        Transforms.moveNodes(editor, {
          at: path3,
          to: newPath,
          voids
        });
      }
      if (emptyRef) {
        Transforms.removeNodes(editor, {
          at: emptyRef.current,
          voids
        });
      }
      if (Element2.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === "" && prevPath[prevPath.length - 1] !== 0) {
        Transforms.removeNodes(editor, {
          at: prevPath,
          voids
        });
      } else {
        editor.apply({
          type: "merge_node",
          path: newPath,
          position: position3,
          properties
        });
      }
      if (emptyRef) {
        emptyRef.unref();
      }
    });
  },
  /**
   * Move the nodes at a location to a new location.
   */
  moveNodes(editor, options) {
    Editor.withoutNormalizing(editor, () => {
      var {
        to,
        at = editor.selection,
        mode = "lowest",
        voids = false
      } = options;
      var {
        match: match3
      } = options;
      if (!at) {
        return;
      }
      if (match3 == null) {
        match3 = Path.isPath(at) ? matchPath(editor, at) : (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6);
      }
      var toRef = Editor.pathRef(editor, to);
      var targets = Editor.nodes(editor, {
        at,
        match: match3,
        mode,
        voids
      });
      var pathRefs = Array.from(targets, (_ref3) => {
        var [, p5] = _ref3;
        return Editor.pathRef(editor, p5);
      });
      for (var pathRef of pathRefs) {
        var path3 = pathRef.unref();
        var newPath = toRef.current;
        if (path3.length !== 0) {
          editor.apply({
            type: "move_node",
            path: path3,
            newPath
          });
        }
        if (toRef.current && Path.isSibling(newPath, path3) && Path.isAfter(newPath, path3)) {
          toRef.current = Path.next(toRef.current);
        }
      }
      toRef.unref();
    });
  },
  /**
   * Remove the nodes at a specific location in the document.
   */
  removeNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        hanging = false,
        voids = false,
        mode = "lowest"
      } = options;
      var {
        at = editor.selection,
        match: match3
      } = options;
      if (!at) {
        return;
      }
      if (match3 == null) {
        match3 = Path.isPath(at) ? matchPath(editor, at) : (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6);
      }
      if (!hanging && Range.isRange(at)) {
        at = Editor.unhangRange(editor, at, {
          voids
        });
      }
      var depths = Editor.nodes(editor, {
        at,
        match: match3,
        mode,
        voids
      });
      var pathRefs = Array.from(depths, (_ref4) => {
        var [, p5] = _ref4;
        return Editor.pathRef(editor, p5);
      });
      for (var pathRef of pathRefs) {
        var path3 = pathRef.unref();
        if (path3) {
          var [node4] = Editor.node(editor, path3);
          editor.apply({
            type: "remove_node",
            path: path3,
            node: node4
          });
        }
      }
    });
  },
  /**
   * Set new properties on the nodes at a location.
   */
  setNodes(editor, props) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        match: match3,
        at = editor.selection,
        compare,
        merge: merge4
      } = options;
      var {
        hanging = false,
        mode = "lowest",
        split: split2 = false,
        voids = false
      } = options;
      if (!at) {
        return;
      }
      if (match3 == null) {
        match3 = Path.isPath(at) ? matchPath(editor, at) : (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6);
      }
      if (!hanging && Range.isRange(at)) {
        at = Editor.unhangRange(editor, at, {
          voids
        });
      }
      if (split2 && Range.isRange(at)) {
        if (Range.isCollapsed(at) && Editor.leaf(editor, at.anchor)[0].text.length > 0) {
          return;
        }
        var rangeRef = Editor.rangeRef(editor, at, {
          affinity: "inward"
        });
        var [start2, end] = Range.edges(at);
        var splitMode = mode === "lowest" ? "lowest" : "highest";
        var endAtEndOfNode = Editor.isEnd(editor, end, end.path);
        Transforms.splitNodes(editor, {
          at: end,
          match: match3,
          mode: splitMode,
          voids,
          always: !endAtEndOfNode
        });
        var startAtStartOfNode = Editor.isStart(editor, start2, start2.path);
        Transforms.splitNodes(editor, {
          at: start2,
          match: match3,
          mode: splitMode,
          voids,
          always: !startAtStartOfNode
        });
        at = rangeRef.unref();
        if (options.at == null) {
          Transforms.select(editor, at);
        }
      }
      if (!compare) {
        compare = (prop, nodeProp) => prop !== nodeProp;
      }
      for (var [node4, path3] of Editor.nodes(editor, {
        at,
        match: match3,
        mode,
        voids
      })) {
        var properties = {};
        var newProperties = {};
        if (path3.length === 0) {
          continue;
        }
        var hasChanges = false;
        for (var k2 in props) {
          if (k2 === "children" || k2 === "text") {
            continue;
          }
          if (compare(props[k2], node4[k2])) {
            hasChanges = true;
            if (node4.hasOwnProperty(k2))
              properties[k2] = node4[k2];
            if (merge4) {
              if (props[k2] != null)
                newProperties[k2] = merge4(node4[k2], props[k2]);
            } else {
              if (props[k2] != null)
                newProperties[k2] = props[k2];
            }
          }
        }
        if (hasChanges) {
          editor.apply({
            type: "set_node",
            path: path3,
            properties,
            newProperties
          });
        }
      }
    });
  },
  /**
   * Split the nodes at a specific location.
   */
  splitNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        mode = "lowest",
        voids = false
      } = options;
      var {
        match: match3,
        at = editor.selection,
        height = 0,
        always = false
      } = options;
      if (match3 == null) {
        match3 = (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6);
      }
      if (Range.isRange(at)) {
        at = deleteRange(editor, at);
      }
      if (Path.isPath(at)) {
        var path3 = at;
        var point3 = Editor.point(editor, path3);
        var [parent] = Editor.parent(editor, path3);
        match3 = (n6) => n6 === parent;
        height = point3.path.length - path3.length + 1;
        at = point3;
        always = true;
      }
      if (!at) {
        return;
      }
      var beforeRef = Editor.pointRef(editor, at, {
        affinity: "backward"
      });
      var afterRef;
      try {
        var [highest] = Editor.nodes(editor, {
          at,
          match: match3,
          mode,
          voids
        });
        if (!highest) {
          return;
        }
        var voidMatch = Editor.void(editor, {
          at,
          mode: "highest"
        });
        var nudge = 0;
        if (!voids && voidMatch) {
          var [voidNode, voidPath] = voidMatch;
          if (Element2.isElement(voidNode) && editor.isInline(voidNode)) {
            var after = Editor.after(editor, voidPath);
            if (!after) {
              var text7 = {
                text: ""
              };
              var afterPath = Path.next(voidPath);
              Transforms.insertNodes(editor, text7, {
                at: afterPath,
                voids
              });
              after = Editor.point(editor, afterPath);
            }
            at = after;
            always = true;
          }
          var siblingHeight = at.path.length - voidPath.length;
          height = siblingHeight + 1;
          always = true;
        }
        afterRef = Editor.pointRef(editor, at);
        var depth = at.path.length - height;
        var [, highestPath] = highest;
        var lowestPath = at.path.slice(0, depth);
        var position3 = height === 0 ? at.offset : at.path[depth] + nudge;
        for (var [node4, _path2] of Editor.levels(editor, {
          at: lowestPath,
          reverse: true,
          voids
        })) {
          var split2 = false;
          if (_path2.length < highestPath.length || _path2.length === 0 || !voids && Element2.isElement(node4) && Editor.isVoid(editor, node4)) {
            break;
          }
          var _point = beforeRef.current;
          var isEnd = Editor.isEnd(editor, _point, _path2);
          if (always || !beforeRef || !Editor.isEdge(editor, _point, _path2)) {
            split2 = true;
            var properties = Node3.extractProps(node4);
            editor.apply({
              type: "split_node",
              path: _path2,
              position: position3,
              properties
            });
          }
          position3 = _path2[_path2.length - 1] + (split2 || isEnd ? 1 : 0);
        }
        if (options.at == null) {
          var _point2 = afterRef.current || Editor.end(editor, []);
          Transforms.select(editor, _point2);
        }
      } finally {
        var _afterRef;
        beforeRef.unref();
        (_afterRef = afterRef) === null || _afterRef === void 0 ? void 0 : _afterRef.unref();
      }
    });
  },
  /**
   * Unset properties on the nodes at a location.
   */
  unsetNodes(editor, props) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!Array.isArray(props)) {
      props = [props];
    }
    var obj = {};
    for (var key of props) {
      obj[key] = null;
    }
    Transforms.setNodes(editor, obj, options);
  },
  /**
   * Unwrap the nodes at a location from a parent node, splitting the parent if
   * necessary to ensure that only the content in the range is unwrapped.
   */
  unwrapNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        mode = "lowest",
        split: split2 = false,
        voids = false
      } = options;
      var {
        at = editor.selection,
        match: match3
      } = options;
      if (!at) {
        return;
      }
      if (match3 == null) {
        match3 = Path.isPath(at) ? matchPath(editor, at) : (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6);
      }
      if (Path.isPath(at)) {
        at = Editor.range(editor, at);
      }
      var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;
      var matches = Editor.nodes(editor, {
        at,
        match: match3,
        mode,
        voids
      });
      var pathRefs = Array.from(
        matches,
        (_ref5) => {
          var [, p5] = _ref5;
          return Editor.pathRef(editor, p5);
        }
        // unwrapNode will call liftNode which does not support splitting the node when nested.
        // If we do not reverse the order and call it from top to the bottom, it will remove all blocks
        // that wrap target node. So we reverse the order.
      ).reverse();
      var _loop = function _loop2(pathRef2) {
        var path3 = pathRef2.unref();
        var [node4] = Editor.node(editor, path3);
        var range = Editor.range(editor, path3);
        if (split2 && rangeRef) {
          range = Range.intersection(rangeRef.current, range);
        }
        Transforms.liftNodes(editor, {
          at: range,
          match: (n6) => Element2.isAncestor(node4) && node4.children.includes(n6),
          voids
        });
      };
      for (var pathRef of pathRefs) {
        _loop(pathRef);
      }
      if (rangeRef) {
        rangeRef.unref();
      }
    });
  },
  /**
   * Wrap the nodes at a location in a new container node, splitting the edges
   * of the range first to ensure that only the content in the range is wrapped.
   */
  wrapNodes(editor, element4) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        mode = "lowest",
        split: split2 = false,
        voids = false
      } = options;
      var {
        match: match3,
        at = editor.selection
      } = options;
      if (!at) {
        return;
      }
      if (match3 == null) {
        if (Path.isPath(at)) {
          match3 = matchPath(editor, at);
        } else if (editor.isInline(element4)) {
          match3 = (n6) => Element2.isElement(n6) && Editor.isInline(editor, n6) || Text.isText(n6);
        } else {
          match3 = (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6);
        }
      }
      if (split2 && Range.isRange(at)) {
        var [start2, end] = Range.edges(at);
        var rangeRef = Editor.rangeRef(editor, at, {
          affinity: "inward"
        });
        Transforms.splitNodes(editor, {
          at: end,
          match: match3,
          voids
        });
        Transforms.splitNodes(editor, {
          at: start2,
          match: match3,
          voids
        });
        at = rangeRef.unref();
        if (options.at == null) {
          Transforms.select(editor, at);
        }
      }
      var roots = Array.from(Editor.nodes(editor, {
        at,
        match: editor.isInline(element4) ? (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6) : (n6) => Editor.isEditor(n6),
        mode: "lowest",
        voids
      }));
      for (var [, rootPath] of roots) {
        var a3 = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;
        if (!a3) {
          continue;
        }
        var matches = Array.from(Editor.nodes(editor, {
          at: a3,
          match: match3,
          mode,
          voids
        }));
        if (matches.length > 0) {
          var _ret = function() {
            var [first] = matches;
            var last2 = matches[matches.length - 1];
            var [, firstPath] = first;
            var [, lastPath] = last2;
            if (firstPath.length === 0 && lastPath.length === 0) {
              return "continue";
            }
            var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);
            var range = Editor.range(editor, firstPath, lastPath);
            var commonNodeEntry = Editor.node(editor, commonPath);
            var [commonNode] = commonNodeEntry;
            var depth = commonPath.length + 1;
            var wrapperPath = Path.next(lastPath.slice(0, depth));
            var wrapper = _objectSpread$2(_objectSpread$2({}, element4), {}, {
              children: []
            });
            Transforms.insertNodes(editor, wrapper, {
              at: wrapperPath,
              voids
            });
            Transforms.moveNodes(editor, {
              at: range,
              match: (n6) => Element2.isAncestor(commonNode) && commonNode.children.includes(n6),
              to: wrapperPath.concat(0),
              voids
            });
          }();
          if (_ret === "continue")
            continue;
        }
      }
    });
  }
};
var hasSingleChildNest = (editor, node4) => {
  if (Element2.isElement(node4)) {
    var element4 = node4;
    if (Editor.isVoid(editor, node4)) {
      return true;
    } else if (element4.children.length === 1) {
      return hasSingleChildNest(editor, element4.children[0]);
    } else {
      return false;
    }
  } else if (Editor.isEditor(node4)) {
    return false;
  } else {
    return true;
  }
};
var deleteRange = (editor, range) => {
  if (Range.isCollapsed(range)) {
    return range.anchor;
  } else {
    var [, end] = Range.edges(range);
    var pointRef = Editor.pointRef(editor, end);
    Transforms.delete(editor, {
      at: range
    });
    return pointRef.unref();
  }
};
var matchPath = (editor, path3) => {
  var [node4] = Editor.node(editor, path3);
  return (n6) => n6 === node4;
};
function ownKeys$1(object2, enumerableOnly) {
  var keys3 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$1(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6] != null ? arguments[i6] : {};
    if (i6 % 2) {
      ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var SelectionTransforms = {
  /**
   * Collapse the selection.
   */
  collapse(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      edge = "anchor"
    } = options;
    var {
      selection
    } = editor;
    if (!selection) {
      return;
    } else if (edge === "anchor") {
      Transforms.select(editor, selection.anchor);
    } else if (edge === "focus") {
      Transforms.select(editor, selection.focus);
    } else if (edge === "start") {
      var [start2] = Range.edges(selection);
      Transforms.select(editor, start2);
    } else if (edge === "end") {
      var [, end] = Range.edges(selection);
      Transforms.select(editor, end);
    }
  },
  /**
   * Unset the selection.
   */
  deselect(editor) {
    var {
      selection
    } = editor;
    if (selection) {
      editor.apply({
        type: "set_selection",
        properties: selection,
        newProperties: null
      });
    }
  },
  /**
   * Move the selection's point forward or backward.
   */
  move(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      selection
    } = editor;
    var {
      distance = 1,
      unit = "character",
      reverse = false
    } = options;
    var {
      edge = null
    } = options;
    if (!selection) {
      return;
    }
    if (edge === "start") {
      edge = Range.isBackward(selection) ? "focus" : "anchor";
    }
    if (edge === "end") {
      edge = Range.isBackward(selection) ? "anchor" : "focus";
    }
    var {
      anchor,
      focus
    } = selection;
    var opts = {
      distance,
      unit
    };
    var props = {};
    if (edge == null || edge === "anchor") {
      var point3 = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);
      if (point3) {
        props.anchor = point3;
      }
    }
    if (edge == null || edge === "focus") {
      var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);
      if (_point) {
        props.focus = _point;
      }
    }
    Transforms.setSelection(editor, props);
  },
  /**
   * Set the selection to a new value.
   */
  select(editor, target) {
    var {
      selection
    } = editor;
    target = Editor.range(editor, target);
    if (selection) {
      Transforms.setSelection(editor, target);
      return;
    }
    if (!Range.isRange(target)) {
      throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(Scrubber.stringify(target)));
    }
    editor.apply({
      type: "set_selection",
      properties: selection,
      newProperties: target
    });
  },
  /**
   * Set new properties on one of the selection's points.
   */
  setPoint(editor, props) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      selection
    } = editor;
    var {
      edge = "both"
    } = options;
    if (!selection) {
      return;
    }
    if (edge === "start") {
      edge = Range.isBackward(selection) ? "focus" : "anchor";
    }
    if (edge === "end") {
      edge = Range.isBackward(selection) ? "anchor" : "focus";
    }
    var {
      anchor,
      focus
    } = selection;
    var point3 = edge === "anchor" ? anchor : focus;
    Transforms.setSelection(editor, {
      [edge === "anchor" ? "anchor" : "focus"]: _objectSpread$1(_objectSpread$1({}, point3), props)
    });
  },
  /**
   * Set new properties on the selection.
   */
  setSelection(editor, props) {
    var {
      selection
    } = editor;
    var oldProps = {};
    var newProps = {};
    if (!selection) {
      return;
    }
    for (var k2 in props) {
      if (k2 === "anchor" && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k2 === "focus" && props.focus != null && !Point.equals(props.focus, selection.focus) || k2 !== "anchor" && k2 !== "focus" && props[k2] !== selection[k2]) {
        oldProps[k2] = selection[k2];
        newProps[k2] = props[k2];
      }
    }
    if (Object.keys(oldProps).length > 0) {
      editor.apply({
        type: "set_selection",
        properties: oldProps,
        newProperties: newProps
      });
    }
  }
};
var TextTransforms = {
  /**
   * Delete content in the editor.
   */
  delete(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        reverse = false,
        unit = "character",
        distance = 1,
        voids = false
      } = options;
      var {
        at = editor.selection,
        hanging = false
      } = options;
      if (!at) {
        return;
      }
      var isCollapsed = false;
      if (Range.isRange(at) && Range.isCollapsed(at)) {
        isCollapsed = true;
        at = at.anchor;
      }
      if (Point.isPoint(at)) {
        var furthestVoid = Editor.void(editor, {
          at,
          mode: "highest"
        });
        if (!voids && furthestVoid) {
          var [, voidPath] = furthestVoid;
          at = voidPath;
        } else {
          var opts = {
            unit,
            distance
          };
          var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);
          at = {
            anchor: at,
            focus: target
          };
          hanging = true;
        }
      }
      if (Path.isPath(at)) {
        Transforms.removeNodes(editor, {
          at,
          voids
        });
        return;
      }
      if (Range.isCollapsed(at)) {
        return;
      }
      if (!hanging) {
        var [, _end] = Range.edges(at);
        var endOfDoc = Editor.end(editor, []);
        if (!Point.equals(_end, endOfDoc)) {
          at = Editor.unhangRange(editor, at, {
            voids
          });
        }
      }
      var [start2, end] = Range.edges(at);
      var startBlock = Editor.above(editor, {
        match: (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6),
        at: start2,
        voids
      });
      var endBlock = Editor.above(editor, {
        match: (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6),
        at: end,
        voids
      });
      var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);
      var isSingleText = Path.equals(start2.path, end.path);
      var startVoid = voids ? null : Editor.void(editor, {
        at: start2,
        mode: "highest"
      });
      var endVoid = voids ? null : Editor.void(editor, {
        at: end,
        mode: "highest"
      });
      if (startVoid) {
        var before = Editor.before(editor, start2);
        if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {
          start2 = before;
        }
      }
      if (endVoid) {
        var after = Editor.after(editor, end);
        if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {
          end = after;
        }
      }
      var matches = [];
      var lastPath;
      for (var entry of Editor.nodes(editor, {
        at,
        voids
      })) {
        var [node4, path3] = entry;
        if (lastPath && Path.compare(path3, lastPath) === 0) {
          continue;
        }
        if (!voids && Element2.isElement(node4) && Editor.isVoid(editor, node4) || !Path.isCommon(path3, start2.path) && !Path.isCommon(path3, end.path)) {
          matches.push(entry);
          lastPath = path3;
        }
      }
      var pathRefs = Array.from(matches, (_ref) => {
        var [, p5] = _ref;
        return Editor.pathRef(editor, p5);
      });
      var startRef = Editor.pointRef(editor, start2);
      var endRef = Editor.pointRef(editor, end);
      var removedText = "";
      if (!isSingleText && !startVoid) {
        var _point = startRef.current;
        var [_node] = Editor.leaf(editor, _point);
        var {
          path: _path
        } = _point;
        var {
          offset
        } = start2;
        var text7 = _node.text.slice(offset);
        if (text7.length > 0) {
          editor.apply({
            type: "remove_text",
            path: _path,
            offset,
            text: text7
          });
          removedText = text7;
        }
      }
      pathRefs.reverse().map((r7) => r7.unref()).filter((r7) => r7 !== null).forEach((p5) => Transforms.removeNodes(editor, {
        at: p5,
        voids
      }));
      if (!endVoid) {
        var _point2 = endRef.current;
        var [_node2] = Editor.leaf(editor, _point2);
        var {
          path: _path2
        } = _point2;
        var _offset = isSingleText ? start2.offset : 0;
        var _text = _node2.text.slice(_offset, end.offset);
        if (_text.length > 0) {
          editor.apply({
            type: "remove_text",
            path: _path2,
            offset: _offset,
            text: _text
          });
          removedText = _text;
        }
      }
      if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {
        Transforms.mergeNodes(editor, {
          at: endRef.current,
          hanging: true,
          voids
        });
      }
      if (isCollapsed && reverse && unit === "character" && removedText.length > 1 && removedText.match(/[\u0E00-\u0E7F]+/)) {
        Transforms.insertText(editor, removedText.slice(0, removedText.length - distance));
      }
      var startUnref = startRef.unref();
      var endUnref = endRef.unref();
      var point3 = reverse ? startUnref || endUnref : endUnref || startUnref;
      if (options.at == null && point3) {
        Transforms.select(editor, point3);
      }
    });
  },
  /**
   * Insert a fragment at a specific location in the editor.
   */
  insertFragment(editor, fragment) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        hanging = false,
        voids = false
      } = options;
      var {
        at = editor.selection
      } = options;
      if (!fragment.length) {
        return;
      }
      if (!at) {
        return;
      } else if (Range.isRange(at)) {
        if (!hanging) {
          at = Editor.unhangRange(editor, at, {
            voids
          });
        }
        if (Range.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var [, end] = Range.edges(at);
          if (!voids && Editor.void(editor, {
            at: end
          })) {
            return;
          }
          var pointRef = Editor.pointRef(editor, end);
          Transforms.delete(editor, {
            at
          });
          at = pointRef.unref();
        }
      } else if (Path.isPath(at)) {
        at = Editor.start(editor, at);
      }
      if (!voids && Editor.void(editor, {
        at
      })) {
        return;
      }
      var inlineElementMatch = Editor.above(editor, {
        at,
        match: (n6) => Element2.isElement(n6) && Editor.isInline(editor, n6),
        mode: "highest",
        voids
      });
      if (inlineElementMatch) {
        var [, _inlinePath] = inlineElementMatch;
        if (Editor.isEnd(editor, at, _inlinePath)) {
          var after = Editor.after(editor, _inlinePath);
          at = after;
        } else if (Editor.isStart(editor, at, _inlinePath)) {
          var before = Editor.before(editor, _inlinePath);
          at = before;
        }
      }
      var blockMatch = Editor.above(editor, {
        match: (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6),
        at,
        voids
      });
      var [, blockPath] = blockMatch;
      var isBlockStart = Editor.isStart(editor, at, blockPath);
      var isBlockEnd = Editor.isEnd(editor, at, blockPath);
      var isBlockEmpty = isBlockStart && isBlockEnd;
      var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;
      var mergeEnd = !isBlockEnd;
      var [, firstPath] = Node3.first({
        children: fragment
      }, []);
      var [, lastPath] = Node3.last({
        children: fragment
      }, []);
      var matches = [];
      var matcher = (_ref2) => {
        var [n6, p5] = _ref2;
        var isRoot = p5.length === 0;
        if (isRoot) {
          return false;
        }
        if (isBlockEmpty) {
          return true;
        }
        if (mergeStart && Path.isAncestor(p5, firstPath) && Element2.isElement(n6) && !editor.isVoid(n6) && !editor.isInline(n6)) {
          return false;
        }
        if (mergeEnd && Path.isAncestor(p5, lastPath) && Element2.isElement(n6) && !editor.isVoid(n6) && !editor.isInline(n6)) {
          return false;
        }
        return true;
      };
      for (var entry of Node3.nodes({
        children: fragment
      }, {
        pass: matcher
      })) {
        if (matcher(entry)) {
          matches.push(entry);
        }
      }
      var starts = [];
      var middles = [];
      var ends = [];
      var starting = true;
      var hasBlocks = false;
      for (var [node4] of matches) {
        if (Element2.isElement(node4) && !editor.isInline(node4)) {
          starting = false;
          hasBlocks = true;
          middles.push(node4);
        } else if (starting) {
          starts.push(node4);
        } else {
          ends.push(node4);
        }
      }
      var [inlineMatch] = Editor.nodes(editor, {
        at,
        match: (n6) => Text.isText(n6) || Editor.isInline(editor, n6),
        mode: "highest",
        voids
      });
      var [, inlinePath] = inlineMatch;
      var isInlineStart = Editor.isStart(editor, at, inlinePath);
      var isInlineEnd = Editor.isEnd(editor, at, inlinePath);
      var middleRef = Editor.pathRef(editor, isBlockEnd && !ends.length ? Path.next(blockPath) : blockPath);
      var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);
      Transforms.splitNodes(editor, {
        at,
        match: (n6) => hasBlocks ? Element2.isElement(n6) && Editor.isBlock(editor, n6) : Text.isText(n6) || Editor.isInline(editor, n6),
        mode: hasBlocks ? "lowest" : "highest",
        always: hasBlocks && (!isBlockStart || starts.length > 0) && (!isBlockEnd || ends.length > 0),
        voids
      });
      var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);
      Transforms.insertNodes(editor, starts, {
        at: startRef.current,
        match: (n6) => Text.isText(n6) || Editor.isInline(editor, n6),
        mode: "highest",
        voids
      });
      if (isBlockEmpty && !starts.length && middles.length && !ends.length) {
        Transforms.delete(editor, {
          at: blockPath,
          voids
        });
      }
      Transforms.insertNodes(editor, middles, {
        at: middleRef.current,
        match: (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6),
        mode: "lowest",
        voids
      });
      Transforms.insertNodes(editor, ends, {
        at: endRef.current,
        match: (n6) => Text.isText(n6) || Editor.isInline(editor, n6),
        mode: "highest",
        voids
      });
      if (!options.at) {
        var path3;
        if (ends.length > 0 && endRef.current) {
          path3 = Path.previous(endRef.current);
        } else if (middles.length > 0 && middleRef.current) {
          path3 = Path.previous(middleRef.current);
        } else if (startRef.current) {
          path3 = Path.previous(startRef.current);
        }
        if (path3) {
          var _end2 = Editor.end(editor, path3);
          Transforms.select(editor, _end2);
        }
      }
      startRef.unref();
      middleRef.unref();
      endRef.unref();
    });
  },
  /**
   * Insert a string of text in the Editor.
   */
  insertText(editor, text7) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        voids = false
      } = options;
      var {
        at = editor.selection
      } = options;
      if (!at) {
        return;
      }
      if (Path.isPath(at)) {
        at = Editor.range(editor, at);
      }
      if (Range.isRange(at)) {
        if (Range.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var end = Range.end(at);
          if (!voids && Editor.void(editor, {
            at: end
          })) {
            return;
          }
          var start2 = Range.start(at);
          var startRef = Editor.pointRef(editor, start2);
          var endRef = Editor.pointRef(editor, end);
          Transforms.delete(editor, {
            at,
            voids
          });
          var startPoint = startRef.unref();
          var endPoint = endRef.unref();
          at = startPoint || endPoint;
          Transforms.setSelection(editor, {
            anchor: at,
            focus: at
          });
        }
      }
      if (!voids && Editor.void(editor, {
        at
      })) {
        return;
      }
      var {
        path: path3,
        offset
      } = at;
      if (text7.length > 0)
        editor.apply({
          type: "insert_text",
          path: path3,
          offset,
          text: text7
        });
    });
  }
};
function ownKeys(object2, enumerableOnly) {
  var keys3 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6] != null ? arguments[i6] : {};
    if (i6 % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Transforms = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);

// node_modules/emery/assertions/dist/emery-assertions.esm.js
function assert(condition) {
  var message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "Assert failed";
  if (!condition) {
    throw new TypeError(message);
  }
}
function assertNever(arg) {
  throw new Error("Expected never to be called, but received: " + JSON.stringify(arg));
}
function warning(condition, message) {
  if (true) {
    if (condition) {
      return;
    }
    var text7 = "Warning: ".concat(message);
    if (typeof console !== "undefined") {
      console.warn(text7);
    }
    try {
      throw Error(text7);
    } catch (x4) {
    }
  }
}

// node_modules/emery/dist/number-556a10ae.esm.js
function negate(predicate) {
  return function(value2) {
    return !predicate(value2);
  };
}
var isFinite2 = Number.isFinite;
var isInfinite = negate(isFinite2);
var isInteger = Number.isInteger;
var isFloat = negate(isInteger);

// node_modules/emery/guards/dist/emery-guards.esm.js
function isNumber(value2) {
  return typeof value2 === "number" && !isNaN(value2);
}
function isNullish(value2) {
  return value2 === null || value2 === void 0;
}
function isDefined(value2) {
  return !isNullish(value2);
}

// node_modules/emery/dist/object-d266a626.esm.js
function typedEntries(value2) {
  return Object.entries(value2);
}
function typedKeys(value2) {
  return Object.keys(value2);
}

// node_modules/lib0/math.js
var floor = Math.floor;
var abs = Math.abs;
var log10 = Math.log10;
var min = (a3, b2) => a3 < b2 ? a3 : b2;
var max2 = (a3, b2) => a3 > b2 ? a3 : b2;
var isNaN2 = Number.isNaN;
var isNegativeZero2 = (n6) => n6 !== 0 ? n6 < 0 : 1 / n6 < 0;

// node_modules/lib0/binary.js
var BIT1 = 1;
var BIT2 = 2;
var BIT3 = 4;
var BIT4 = 8;
var BIT6 = 32;
var BIT7 = 64;
var BIT8 = 128;
var BIT18 = 1 << 17;
var BIT19 = 1 << 18;
var BIT20 = 1 << 19;
var BIT21 = 1 << 20;
var BIT22 = 1 << 21;
var BIT23 = 1 << 22;
var BIT24 = 1 << 23;
var BIT25 = 1 << 24;
var BIT26 = 1 << 25;
var BIT27 = 1 << 26;
var BIT28 = 1 << 27;
var BIT29 = 1 << 28;
var BIT30 = 1 << 29;
var BIT31 = 1 << 30;
var BIT32 = 1 << 31;
var BITS5 = 31;
var BITS6 = 63;
var BITS7 = 127;
var BITS17 = BIT18 - 1;
var BITS18 = BIT19 - 1;
var BITS19 = BIT20 - 1;
var BITS20 = BIT21 - 1;
var BITS21 = BIT22 - 1;
var BITS22 = BIT23 - 1;
var BITS23 = BIT24 - 1;
var BITS24 = BIT25 - 1;
var BITS25 = BIT26 - 1;
var BITS26 = BIT27 - 1;
var BITS27 = BIT28 - 1;
var BITS28 = BIT29 - 1;
var BITS29 = BIT30 - 1;
var BITS30 = BIT31 - 1;
var BITS31 = 2147483647;

// node_modules/lib0/number.js
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;
var LOWEST_INT32 = 1 << 31;
var isInteger2 = Number.isInteger || ((num) => typeof num === "number" && isFinite(num) && floor(num) === num);
var isNaN3 = Number.isNaN;
var parseInt2 = Number.parseInt;

// node_modules/lib0/set.js
var create = () => /* @__PURE__ */ new Set();

// node_modules/lib0/array.js
var last = (arr) => arr[arr.length - 1];
var appendTo = (dest, src) => {
  for (let i6 = 0; i6 < src.length; i6++) {
    dest.push(src[i6]);
  }
};
var from2 = Array.from;
var isArray = Array.isArray;

// node_modules/lib0/string.js
var fromCharCode = String.fromCharCode;
var fromCodePoint = String.fromCodePoint;
var MAX_UTF16_CHARACTER = fromCharCode(65535);
var toLowerCase = (s4) => s4.toLowerCase();
var trimLeftRegex = /^\s*/g;
var trimLeft = (s4) => s4.replace(trimLeftRegex, "");
var fromCamelCaseRegex = /([A-Z])/g;
var fromCamelCase = (s4, separator) => trimLeft(s4.replace(fromCamelCaseRegex, (match3) => `${separator}${toLowerCase(match3)}`));
var _encodeUtf8Polyfill = (str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  const buf = new Uint8Array(len);
  for (let i6 = 0; i6 < len; i6++) {
    buf[i6] = /** @type {number} */
    encodedString.codePointAt(i6);
  }
  return buf;
};
var utf8TextEncoder = (
  /** @type {TextEncoder} */
  typeof TextEncoder !== "undefined" ? new TextEncoder() : null
);
var _encodeUtf8Native = (str) => utf8TextEncoder.encode(str);
var encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;
var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
if (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {
  utf8TextDecoder = null;
}

// node_modules/lib0/encoding.js
var Encoder = class {
  constructor() {
    this.cpos = 0;
    this.cbuf = new Uint8Array(100);
    this.bufs = [];
  }
};
var createEncoder = () => new Encoder();
var length = (encoder) => {
  let len = encoder.cpos;
  for (let i6 = 0; i6 < encoder.bufs.length; i6++) {
    len += encoder.bufs[i6].length;
  }
  return len;
};
var toUint8Array = (encoder) => {
  const uint8arr = new Uint8Array(length(encoder));
  let curPos = 0;
  for (let i6 = 0; i6 < encoder.bufs.length; i6++) {
    const d5 = encoder.bufs[i6];
    uint8arr.set(d5, curPos);
    curPos += d5.length;
  }
  uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos);
  return uint8arr;
};
var verifyLen = (encoder, len) => {
  const bufferLen = encoder.cbuf.length;
  if (bufferLen - encoder.cpos < len) {
    encoder.bufs.push(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos));
    encoder.cbuf = new Uint8Array(max2(bufferLen, len) * 2);
    encoder.cpos = 0;
  }
};
var write = (encoder, num) => {
  const bufferLen = encoder.cbuf.length;
  if (encoder.cpos === bufferLen) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(bufferLen * 2);
    encoder.cpos = 0;
  }
  encoder.cbuf[encoder.cpos++] = num;
};
var writeUint8 = write;
var writeVarUint = (encoder, num) => {
  while (num > BITS7) {
    write(encoder, BIT8 | BITS7 & num);
    num = floor(num / 128);
  }
  write(encoder, BITS7 & num);
};
var writeVarInt = (encoder, num) => {
  const isNegative2 = isNegativeZero2(num);
  if (isNegative2) {
    num = -num;
  }
  write(encoder, (num > BITS6 ? BIT8 : 0) | (isNegative2 ? BIT7 : 0) | BITS6 & num);
  num = floor(num / 64);
  while (num > 0) {
    write(encoder, (num > BITS7 ? BIT8 : 0) | BITS7 & num);
    num = floor(num / 128);
  }
};
var _strBuffer = new Uint8Array(3e4);
var _maxStrBSize = _strBuffer.length / 3;
var _writeVarStringNative = (encoder, str) => {
  if (str.length < _maxStrBSize) {
    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;
    writeVarUint(encoder, written);
    for (let i6 = 0; i6 < written; i6++) {
      write(encoder, _strBuffer[i6]);
    }
  } else {
    writeVarUint8Array(encoder, encodeUtf8(str));
  }
};
var _writeVarStringPolyfill = (encoder, str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  writeVarUint(encoder, len);
  for (let i6 = 0; i6 < len; i6++) {
    write(
      encoder,
      /** @type {number} */
      encodedString.codePointAt(i6)
    );
  }
};
var writeVarString = utf8TextEncoder && /** @type {any} */
utf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;
var writeBinaryEncoder = (encoder, append3) => writeUint8Array(encoder, toUint8Array(append3));
var writeUint8Array = (encoder, uint8Array) => {
  const bufferLen = encoder.cbuf.length;
  const cpos = encoder.cpos;
  const leftCopyLen = min(bufferLen - cpos, uint8Array.length);
  const rightCopyLen = uint8Array.length - leftCopyLen;
  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
  encoder.cpos += leftCopyLen;
  if (rightCopyLen > 0) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(max2(bufferLen * 2, rightCopyLen));
    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
    encoder.cpos = rightCopyLen;
  }
};
var writeVarUint8Array = (encoder, uint8Array) => {
  writeVarUint(encoder, uint8Array.byteLength);
  writeUint8Array(encoder, uint8Array);
};
var writeOnDataView = (encoder, len) => {
  verifyLen(encoder, len);
  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);
  encoder.cpos += len;
  return dview;
};
var writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false);
var writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false);
var writeBigInt64 = (encoder, num) => (
  /** @type {any} */
  writeOnDataView(encoder, 8).setBigInt64(0, num, false)
);
var floatTestBed = new DataView(new ArrayBuffer(4));
var isFloat32 = (num) => {
  floatTestBed.setFloat32(0, num);
  return floatTestBed.getFloat32(0) === num;
};
var writeAny = (encoder, data) => {
  switch (typeof data) {
    case "string":
      write(encoder, 119);
      writeVarString(encoder, data);
      break;
    case "number":
      if (isInteger2(data) && abs(data) <= BITS31) {
        write(encoder, 125);
        writeVarInt(encoder, data);
      } else if (isFloat32(data)) {
        write(encoder, 124);
        writeFloat32(encoder, data);
      } else {
        write(encoder, 123);
        writeFloat64(encoder, data);
      }
      break;
    case "bigint":
      write(encoder, 122);
      writeBigInt64(encoder, data);
      break;
    case "object":
      if (data === null) {
        write(encoder, 126);
      } else if (isArray(data)) {
        write(encoder, 117);
        writeVarUint(encoder, data.length);
        for (let i6 = 0; i6 < data.length; i6++) {
          writeAny(encoder, data[i6]);
        }
      } else if (data instanceof Uint8Array) {
        write(encoder, 116);
        writeVarUint8Array(encoder, data);
      } else {
        write(encoder, 118);
        const keys3 = Object.keys(data);
        writeVarUint(encoder, keys3.length);
        for (let i6 = 0; i6 < keys3.length; i6++) {
          const key = keys3[i6];
          writeVarString(encoder, key);
          writeAny(encoder, data[key]);
        }
      }
      break;
    case "boolean":
      write(encoder, data ? 120 : 121);
      break;
    default:
      write(encoder, 127);
  }
};
var RleEncoder = class extends Encoder {
  /**
   * @param {function(Encoder, T):void} writer
   */
  constructor(writer) {
    super();
    this.w = writer;
    this.s = null;
    this.count = 0;
  }
  /**
   * @param {T} v
   */
  write(v6) {
    if (this.s === v6) {
      this.count++;
    } else {
      if (this.count > 0) {
        writeVarUint(this, this.count - 1);
      }
      this.count = 1;
      this.w(this, v6);
      this.s = v6;
    }
  }
};
var flushUintOptRleEncoder = (encoder) => {
  if (encoder.count > 0) {
    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s);
    if (encoder.count > 1) {
      writeVarUint(encoder.encoder, encoder.count - 2);
    }
  }
};
var UintOptRleEncoder = class {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
  }
  /**
   * @param {number} v
   */
  write(v6) {
    if (this.s === v6) {
      this.count++;
    } else {
      flushUintOptRleEncoder(this);
      this.count = 1;
      this.s = v6;
    }
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    flushUintOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
};
var flushIntDiffOptRleEncoder = (encoder) => {
  if (encoder.count > 0) {
    const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1);
    writeVarInt(encoder.encoder, encodedDiff);
    if (encoder.count > 1) {
      writeVarUint(encoder.encoder, encoder.count - 2);
    }
  }
};
var IntDiffOptRleEncoder = class {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  /**
   * @param {number} v
   */
  write(v6) {
    if (this.diff === v6 - this.s) {
      this.s = v6;
      this.count++;
    } else {
      flushIntDiffOptRleEncoder(this);
      this.count = 1;
      this.diff = v6 - this.s;
      this.s = v6;
    }
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    flushIntDiffOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
};
var StringEncoder = class {
  constructor() {
    this.sarr = [];
    this.s = "";
    this.lensE = new UintOptRleEncoder();
  }
  /**
   * @param {string} string
   */
  write(string3) {
    this.s += string3;
    if (this.s.length > 19) {
      this.sarr.push(this.s);
      this.s = "";
    }
    this.lensE.write(string3.length);
  }
  toUint8Array() {
    const encoder = new Encoder();
    this.sarr.push(this.s);
    this.s = "";
    writeVarString(encoder, this.sarr.join(""));
    writeUint8Array(encoder, this.lensE.toUint8Array());
    return toUint8Array(encoder);
  }
};

// node_modules/lib0/error.js
var create2 = (s4) => new Error(s4);
var methodUnimplemented = () => {
  throw create2("Method unimplemented");
};
var unexpectedCase = () => {
  throw create2("Unexpected case");
};

// node_modules/lib0/decoding.js
var errorUnexpectedEndOfArray = create2("Unexpected end of array");
var errorIntegerOutOfRange = create2("Integer out of Range");
var Decoder = class {
  /**
   * @param {Uint8Array} uint8Array Binary data to decode
   */
  constructor(uint8Array) {
    this.arr = uint8Array;
    this.pos = 0;
  }
};
var createDecoder = (uint8Array) => new Decoder(uint8Array);
var hasContent = (decoder) => decoder.pos !== decoder.arr.length;
var readUint8Array = (decoder, len) => {
  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);
  decoder.pos += len;
  return view;
};
var readVarUint8Array = (decoder) => readUint8Array(decoder, readVarUint(decoder));
var readUint8 = (decoder) => decoder.arr[decoder.pos++];
var readVarUint = (decoder) => {
  let num = 0;
  let mult = 1;
  const len = decoder.arr.length;
  while (decoder.pos < len) {
    const r7 = decoder.arr[decoder.pos++];
    num = num + (r7 & BITS7) * mult;
    mult *= 128;
    if (r7 < BIT8) {
      return num;
    }
    if (num > MAX_SAFE_INTEGER) {
      throw errorIntegerOutOfRange;
    }
  }
  throw errorUnexpectedEndOfArray;
};
var readVarInt = (decoder) => {
  let r7 = decoder.arr[decoder.pos++];
  let num = r7 & BITS6;
  let mult = 64;
  const sign2 = (r7 & BIT7) > 0 ? -1 : 1;
  if ((r7 & BIT8) === 0) {
    return sign2 * num;
  }
  const len = decoder.arr.length;
  while (decoder.pos < len) {
    r7 = decoder.arr[decoder.pos++];
    num = num + (r7 & BITS7) * mult;
    mult *= 128;
    if (r7 < BIT8) {
      return sign2 * num;
    }
    if (num > MAX_SAFE_INTEGER) {
      throw errorIntegerOutOfRange;
    }
  }
  throw errorUnexpectedEndOfArray;
};
var _readVarStringPolyfill = (decoder) => {
  let remainingLen = readVarUint(decoder);
  if (remainingLen === 0) {
    return "";
  } else {
    let encodedString = String.fromCodePoint(readUint8(decoder));
    if (--remainingLen < 100) {
      while (remainingLen--) {
        encodedString += String.fromCodePoint(readUint8(decoder));
      }
    } else {
      while (remainingLen > 0) {
        const nextLen = remainingLen < 1e4 ? remainingLen : 1e4;
        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);
        decoder.pos += nextLen;
        encodedString += String.fromCodePoint.apply(
          null,
          /** @type {any} */
          bytes
        );
        remainingLen -= nextLen;
      }
    }
    return decodeURIComponent(escape(encodedString));
  }
};
var _readVarStringNative = (decoder) => (
  /** @type any */
  utf8TextDecoder.decode(readVarUint8Array(decoder))
);
var readVarString = utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;
var readFromDataView = (decoder, len) => {
  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len);
  decoder.pos += len;
  return dv;
};
var readFloat32 = (decoder) => readFromDataView(decoder, 4).getFloat32(0, false);
var readFloat64 = (decoder) => readFromDataView(decoder, 8).getFloat64(0, false);
var readBigInt64 = (decoder) => (
  /** @type {any} */
  readFromDataView(decoder, 8).getBigInt64(0, false)
);
var readAnyLookupTable = [
  (decoder) => void 0,
  // CASE 127: undefined
  (decoder) => null,
  // CASE 126: null
  readVarInt,
  // CASE 125: integer
  readFloat32,
  // CASE 124: float32
  readFloat64,
  // CASE 123: float64
  readBigInt64,
  // CASE 122: bigint
  (decoder) => false,
  // CASE 121: boolean (false)
  (decoder) => true,
  // CASE 120: boolean (true)
  readVarString,
  // CASE 119: string
  (decoder) => {
    const len = readVarUint(decoder);
    const obj = {};
    for (let i6 = 0; i6 < len; i6++) {
      const key = readVarString(decoder);
      obj[key] = readAny(decoder);
    }
    return obj;
  },
  (decoder) => {
    const len = readVarUint(decoder);
    const arr = [];
    for (let i6 = 0; i6 < len; i6++) {
      arr.push(readAny(decoder));
    }
    return arr;
  },
  readVarUint8Array
  // CASE 116: Uint8Array
];
var readAny = (decoder) => readAnyLookupTable[127 - readUint8(decoder)](decoder);
var RleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   * @param {function(Decoder):T} reader
   */
  constructor(uint8Array, reader) {
    super(uint8Array);
    this.reader = reader;
    this.s = null;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = this.reader(this);
      if (hasContent(this)) {
        this.count = readVarUint(this) + 1;
      } else {
        this.count = -1;
      }
    }
    this.count--;
    return (
      /** @type {T} */
      this.s
    );
  }
};
var UintOptRleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = readVarInt(this);
      const isNegative2 = isNegativeZero2(this.s);
      this.count = 1;
      if (isNegative2) {
        this.s = -this.s;
        this.count = readVarUint(this) + 2;
      }
    }
    this.count--;
    return (
      /** @type {number} */
      this.s
    );
  }
};
var IntDiffOptRleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  /**
   * @return {number}
   */
  read() {
    if (this.count === 0) {
      const diff = readVarInt(this);
      const hasCount = diff & 1;
      this.diff = floor(diff / 2);
      this.count = 1;
      if (hasCount) {
        this.count = readVarUint(this) + 2;
      }
    }
    this.s += this.diff;
    this.count--;
    return this.s;
  }
};
var StringDecoder = class {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    this.decoder = new UintOptRleDecoder(uint8Array);
    this.str = readVarString(this.decoder);
    this.spos = 0;
  }
  /**
   * @return {string}
   */
  read() {
    const end = this.spos + this.decoder.read();
    const res = this.str.slice(this.spos, end);
    this.spos = end;
    return res;
  }
};

// node_modules/lib0/time.js
var getUnixTime = Date.now;

// node_modules/lib0/map.js
var create3 = () => /* @__PURE__ */ new Map();
var copy = (m3) => {
  const r7 = create3();
  m3.forEach((v6, k2) => {
    r7.set(k2, v6);
  });
  return r7;
};
var setIfUndefined = (map4, key, createT) => {
  let set2 = map4.get(key);
  if (set2 === void 0) {
    map4.set(key, set2 = createT());
  }
  return set2;
};
var map = (m3, f6) => {
  const res = [];
  for (const [key, value2] of m3) {
    res.push(f6(value2, key));
  }
  return res;
};
var any = (m3, f6) => {
  for (const [key, value2] of m3) {
    if (f6(value2, key)) {
      return true;
    }
  }
  return false;
};

// node_modules/lib0/observable.js
var Observable = class {
  constructor() {
    this._observers = create3();
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  on(name2, f6) {
    setIfUndefined(this._observers, name2, create).add(f6);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  once(name2, f6) {
    const _f = (...args2) => {
      this.off(name2, _f);
      f6(...args2);
    };
    this.on(name2, _f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  off(name2, f6) {
    const observers = this._observers.get(name2);
    if (observers !== void 0) {
      observers.delete(f6);
      if (observers.size === 0) {
        this._observers.delete(name2);
      }
    }
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @param {N} name The event name.
   * @param {Array<any>} args The arguments that are applied to the event listener.
   */
  emit(name2, args2) {
    return from2((this._observers.get(name2) || create3()).values()).forEach((f6) => f6(...args2));
  }
  destroy() {
    this._observers = create3();
  }
};

// node_modules/lib0/webcrypto.js
var subtle = crypto.subtle;
var getRandomValues = crypto.getRandomValues.bind(crypto);

// node_modules/lib0/random.js
var uint32 = () => getRandomValues(new Uint32Array(1))[0];
var uuidv4Template = "10000000-1000-4000-8000" + -1e11;
var uuidv4 = () => uuidv4Template.replace(
  /[018]/g,
  /** @param {number} c */
  (c5) => (c5 ^ uint32() & 15 >> c5 / 4).toString(16)
);

// node_modules/lib0/promise.js
var create4 = (f6) => (
  /** @type {Promise<T>} */
  new Promise(f6)
);
var all = Promise.all.bind(Promise);

// node_modules/lib0/conditions.js
var undefinedToNull = (v6) => v6 === void 0 ? null : v6;

// node_modules/lib0/storage.js
var VarStoragePolyfill = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(key, newValue) {
    this.map.set(key, newValue);
  }
  /**
   * @param {string} key
   */
  getItem(key) {
    return this.map.get(key);
  }
};
var _localStorage = new VarStoragePolyfill();
var usePolyfill = true;
try {
  if (typeof localStorage !== "undefined" && localStorage) {
    _localStorage = localStorage;
    usePolyfill = false;
  }
} catch (e6) {
}
var varStorage = _localStorage;
var onChange = (eventHandler) => usePolyfill || addEventListener(
  "storage",
  /** @type {any} */
  eventHandler
);
var offChange = (eventHandler) => usePolyfill || removeEventListener(
  "storage",
  /** @type {any} */
  eventHandler
);

// node_modules/lib0/object.js
var assign = Object.assign;
var keys = Object.keys;
var forEach = (obj, f6) => {
  for (const key in obj) {
    f6(obj[key], key);
  }
};
var length2 = (obj) => keys(obj).length;
var isEmpty = (obj) => {
  for (const _k in obj) {
    return false;
  }
  return true;
};
var every = (obj, f6) => {
  for (const key in obj) {
    if (!f6(obj[key], key)) {
      return false;
    }
  }
  return true;
};
var hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
var equalFlat = (a3, b2) => a3 === b2 || length2(a3) === length2(b2) && every(a3, (val, key) => (val !== void 0 || hasProperty(b2, key)) && b2[key] === val);

// node_modules/lib0/function.js
var callAll = (fs, args2, i6 = 0) => {
  try {
    for (; i6 < fs.length; i6++) {
      fs[i6](...args2);
    }
  } finally {
    if (i6 < fs.length) {
      callAll(fs, args2, i6 + 1);
    }
  }
};
var id = (a3) => a3;
var equalityStrict = (a3, b2) => a3 === b2;
var equalityDeep = (a3, b2) => {
  if (a3 == null || b2 == null) {
    return equalityStrict(a3, b2);
  }
  if (a3.constructor !== b2.constructor) {
    return false;
  }
  if (a3 === b2) {
    return true;
  }
  switch (a3.constructor) {
    case ArrayBuffer:
      a3 = new Uint8Array(a3);
      b2 = new Uint8Array(b2);
    case Uint8Array: {
      if (a3.byteLength !== b2.byteLength) {
        return false;
      }
      for (let i6 = 0; i6 < a3.length; i6++) {
        if (a3[i6] !== b2[i6]) {
          return false;
        }
      }
      break;
    }
    case Set: {
      if (a3.size !== b2.size) {
        return false;
      }
      for (const value2 of a3) {
        if (!b2.has(value2)) {
          return false;
        }
      }
      break;
    }
    case Map: {
      if (a3.size !== b2.size) {
        return false;
      }
      for (const key of a3.keys()) {
        if (!b2.has(key) || !equalityDeep(a3.get(key), b2.get(key))) {
          return false;
        }
      }
      break;
    }
    case Object:
      if (length2(a3) !== length2(b2)) {
        return false;
      }
      for (const key in a3) {
        if (!hasProperty(a3, key) || !equalityDeep(a3[key], b2[key])) {
          return false;
        }
      }
      break;
    case Array:
      if (a3.length !== b2.length) {
        return false;
      }
      for (let i6 = 0; i6 < a3.length; i6++) {
        if (!equalityDeep(a3[i6], b2[i6])) {
          return false;
        }
      }
      break;
    default:
      return false;
  }
  return true;
};
var isOneOf = (value2, options) => options.includes(value2);

// node_modules/lib0/environment.js
var isNode = typeof process !== "undefined" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && !isNode;
var isMac = typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
var params;
var args = [];
var computeParams = () => {
  if (params === void 0) {
    if (isNode) {
      params = create3();
      const pargs = process.argv;
      let currParamName = null;
      for (let i6 = 0; i6 < pargs.length; i6++) {
        const parg = pargs[i6];
        if (parg[0] === "-") {
          if (currParamName !== null) {
            params.set(currParamName, "");
          }
          currParamName = parg;
        } else {
          if (currParamName !== null) {
            params.set(currParamName, parg);
            currParamName = null;
          } else {
            args.push(parg);
          }
        }
      }
      if (currParamName !== null) {
        params.set(currParamName, "");
      }
    } else if (typeof location === "object") {
      params = create3();
      (location.search || "?").slice(1).split("&").forEach((kv) => {
        if (kv.length !== 0) {
          const [key, value2] = kv.split("=");
          params.set(`--${fromCamelCase(key, "-")}`, value2);
          params.set(`-${fromCamelCase(key, "-")}`, value2);
        }
      });
    } else {
      params = create3();
    }
  }
  return params;
};
var hasParam = (name2) => computeParams().has(name2);
var getVariable = (name2) => isNode ? undefinedToNull(process.env[name2.toUpperCase().replaceAll("-", "_")]) : undefinedToNull(varStorage.getItem(name2));
var hasConf = (name2) => hasParam("--" + name2) || getVariable(name2) !== null;
var production = hasConf("production");
var forceColor = isNode && isOneOf(process.env.FORCE_COLOR, ["true", "1", "2"]);
var supportsColor = !hasParam("no-colors") && (!isNode || process.stdout.isTTY || forceColor) && (!isNode || hasParam("color") || forceColor || getVariable("COLORTERM") !== null || (getVariable("TERM") || "").includes("color"));

// node_modules/lib0/buffer.js
var createUint8ArrayFromLen = (len) => new Uint8Array(len);
var createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length4) => new Uint8Array(buffer, byteOffset, length4);
var createUint8ArrayFromArrayBuffer = (buffer) => new Uint8Array(buffer);
var toBase64Browser = (bytes) => {
  let s4 = "";
  for (let i6 = 0; i6 < bytes.byteLength; i6++) {
    s4 += fromCharCode(bytes[i6]);
  }
  return btoa(s4);
};
var toBase64Node = (bytes) => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString("base64");
var fromBase64Browser = (s4) => {
  const a3 = atob(s4);
  const bytes = createUint8ArrayFromLen(a3.length);
  for (let i6 = 0; i6 < a3.length; i6++) {
    bytes[i6] = a3.charCodeAt(i6);
  }
  return bytes;
};
var fromBase64Node = (s4) => {
  const buf = Buffer.from(s4, "base64");
  return createUint8ArrayViewFromArrayBuffer(buf.buffer, buf.byteOffset, buf.byteLength);
};
var toBase64 = isBrowser ? toBase64Browser : toBase64Node;
var fromBase64 = isBrowser ? fromBase64Browser : fromBase64Node;
var copyUint8Array = (uint8Array) => {
  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength);
  newBuf.set(uint8Array);
  return newBuf;
};

// node_modules/lib0/pair.js
var Pair = class {
  /**
   * @param {L} left
   * @param {R} right
   */
  constructor(left, right) {
    this.left = left;
    this.right = right;
  }
};
var create5 = (left, right) => new Pair(left, right);

// node_modules/lib0/dom.js
var doc = (
  /** @type {Document} */
  typeof document !== "undefined" ? document : {}
);
var domParser = (
  /** @type {DOMParser} */
  typeof DOMParser !== "undefined" ? new DOMParser() : null
);
var mapToStyleString = (m3) => map(m3, (value2, key) => `${key}:${value2};`).join("");
var ELEMENT_NODE = doc.ELEMENT_NODE;
var TEXT_NODE = doc.TEXT_NODE;
var CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE;
var COMMENT_NODE = doc.COMMENT_NODE;
var DOCUMENT_NODE = doc.DOCUMENT_NODE;
var DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE;
var DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE;

// node_modules/lib0/eventloop.js
var createTimeoutClass = (clearFunction) => class TT {
  /**
   * @param {number} timeoutId
   */
  constructor(timeoutId) {
    this._ = timeoutId;
  }
  destroy() {
    clearFunction(this._);
  }
};
var Timeout = createTimeoutClass(clearTimeout);
var Interval = createTimeoutClass(clearInterval);
var Animation = createTimeoutClass((arg) => typeof requestAnimationFrame !== "undefined" && cancelAnimationFrame(arg));
var Idle = createTimeoutClass((arg) => typeof cancelIdleCallback !== "undefined" && cancelIdleCallback(arg));

// node_modules/lib0/symbol.js
var create6 = Symbol;

// node_modules/lib0/logging.common.js
var BOLD = create6();
var UNBOLD = create6();
var BLUE = create6();
var GREY = create6();
var GREEN = create6();
var RED = create6();
var PURPLE = create6();
var ORANGE = create6();
var UNCOLOR = create6();
var computeNoColorLoggingArgs = (args2) => {
  const strBuilder = [];
  const logArgs = [];
  let i6 = 0;
  for (; i6 < args2.length; i6++) {
    const arg = args2[i6];
    if (arg.constructor === String || arg.constructor === Number) {
      strBuilder.push(arg);
    } else if (arg.constructor === Object) {
      logArgs.push(JSON.stringify(arg));
    }
  }
  return logArgs;
};
var lastLoggingTime = getUnixTime();

// node_modules/lib0/logging.js
var _browserStyleMap = {
  [BOLD]: create5("font-weight", "bold"),
  [UNBOLD]: create5("font-weight", "normal"),
  [BLUE]: create5("color", "blue"),
  [GREEN]: create5("color", "green"),
  [GREY]: create5("color", "grey"),
  [RED]: create5("color", "red"),
  [PURPLE]: create5("color", "purple"),
  [ORANGE]: create5("color", "orange"),
  // not well supported in chrome when debugging node with inspector - TODO: deprecate
  [UNCOLOR]: create5("color", "black")
};
var computeBrowserLoggingArgs = (args2) => {
  const strBuilder = [];
  const styles2 = [];
  const currentStyle = create3();
  let logArgs = [];
  let i6 = 0;
  for (; i6 < args2.length; i6++) {
    const arg = args2[i6];
    const style = _browserStyleMap[arg];
    if (style !== void 0) {
      currentStyle.set(style.left, style.right);
    } else {
      if (arg.constructor === String || arg.constructor === Number) {
        const style2 = mapToStyleString(currentStyle);
        if (i6 > 0 || style2.length > 0) {
          strBuilder.push("%c" + arg);
          styles2.push(style2);
        } else {
          strBuilder.push(arg);
        }
      } else {
        break;
      }
    }
  }
  if (i6 > 0) {
    logArgs = styles2;
    logArgs.unshift(strBuilder.join(""));
  }
  for (; i6 < args2.length; i6++) {
    const arg = args2[i6];
    if (!(arg instanceof Symbol)) {
      logArgs.push(arg);
    }
  }
  return logArgs;
};
var computeLoggingArgs = supportsColor ? computeBrowserLoggingArgs : computeNoColorLoggingArgs;
var print = (...args2) => {
  console.log(...computeLoggingArgs(args2));
  vconsoles.forEach((vc) => vc.print(args2));
};
var vconsoles = create();

// node_modules/lib0/iterator.js
var createIterator = (next2) => ({
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return this;
  },
  // @ts-ignore
  next: next2
});
var iteratorFilter = (iterator, filter3) => createIterator(() => {
  let res;
  do {
    res = iterator.next();
  } while (!res.done && !filter3(res.value));
  return res;
});
var iteratorMap = (iterator, fmap) => createIterator(() => {
  const { done, value: value2 } = iterator.next();
  return { done, value: done ? void 0 : fmap(value2) };
});

// node_modules/yjs/dist/yjs.mjs
var DeleteItem = class {
  /**
   * @param {number} clock
   * @param {number} len
   */
  constructor(clock, len) {
    this.clock = clock;
    this.len = len;
  }
};
var DeleteSet = class {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
};
var iterateDeletedStructs = (transaction, ds, f6) => ds.clients.forEach((deletes, clientid) => {
  const structs = (
    /** @type {Array<GC|Item>} */
    transaction.doc.store.clients.get(clientid)
  );
  for (let i6 = 0; i6 < deletes.length; i6++) {
    const del2 = deletes[i6];
    iterateStructs(transaction, structs, del2.clock, del2.len, f6);
  }
});
var findIndexDS = (dis, clock) => {
  let left = 0;
  let right = dis.length - 1;
  while (left <= right) {
    const midindex = floor((left + right) / 2);
    const mid = dis[midindex];
    const midclock = mid.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.len) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
  }
  return null;
};
var isDeleted = (ds, id2) => {
  const dis = ds.clients.get(id2.client);
  return dis !== void 0 && findIndexDS(dis, id2.clock) !== null;
};
var sortAndMergeDeleteSet = (ds) => {
  ds.clients.forEach((dels) => {
    dels.sort((a3, b2) => a3.clock - b2.clock);
    let i6, j4;
    for (i6 = 1, j4 = 1; i6 < dels.length; i6++) {
      const left = dels[j4 - 1];
      const right = dels[i6];
      if (left.clock + left.len >= right.clock) {
        left.len = max2(left.len, right.clock + right.len - left.clock);
      } else {
        if (j4 < i6) {
          dels[j4] = right;
        }
        j4++;
      }
    }
    dels.length = j4;
  });
};
var mergeDeleteSets = (dss) => {
  const merged = new DeleteSet();
  for (let dssI = 0; dssI < dss.length; dssI++) {
    dss[dssI].clients.forEach((delsLeft, client) => {
      if (!merged.clients.has(client)) {
        const dels = delsLeft.slice();
        for (let i6 = dssI + 1; i6 < dss.length; i6++) {
          appendTo(dels, dss[i6].clients.get(client) || []);
        }
        merged.clients.set(client, dels);
      }
    });
  }
  sortAndMergeDeleteSet(merged);
  return merged;
};
var addToDeleteSet = (ds, client, clock, length4) => {
  setIfUndefined(ds.clients, client, () => (
    /** @type {Array<DeleteItem>} */
    []
  )).push(new DeleteItem(clock, length4));
};
var createDeleteSet = () => new DeleteSet();
var createDeleteSetFromStructStore = (ss) => {
  const ds = createDeleteSet();
  ss.clients.forEach((structs, client) => {
    const dsitems = [];
    for (let i6 = 0; i6 < structs.length; i6++) {
      const struct = structs[i6];
      if (struct.deleted) {
        const clock = struct.id.clock;
        let len = struct.length;
        if (i6 + 1 < structs.length) {
          for (let next2 = structs[i6 + 1]; i6 + 1 < structs.length && next2.deleted; next2 = structs[++i6 + 1]) {
            len += next2.length;
          }
        }
        dsitems.push(new DeleteItem(clock, len));
      }
    }
    if (dsitems.length > 0) {
      ds.clients.set(client, dsitems);
    }
  });
  return ds;
};
var writeDeleteSet = (encoder, ds) => {
  writeVarUint(encoder.restEncoder, ds.clients.size);
  from2(ds.clients.entries()).sort((a3, b2) => b2[0] - a3[0]).forEach(([client, dsitems]) => {
    encoder.resetDsCurVal();
    writeVarUint(encoder.restEncoder, client);
    const len = dsitems.length;
    writeVarUint(encoder.restEncoder, len);
    for (let i6 = 0; i6 < len; i6++) {
      const item2 = dsitems[i6];
      encoder.writeDsClock(item2.clock);
      encoder.writeDsLen(item2.len);
    }
  });
};
var readDeleteSet = (decoder) => {
  const ds = new DeleteSet();
  const numClients = readVarUint(decoder.restDecoder);
  for (let i6 = 0; i6 < numClients; i6++) {
    decoder.resetDsCurVal();
    const client = readVarUint(decoder.restDecoder);
    const numberOfDeletes = readVarUint(decoder.restDecoder);
    if (numberOfDeletes > 0) {
      const dsField = setIfUndefined(ds.clients, client, () => (
        /** @type {Array<DeleteItem>} */
        []
      ));
      for (let i7 = 0; i7 < numberOfDeletes; i7++) {
        dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));
      }
    }
  }
  return ds;
};
var readAndApplyDeleteSet = (decoder, transaction, store2) => {
  const unappliedDS = new DeleteSet();
  const numClients = readVarUint(decoder.restDecoder);
  for (let i6 = 0; i6 < numClients; i6++) {
    decoder.resetDsCurVal();
    const client = readVarUint(decoder.restDecoder);
    const numberOfDeletes = readVarUint(decoder.restDecoder);
    const structs = store2.clients.get(client) || [];
    const state = getState(store2, client);
    for (let i7 = 0; i7 < numberOfDeletes; i7++) {
      const clock = decoder.readDsClock();
      const clockEnd = clock + decoder.readDsLen();
      if (clock < state) {
        if (state < clockEnd) {
          addToDeleteSet(unappliedDS, client, state, clockEnd - state);
        }
        let index3 = findIndexSS(structs, clock);
        let struct = structs[index3];
        if (!struct.deleted && struct.id.clock < clock) {
          structs.splice(index3 + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
          index3++;
        }
        while (index3 < structs.length) {
          struct = structs[index3++];
          if (struct.id.clock < clockEnd) {
            if (!struct.deleted) {
              if (clockEnd < struct.id.clock + struct.length) {
                structs.splice(index3, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));
              }
              struct.delete(transaction);
            }
          } else {
            break;
          }
        }
      } else {
        addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);
      }
    }
  }
  if (unappliedDS.clients.size > 0) {
    const ds = new UpdateEncoderV2();
    writeVarUint(ds.restEncoder, 0);
    writeDeleteSet(ds, unappliedDS);
    return ds.toUint8Array();
  }
  return null;
};
var generateNewClientId = uint32;
var Doc = class _Doc extends Observable {
  /**
   * @param {DocOpts} opts configuration
   */
  constructor({ guid = uuidv4(), collectionid = null, gc = true, gcFilter = () => true, meta = null, autoLoad = false, shouldLoad = true } = {}) {
    super();
    this.gc = gc;
    this.gcFilter = gcFilter;
    this.clientID = generateNewClientId();
    this.guid = guid;
    this.collectionid = collectionid;
    this.share = /* @__PURE__ */ new Map();
    this.store = new StructStore();
    this._transaction = null;
    this._transactionCleanups = [];
    this.subdocs = /* @__PURE__ */ new Set();
    this._item = null;
    this.shouldLoad = shouldLoad;
    this.autoLoad = autoLoad;
    this.meta = meta;
    this.isLoaded = false;
    this.isSynced = false;
    this.whenLoaded = create4((resolve3) => {
      this.on("load", () => {
        this.isLoaded = true;
        resolve3(this);
      });
    });
    const provideSyncedPromise = () => create4((resolve3) => {
      const eventHandler = (isSynced) => {
        if (isSynced === void 0 || isSynced === true) {
          this.off("sync", eventHandler);
          resolve3();
        }
      };
      this.on("sync", eventHandler);
    });
    this.on("sync", (isSynced) => {
      if (isSynced === false && this.isSynced) {
        this.whenSynced = provideSyncedPromise();
      }
      this.isSynced = isSynced === void 0 || isSynced === true;
      if (this.isSynced && !this.isLoaded) {
        this.emit("load", []);
      }
    });
    this.whenSynced = provideSyncedPromise();
  }
  /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */
  load() {
    const item2 = this._item;
    if (item2 !== null && !this.shouldLoad) {
      transact(
        /** @type {any} */
        item2.parent.doc,
        (transaction) => {
          transaction.subdocsLoaded.add(this);
        },
        null,
        true
      );
    }
    this.shouldLoad = true;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(from2(this.subdocs).map((doc2) => doc2.guid));
  }
  /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @template T
   * @param {function(Transaction):T} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   * @return T
   *
   * @public
   */
  transact(f6, origin = null) {
    return transact(this, f6, origin);
  }
  /**
   * Define a shared data type.
   *
   * Multiple calls of `y.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `y.define(name, Y.Array) === y.define(name, Y.Array)`
   *
   * After this method is called, the type is also available on `y.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Yjs instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @template {typeof AbstractType<any>} Type
   * @example
   *   const y = new Y(..)
   *   const appState = {
   *     document: y.getText('document')
   *     comments: y.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor
   *
   * @public
   */
  get(name2, TypeConstructor = (
    /** @type {any} */
    AbstractType
  )) {
    const type2 = setIfUndefined(this.share, name2, () => {
      const t5 = new TypeConstructor();
      t5._integrate(this, null);
      return t5;
    });
    const Constr = type2.constructor;
    if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {
      if (Constr === AbstractType) {
        const t5 = new TypeConstructor();
        t5._map = type2._map;
        type2._map.forEach(
          /** @param {Item?} n */
          (n6) => {
            for (; n6 !== null; n6 = n6.left) {
              n6.parent = t5;
            }
          }
        );
        t5._start = type2._start;
        for (let n6 = t5._start; n6 !== null; n6 = n6.right) {
          n6.parent = t5;
        }
        t5._length = type2._length;
        this.share.set(name2, t5);
        t5._integrate(this, null);
        return (
          /** @type {InstanceType<Type>} */
          t5
        );
      } else {
        throw new Error(`Type with the name ${name2} has already been defined with a different constructor`);
      }
    }
    return (
      /** @type {InstanceType<Type>} */
      type2
    );
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */
  getArray(name2 = "") {
    return (
      /** @type {YArray<T>} */
      this.get(name2, YArray)
    );
  }
  /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */
  getText(name2 = "") {
    return this.get(name2, YText);
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */
  getMap(name2 = "") {
    return (
      /** @type {YMap<T>} */
      this.get(name2, YMap)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlElement}
   *
   * @public
   */
  getXmlElement(name2 = "") {
    return (
      /** @type {YXmlElement<{[key:string]:string}>} */
      this.get(name2, YXmlElement)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */
  getXmlFragment(name2 = "") {
    return this.get(name2, YXmlFragment);
  }
  /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */
  toJSON() {
    const doc2 = {};
    this.share.forEach((value2, key) => {
      doc2[key] = value2.toJSON();
    });
    return doc2;
  }
  /**
   * Emit `destroy` event and unregister all event handlers.
   */
  destroy() {
    from2(this.subdocs).forEach((subdoc) => subdoc.destroy());
    const item2 = this._item;
    if (item2 !== null) {
      this._item = null;
      const content3 = (
        /** @type {ContentDoc} */
        item2.content
      );
      content3.doc = new _Doc({ guid: this.guid, ...content3.opts, shouldLoad: false });
      content3.doc._item = item2;
      transact(
        /** @type {any} */
        item2.parent.doc,
        (transaction) => {
          const doc2 = content3.doc;
          if (!item2.deleted) {
            transaction.subdocsAdded.add(doc2);
          }
          transaction.subdocsRemoved.add(this);
        },
        null,
        true
      );
    }
    this.emit("destroyed", [true]);
    this.emit("destroy", [this]);
    super.destroy();
  }
  /**
   * @param {string} eventName
   * @param {function(...any):any} f
   */
  on(eventName, f6) {
    super.on(eventName, f6);
  }
  /**
   * @param {string} eventName
   * @param {function} f
   */
  off(eventName, f6) {
    super.off(eventName, f6);
  }
};
var DSDecoderV1 = class {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    this.restDecoder = decoder;
  }
  resetDsCurVal() {
  }
  /**
   * @return {number}
   */
  readDsClock() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {number}
   */
  readDsLen() {
    return readVarUint(this.restDecoder);
  }
};
var UpdateDecoderV1 = class extends DSDecoderV1 {
  /**
   * @return {ID}
   */
  readLeftID() {
    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return readUint8(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readString() {
    return readVarString(this.restDecoder);
  }
  /**
   * @return {boolean} isKey
   */
  readParentInfo() {
    return readVarUint(this.restDecoder) === 1;
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readTypeRef() {
    return readVarUint(this.restDecoder);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number} len
   */
  readLen() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {any}
   */
  readAny() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return copyUint8Array(readVarUint8Array(this.restDecoder));
  }
  /**
   * Legacy implementation uses JSON parse. We use any-decoding in v2.
   *
   * @return {any}
   */
  readJSON() {
    return JSON.parse(readVarString(this.restDecoder));
  }
  /**
   * @return {string}
   */
  readKey() {
    return readVarString(this.restDecoder);
  }
};
var DSDecoderV2 = class {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    this.dsCurrVal = 0;
    this.restDecoder = decoder;
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @return {number}
   */
  readDsClock() {
    this.dsCurrVal += readVarUint(this.restDecoder);
    return this.dsCurrVal;
  }
  /**
   * @return {number}
   */
  readDsLen() {
    const diff = readVarUint(this.restDecoder) + 1;
    this.dsCurrVal += diff;
    return diff;
  }
};
var UpdateDecoderV2 = class extends DSDecoderV2 {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    super(decoder);
    this.keys = [];
    readVarUint(decoder);
    this.keyClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.clientDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
    this.leftClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.rightClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.infoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
    this.stringDecoder = new StringDecoder(readVarUint8Array(decoder));
    this.parentInfoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
    this.typeRefDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
    this.lenDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
  }
  /**
   * @return {ID}
   */
  readLeftID() {
    return new ID(this.clientDecoder.read(), this.leftClockDecoder.read());
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return new ID(this.clientDecoder.read(), this.rightClockDecoder.read());
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return this.clientDecoder.read();
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return (
      /** @type {number} */
      this.infoDecoder.read()
    );
  }
  /**
   * @return {string}
   */
  readString() {
    return this.stringDecoder.read();
  }
  /**
   * @return {boolean}
   */
  readParentInfo() {
    return this.parentInfoDecoder.read() === 1;
  }
  /**
   * @return {number} An unsigned 8-bit integer
   */
  readTypeRef() {
    return this.typeRefDecoder.read();
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number}
   */
  readLen() {
    return this.lenDecoder.read();
  }
  /**
   * @return {any}
   */
  readAny() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return readVarUint8Array(this.restDecoder);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @return {any}
   */
  readJSON() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readKey() {
    const keyClock = this.keyClockDecoder.read();
    if (keyClock < this.keys.length) {
      return this.keys[keyClock];
    } else {
      const key = this.stringDecoder.read();
      this.keys.push(key);
      return key;
    }
  }
};
var DSEncoderV1 = class {
  constructor() {
    this.restEncoder = createEncoder();
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
  }
  /**
   * @param {number} clock
   */
  writeDsClock(clock) {
    writeVarUint(this.restEncoder, clock);
  }
  /**
   * @param {number} len
   */
  writeDsLen(len) {
    writeVarUint(this.restEncoder, len);
  }
};
var UpdateEncoderV1 = class extends DSEncoderV1 {
  /**
   * @param {ID} id
   */
  writeLeftID(id2) {
    writeVarUint(this.restEncoder, id2.client);
    writeVarUint(this.restEncoder, id2.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(id2) {
    writeVarUint(this.restEncoder, id2.client);
    writeVarUint(this.restEncoder, id2.clock);
  }
  /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */
  writeClient(client) {
    writeVarUint(this.restEncoder, client);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(info) {
    writeUint8(this.restEncoder, info);
  }
  /**
   * @param {string} s
   */
  writeString(s4) {
    writeVarString(this.restEncoder, s4);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(isYKey) {
    writeVarUint(this.restEncoder, isYKey ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(info) {
    writeVarUint(this.restEncoder, info);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(len) {
    writeVarUint(this.restEncoder, len);
  }
  /**
   * @param {any} any
   */
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  /**
   * @param {any} embed
   */
  writeJSON(embed) {
    writeVarString(this.restEncoder, JSON.stringify(embed));
  }
  /**
   * @param {string} key
   */
  writeKey(key) {
    writeVarString(this.restEncoder, key);
  }
};
var DSEncoderV2 = class {
  constructor() {
    this.restEncoder = createEncoder();
    this.dsCurrVal = 0;
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @param {number} clock
   */
  writeDsClock(clock) {
    const diff = clock - this.dsCurrVal;
    this.dsCurrVal = clock;
    writeVarUint(this.restEncoder, diff);
  }
  /**
   * @param {number} len
   */
  writeDsLen(len) {
    if (len === 0) {
      unexpectedCase();
    }
    writeVarUint(this.restEncoder, len - 1);
    this.dsCurrVal += len;
  }
};
var UpdateEncoderV2 = class extends DSEncoderV2 {
  constructor() {
    super();
    this.keyMap = /* @__PURE__ */ new Map();
    this.keyClock = 0;
    this.keyClockEncoder = new IntDiffOptRleEncoder();
    this.clientEncoder = new UintOptRleEncoder();
    this.leftClockEncoder = new IntDiffOptRleEncoder();
    this.rightClockEncoder = new IntDiffOptRleEncoder();
    this.infoEncoder = new RleEncoder(writeUint8);
    this.stringEncoder = new StringEncoder();
    this.parentInfoEncoder = new RleEncoder(writeUint8);
    this.typeRefEncoder = new UintOptRleEncoder();
    this.lenEncoder = new UintOptRleEncoder();
  }
  toUint8Array() {
    const encoder = createEncoder();
    writeVarUint(encoder, 0);
    writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, toUint8Array(this.infoEncoder));
    writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());
    writeVarUint8Array(encoder, toUint8Array(this.parentInfoEncoder));
    writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());
    writeUint8Array(encoder, toUint8Array(this.restEncoder));
    return toUint8Array(encoder);
  }
  /**
   * @param {ID} id
   */
  writeLeftID(id2) {
    this.clientEncoder.write(id2.client);
    this.leftClockEncoder.write(id2.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(id2) {
    this.clientEncoder.write(id2.client);
    this.rightClockEncoder.write(id2.clock);
  }
  /**
   * @param {number} client
   */
  writeClient(client) {
    this.clientEncoder.write(client);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(info) {
    this.infoEncoder.write(info);
  }
  /**
   * @param {string} s
   */
  writeString(s4) {
    this.stringEncoder.write(s4);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(isYKey) {
    this.parentInfoEncoder.write(isYKey ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(info) {
    this.typeRefEncoder.write(info);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(len) {
    this.lenEncoder.write(len);
  }
  /**
   * @param {any} any
   */
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */
  writeJSON(embed) {
    writeAny(this.restEncoder, embed);
  }
  /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */
  writeKey(key) {
    const clock = this.keyMap.get(key);
    if (clock === void 0) {
      this.keyClockEncoder.write(this.keyClock++);
      this.stringEncoder.write(key);
    } else {
      this.keyClockEncoder.write(clock);
    }
  }
};
var writeStructs = (encoder, structs, client, clock) => {
  clock = max2(clock, structs[0].id.clock);
  const startNewStructs = findIndexSS(structs, clock);
  writeVarUint(encoder.restEncoder, structs.length - startNewStructs);
  encoder.writeClient(client);
  writeVarUint(encoder.restEncoder, clock);
  const firstStruct = structs[startNewStructs];
  firstStruct.write(encoder, clock - firstStruct.id.clock);
  for (let i6 = startNewStructs + 1; i6 < structs.length; i6++) {
    structs[i6].write(encoder, 0);
  }
};
var writeClientsStructs = (encoder, store2, _sm) => {
  const sm = /* @__PURE__ */ new Map();
  _sm.forEach((clock, client) => {
    if (getState(store2, client) > clock) {
      sm.set(client, clock);
    }
  });
  getStateVector(store2).forEach((_clock, client) => {
    if (!_sm.has(client)) {
      sm.set(client, 0);
    }
  });
  writeVarUint(encoder.restEncoder, sm.size);
  from2(sm.entries()).sort((a3, b2) => b2[0] - a3[0]).forEach(([client, clock]) => {
    writeStructs(
      encoder,
      /** @type {Array<GC|Item>} */
      store2.clients.get(client),
      client,
      clock
    );
  });
};
var readClientsStructRefs = (decoder, doc2) => {
  const clientRefs = create3();
  const numOfStateUpdates = readVarUint(decoder.restDecoder);
  for (let i6 = 0; i6 < numOfStateUpdates; i6++) {
    const numberOfStructs = readVarUint(decoder.restDecoder);
    const refs = new Array(numberOfStructs);
    const client = decoder.readClient();
    let clock = readVarUint(decoder.restDecoder);
    clientRefs.set(client, { i: 0, refs });
    for (let i7 = 0; i7 < numberOfStructs; i7++) {
      const info = decoder.readInfo();
      switch (BITS5 & info) {
        case 0: {
          const len = decoder.readLen();
          refs[i7] = new GC(createID(client, clock), len);
          clock += len;
          break;
        }
        case 10: {
          const len = readVarUint(decoder.restDecoder);
          refs[i7] = new Skip(createID(client, clock), len);
          clock += len;
          break;
        }
        default: {
          const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
          const struct = new Item(
            createID(client, clock),
            null,
            // leftd
            (info & BIT8) === BIT8 ? decoder.readLeftID() : null,
            // origin
            null,
            // right
            (info & BIT7) === BIT7 ? decoder.readRightID() : null,
            // right origin
            cantCopyParentInfo ? decoder.readParentInfo() ? doc2.get(decoder.readString()) : decoder.readLeftID() : null,
            // parent
            cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,
            // parentSub
            readItemContent(decoder, info)
            // item content
          );
          refs[i7] = struct;
          clock += struct.length;
        }
      }
    }
  }
  return clientRefs;
};
var integrateStructs = (transaction, store2, clientsStructRefs) => {
  const stack = [];
  let clientsStructRefsIds = from2(clientsStructRefs.keys()).sort((a3, b2) => a3 - b2);
  if (clientsStructRefsIds.length === 0) {
    return null;
  }
  const getNextStructTarget = () => {
    if (clientsStructRefsIds.length === 0) {
      return null;
    }
    let nextStructsTarget = (
      /** @type {{i:number,refs:Array<GC|Item>}} */
      clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1])
    );
    while (nextStructsTarget.refs.length === nextStructsTarget.i) {
      clientsStructRefsIds.pop();
      if (clientsStructRefsIds.length > 0) {
        nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */
        clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
      } else {
        return null;
      }
    }
    return nextStructsTarget;
  };
  let curStructsTarget = getNextStructTarget();
  if (curStructsTarget === null) {
    return null;
  }
  const restStructs = new StructStore();
  const missingSV = /* @__PURE__ */ new Map();
  const updateMissingSv = (client, clock) => {
    const mclock = missingSV.get(client);
    if (mclock == null || mclock > clock) {
      missingSV.set(client, clock);
    }
  };
  let stackHead = (
    /** @type {any} */
    curStructsTarget.refs[
      /** @type {any} */
      curStructsTarget.i++
    ]
  );
  const state = /* @__PURE__ */ new Map();
  const addStackToRestSS = () => {
    for (const item2 of stack) {
      const client = item2.id.client;
      const unapplicableItems = clientsStructRefs.get(client);
      if (unapplicableItems) {
        unapplicableItems.i--;
        restStructs.clients.set(client, unapplicableItems.refs.slice(unapplicableItems.i));
        clientsStructRefs.delete(client);
        unapplicableItems.i = 0;
        unapplicableItems.refs = [];
      } else {
        restStructs.clients.set(client, [item2]);
      }
      clientsStructRefsIds = clientsStructRefsIds.filter((c5) => c5 !== client);
    }
    stack.length = 0;
  };
  while (true) {
    if (stackHead.constructor !== Skip) {
      const localClock = setIfUndefined(state, stackHead.id.client, () => getState(store2, stackHead.id.client));
      const offset = localClock - stackHead.id.clock;
      if (offset < 0) {
        stack.push(stackHead);
        updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);
        addStackToRestSS();
      } else {
        const missing = stackHead.getMissing(transaction, store2);
        if (missing !== null) {
          stack.push(stackHead);
          const structRefs = clientsStructRefs.get(
            /** @type {number} */
            missing
          ) || { refs: [], i: 0 };
          if (structRefs.refs.length === structRefs.i) {
            updateMissingSv(
              /** @type {number} */
              missing,
              getState(store2, missing)
            );
            addStackToRestSS();
          } else {
            stackHead = structRefs.refs[structRefs.i++];
            continue;
          }
        } else if (offset === 0 || offset < stackHead.length) {
          stackHead.integrate(transaction, offset);
          state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);
        }
      }
    }
    if (stack.length > 0) {
      stackHead = /** @type {GC|Item} */
      stack.pop();
    } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {
      stackHead = /** @type {GC|Item} */
      curStructsTarget.refs[curStructsTarget.i++];
    } else {
      curStructsTarget = getNextStructTarget();
      if (curStructsTarget === null) {
        break;
      } else {
        stackHead = /** @type {GC|Item} */
        curStructsTarget.refs[curStructsTarget.i++];
      }
    }
  }
  if (restStructs.clients.size > 0) {
    const encoder = new UpdateEncoderV2();
    writeClientsStructs(encoder, restStructs, /* @__PURE__ */ new Map());
    writeVarUint(encoder.restEncoder, 0);
    return { missing: missingSV, update: encoder.toUint8Array() };
  }
  return null;
};
var writeStructsFromTransaction = (encoder, transaction) => writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);
var readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) => transact(ydoc, (transaction) => {
  transaction.local = false;
  let retry = false;
  const doc2 = transaction.doc;
  const store2 = doc2.store;
  const ss = readClientsStructRefs(structDecoder, doc2);
  const restStructs = integrateStructs(transaction, store2, ss);
  const pending = store2.pendingStructs;
  if (pending) {
    for (const [client, clock] of pending.missing) {
      if (clock < getState(store2, client)) {
        retry = true;
        break;
      }
    }
    if (restStructs) {
      for (const [client, clock] of restStructs.missing) {
        const mclock = pending.missing.get(client);
        if (mclock == null || mclock > clock) {
          pending.missing.set(client, clock);
        }
      }
      pending.update = mergeUpdatesV2([pending.update, restStructs.update]);
    }
  } else {
    store2.pendingStructs = restStructs;
  }
  const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store2);
  if (store2.pendingDs) {
    const pendingDSUpdate = new UpdateDecoderV2(createDecoder(store2.pendingDs));
    readVarUint(pendingDSUpdate.restDecoder);
    const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store2);
    if (dsRest && dsRest2) {
      store2.pendingDs = mergeUpdatesV2([dsRest, dsRest2]);
    } else {
      store2.pendingDs = dsRest || dsRest2;
    }
  } else {
    store2.pendingDs = dsRest;
  }
  if (retry) {
    const update = (
      /** @type {{update: Uint8Array}} */
      store2.pendingStructs.update
    );
    store2.pendingStructs = null;
    applyUpdateV2(transaction.doc, update);
  }
}, transactionOrigin, false);
var applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) => {
  const decoder = createDecoder(update);
  readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));
};
var applyUpdate = (ydoc, update, transactionOrigin) => applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1);
var writeStateAsUpdate = (encoder, doc2, targetStateVector = /* @__PURE__ */ new Map()) => {
  writeClientsStructs(encoder, doc2.store, targetStateVector);
  writeDeleteSet(encoder, createDeleteSetFromStructStore(doc2.store));
};
var encodeStateAsUpdateV2 = (doc2, encodedTargetStateVector = new Uint8Array([0]), encoder = new UpdateEncoderV2()) => {
  const targetStateVector = decodeStateVector(encodedTargetStateVector);
  writeStateAsUpdate(encoder, doc2, targetStateVector);
  const updates = [encoder.toUint8Array()];
  if (doc2.store.pendingDs) {
    updates.push(doc2.store.pendingDs);
  }
  if (doc2.store.pendingStructs) {
    updates.push(diffUpdateV2(doc2.store.pendingStructs.update, encodedTargetStateVector));
  }
  if (updates.length > 1) {
    if (encoder.constructor === UpdateEncoderV1) {
      return mergeUpdates(updates.map((update, i6) => i6 === 0 ? update : convertUpdateFormatV2ToV1(update)));
    } else if (encoder.constructor === UpdateEncoderV2) {
      return mergeUpdatesV2(updates);
    }
  }
  return updates[0];
};
var encodeStateAsUpdate = (doc2, encodedTargetStateVector) => encodeStateAsUpdateV2(doc2, encodedTargetStateVector, new UpdateEncoderV1());
var readStateVector = (decoder) => {
  const ss = /* @__PURE__ */ new Map();
  const ssLength = readVarUint(decoder.restDecoder);
  for (let i6 = 0; i6 < ssLength; i6++) {
    const client = readVarUint(decoder.restDecoder);
    const clock = readVarUint(decoder.restDecoder);
    ss.set(client, clock);
  }
  return ss;
};
var decodeStateVector = (decodedState) => readStateVector(new DSDecoderV1(createDecoder(decodedState)));
var writeStateVector = (encoder, sv) => {
  writeVarUint(encoder.restEncoder, sv.size);
  from2(sv.entries()).sort((a3, b2) => b2[0] - a3[0]).forEach(([client, clock]) => {
    writeVarUint(encoder.restEncoder, client);
    writeVarUint(encoder.restEncoder, clock);
  });
  return encoder;
};
var writeDocumentStateVector = (encoder, doc2) => writeStateVector(encoder, getStateVector(doc2.store));
var encodeStateVectorV2 = (doc2, encoder = new DSEncoderV2()) => {
  if (doc2 instanceof Map) {
    writeStateVector(encoder, doc2);
  } else {
    writeDocumentStateVector(encoder, doc2);
  }
  return encoder.toUint8Array();
};
var encodeStateVector = (doc2) => encodeStateVectorV2(doc2, new DSEncoderV1());
var EventHandler = class {
  constructor() {
    this.l = [];
  }
};
var createEventHandler = () => new EventHandler();
var addEventHandlerListener = (eventHandler, f6) => eventHandler.l.push(f6);
var removeEventHandlerListener = (eventHandler, f6) => {
  const l7 = eventHandler.l;
  const len = l7.length;
  eventHandler.l = l7.filter((g4) => f6 !== g4);
  if (len === eventHandler.l.length) {
    console.error("[yjs] Tried to remove event handler that doesn't exist.");
  }
};
var callEventHandlerListeners = (eventHandler, arg0, arg1) => callAll(eventHandler.l, [arg0, arg1]);
var ID = class {
  /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */
  constructor(client, clock) {
    this.client = client;
    this.clock = clock;
  }
};
var compareIDs = (a3, b2) => a3 === b2 || a3 !== null && b2 !== null && a3.client === b2.client && a3.clock === b2.clock;
var createID = (client, clock) => new ID(client, clock);
var findRootTypeKey = (type2) => {
  for (const [key, value2] of type2.doc.share.entries()) {
    if (value2 === type2) {
      return key;
    }
  }
  throw unexpectedCase();
};
var Snapshot = class {
  /**
   * @param {DeleteSet} ds
   * @param {Map<number,number>} sv state map
   */
  constructor(ds, sv) {
    this.ds = ds;
    this.sv = sv;
  }
};
var createSnapshot = (ds, sm) => new Snapshot(ds, sm);
var emptySnapshot = createSnapshot(createDeleteSet(), /* @__PURE__ */ new Map());
var isVisible = (item2, snapshot) => snapshot === void 0 ? !item2.deleted : snapshot.sv.has(item2.id.client) && (snapshot.sv.get(item2.id.client) || 0) > item2.id.clock && !isDeleted(snapshot.ds, item2.id);
var splitSnapshotAffectedStructs = (transaction, snapshot) => {
  const meta = setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, create);
  const store2 = transaction.doc.store;
  if (!meta.has(snapshot)) {
    snapshot.sv.forEach((clock, client) => {
      if (clock < getState(store2, client)) {
        getItemCleanStart(transaction, createID(client, clock));
      }
    });
    iterateDeletedStructs(transaction, snapshot.ds, (_item) => {
    });
    meta.add(snapshot);
  }
};
var StructStore = class {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
    this.pendingStructs = null;
    this.pendingDs = null;
  }
};
var getStateVector = (store2) => {
  const sm = /* @__PURE__ */ new Map();
  store2.clients.forEach((structs, client) => {
    const struct = structs[structs.length - 1];
    sm.set(client, struct.id.clock + struct.length);
  });
  return sm;
};
var getState = (store2, client) => {
  const structs = store2.clients.get(client);
  if (structs === void 0) {
    return 0;
  }
  const lastStruct = structs[structs.length - 1];
  return lastStruct.id.clock + lastStruct.length;
};
var addStruct = (store2, struct) => {
  let structs = store2.clients.get(struct.id.client);
  if (structs === void 0) {
    structs = [];
    store2.clients.set(struct.id.client, structs);
  } else {
    const lastStruct = structs[structs.length - 1];
    if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {
      throw unexpectedCase();
    }
  }
  structs.push(struct);
};
var findIndexSS = (structs, clock) => {
  let left = 0;
  let right = structs.length - 1;
  let mid = structs[right];
  let midclock = mid.id.clock;
  if (midclock === clock) {
    return right;
  }
  let midindex = floor(clock / (midclock + mid.length - 1) * right);
  while (left <= right) {
    mid = structs[midindex];
    midclock = mid.id.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.length) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
    midindex = floor((left + right) / 2);
  }
  throw unexpectedCase();
};
var find = (store2, id2) => {
  const structs = store2.clients.get(id2.client);
  return structs[findIndexSS(structs, id2.clock)];
};
var getItem = (
  /** @type {function(StructStore,ID):Item} */
  find
);
var findIndexCleanStart = (transaction, structs, clock) => {
  const index3 = findIndexSS(structs, clock);
  const struct = structs[index3];
  if (struct.id.clock < clock && struct instanceof Item) {
    structs.splice(index3 + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
    return index3 + 1;
  }
  return index3;
};
var getItemCleanStart = (transaction, id2) => {
  const structs = (
    /** @type {Array<Item>} */
    transaction.doc.store.clients.get(id2.client)
  );
  return structs[findIndexCleanStart(transaction, structs, id2.clock)];
};
var getItemCleanEnd = (transaction, store2, id2) => {
  const structs = store2.clients.get(id2.client);
  const index3 = findIndexSS(structs, id2.clock);
  const struct = structs[index3];
  if (id2.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {
    structs.splice(index3 + 1, 0, splitItem(transaction, struct, id2.clock - struct.id.clock + 1));
  }
  return struct;
};
var replaceStruct = (store2, struct, newStruct) => {
  const structs = (
    /** @type {Array<GC|Item>} */
    store2.clients.get(struct.id.client)
  );
  structs[findIndexSS(structs, struct.id.clock)] = newStruct;
};
var iterateStructs = (transaction, structs, clockStart, len, f6) => {
  if (len === 0) {
    return;
  }
  const clockEnd = clockStart + len;
  let index3 = findIndexCleanStart(transaction, structs, clockStart);
  let struct;
  do {
    struct = structs[index3++];
    if (clockEnd < struct.id.clock + struct.length) {
      findIndexCleanStart(transaction, structs, clockEnd);
    }
    f6(struct);
  } while (index3 < structs.length && structs[index3].id.clock < clockEnd);
};
var Transaction = class {
  /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */
  constructor(doc2, origin, local) {
    this.doc = doc2;
    this.deleteSet = new DeleteSet();
    this.beforeState = getStateVector(doc2.store);
    this.afterState = /* @__PURE__ */ new Map();
    this.changed = /* @__PURE__ */ new Map();
    this.changedParentTypes = /* @__PURE__ */ new Map();
    this._mergeStructs = [];
    this.origin = origin;
    this.meta = /* @__PURE__ */ new Map();
    this.local = local;
    this.subdocsAdded = /* @__PURE__ */ new Set();
    this.subdocsRemoved = /* @__PURE__ */ new Set();
    this.subdocsLoaded = /* @__PURE__ */ new Set();
    this._needFormattingCleanup = false;
  }
};
var writeUpdateMessageFromTransaction = (encoder, transaction) => {
  if (transaction.deleteSet.clients.size === 0 && !any(transaction.afterState, (clock, client) => transaction.beforeState.get(client) !== clock)) {
    return false;
  }
  sortAndMergeDeleteSet(transaction.deleteSet);
  writeStructsFromTransaction(encoder, transaction);
  writeDeleteSet(encoder, transaction.deleteSet);
  return true;
};
var addChangedTypeToTransaction = (transaction, type2, parentSub) => {
  const item2 = type2._item;
  if (item2 === null || item2.id.clock < (transaction.beforeState.get(item2.id.client) || 0) && !item2.deleted) {
    setIfUndefined(transaction.changed, type2, create).add(parentSub);
  }
};
var tryToMergeWithLefts = (structs, pos) => {
  let right = structs[pos];
  let left = structs[pos - 1];
  let i6 = pos;
  for (; i6 > 0; right = left, left = structs[--i6 - 1]) {
    if (left.deleted === right.deleted && left.constructor === right.constructor) {
      if (left.mergeWith(right)) {
        if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */
        right.parent._map.get(right.parentSub) === right) {
          right.parent._map.set(
            right.parentSub,
            /** @type {Item} */
            left
          );
        }
        continue;
      }
    }
    break;
  }
  const merged = pos - i6;
  if (merged) {
    structs.splice(pos + 1 - merged, merged);
  }
  return merged;
};
var tryGcDeleteSet = (ds, store2, gcFilter) => {
  for (const [client, deleteItems] of ds.clients.entries()) {
    const structs = (
      /** @type {Array<GC|Item>} */
      store2.clients.get(client)
    );
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const endDeleteItemClock = deleteItem.clock + deleteItem.len;
      for (let si = findIndexSS(structs, deleteItem.clock), struct = structs[si]; si < structs.length && struct.id.clock < endDeleteItemClock; struct = structs[++si]) {
        const struct2 = structs[si];
        if (deleteItem.clock + deleteItem.len <= struct2.id.clock) {
          break;
        }
        if (struct2 instanceof Item && struct2.deleted && !struct2.keep && gcFilter(struct2)) {
          struct2.gc(store2, false);
        }
      }
    }
  }
};
var tryMergeDeleteSet = (ds, store2) => {
  ds.clients.forEach((deleteItems, client) => {
    const structs = (
      /** @type {Array<GC|Item>} */
      store2.clients.get(client)
    );
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const mostRightIndexToCheck = min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));
      for (let si = mostRightIndexToCheck, struct = structs[si]; si > 0 && struct.id.clock >= deleteItem.clock; struct = structs[si]) {
        si -= 1 + tryToMergeWithLefts(structs, si);
      }
    }
  });
};
var cleanupTransactions = (transactionCleanups, i6) => {
  if (i6 < transactionCleanups.length) {
    const transaction = transactionCleanups[i6];
    const doc2 = transaction.doc;
    const store2 = doc2.store;
    const ds = transaction.deleteSet;
    const mergeStructs = transaction._mergeStructs;
    try {
      sortAndMergeDeleteSet(ds);
      transaction.afterState = getStateVector(transaction.doc.store);
      doc2.emit("beforeObserverCalls", [transaction, doc2]);
      const fs = [];
      transaction.changed.forEach(
        (subs, itemtype) => fs.push(() => {
          if (itemtype._item === null || !itemtype._item.deleted) {
            itemtype._callObserver(transaction, subs);
          }
        })
      );
      fs.push(() => {
        transaction.changedParentTypes.forEach((events2, type2) => {
          if (type2._dEH.l.length > 0 && (type2._item === null || !type2._item.deleted)) {
            events2 = events2.filter(
              (event) => event.target._item === null || !event.target._item.deleted
            );
            events2.forEach((event) => {
              event.currentTarget = type2;
              event._path = null;
            });
            events2.sort((event1, event2) => event1.path.length - event2.path.length);
            callEventHandlerListeners(type2._dEH, events2, transaction);
          }
        });
      });
      fs.push(() => doc2.emit("afterTransaction", [transaction, doc2]));
      callAll(fs, []);
      if (transaction._needFormattingCleanup) {
        cleanupYTextAfterTransaction(transaction);
      }
    } finally {
      if (doc2.gc) {
        tryGcDeleteSet(ds, store2, doc2.gcFilter);
      }
      tryMergeDeleteSet(ds, store2);
      transaction.afterState.forEach((clock, client) => {
        const beforeClock = transaction.beforeState.get(client) || 0;
        if (beforeClock !== clock) {
          const structs = (
            /** @type {Array<GC|Item>} */
            store2.clients.get(client)
          );
          const firstChangePos = max2(findIndexSS(structs, beforeClock), 1);
          for (let i7 = structs.length - 1; i7 >= firstChangePos; ) {
            i7 -= 1 + tryToMergeWithLefts(structs, i7);
          }
        }
      });
      for (let i7 = mergeStructs.length - 1; i7 >= 0; i7--) {
        const { client, clock } = mergeStructs[i7].id;
        const structs = (
          /** @type {Array<GC|Item>} */
          store2.clients.get(client)
        );
        const replacedStructPos = findIndexSS(structs, clock);
        if (replacedStructPos + 1 < structs.length) {
          if (tryToMergeWithLefts(structs, replacedStructPos + 1) > 1) {
            continue;
          }
        }
        if (replacedStructPos > 0) {
          tryToMergeWithLefts(structs, replacedStructPos);
        }
      }
      if (!transaction.local && transaction.afterState.get(doc2.clientID) !== transaction.beforeState.get(doc2.clientID)) {
        print(ORANGE, BOLD, "[yjs] ", UNBOLD, RED, "Changed the client-id because another client seems to be using it.");
        doc2.clientID = generateNewClientId();
      }
      doc2.emit("afterTransactionCleanup", [transaction, doc2]);
      if (doc2._observers.has("update")) {
        const encoder = new UpdateEncoderV1();
        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);
        if (hasContent2) {
          doc2.emit("update", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);
        }
      }
      if (doc2._observers.has("updateV2")) {
        const encoder = new UpdateEncoderV2();
        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);
        if (hasContent2) {
          doc2.emit("updateV2", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);
        }
      }
      const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;
      if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {
        subdocsAdded.forEach((subdoc) => {
          subdoc.clientID = doc2.clientID;
          if (subdoc.collectionid == null) {
            subdoc.collectionid = doc2.collectionid;
          }
          doc2.subdocs.add(subdoc);
        });
        subdocsRemoved.forEach((subdoc) => doc2.subdocs.delete(subdoc));
        doc2.emit("subdocs", [{ loaded: subdocsLoaded, added: subdocsAdded, removed: subdocsRemoved }, doc2, transaction]);
        subdocsRemoved.forEach((subdoc) => subdoc.destroy());
      }
      if (transactionCleanups.length <= i6 + 1) {
        doc2._transactionCleanups = [];
        doc2.emit("afterAllTransactions", [doc2, transactionCleanups]);
      } else {
        cleanupTransactions(transactionCleanups, i6 + 1);
      }
    }
  }
};
var transact = (doc2, f6, origin = null, local = true) => {
  const transactionCleanups = doc2._transactionCleanups;
  let initialCall = false;
  let result = null;
  if (doc2._transaction === null) {
    initialCall = true;
    doc2._transaction = new Transaction(doc2, origin, local);
    transactionCleanups.push(doc2._transaction);
    if (transactionCleanups.length === 1) {
      doc2.emit("beforeAllTransactions", [doc2]);
    }
    doc2.emit("beforeTransaction", [doc2._transaction, doc2]);
  }
  try {
    result = f6(doc2._transaction);
  } finally {
    if (initialCall) {
      const finishCleanup = doc2._transaction === transactionCleanups[0];
      doc2._transaction = null;
      if (finishCleanup) {
        cleanupTransactions(transactionCleanups, 0);
      }
    }
  }
  return result;
};
function* lazyStructReaderGenerator(decoder) {
  const numOfStateUpdates = readVarUint(decoder.restDecoder);
  for (let i6 = 0; i6 < numOfStateUpdates; i6++) {
    const numberOfStructs = readVarUint(decoder.restDecoder);
    const client = decoder.readClient();
    let clock = readVarUint(decoder.restDecoder);
    for (let i7 = 0; i7 < numberOfStructs; i7++) {
      const info = decoder.readInfo();
      if (info === 10) {
        const len = readVarUint(decoder.restDecoder);
        yield new Skip(createID(client, clock), len);
        clock += len;
      } else if ((BITS5 & info) !== 0) {
        const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
        const struct = new Item(
          createID(client, clock),
          null,
          // left
          (info & BIT8) === BIT8 ? decoder.readLeftID() : null,
          // origin
          null,
          // right
          (info & BIT7) === BIT7 ? decoder.readRightID() : null,
          // right origin
          // @ts-ignore Force writing a string here.
          cantCopyParentInfo ? decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID() : null,
          // parent
          cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,
          // parentSub
          readItemContent(decoder, info)
          // item content
        );
        yield struct;
        clock += struct.length;
      } else {
        const len = decoder.readLen();
        yield new GC(createID(client, clock), len);
        clock += len;
      }
    }
  }
}
var LazyStructReader = class {
  /**
   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
   * @param {boolean} filterSkips
   */
  constructor(decoder, filterSkips) {
    this.gen = lazyStructReaderGenerator(decoder);
    this.curr = null;
    this.done = false;
    this.filterSkips = filterSkips;
    this.next();
  }
  /**
   * @return {Item | GC | Skip |null}
   */
  next() {
    do {
      this.curr = this.gen.next().value || null;
    } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip);
    return this.curr;
  }
};
var LazyStructWriter = class {
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  constructor(encoder) {
    this.currClient = 0;
    this.startClock = 0;
    this.written = 0;
    this.encoder = encoder;
    this.clientStructs = [];
  }
};
var mergeUpdates = (updates) => mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);
var encodeStateVectorFromUpdateV2 = (update, YEncoder = DSEncoderV2, YDecoder = UpdateDecoderV2) => {
  const encoder = new YEncoder();
  const updateDecoder = new LazyStructReader(new YDecoder(createDecoder(update)), false);
  let curr = updateDecoder.curr;
  if (curr !== null) {
    let size3 = 0;
    let currClient = curr.id.client;
    let stopCounting = curr.id.clock !== 0;
    let currClock = stopCounting ? 0 : curr.id.clock + curr.length;
    for (; curr !== null; curr = updateDecoder.next()) {
      if (currClient !== curr.id.client) {
        if (currClock !== 0) {
          size3++;
          writeVarUint(encoder.restEncoder, currClient);
          writeVarUint(encoder.restEncoder, currClock);
        }
        currClient = curr.id.client;
        currClock = 0;
        stopCounting = curr.id.clock !== 0;
      }
      if (curr.constructor === Skip) {
        stopCounting = true;
      }
      if (!stopCounting) {
        currClock = curr.id.clock + curr.length;
      }
    }
    if (currClock !== 0) {
      size3++;
      writeVarUint(encoder.restEncoder, currClient);
      writeVarUint(encoder.restEncoder, currClock);
    }
    const enc = createEncoder();
    writeVarUint(enc, size3);
    writeBinaryEncoder(enc, encoder.restEncoder);
    encoder.restEncoder = enc;
    return encoder.toUint8Array();
  } else {
    writeVarUint(encoder.restEncoder, 0);
    return encoder.toUint8Array();
  }
};
var encodeStateVectorFromUpdate = (update) => encodeStateVectorFromUpdateV2(update, DSEncoderV1, UpdateDecoderV1);
var sliceStruct = (left, diff) => {
  if (left.constructor === GC) {
    const { client, clock } = left.id;
    return new GC(createID(client, clock + diff), left.length - diff);
  } else if (left.constructor === Skip) {
    const { client, clock } = left.id;
    return new Skip(createID(client, clock + diff), left.length - diff);
  } else {
    const leftItem = (
      /** @type {Item} */
      left
    );
    const { client, clock } = leftItem.id;
    return new Item(
      createID(client, clock + diff),
      null,
      createID(client, clock + diff - 1),
      null,
      leftItem.rightOrigin,
      leftItem.parent,
      leftItem.parentSub,
      leftItem.content.splice(diff)
    );
  }
};
var mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
  if (updates.length === 1) {
    return updates[0];
  }
  const updateDecoders = updates.map((update) => new YDecoder(createDecoder(update)));
  let lazyStructDecoders = updateDecoders.map((decoder) => new LazyStructReader(decoder, true));
  let currWrite = null;
  const updateEncoder = new YEncoder();
  const lazyStructEncoder = new LazyStructWriter(updateEncoder);
  while (true) {
    lazyStructDecoders = lazyStructDecoders.filter((dec) => dec.curr !== null);
    lazyStructDecoders.sort(
      /** @type {function(any,any):number} */
      (dec1, dec2) => {
        if (dec1.curr.id.client === dec2.curr.id.client) {
          const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;
          if (clockDiff === 0) {
            return dec1.curr.constructor === dec2.curr.constructor ? 0 : dec1.curr.constructor === Skip ? 1 : -1;
          } else {
            return clockDiff;
          }
        } else {
          return dec2.curr.id.client - dec1.curr.id.client;
        }
      }
    );
    if (lazyStructDecoders.length === 0) {
      break;
    }
    const currDecoder = lazyStructDecoders[0];
    const firstClient = (
      /** @type {Item | GC} */
      currDecoder.curr.id.client
    );
    if (currWrite !== null) {
      let curr = (
        /** @type {Item | GC | null} */
        currDecoder.curr
      );
      let iterated = false;
      while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {
        curr = currDecoder.next();
        iterated = true;
      }
      if (curr === null || // current decoder is empty
      curr.id.client !== firstClient || // check whether there is another decoder that has has updates from `firstClient`
      iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length) {
        continue;
      }
      if (firstClient !== currWrite.struct.id.client) {
        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
        currWrite = { struct: curr, offset: 0 };
        currDecoder.next();
      } else {
        if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {
          if (currWrite.struct.constructor === Skip) {
            currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;
          } else {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;
            const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);
            currWrite = { struct, offset: 0 };
          }
        } else {
          const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;
          if (diff > 0) {
            if (currWrite.struct.constructor === Skip) {
              currWrite.struct.length -= diff;
            } else {
              curr = sliceStruct(curr, diff);
            }
          }
          if (!currWrite.struct.mergeWith(
            /** @type {any} */
            curr
          )) {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            currWrite = { struct: curr, offset: 0 };
            currDecoder.next();
          }
        }
      }
    } else {
      currWrite = { struct: (
        /** @type {Item | GC} */
        currDecoder.curr
      ), offset: 0 };
      currDecoder.next();
    }
    for (let next2 = currDecoder.curr; next2 !== null && next2.id.client === firstClient && next2.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next2.constructor !== Skip; next2 = currDecoder.next()) {
      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
      currWrite = { struct: next2, offset: 0 };
    }
  }
  if (currWrite !== null) {
    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
    currWrite = null;
  }
  finishLazyStructWriting(lazyStructEncoder);
  const dss = updateDecoders.map((decoder) => readDeleteSet(decoder));
  const ds = mergeDeleteSets(dss);
  writeDeleteSet(updateEncoder, ds);
  return updateEncoder.toUint8Array();
};
var diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
  const state = decodeStateVector(sv);
  const encoder = new YEncoder();
  const lazyStructWriter = new LazyStructWriter(encoder);
  const decoder = new YDecoder(createDecoder(update));
  const reader = new LazyStructReader(decoder, false);
  while (reader.curr) {
    const curr = reader.curr;
    const currClient = curr.id.client;
    const svClock = state.get(currClient) || 0;
    if (reader.curr.constructor === Skip) {
      reader.next();
      continue;
    }
    if (curr.id.clock + curr.length > svClock) {
      writeStructToLazyStructWriter(lazyStructWriter, curr, max2(svClock - curr.id.clock, 0));
      reader.next();
      while (reader.curr && reader.curr.id.client === currClient) {
        writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);
        reader.next();
      }
    } else {
      while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {
        reader.next();
      }
    }
  }
  finishLazyStructWriting(lazyStructWriter);
  const ds = readDeleteSet(decoder);
  writeDeleteSet(encoder, ds);
  return encoder.toUint8Array();
};
var diffUpdate = (update, sv) => diffUpdateV2(update, sv, UpdateDecoderV1, UpdateEncoderV1);
var flushLazyStructWriter = (lazyWriter) => {
  if (lazyWriter.written > 0) {
    lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: toUint8Array(lazyWriter.encoder.restEncoder) });
    lazyWriter.encoder.restEncoder = createEncoder();
    lazyWriter.written = 0;
  }
};
var writeStructToLazyStructWriter = (lazyWriter, struct, offset) => {
  if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {
    flushLazyStructWriter(lazyWriter);
  }
  if (lazyWriter.written === 0) {
    lazyWriter.currClient = struct.id.client;
    lazyWriter.encoder.writeClient(struct.id.client);
    writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);
  }
  struct.write(lazyWriter.encoder, offset);
  lazyWriter.written++;
};
var finishLazyStructWriting = (lazyWriter) => {
  flushLazyStructWriter(lazyWriter);
  const restEncoder = lazyWriter.encoder.restEncoder;
  writeVarUint(restEncoder, lazyWriter.clientStructs.length);
  for (let i6 = 0; i6 < lazyWriter.clientStructs.length; i6++) {
    const partStructs = lazyWriter.clientStructs[i6];
    writeVarUint(restEncoder, partStructs.written);
    writeUint8Array(restEncoder, partStructs.restEncoder);
  }
};
var convertUpdateFormat = (update, blockTransformer, YDecoder, YEncoder) => {
  const updateDecoder = new YDecoder(createDecoder(update));
  const lazyDecoder = new LazyStructReader(updateDecoder, false);
  const updateEncoder = new YEncoder();
  const lazyWriter = new LazyStructWriter(updateEncoder);
  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
    writeStructToLazyStructWriter(lazyWriter, blockTransformer(curr), 0);
  }
  finishLazyStructWriting(lazyWriter);
  const ds = readDeleteSet(updateDecoder);
  writeDeleteSet(updateEncoder, ds);
  return updateEncoder.toUint8Array();
};
var convertUpdateFormatV2ToV1 = (update) => convertUpdateFormat(update, id, UpdateDecoderV2, UpdateEncoderV1);
var errorComputeChanges = "You must not compute changes after the event-handler fired.";
var YEvent = class {
  /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */
  constructor(target, transaction) {
    this.target = target;
    this.currentTarget = target;
    this.transaction = transaction;
    this._changes = null;
    this._keys = null;
    this._delta = null;
    this._path = null;
  }
  /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */
  get path() {
    return this._path || (this._path = getPathTo(this.currentTarget, this.target));
  }
  /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  deletes(struct) {
    return isDeleted(this.transaction.deleteSet, struct.id);
  }
  /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
   */
  get keys() {
    if (this._keys === null) {
      if (this.transaction.doc._transactionCleanups.length === 0) {
        throw create2(errorComputeChanges);
      }
      const keys3 = /* @__PURE__ */ new Map();
      const target = this.target;
      const changed = (
        /** @type Set<string|null> */
        this.transaction.changed.get(target)
      );
      changed.forEach((key) => {
        if (key !== null) {
          const item2 = (
            /** @type {Item} */
            target._map.get(key)
          );
          let action;
          let oldValue;
          if (this.adds(item2)) {
            let prev2 = item2.left;
            while (prev2 !== null && this.adds(prev2)) {
              prev2 = prev2.left;
            }
            if (this.deletes(item2)) {
              if (prev2 !== null && this.deletes(prev2)) {
                action = "delete";
                oldValue = last(prev2.content.getContent());
              } else {
                return;
              }
            } else {
              if (prev2 !== null && this.deletes(prev2)) {
                action = "update";
                oldValue = last(prev2.content.getContent());
              } else {
                action = "add";
                oldValue = void 0;
              }
            }
          } else {
            if (this.deletes(item2)) {
              action = "delete";
              oldValue = last(
                /** @type {Item} */
                item2.content.getContent()
              );
            } else {
              return;
            }
          }
          keys3.set(key, { action, oldValue });
        }
      });
      this._keys = keys3;
    }
    return this._keys;
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */
  get delta() {
    return this.changes.delta;
  }
  /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  adds(struct) {
    return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0);
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    let changes = this._changes;
    if (changes === null) {
      if (this.transaction.doc._transactionCleanups.length === 0) {
        throw create2(errorComputeChanges);
      }
      const target = this.target;
      const added = create();
      const deleted = create();
      const delta = [];
      changes = {
        added,
        deleted,
        delta,
        keys: this.keys
      };
      const changed = (
        /** @type Set<string|null> */
        this.transaction.changed.get(target)
      );
      if (changed.has(null)) {
        let lastOp = null;
        const packOp = () => {
          if (lastOp) {
            delta.push(lastOp);
          }
        };
        for (let item2 = target._start; item2 !== null; item2 = item2.right) {
          if (item2.deleted) {
            if (this.deletes(item2) && !this.adds(item2)) {
              if (lastOp === null || lastOp.delete === void 0) {
                packOp();
                lastOp = { delete: 0 };
              }
              lastOp.delete += item2.length;
              deleted.add(item2);
            }
          } else {
            if (this.adds(item2)) {
              if (lastOp === null || lastOp.insert === void 0) {
                packOp();
                lastOp = { insert: [] };
              }
              lastOp.insert = lastOp.insert.concat(item2.content.getContent());
              added.add(item2);
            } else {
              if (lastOp === null || lastOp.retain === void 0) {
                packOp();
                lastOp = { retain: 0 };
              }
              lastOp.retain += item2.length;
            }
          }
        }
        if (lastOp !== null && lastOp.retain === void 0) {
          packOp();
        }
      }
      this._changes = changes;
    }
    return (
      /** @type {any} */
      changes
    );
  }
};
var getPathTo = (parent, child) => {
  const path3 = [];
  while (child._item !== null && child !== parent) {
    if (child._item.parentSub !== null) {
      path3.unshift(child._item.parentSub);
    } else {
      let i6 = 0;
      let c5 = (
        /** @type {AbstractType<any>} */
        child._item.parent._start
      );
      while (c5 !== child._item && c5 !== null) {
        if (!c5.deleted) {
          i6++;
        }
        c5 = c5.right;
      }
      path3.unshift(i6);
    }
    child = /** @type {AbstractType<any>} */
    child._item.parent;
  }
  return path3;
};
var maxSearchMarker = 80;
var globalSearchMarkerTimestamp = 0;
var ArraySearchMarker = class {
  /**
   * @param {Item} p
   * @param {number} index
   */
  constructor(p5, index3) {
    p5.marker = true;
    this.p = p5;
    this.index = index3;
    this.timestamp = globalSearchMarkerTimestamp++;
  }
};
var refreshMarkerTimestamp = (marker) => {
  marker.timestamp = globalSearchMarkerTimestamp++;
};
var overwriteMarker = (marker, p5, index3) => {
  marker.p.marker = false;
  marker.p = p5;
  p5.marker = true;
  marker.index = index3;
  marker.timestamp = globalSearchMarkerTimestamp++;
};
var markPosition = (searchMarker, p5, index3) => {
  if (searchMarker.length >= maxSearchMarker) {
    const marker = searchMarker.reduce((a3, b2) => a3.timestamp < b2.timestamp ? a3 : b2);
    overwriteMarker(marker, p5, index3);
    return marker;
  } else {
    const pm = new ArraySearchMarker(p5, index3);
    searchMarker.push(pm);
    return pm;
  }
};
var findMarker = (yarray, index3) => {
  if (yarray._start === null || index3 === 0 || yarray._searchMarker === null) {
    return null;
  }
  const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a3, b2) => abs(index3 - a3.index) < abs(index3 - b2.index) ? a3 : b2);
  let p5 = yarray._start;
  let pindex = 0;
  if (marker !== null) {
    p5 = marker.p;
    pindex = marker.index;
    refreshMarkerTimestamp(marker);
  }
  while (p5.right !== null && pindex < index3) {
    if (!p5.deleted && p5.countable) {
      if (index3 < pindex + p5.length) {
        break;
      }
      pindex += p5.length;
    }
    p5 = p5.right;
  }
  while (p5.left !== null && pindex > index3) {
    p5 = p5.left;
    if (!p5.deleted && p5.countable) {
      pindex -= p5.length;
    }
  }
  while (p5.left !== null && p5.left.id.client === p5.id.client && p5.left.id.clock + p5.left.length === p5.id.clock) {
    p5 = p5.left;
    if (!p5.deleted && p5.countable) {
      pindex -= p5.length;
    }
  }
  if (marker !== null && abs(marker.index - pindex) < /** @type {YText|YArray<any>} */
  p5.parent.length / maxSearchMarker) {
    overwriteMarker(marker, p5, pindex);
    return marker;
  } else {
    return markPosition(yarray._searchMarker, p5, pindex);
  }
};
var updateMarkerChanges = (searchMarker, index3, len) => {
  for (let i6 = searchMarker.length - 1; i6 >= 0; i6--) {
    const m3 = searchMarker[i6];
    if (len > 0) {
      let p5 = m3.p;
      p5.marker = false;
      while (p5 && (p5.deleted || !p5.countable)) {
        p5 = p5.left;
        if (p5 && !p5.deleted && p5.countable) {
          m3.index -= p5.length;
        }
      }
      if (p5 === null || p5.marker === true) {
        searchMarker.splice(i6, 1);
        continue;
      }
      m3.p = p5;
      p5.marker = true;
    }
    if (index3 < m3.index || len > 0 && index3 === m3.index) {
      m3.index = max2(index3, m3.index + len);
    }
  }
};
var callTypeObservers = (type2, transaction, event) => {
  const changedType = type2;
  const changedParentTypes = transaction.changedParentTypes;
  while (true) {
    setIfUndefined(changedParentTypes, type2, () => []).push(event);
    if (type2._item === null) {
      break;
    }
    type2 = /** @type {AbstractType<any>} */
    type2._item.parent;
  }
  callEventHandlerListeners(changedType._eH, event, transaction);
};
var AbstractType = class {
  constructor() {
    this._item = null;
    this._map = /* @__PURE__ */ new Map();
    this._start = null;
    this.doc = null;
    this._length = 0;
    this._eH = createEventHandler();
    this._dEH = createEventHandler();
    this._searchMarker = null;
  }
  /**
   * @return {AbstractType<any>|null}
   */
  get parent() {
    return this._item ? (
      /** @type {AbstractType<any>} */
      this._item.parent
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */
  _integrate(y4, item2) {
    this.doc = y4;
    this._item = item2;
  }
  /**
   * @return {AbstractType<EventType>}
   */
  _copy() {
    throw methodUnimplemented();
  }
  /**
   * @return {AbstractType<EventType>}
   */
  clone() {
    throw methodUnimplemented();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */
  _write(_encoder) {
  }
  /**
   * The first non-deleted item
   */
  get _first() {
    let n6 = this._start;
    while (n6 !== null && n6.deleted) {
      n6 = n6.right;
    }
    return n6;
  }
  /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, _parentSubs) {
    if (!transaction.local && this._searchMarker) {
      this._searchMarker.length = 0;
    }
  }
  /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */
  observe(f6) {
    addEventHandlerListener(this._eH, f6);
  }
  /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  observeDeep(f6) {
    addEventHandlerListener(this._dEH, f6);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */
  unobserve(f6) {
    removeEventHandlerListener(this._eH, f6);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  unobserveDeep(f6) {
    removeEventHandlerListener(this._dEH, f6);
  }
  /**
   * @abstract
   * @return {any}
   */
  toJSON() {
  }
};
var typeListSlice = (type2, start2, end) => {
  if (start2 < 0) {
    start2 = type2._length + start2;
  }
  if (end < 0) {
    end = type2._length + end;
  }
  let len = end - start2;
  const cs = [];
  let n6 = type2._start;
  while (n6 !== null && len > 0) {
    if (n6.countable && !n6.deleted) {
      const c5 = n6.content.getContent();
      if (c5.length <= start2) {
        start2 -= c5.length;
      } else {
        for (let i6 = start2; i6 < c5.length && len > 0; i6++) {
          cs.push(c5[i6]);
          len--;
        }
        start2 = 0;
      }
    }
    n6 = n6.right;
  }
  return cs;
};
var typeListToArray = (type2) => {
  const cs = [];
  let n6 = type2._start;
  while (n6 !== null) {
    if (n6.countable && !n6.deleted) {
      const c5 = n6.content.getContent();
      for (let i6 = 0; i6 < c5.length; i6++) {
        cs.push(c5[i6]);
      }
    }
    n6 = n6.right;
  }
  return cs;
};
var typeListForEach = (type2, f6) => {
  let index3 = 0;
  let n6 = type2._start;
  while (n6 !== null) {
    if (n6.countable && !n6.deleted) {
      const c5 = n6.content.getContent();
      for (let i6 = 0; i6 < c5.length; i6++) {
        f6(c5[i6], index3++, type2);
      }
    }
    n6 = n6.right;
  }
};
var typeListMap = (type2, f6) => {
  const result = [];
  typeListForEach(type2, (c5, i6) => {
    result.push(f6(c5, i6, type2));
  });
  return result;
};
var typeListCreateIterator = (type2) => {
  let n6 = type2._start;
  let currentContent = null;
  let currentContentIndex = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: () => {
      if (currentContent === null) {
        while (n6 !== null && n6.deleted) {
          n6 = n6.right;
        }
        if (n6 === null) {
          return {
            done: true,
            value: void 0
          };
        }
        currentContent = n6.content.getContent();
        currentContentIndex = 0;
        n6 = n6.right;
      }
      const value2 = currentContent[currentContentIndex++];
      if (currentContent.length <= currentContentIndex) {
        currentContent = null;
      }
      return {
        done: false,
        value: value2
      };
    }
  };
};
var typeListGet = (type2, index3) => {
  const marker = findMarker(type2, index3);
  let n6 = type2._start;
  if (marker !== null) {
    n6 = marker.p;
    index3 -= marker.index;
  }
  for (; n6 !== null; n6 = n6.right) {
    if (!n6.deleted && n6.countable) {
      if (index3 < n6.length) {
        return n6.content.getContent()[index3];
      }
      index3 -= n6.length;
    }
  }
};
var typeListInsertGenericsAfter = (transaction, parent, referenceItem, content3) => {
  let left = referenceItem;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  const store2 = doc2.store;
  const right = referenceItem === null ? parent._start : referenceItem.right;
  let jsonContent = [];
  const packJsonContent = () => {
    if (jsonContent.length > 0) {
      left = new Item(createID(ownClientId, getState(store2, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));
      left.integrate(transaction, 0);
      jsonContent = [];
    }
  };
  content3.forEach((c5) => {
    if (c5 === null) {
      jsonContent.push(c5);
    } else {
      switch (c5.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          jsonContent.push(c5);
          break;
        default:
          packJsonContent();
          switch (c5.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              left = new Item(createID(ownClientId, getState(store2, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(
                /** @type {Uint8Array} */
                c5
              )));
              left.integrate(transaction, 0);
              break;
            case Doc:
              left = new Item(createID(ownClientId, getState(store2, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(
                /** @type {Doc} */
                c5
              ));
              left.integrate(transaction, 0);
              break;
            default:
              if (c5 instanceof AbstractType) {
                left = new Item(createID(ownClientId, getState(store2, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c5));
                left.integrate(transaction, 0);
              } else {
                throw new Error("Unexpected content type in insert operation");
              }
          }
      }
    }
  });
  packJsonContent();
};
var lengthExceeded = () => create2("Length exceeded!");
var typeListInsertGenerics = (transaction, parent, index3, content3) => {
  if (index3 > parent._length) {
    throw lengthExceeded();
  }
  if (index3 === 0) {
    if (parent._searchMarker) {
      updateMarkerChanges(parent._searchMarker, index3, content3.length);
    }
    return typeListInsertGenericsAfter(transaction, parent, null, content3);
  }
  const startIndex = index3;
  const marker = findMarker(parent, index3);
  let n6 = parent._start;
  if (marker !== null) {
    n6 = marker.p;
    index3 -= marker.index;
    if (index3 === 0) {
      n6 = n6.prev;
      index3 += n6 && n6.countable && !n6.deleted ? n6.length : 0;
    }
  }
  for (; n6 !== null; n6 = n6.right) {
    if (!n6.deleted && n6.countable) {
      if (index3 <= n6.length) {
        if (index3 < n6.length) {
          getItemCleanStart(transaction, createID(n6.id.client, n6.id.clock + index3));
        }
        break;
      }
      index3 -= n6.length;
    }
  }
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, startIndex, content3.length);
  }
  return typeListInsertGenericsAfter(transaction, parent, n6, content3);
};
var typeListPushGenerics = (transaction, parent, content3) => {
  const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker) => currMarker.index > maxMarker.index ? currMarker : maxMarker, { index: 0, p: parent._start });
  let n6 = marker.p;
  if (n6) {
    while (n6.right) {
      n6 = n6.right;
    }
  }
  return typeListInsertGenericsAfter(transaction, parent, n6, content3);
};
var typeListDelete = (transaction, parent, index3, length4) => {
  if (length4 === 0) {
    return;
  }
  const startIndex = index3;
  const startLength = length4;
  const marker = findMarker(parent, index3);
  let n6 = parent._start;
  if (marker !== null) {
    n6 = marker.p;
    index3 -= marker.index;
  }
  for (; n6 !== null && index3 > 0; n6 = n6.right) {
    if (!n6.deleted && n6.countable) {
      if (index3 < n6.length) {
        getItemCleanStart(transaction, createID(n6.id.client, n6.id.clock + index3));
      }
      index3 -= n6.length;
    }
  }
  while (length4 > 0 && n6 !== null) {
    if (!n6.deleted) {
      if (length4 < n6.length) {
        getItemCleanStart(transaction, createID(n6.id.client, n6.id.clock + length4));
      }
      n6.delete(transaction);
      length4 -= n6.length;
    }
    n6 = n6.right;
  }
  if (length4 > 0) {
    throw lengthExceeded();
  }
  if (parent._searchMarker) {
    updateMarkerChanges(
      parent._searchMarker,
      startIndex,
      -startLength + length4
      /* in case we remove the above exception */
    );
  }
};
var typeMapDelete = (transaction, parent, key) => {
  const c5 = parent._map.get(key);
  if (c5 !== void 0) {
    c5.delete(transaction);
  }
};
var typeMapSet = (transaction, parent, key, value2) => {
  const left = parent._map.get(key) || null;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  let content3;
  if (value2 == null) {
    content3 = new ContentAny([value2]);
  } else {
    switch (value2.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
        content3 = new ContentAny([value2]);
        break;
      case Uint8Array:
        content3 = new ContentBinary(
          /** @type {Uint8Array} */
          value2
        );
        break;
      case Doc:
        content3 = new ContentDoc(
          /** @type {Doc} */
          value2
        );
        break;
      default:
        if (value2 instanceof AbstractType) {
          content3 = new ContentType(value2);
        } else {
          throw new Error("Unexpected content type");
        }
    }
  }
  new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content3).integrate(transaction, 0);
};
var typeMapGet = (parent, key) => {
  const val = parent._map.get(key);
  return val !== void 0 && !val.deleted ? val.content.getContent()[val.length - 1] : void 0;
};
var typeMapGetAll = (parent) => {
  const res = {};
  parent._map.forEach((value2, key) => {
    if (!value2.deleted) {
      res[key] = value2.content.getContent()[value2.length - 1];
    }
  });
  return res;
};
var typeMapHas = (parent, key) => {
  const val = parent._map.get(key);
  return val !== void 0 && !val.deleted;
};
var typeMapGetAllSnapshot = (parent, snapshot) => {
  const res = {};
  parent._map.forEach((value2, key) => {
    let v6 = value2;
    while (v6 !== null && (!snapshot.sv.has(v6.id.client) || v6.id.clock >= (snapshot.sv.get(v6.id.client) || 0))) {
      v6 = v6.left;
    }
    if (v6 !== null && isVisible(v6, snapshot)) {
      res[key] = v6.content.getContent()[v6.length - 1];
    }
  });
  return res;
};
var createMapIterator = (map4) => iteratorFilter(
  map4.entries(),
  /** @param {any} entry */
  (entry) => !entry[1].deleted
);
var YArrayEvent = class extends YEvent {
  /**
   * @param {YArray<T>} yarray The changed type
   * @param {Transaction} transaction The transaction object
   */
  constructor(yarray, transaction) {
    super(yarray, transaction);
    this._transaction = transaction;
  }
};
var YArray = class _YArray extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
    this._searchMarker = [];
  }
  /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */
  static from(items) {
    const a3 = new _YArray();
    a3.push(items);
    return a3;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y4, item2) {
    super._integrate(y4, item2);
    this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    );
    this._prelimContent = null;
  }
  /**
   * @return {YArray<T>}
   */
  _copy() {
    return new _YArray();
  }
  /**
   * @return {YArray<T>}
   */
  clone() {
    const arr = new _YArray();
    arr.insert(0, this.toArray().map(
      (el) => el instanceof AbstractType ? (
        /** @type {typeof el} */
        el.clone()
      ) : el
    ));
    return arr;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    callTypeObservers(this, transaction, new YArrayEvent(this, transaction));
  }
  /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */
  insert(index3, content3) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(
          transaction,
          this,
          index3,
          /** @type {any} */
          content3
        );
      });
    } else {
      this._prelimContent.splice(index3, 0, ...content3);
    }
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */
  push(content3) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListPushGenerics(
          transaction,
          this,
          /** @type {any} */
          content3
        );
      });
    } else {
      this._prelimContent.push(...content3);
    }
  }
  /**
   * Preppends content to this YArray.
   *
   * @param {Array<T>} content Array of content to preppend.
   */
  unshift(content3) {
    this.insert(0, content3);
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */
  delete(index3, length4 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index3, length4);
      });
    } else {
      this._prelimContent.splice(index3, length4);
    }
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */
  get(index3) {
    return typeListGet(this, index3);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */
  toArray() {
    return typeListToArray(this);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */
  slice(start2 = 0, end = this.length) {
    return typeListSlice(this, start2, end);
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */
  toJSON() {
    return this.map((c5) => c5 instanceof AbstractType ? c5.toJSON() : c5);
  }
  /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */
  map(f6) {
    return typeListMap(
      this,
      /** @type {any} */
      f6
    );
  }
  /**
   * Executes a provided function once on overy element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */
  forEach(f6) {
    typeListForEach(this, f6);
  }
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return typeListCreateIterator(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YArrayRefID);
  }
};
var readYArray = (_decoder) => new YArray();
var YMapEvent = class extends YEvent {
  /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */
  constructor(ymap, transaction, subs) {
    super(ymap, transaction);
    this.keysChanged = subs;
  }
};
var YMap = class _YMap extends AbstractType {
  /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */
  constructor(entries2) {
    super();
    this._prelimContent = null;
    if (entries2 === void 0) {
      this._prelimContent = /* @__PURE__ */ new Map();
    } else {
      this._prelimContent = new Map(entries2);
    }
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y4, item2) {
    super._integrate(y4, item2);
    this._prelimContent.forEach((value2, key) => {
      this.set(key, value2);
    });
    this._prelimContent = null;
  }
  /**
   * @return {YMap<MapType>}
   */
  _copy() {
    return new _YMap();
  }
  /**
   * @return {YMap<MapType>}
   */
  clone() {
    const map4 = new _YMap();
    this.forEach((value2, key) => {
      map4.set(key, value2 instanceof AbstractType ? (
        /** @type {typeof value} */
        value2.clone()
      ) : value2);
    });
    return map4;
  }
  /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */
  toJSON() {
    const map4 = {};
    this._map.forEach((item2, key) => {
      if (!item2.deleted) {
        const v6 = item2.content.getContent()[item2.length - 1];
        map4[key] = v6 instanceof AbstractType ? v6.toJSON() : v6;
      }
    });
    return map4;
  }
  /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */
  get size() {
    return [...createMapIterator(this._map)].length;
  }
  /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */
  keys() {
    return iteratorMap(
      createMapIterator(this._map),
      /** @param {any} v */
      (v6) => v6[0]
    );
  }
  /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<MapType>}
   */
  values() {
    return iteratorMap(
      createMapIterator(this._map),
      /** @param {any} v */
      (v6) => v6[1].content.getContent()[v6[1].length - 1]
    );
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  entries() {
    return iteratorMap(
      createMapIterator(this._map),
      /** @param {any} v */
      (v6) => (
        /** @type {any} */
        [v6[0], v6[1].content.getContent()[v6[1].length - 1]]
      )
    );
  }
  /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */
  forEach(f6) {
    this._map.forEach((item2, key) => {
      if (!item2.deleted) {
        f6(item2.content.getContent()[item2.length - 1], key, this);
      }
    });
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */
  delete(key) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, key);
      });
    } else {
      this._prelimContent.delete(key);
    }
  }
  /**
   * Adds or updates an element with a specified key and value.
   * @template {MapType} VAL
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {VAL} value The value of the element to add
   * @return {VAL}
   */
  set(key, value2) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(
          transaction,
          this,
          key,
          /** @type {any} */
          value2
        );
      });
    } else {
      this._prelimContent.set(key, value2);
    }
    return value2;
  }
  /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */
  get(key) {
    return (
      /** @type {any} */
      typeMapGet(this, key)
    );
  }
  /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */
  has(key) {
    return typeMapHas(this, key);
  }
  /**
   * Removes all elements from this YMap.
   */
  clear() {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        this.forEach(function(_value, key, map4) {
          typeMapDelete(transaction, map4, key);
        });
      });
    } else {
      this._prelimContent.clear();
    }
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YMapRefID);
  }
};
var readYMap = (_decoder) => new YMap();
var equalAttrs = (a3, b2) => a3 === b2 || typeof a3 === "object" && typeof b2 === "object" && a3 && b2 && equalFlat(a3, b2);
var ItemTextListPosition = class {
  /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */
  constructor(left, right, index3, currentAttributes) {
    this.left = left;
    this.right = right;
    this.index = index3;
    this.currentAttributes = currentAttributes;
  }
  /**
   * Only call this if you know that this.right is defined
   */
  forward() {
    if (this.right === null) {
      unexpectedCase();
    }
    switch (this.right.content.constructor) {
      case ContentFormat:
        if (!this.right.deleted) {
          updateCurrentAttributes(
            this.currentAttributes,
            /** @type {ContentFormat} */
            this.right.content
          );
        }
        break;
      default:
        if (!this.right.deleted) {
          this.index += this.right.length;
        }
        break;
    }
    this.left = this.right;
    this.right = this.right.right;
  }
};
var findNextPosition = (transaction, pos, count) => {
  while (pos.right !== null && count > 0) {
    switch (pos.right.content.constructor) {
      case ContentFormat:
        if (!pos.right.deleted) {
          updateCurrentAttributes(
            pos.currentAttributes,
            /** @type {ContentFormat} */
            pos.right.content
          );
        }
        break;
      default:
        if (!pos.right.deleted) {
          if (count < pos.right.length) {
            getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count));
          }
          pos.index += pos.right.length;
          count -= pos.right.length;
        }
        break;
    }
    pos.left = pos.right;
    pos.right = pos.right.right;
  }
  return pos;
};
var findPosition = (transaction, parent, index3, useSearchMarker) => {
  const currentAttributes = /* @__PURE__ */ new Map();
  const marker = useSearchMarker ? findMarker(parent, index3) : null;
  if (marker) {
    const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);
    return findNextPosition(transaction, pos, index3 - marker.index);
  } else {
    const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);
    return findNextPosition(transaction, pos, index3);
  }
};
var insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {
  while (currPos.right !== null && (currPos.right.deleted === true || currPos.right.content.constructor === ContentFormat && equalAttrs(
    negatedAttributes.get(
      /** @type {ContentFormat} */
      currPos.right.content.key
    ),
    /** @type {ContentFormat} */
    currPos.right.content.value
  ))) {
    if (!currPos.right.deleted) {
      negatedAttributes.delete(
        /** @type {ContentFormat} */
        currPos.right.content.key
      );
    }
    currPos.forward();
  }
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  negatedAttributes.forEach((val, key) => {
    const left = currPos.left;
    const right = currPos.right;
    const nextFormat = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
    nextFormat.integrate(transaction, 0);
    currPos.right = nextFormat;
    currPos.forward();
  });
};
var updateCurrentAttributes = (currentAttributes, format2) => {
  const { key, value: value2 } = format2;
  if (value2 === null) {
    currentAttributes.delete(key);
  } else {
    currentAttributes.set(key, value2);
  }
};
var minimizeAttributeChanges = (currPos, attributes) => {
  while (true) {
    if (currPos.right === null) {
      break;
    } else if (currPos.right.deleted || currPos.right.content.constructor === ContentFormat && equalAttrs(
      attributes[
        /** @type {ContentFormat} */
        currPos.right.content.key
      ] || null,
      /** @type {ContentFormat} */
      currPos.right.content.value
    ))
      ;
    else {
      break;
    }
    currPos.forward();
  }
};
var insertAttributes = (transaction, parent, currPos, attributes) => {
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  const negatedAttributes = /* @__PURE__ */ new Map();
  for (const key in attributes) {
    const val = attributes[key];
    const currentVal = currPos.currentAttributes.get(key) || null;
    if (!equalAttrs(currentVal, val)) {
      negatedAttributes.set(key, currentVal);
      const { left, right } = currPos;
      currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
      currPos.right.integrate(transaction, 0);
      currPos.forward();
    }
  }
  return negatedAttributes;
};
var insertText = (transaction, parent, currPos, text7, attributes) => {
  currPos.currentAttributes.forEach((_val, key) => {
    if (attributes[key] === void 0) {
      attributes[key] = null;
    }
  });
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  const content3 = text7.constructor === String ? new ContentString(
    /** @type {string} */
    text7
  ) : text7 instanceof AbstractType ? new ContentType(text7) : new ContentEmbed(text7);
  let { left, right, index: index3 } = currPos;
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, content3.getLength());
  }
  right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content3);
  right.integrate(transaction, 0);
  currPos.right = right;
  currPos.index = index3;
  currPos.forward();
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
var formatText = (transaction, parent, currPos, length4, attributes) => {
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  iterationLoop:
    while (currPos.right !== null && (length4 > 0 || negatedAttributes.size > 0 && (currPos.right.deleted || currPos.right.content.constructor === ContentFormat))) {
      if (!currPos.right.deleted) {
        switch (currPos.right.content.constructor) {
          case ContentFormat: {
            const { key, value: value2 } = (
              /** @type {ContentFormat} */
              currPos.right.content
            );
            const attr = attributes[key];
            if (attr !== void 0) {
              if (equalAttrs(attr, value2)) {
                negatedAttributes.delete(key);
              } else {
                if (length4 === 0) {
                  break iterationLoop;
                }
                negatedAttributes.set(key, value2);
              }
              currPos.right.delete(transaction);
            } else {
              currPos.currentAttributes.set(key, value2);
            }
            break;
          }
          default:
            if (length4 < currPos.right.length) {
              getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length4));
            }
            length4 -= currPos.right.length;
            break;
        }
      }
      currPos.forward();
    }
  if (length4 > 0) {
    let newlines = "";
    for (; length4 > 0; length4--) {
      newlines += "\n";
    }
    currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));
    currPos.right.integrate(transaction, 0);
    currPos.forward();
  }
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
var cleanupFormattingGap = (transaction, start2, curr, startAttributes, currAttributes) => {
  let end = start2;
  const endFormats = create3();
  while (end && (!end.countable || end.deleted)) {
    if (!end.deleted && end.content.constructor === ContentFormat) {
      const cf = (
        /** @type {ContentFormat} */
        end.content
      );
      endFormats.set(cf.key, cf);
    }
    end = end.right;
  }
  let cleanups = 0;
  let reachedCurr = false;
  while (start2 !== end) {
    if (curr === start2) {
      reachedCurr = true;
    }
    if (!start2.deleted) {
      const content3 = start2.content;
      switch (content3.constructor) {
        case ContentFormat: {
          const { key, value: value2 } = (
            /** @type {ContentFormat} */
            content3
          );
          const startAttrValue = startAttributes.get(key) || null;
          if (endFormats.get(key) !== content3 || startAttrValue === value2) {
            start2.delete(transaction);
            cleanups++;
            if (!reachedCurr && (currAttributes.get(key) || null) === value2 && startAttrValue !== value2) {
              if (startAttrValue === null) {
                currAttributes.delete(key);
              } else {
                currAttributes.set(key, startAttrValue);
              }
            }
          }
          if (!reachedCurr && !start2.deleted) {
            updateCurrentAttributes(
              currAttributes,
              /** @type {ContentFormat} */
              content3
            );
          }
          break;
        }
      }
    }
    start2 = /** @type {Item} */
    start2.right;
  }
  return cleanups;
};
var cleanupContextlessFormattingGap = (transaction, item2) => {
  while (item2 && item2.right && (item2.right.deleted || !item2.right.countable)) {
    item2 = item2.right;
  }
  const attrs = /* @__PURE__ */ new Set();
  while (item2 && (item2.deleted || !item2.countable)) {
    if (!item2.deleted && item2.content.constructor === ContentFormat) {
      const key = (
        /** @type {ContentFormat} */
        item2.content.key
      );
      if (attrs.has(key)) {
        item2.delete(transaction);
      } else {
        attrs.add(key);
      }
    }
    item2 = item2.left;
  }
};
var cleanupYTextFormatting = (type2) => {
  let res = 0;
  transact(
    /** @type {Doc} */
    type2.doc,
    (transaction) => {
      let start2 = (
        /** @type {Item} */
        type2._start
      );
      let end = type2._start;
      let startAttributes = create3();
      const currentAttributes = copy(startAttributes);
      while (end) {
        if (end.deleted === false) {
          switch (end.content.constructor) {
            case ContentFormat:
              updateCurrentAttributes(
                currentAttributes,
                /** @type {ContentFormat} */
                end.content
              );
              break;
            default:
              res += cleanupFormattingGap(transaction, start2, end, startAttributes, currentAttributes);
              startAttributes = copy(currentAttributes);
              start2 = end;
              break;
          }
        }
        end = end.right;
      }
    }
  );
  return res;
};
var cleanupYTextAfterTransaction = (transaction) => {
  const needFullCleanup = /* @__PURE__ */ new Set();
  const doc2 = transaction.doc;
  for (const [client, afterClock] of transaction.afterState.entries()) {
    const clock = transaction.beforeState.get(client) || 0;
    if (afterClock === clock) {
      continue;
    }
    iterateStructs(
      transaction,
      /** @type {Array<Item|GC>} */
      doc2.store.clients.get(client),
      clock,
      afterClock,
      (item2) => {
        if (!item2.deleted && /** @type {Item} */
        item2.content.constructor === ContentFormat && item2.constructor !== GC) {
          needFullCleanup.add(
            /** @type {any} */
            item2.parent
          );
        }
      }
    );
  }
  transact(doc2, (t5) => {
    iterateDeletedStructs(transaction, transaction.deleteSet, (item2) => {
      if (item2 instanceof GC || !/** @type {YText} */
      item2.parent._hasFormatting || needFullCleanup.has(
        /** @type {YText} */
        item2.parent
      )) {
        return;
      }
      const parent = (
        /** @type {YText} */
        item2.parent
      );
      if (item2.content.constructor === ContentFormat) {
        needFullCleanup.add(parent);
      } else {
        cleanupContextlessFormattingGap(t5, item2);
      }
    });
    for (const yText of needFullCleanup) {
      cleanupYTextFormatting(yText);
    }
  });
};
var deleteText = (transaction, currPos, length4) => {
  const startLength = length4;
  const startAttrs = copy(currPos.currentAttributes);
  const start2 = currPos.right;
  while (length4 > 0 && currPos.right !== null) {
    if (currPos.right.deleted === false) {
      switch (currPos.right.content.constructor) {
        case ContentType:
        case ContentEmbed:
        case ContentString:
          if (length4 < currPos.right.length) {
            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length4));
          }
          length4 -= currPos.right.length;
          currPos.right.delete(transaction);
          break;
      }
    }
    currPos.forward();
  }
  if (start2) {
    cleanupFormattingGap(transaction, start2, currPos.right, startAttrs, currPos.currentAttributes);
  }
  const parent = (
    /** @type {AbstractType<any>} */
    /** @type {Item} */
    (currPos.left || currPos.right).parent
  );
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length4);
  }
  return currPos;
};
var YTextEvent = class extends YEvent {
  /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */
  constructor(ytext, transaction, subs) {
    super(ytext, transaction);
    this.childListChanged = false;
    this.keysChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub2) => {
      if (sub2 === null) {
        this.childListChanged = true;
      } else {
        this.keysChanged.add(sub2);
      }
    });
  }
  /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    if (this._changes === null) {
      const changes = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = changes;
    }
    return (
      /** @type {any} */
      this._changes
    );
  }
  /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */
  get delta() {
    if (this._delta === null) {
      const y4 = (
        /** @type {Doc} */
        this.target.doc
      );
      const delta = [];
      transact(y4, (transaction) => {
        const currentAttributes = /* @__PURE__ */ new Map();
        const oldAttributes = /* @__PURE__ */ new Map();
        let item2 = this.target._start;
        let action = null;
        const attributes = {};
        let insert = "";
        let retain = 0;
        let deleteLen = 0;
        const addOp = () => {
          if (action !== null) {
            let op = null;
            switch (action) {
              case "delete":
                if (deleteLen > 0) {
                  op = { delete: deleteLen };
                }
                deleteLen = 0;
                break;
              case "insert":
                if (typeof insert === "object" || insert.length > 0) {
                  op = { insert };
                  if (currentAttributes.size > 0) {
                    op.attributes = {};
                    currentAttributes.forEach((value2, key) => {
                      if (value2 !== null) {
                        op.attributes[key] = value2;
                      }
                    });
                  }
                }
                insert = "";
                break;
              case "retain":
                if (retain > 0) {
                  op = { retain };
                  if (!isEmpty(attributes)) {
                    op.attributes = assign({}, attributes);
                  }
                }
                retain = 0;
                break;
            }
            if (op)
              delta.push(op);
            action = null;
          }
        };
        while (item2 !== null) {
          switch (item2.content.constructor) {
            case ContentType:
            case ContentEmbed:
              if (this.adds(item2)) {
                if (!this.deletes(item2)) {
                  addOp();
                  action = "insert";
                  insert = item2.content.getContent()[0];
                  addOp();
                }
              } else if (this.deletes(item2)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += 1;
              } else if (!item2.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += 1;
              }
              break;
            case ContentString:
              if (this.adds(item2)) {
                if (!this.deletes(item2)) {
                  if (action !== "insert") {
                    addOp();
                    action = "insert";
                  }
                  insert += /** @type {ContentString} */
                  item2.content.str;
                }
              } else if (this.deletes(item2)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += item2.length;
              } else if (!item2.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += item2.length;
              }
              break;
            case ContentFormat: {
              const { key, value: value2 } = (
                /** @type {ContentFormat} */
                item2.content
              );
              if (this.adds(item2)) {
                if (!this.deletes(item2)) {
                  const curVal = currentAttributes.get(key) || null;
                  if (!equalAttrs(curVal, value2)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (equalAttrs(value2, oldAttributes.get(key) || null)) {
                      delete attributes[key];
                    } else {
                      attributes[key] = value2;
                    }
                  } else if (value2 !== null) {
                    item2.delete(transaction);
                  }
                }
              } else if (this.deletes(item2)) {
                oldAttributes.set(key, value2);
                const curVal = currentAttributes.get(key) || null;
                if (!equalAttrs(curVal, value2)) {
                  if (action === "retain") {
                    addOp();
                  }
                  attributes[key] = curVal;
                }
              } else if (!item2.deleted) {
                oldAttributes.set(key, value2);
                const attr = attributes[key];
                if (attr !== void 0) {
                  if (!equalAttrs(attr, value2)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (value2 === null) {
                      delete attributes[key];
                    } else {
                      attributes[key] = value2;
                    }
                  } else if (attr !== null) {
                    item2.delete(transaction);
                  }
                }
              }
              if (!item2.deleted) {
                if (action === "insert") {
                  addOp();
                }
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  item2.content
                );
              }
              break;
            }
          }
          item2 = item2.right;
        }
        addOp();
        while (delta.length > 0) {
          const lastOp = delta[delta.length - 1];
          if (lastOp.retain !== void 0 && lastOp.attributes === void 0) {
            delta.pop();
          } else {
            break;
          }
        }
      });
      this._delta = delta;
    }
    return (
      /** @type {any} */
      this._delta
    );
  }
};
var YText = class _YText extends AbstractType {
  /**
   * @param {String} [string] The initial value of the YText.
   */
  constructor(string3) {
    super();
    this._pending = string3 !== void 0 ? [() => this.insert(0, string3)] : [];
    this._searchMarker = [];
    this._hasFormatting = false;
  }
  /**
   * Number of characters of this text type.
   *
   * @type {number}
   */
  get length() {
    return this._length;
  }
  /**
   * @param {Doc} y
   * @param {Item} item
   */
  _integrate(y4, item2) {
    super._integrate(y4, item2);
    try {
      this._pending.forEach((f6) => f6());
    } catch (e6) {
      console.error(e6);
    }
    this._pending = null;
  }
  _copy() {
    return new _YText();
  }
  /**
   * @return {YText}
   */
  clone() {
    const text7 = new _YText();
    text7.applyDelta(this.toDelta());
    return text7;
  }
  /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    const event = new YTextEvent(this, transaction, parentSubs);
    callTypeObservers(this, transaction, event);
    if (!transaction.local && this._hasFormatting) {
      transaction._needFormattingCleanup = true;
    }
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */
  toString() {
    let str = "";
    let n6 = this._start;
    while (n6 !== null) {
      if (!n6.deleted && n6.countable && n6.content.constructor === ContentString) {
        str += /** @type {ContentString} */
        n6.content.str;
      }
      n6 = n6.right;
    }
    return str;
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {any} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */
  applyDelta(delta, { sanitize = true } = {}) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const currPos = new ItemTextListPosition(null, this._start, 0, /* @__PURE__ */ new Map());
        for (let i6 = 0; i6 < delta.length; i6++) {
          const op = delta[i6];
          if (op.insert !== void 0) {
            const ins = !sanitize && typeof op.insert === "string" && i6 === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === "\n" ? op.insert.slice(0, -1) : op.insert;
            if (typeof ins !== "string" || ins.length > 0) {
              insertText(transaction, this, currPos, ins, op.attributes || {});
            }
          } else if (op.retain !== void 0) {
            formatText(transaction, this, currPos, op.retain, op.attributes || {});
          } else if (op.delete !== void 0) {
            deleteText(transaction, currPos, op.delete);
          }
        }
      });
    } else {
      this._pending.push(() => this.applyDelta(delta));
    }
  }
  /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */
  toDelta(snapshot, prevSnapshot, computeYChange) {
    const ops = [];
    const currentAttributes = /* @__PURE__ */ new Map();
    const doc2 = (
      /** @type {Doc} */
      this.doc
    );
    let str = "";
    let n6 = this._start;
    function packStr() {
      if (str.length > 0) {
        const attributes = {};
        let addAttributes = false;
        currentAttributes.forEach((value2, key) => {
          addAttributes = true;
          attributes[key] = value2;
        });
        const op = { insert: str };
        if (addAttributes) {
          op.attributes = attributes;
        }
        ops.push(op);
        str = "";
      }
    }
    const computeDelta = () => {
      while (n6 !== null) {
        if (isVisible(n6, snapshot) || prevSnapshot !== void 0 && isVisible(n6, prevSnapshot)) {
          switch (n6.content.constructor) {
            case ContentString: {
              const cur = currentAttributes.get("ychange");
              if (snapshot !== void 0 && !isVisible(n6, snapshot)) {
                if (cur === void 0 || cur.user !== n6.id.client || cur.type !== "removed") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("removed", n6.id) : { type: "removed" });
                }
              } else if (prevSnapshot !== void 0 && !isVisible(n6, prevSnapshot)) {
                if (cur === void 0 || cur.user !== n6.id.client || cur.type !== "added") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("added", n6.id) : { type: "added" });
                }
              } else if (cur !== void 0) {
                packStr();
                currentAttributes.delete("ychange");
              }
              str += /** @type {ContentString} */
              n6.content.str;
              break;
            }
            case ContentType:
            case ContentEmbed: {
              packStr();
              const op = {
                insert: n6.content.getContent()[0]
              };
              if (currentAttributes.size > 0) {
                const attrs = (
                  /** @type {Object<string,any>} */
                  {}
                );
                op.attributes = attrs;
                currentAttributes.forEach((value2, key) => {
                  attrs[key] = value2;
                });
              }
              ops.push(op);
              break;
            }
            case ContentFormat:
              if (isVisible(n6, snapshot)) {
                packStr();
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  n6.content
                );
              }
              break;
          }
        }
        n6 = n6.right;
      }
      packStr();
    };
    if (snapshot || prevSnapshot) {
      transact(doc2, (transaction) => {
        if (snapshot) {
          splitSnapshotAffectedStructs(transaction, snapshot);
        }
        if (prevSnapshot) {
          splitSnapshotAffectedStructs(transaction, prevSnapshot);
        }
        computeDelta();
      }, "cleanup");
    } else {
      computeDelta();
    }
    return ops;
  }
  /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */
  insert(index3, text7, attributes) {
    if (text7.length <= 0) {
      return;
    }
    const y4 = this.doc;
    if (y4 !== null) {
      transact(y4, (transaction) => {
        const pos = findPosition(transaction, this, index3, !attributes);
        if (!attributes) {
          attributes = {};
          pos.currentAttributes.forEach((v6, k2) => {
            attributes[k2] = v6;
          });
        }
        insertText(transaction, this, pos, text7, attributes);
      });
    } else {
      this._pending.push(() => this.insert(index3, text7, attributes));
    }
  }
  /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} [attributes] Attribute information to apply on the
   *                                    embed
   *
   * @public
   */
  insertEmbed(index3, embed, attributes) {
    const y4 = this.doc;
    if (y4 !== null) {
      transact(y4, (transaction) => {
        const pos = findPosition(transaction, this, index3, !attributes);
        insertText(transaction, this, pos, embed, attributes || {});
      });
    } else {
      this._pending.push(() => this.insertEmbed(index3, embed, attributes || {}));
    }
  }
  /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */
  delete(index3, length4) {
    if (length4 === 0) {
      return;
    }
    const y4 = this.doc;
    if (y4 !== null) {
      transact(y4, (transaction) => {
        deleteText(transaction, findPosition(transaction, this, index3, true), length4);
      });
    } else {
      this._pending.push(() => this.delete(index3, length4));
    }
  }
  /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */
  format(index3, length4, attributes) {
    if (length4 === 0) {
      return;
    }
    const y4 = this.doc;
    if (y4 !== null) {
      transact(y4, (transaction) => {
        const pos = findPosition(transaction, this, index3, false);
        if (pos.right === null) {
          return;
        }
        formatText(transaction, this, pos, length4, attributes);
      });
    } else {
      this._pending.push(() => this.format(index3, length4, attributes));
    }
  }
  /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._pending.push(() => this.removeAttribute(attributeName));
    }
  }
  /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._pending.push(() => this.setAttribute(attributeName, attributeValue));
    }
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */
  getAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapGet(this, attributeName)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes() {
    return typeMapGetAll(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YTextRefID);
  }
};
var readYText = (_decoder) => new YText();
var YXmlTreeWalker = class {
  /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */
  constructor(root, f6 = () => true) {
    this._filter = f6;
    this._root = root;
    this._currentNode = /** @type {Item} */
    root._start;
    this._firstCall = true;
  }
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */
  next() {
    let n6 = this._currentNode;
    let type2 = n6 && n6.content && /** @type {any} */
    n6.content.type;
    if (n6 !== null && (!this._firstCall || n6.deleted || !this._filter(type2))) {
      do {
        type2 = /** @type {any} */
        n6.content.type;
        if (!n6.deleted && (type2.constructor === YXmlElement || type2.constructor === YXmlFragment) && type2._start !== null) {
          n6 = type2._start;
        } else {
          while (n6 !== null) {
            if (n6.right !== null) {
              n6 = n6.right;
              break;
            } else if (n6.parent === this._root) {
              n6 = null;
            } else {
              n6 = /** @type {AbstractType<any>} */
              n6.parent._item;
            }
          }
        }
      } while (n6 !== null && (n6.deleted || !this._filter(
        /** @type {ContentType} */
        n6.content.type
      )));
    }
    this._firstCall = false;
    if (n6 === null) {
      return { value: void 0, done: true };
    }
    this._currentNode = n6;
    return { value: (
      /** @type {any} */
      n6.content.type
    ), done: false };
  }
};
var YXmlFragment = class _YXmlFragment extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get firstChild() {
    const first = this._first;
    return first ? first.content.getContent()[0] : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y4, item2) {
    super._integrate(y4, item2);
    this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    );
    this._prelimContent = null;
  }
  _copy() {
    return new _YXmlFragment();
  }
  /**
   * @return {YXmlFragment}
   */
  clone() {
    const el = new _YXmlFragment();
    el.insert(0, this.toArray().map((item2) => item2 instanceof AbstractType ? item2.clone() : item2));
    return el;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */
  createTreeWalker(filter3) {
    return new YXmlTreeWalker(this, filter3);
  }
  /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */
  querySelector(query) {
    query = query.toUpperCase();
    const iterator = new YXmlTreeWalker(this, (element4) => element4.nodeName && element4.nodeName.toUpperCase() === query);
    const next2 = iterator.next();
    if (next2.done) {
      return null;
    } else {
      return next2.value;
    }
  }
  /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */
  querySelectorAll(query) {
    query = query.toUpperCase();
    return from2(new YXmlTreeWalker(this, (element4) => element4.nodeName && element4.nodeName.toUpperCase() === query));
  }
  /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));
  }
  /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */
  toString() {
    return typeListMap(this, (xml) => xml.toString()).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const fragment = _document.createDocumentFragment();
    if (binding !== void 0) {
      binding._createAssociation(fragment, this);
    }
    typeListForEach(this, (xmlType) => {
      fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null);
    });
    return fragment;
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insert(index3, content3) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(transaction, this, index3, content3);
      });
    } else {
      this._prelimContent.splice(index3, 0, ...content3);
    }
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insertAfter(ref, content3) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const refItem = ref && ref instanceof AbstractType ? ref._item : ref;
        typeListInsertGenericsAfter(transaction, this, refItem, content3);
      });
    } else {
      const pc = (
        /** @type {Array<any>} */
        this._prelimContent
      );
      const index3 = ref === null ? 0 : pc.findIndex((el) => el === ref) + 1;
      if (index3 === 0 && ref !== null) {
        throw create2("Reference item not found");
      }
      pc.splice(index3, 0, ...content3);
    }
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */
  delete(index3, length4 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index3, length4);
      });
    } else {
      this._prelimContent.splice(index3, length4);
    }
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */
  toArray() {
    return typeListToArray(this);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */
  push(content3) {
    this.insert(this.length, content3);
  }
  /**
   * Preppends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to preppend.
   */
  unshift(content3) {
    this.insert(0, content3);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */
  get(index3) {
    return typeListGet(this, index3);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */
  slice(start2 = 0, end = this.length) {
    return typeListSlice(this, start2, end);
  }
  /**
   * Executes a provided function on once on overy child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */
  forEach(f6) {
    typeListForEach(this, f6);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlFragmentRefID);
  }
};
var readYXmlFragment = (_decoder) => new YXmlFragment();
var YXmlElement = class _YXmlElement extends YXmlFragment {
  constructor(nodeName = "UNDEFINED") {
    super();
    this.nodeName = nodeName;
    this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const n6 = this._item ? this._item.next : null;
    return n6 ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n6.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const n6 = this._item ? this._item.prev : null;
    return n6 ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n6.content.type
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y4, item2) {
    super._integrate(y4, item2);
    /** @type {Map<string, any>} */
    this._prelimAttrs.forEach((value2, key) => {
      this.setAttribute(key, value2);
    });
    this._prelimAttrs = null;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */
  _copy() {
    return new _YXmlElement(this.nodeName);
  }
  /**
   * @return {YXmlElement<KV>}
   */
  clone() {
    const el = new _YXmlElement(this.nodeName);
    const attrs = this.getAttributes();
    forEach(attrs, (value2, key) => {
      if (typeof value2 === "string") {
        el.setAttribute(key, value2);
      }
    });
    el.insert(0, this.toArray().map((item2) => item2 instanceof AbstractType ? item2.clone() : item2));
    return el;
  }
  /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */
  toString() {
    const attrs = this.getAttributes();
    const stringBuilder = [];
    const keys3 = [];
    for (const key in attrs) {
      keys3.push(key);
    }
    keys3.sort();
    const keysLen = keys3.length;
    for (let i6 = 0; i6 < keysLen; i6++) {
      const key = keys3[i6];
      stringBuilder.push(key + '="' + attrs[key] + '"');
    }
    const nodeName = this.nodeName.toLocaleLowerCase();
    const attrsString = stringBuilder.length > 0 ? " " + stringBuilder.join(" ") : "";
    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`;
  }
  /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {string} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._prelimAttrs.delete(attributeName);
    }
  }
  /**
   * Sets or updates an attribute.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that is to be set.
   * @param {KV[KEY]} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._prelimAttrs.set(attributeName, attributeValue);
    }
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {KV[KEY]|undefined} The queried attribute value.
   *
   * @public
   */
  getAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapGet(this, attributeName)
    );
  }
  /**
   * Returns whether an attribute exists
   *
   * @param {string} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */
  hasAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapHas(this, attributeName)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @param {Snapshot} [snapshot]
   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes(snapshot) {
    return (
      /** @type {any} */
      snapshot ? typeMapGetAllSnapshot(this, snapshot) : typeMapGetAll(this)
    );
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const dom = _document.createElement(this.nodeName);
    const attrs = this.getAttributes();
    for (const key in attrs) {
      const value2 = attrs[key];
      if (typeof value2 === "string") {
        dom.setAttribute(key, value2);
      }
    }
    typeListForEach(this, (yxml) => {
      dom.appendChild(yxml.toDOM(_document, hooks, binding));
    });
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlElementRefID);
    encoder.writeKey(this.nodeName);
  }
};
var readYXmlElement = (decoder) => new YXmlElement(decoder.readKey());
var YXmlEvent = class extends YEvent {
  /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with wich the
   *                                  change was created.
   */
  constructor(target, subs, transaction) {
    super(target, transaction);
    this.childListChanged = false;
    this.attributesChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub2) => {
      if (sub2 === null) {
        this.childListChanged = true;
      } else {
        this.attributesChanged.add(sub2);
      }
    });
  }
};
var YXmlHook = class _YXmlHook extends YMap {
  /**
   * @param {string} hookName nodeName of the Dom Node.
   */
  constructor(hookName) {
    super();
    this.hookName = hookName;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   */
  _copy() {
    return new _YXmlHook(this.hookName);
  }
  /**
   * @return {YXmlHook}
   */
  clone() {
    const el = new _YXmlHook(this.hookName);
    this.forEach((value2, key) => {
      el.set(key, value2);
    });
    return el;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type
   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const hook = hooks[this.hookName];
    let dom;
    if (hook !== void 0) {
      dom = hook.createDom(this);
    } else {
      dom = document.createElement(this.hookName);
    }
    dom.setAttribute("data-yjs-hook", this.hookName);
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlHookRefID);
    encoder.writeKey(this.hookName);
  }
};
var readYXmlHook = (decoder) => new YXmlHook(decoder.readKey());
var YXmlText = class _YXmlText extends YText {
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const n6 = this._item ? this._item.next : null;
    return n6 ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n6.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const n6 = this._item ? this._item.prev : null;
    return n6 ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n6.content.type
    ) : null;
  }
  _copy() {
    return new _YXmlText();
  }
  /**
   * @return {YXmlText}
   */
  clone() {
    const text7 = new _YXmlText();
    text7.applyDelta(this.toDelta());
    return text7;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlText.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks, binding) {
    const dom = _document.createTextNode(this.toString());
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  toString() {
    return this.toDelta().map((delta) => {
      const nestedNodes = [];
      for (const nodeName in delta.attributes) {
        const attrs = [];
        for (const key in delta.attributes[nodeName]) {
          attrs.push({ key, value: delta.attributes[nodeName][key] });
        }
        attrs.sort((a3, b2) => a3.key < b2.key ? -1 : 1);
        nestedNodes.push({ nodeName, attrs });
      }
      nestedNodes.sort((a3, b2) => a3.nodeName < b2.nodeName ? -1 : 1);
      let str = "";
      for (let i6 = 0; i6 < nestedNodes.length; i6++) {
        const node4 = nestedNodes[i6];
        str += `<${node4.nodeName}`;
        for (let j4 = 0; j4 < node4.attrs.length; j4++) {
          const attr = node4.attrs[j4];
          str += ` ${attr.key}="${attr.value}"`;
        }
        str += ">";
      }
      str += delta.insert;
      for (let i6 = nestedNodes.length - 1; i6 >= 0; i6--) {
        str += `</${nestedNodes[i6].nodeName}>`;
      }
      return str;
    }).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlTextRefID);
  }
};
var readYXmlText = (decoder) => new YXmlText();
var AbstractStruct = class {
  /**
   * @param {ID} id
   * @param {number} length
   */
  constructor(id2, length4) {
    this.id = id2;
    this.length = length4;
  }
  /**
   * @type {boolean}
   */
  get deleted() {
    throw methodUnimplemented();
  }
  /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} wether this merged with right
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */
  write(encoder, offset, encodingRef) {
    throw methodUnimplemented();
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    throw methodUnimplemented();
  }
};
var structGCRefNumber = 0;
var GC = class extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  /**
   * @param {GC} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.length -= offset;
    }
    addStruct(transaction.doc.store, this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeInfo(structGCRefNumber);
    encoder.writeLen(this.length - offset);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store2) {
    return null;
  }
};
var ContentBinary = class _ContentBinary {
  /**
   * @param {Uint8Array} content
   */
  constructor(content3) {
    this.content = content3;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.content];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentBinary}
   */
  copy() {
    return new _ContentBinary(this.content);
  }
  /**
   * @param {number} offset
   * @return {ContentBinary}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentBinary} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item2) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store2) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeBuf(this.content);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 3;
  }
};
var readContentBinary = (decoder) => new ContentBinary(decoder.readBuf());
var ContentDeleted = class _ContentDeleted {
  /**
   * @param {number} len
   */
  constructor(len) {
    this.len = len;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.len;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return false;
  }
  /**
   * @return {ContentDeleted}
   */
  copy() {
    return new _ContentDeleted(this.len);
  }
  /**
   * @param {number} offset
   * @return {ContentDeleted}
   */
  splice(offset) {
    const right = new _ContentDeleted(this.len - offset);
    this.len = offset;
    return right;
  }
  /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.len += right.len;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item2) {
    addToDeleteSet(transaction.deleteSet, item2.id.client, item2.id.clock, this.len);
    item2.markDeleted();
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store2) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeLen(this.len - offset);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 1;
  }
};
var readContentDeleted = (decoder) => new ContentDeleted(decoder.readLen());
var createDocFromOpts = (guid, opts) => new Doc({ guid, ...opts, shouldLoad: opts.shouldLoad || opts.autoLoad || false });
var ContentDoc = class _ContentDoc {
  /**
   * @param {Doc} doc
   */
  constructor(doc2) {
    if (doc2._item) {
      console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid.");
    }
    this.doc = doc2;
    const opts = {};
    this.opts = opts;
    if (!doc2.gc) {
      opts.gc = false;
    }
    if (doc2.autoLoad) {
      opts.autoLoad = true;
    }
    if (doc2.meta !== null) {
      opts.meta = doc2.meta;
    }
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.doc];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentDoc}
   */
  copy() {
    return new _ContentDoc(createDocFromOpts(this.doc.guid, this.opts));
  }
  /**
   * @param {number} offset
   * @return {ContentDoc}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentDoc} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item2) {
    this.doc._item = item2;
    transaction.subdocsAdded.add(this.doc);
    if (this.doc.shouldLoad) {
      transaction.subdocsLoaded.add(this.doc);
    }
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
    if (transaction.subdocsAdded.has(this.doc)) {
      transaction.subdocsAdded.delete(this.doc);
    } else {
      transaction.subdocsRemoved.add(this.doc);
    }
  }
  /**
   * @param {StructStore} store
   */
  gc(store2) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeString(this.doc.guid);
    encoder.writeAny(this.opts);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 9;
  }
};
var readContentDoc = (decoder) => new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny()));
var ContentEmbed = class _ContentEmbed {
  /**
   * @param {Object} embed
   */
  constructor(embed) {
    this.embed = embed;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.embed];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentEmbed}
   */
  copy() {
    return new _ContentEmbed(this.embed);
  }
  /**
   * @param {number} offset
   * @return {ContentEmbed}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item2) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store2) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeJSON(this.embed);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 5;
  }
};
var readContentEmbed = (decoder) => new ContentEmbed(decoder.readJSON());
var ContentFormat = class _ContentFormat {
  /**
   * @param {string} key
   * @param {Object} value
   */
  constructor(key, value2) {
    this.key = key;
    this.value = value2;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return false;
  }
  /**
   * @return {ContentFormat}
   */
  copy() {
    return new _ContentFormat(this.key, this.value);
  }
  /**
   * @param {number} _offset
   * @return {ContentFormat}
   */
  splice(_offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentFormat} _right
   * @return {boolean}
   */
  mergeWith(_right) {
    return false;
  }
  /**
   * @param {Transaction} _transaction
   * @param {Item} item
   */
  integrate(_transaction, item2) {
    const p5 = (
      /** @type {YText} */
      item2.parent
    );
    p5._searchMarker = null;
    p5._hasFormatting = true;
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store2) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeKey(this.key);
    encoder.writeJSON(this.value);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 6;
  }
};
var readContentFormat = (decoder) => new ContentFormat(decoder.readKey(), decoder.readJSON());
var ContentJSON = class _ContentJSON {
  /**
   * @param {Array<any>} arr
   */
  constructor(arr) {
    this.arr = arr;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentJSON}
   */
  copy() {
    return new _ContentJSON(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentJSON}
   */
  splice(offset) {
    const right = new _ContentJSON(this.arr.slice(offset));
    this.arr = this.arr.slice(0, offset);
    return right;
  }
  /**
   * @param {ContentJSON} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item2) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store2) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    const len = this.arr.length;
    encoder.writeLen(len - offset);
    for (let i6 = offset; i6 < len; i6++) {
      const c5 = this.arr[i6];
      encoder.writeString(c5 === void 0 ? "undefined" : JSON.stringify(c5));
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 2;
  }
};
var readContentJSON = (decoder) => {
  const len = decoder.readLen();
  const cs = [];
  for (let i6 = 0; i6 < len; i6++) {
    const c5 = decoder.readString();
    if (c5 === "undefined") {
      cs.push(void 0);
    } else {
      cs.push(JSON.parse(c5));
    }
  }
  return new ContentJSON(cs);
};
var ContentAny = class _ContentAny {
  /**
   * @param {Array<any>} arr
   */
  constructor(arr) {
    this.arr = arr;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentAny}
   */
  copy() {
    return new _ContentAny(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentAny}
   */
  splice(offset) {
    const right = new _ContentAny(this.arr.slice(offset));
    this.arr = this.arr.slice(0, offset);
    return right;
  }
  /**
   * @param {ContentAny} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item2) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store2) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    const len = this.arr.length;
    encoder.writeLen(len - offset);
    for (let i6 = offset; i6 < len; i6++) {
      const c5 = this.arr[i6];
      encoder.writeAny(c5);
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 8;
  }
};
var readContentAny = (decoder) => {
  const len = decoder.readLen();
  const cs = [];
  for (let i6 = 0; i6 < len; i6++) {
    cs.push(decoder.readAny());
  }
  return new ContentAny(cs);
};
var ContentString = class _ContentString {
  /**
   * @param {string} str
   */
  constructor(str) {
    this.str = str;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.str.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.str.split("");
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentString}
   */
  copy() {
    return new _ContentString(this.str);
  }
  /**
   * @param {number} offset
   * @return {ContentString}
   */
  splice(offset) {
    const right = new _ContentString(this.str.slice(offset));
    this.str = this.str.slice(0, offset);
    const firstCharCode = this.str.charCodeAt(offset - 1);
    if (firstCharCode >= 55296 && firstCharCode <= 56319) {
      this.str = this.str.slice(0, offset - 1) + "�";
      right.str = "�" + right.str.slice(1);
    }
    return right;
  }
  /**
   * @param {ContentString} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.str += right.str;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item2) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store2) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));
  }
  /**
   * @return {number}
   */
  getRef() {
    return 4;
  }
};
var readContentString = (decoder) => new ContentString(decoder.readString());
var typeRefs = [
  readYArray,
  readYMap,
  readYText,
  readYXmlElement,
  readYXmlFragment,
  readYXmlHook,
  readYXmlText
];
var YArrayRefID = 0;
var YMapRefID = 1;
var YTextRefID = 2;
var YXmlElementRefID = 3;
var YXmlFragmentRefID = 4;
var YXmlHookRefID = 5;
var YXmlTextRefID = 6;
var ContentType = class _ContentType {
  /**
   * @param {AbstractType<any>} type
   */
  constructor(type2) {
    this.type = type2;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.type];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentType}
   */
  copy() {
    return new _ContentType(this.type._copy());
  }
  /**
   * @param {number} offset
   * @return {ContentType}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentType} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item2) {
    this.type._integrate(transaction.doc, item2);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
    let item2 = this.type._start;
    while (item2 !== null) {
      if (!item2.deleted) {
        item2.delete(transaction);
      } else if (item2.id.clock < (transaction.beforeState.get(item2.id.client) || 0)) {
        transaction._mergeStructs.push(item2);
      }
      item2 = item2.right;
    }
    this.type._map.forEach((item3) => {
      if (!item3.deleted) {
        item3.delete(transaction);
      } else if (item3.id.clock < (transaction.beforeState.get(item3.id.client) || 0)) {
        transaction._mergeStructs.push(item3);
      }
    });
    transaction.changed.delete(this.type);
  }
  /**
   * @param {StructStore} store
   */
  gc(store2) {
    let item2 = this.type._start;
    while (item2 !== null) {
      item2.gc(store2, true);
      item2 = item2.right;
    }
    this.type._start = null;
    this.type._map.forEach(
      /** @param {Item | null} item */
      (item3) => {
        while (item3 !== null) {
          item3.gc(store2, true);
          item3 = item3.left;
        }
      }
    );
    this.type._map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    this.type._write(encoder);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 7;
  }
};
var readContentType = (decoder) => new ContentType(typeRefs[decoder.readTypeRef()](decoder));
var splitItem = (transaction, leftItem, diff) => {
  const { client, clock } = leftItem.id;
  const rightItem = new Item(
    createID(client, clock + diff),
    leftItem,
    createID(client, clock + diff - 1),
    leftItem.right,
    leftItem.rightOrigin,
    leftItem.parent,
    leftItem.parentSub,
    leftItem.content.splice(diff)
  );
  if (leftItem.deleted) {
    rightItem.markDeleted();
  }
  if (leftItem.keep) {
    rightItem.keep = true;
  }
  if (leftItem.redone !== null) {
    rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);
  }
  leftItem.right = rightItem;
  if (rightItem.right !== null) {
    rightItem.right.left = rightItem;
  }
  transaction._mergeStructs.push(rightItem);
  if (rightItem.parentSub !== null && rightItem.right === null) {
    rightItem.parent._map.set(rightItem.parentSub, rightItem);
  }
  leftItem.length = diff;
  return rightItem;
};
var Item = class _Item extends AbstractStruct {
  /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */
  constructor(id2, left, origin, right, rightOrigin, parent, parentSub, content3) {
    super(id2, content3.getLength());
    this.origin = origin;
    this.left = left;
    this.right = right;
    this.rightOrigin = rightOrigin;
    this.parent = parent;
    this.parentSub = parentSub;
    this.redone = null;
    this.content = content3;
    this.info = this.content.isCountable() ? BIT2 : 0;
  }
  /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */
  set marker(isMarked) {
    if ((this.info & BIT4) > 0 !== isMarked) {
      this.info ^= BIT4;
    }
  }
  get marker() {
    return (this.info & BIT4) > 0;
  }
  /**
   * If true, do not garbage collect this Item.
   */
  get keep() {
    return (this.info & BIT1) > 0;
  }
  set keep(doKeep) {
    if (this.keep !== doKeep) {
      this.info ^= BIT1;
    }
  }
  get countable() {
    return (this.info & BIT2) > 0;
  }
  /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */
  get deleted() {
    return (this.info & BIT3) > 0;
  }
  set deleted(doDelete) {
    if (this.deleted !== doDelete) {
      this.info ^= BIT3;
    }
  }
  markDeleted() {
    this.info |= BIT3;
  }
  /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store2) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store2, this.origin.client)) {
      return this.origin.client;
    }
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store2, this.rightOrigin.client)) {
      return this.rightOrigin.client;
    }
    if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store2, this.parent.client)) {
      return this.parent.client;
    }
    if (this.origin) {
      this.left = getItemCleanEnd(transaction, store2, this.origin);
      this.origin = this.left.lastId;
    }
    if (this.rightOrigin) {
      this.right = getItemCleanStart(transaction, this.rightOrigin);
      this.rightOrigin = this.right.id;
    }
    if (this.left && this.left.constructor === GC || this.right && this.right.constructor === GC) {
      this.parent = null;
    } else if (!this.parent) {
      if (this.left && this.left.constructor === _Item) {
        this.parent = this.left.parent;
        this.parentSub = this.left.parentSub;
      }
      if (this.right && this.right.constructor === _Item) {
        this.parent = this.right.parent;
        this.parentSub = this.right.parentSub;
      }
    } else if (this.parent.constructor === ID) {
      const parentItem = getItem(store2, this.parent);
      if (parentItem.constructor === GC) {
        this.parent = null;
      } else {
        this.parent = /** @type {ContentType} */
        parentItem.content.type;
      }
    }
    return null;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));
      this.origin = this.left.lastId;
      this.content = this.content.splice(offset);
      this.length -= offset;
    }
    if (this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let left = this.left;
        let o5;
        if (left !== null) {
          o5 = left.right;
        } else if (this.parentSub !== null) {
          o5 = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null;
          while (o5 !== null && o5.left !== null) {
            o5 = o5.left;
          }
        } else {
          o5 = /** @type {AbstractType<any>} */
          this.parent._start;
        }
        const conflictingItems = /* @__PURE__ */ new Set();
        const itemsBeforeOrigin = /* @__PURE__ */ new Set();
        while (o5 !== null && o5 !== this.right) {
          itemsBeforeOrigin.add(o5);
          conflictingItems.add(o5);
          if (compareIDs(this.origin, o5.origin)) {
            if (o5.id.client < this.id.client) {
              left = o5;
              conflictingItems.clear();
            } else if (compareIDs(this.rightOrigin, o5.rightOrigin)) {
              break;
            }
          } else if (o5.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o5.origin))) {
            if (!conflictingItems.has(getItem(transaction.doc.store, o5.origin))) {
              left = o5;
              conflictingItems.clear();
            }
          } else {
            break;
          }
          o5 = o5.right;
        }
        this.left = left;
      }
      if (this.left !== null) {
        const right = this.left.right;
        this.right = right;
        this.left.right = this;
      } else {
        let r7;
        if (this.parentSub !== null) {
          r7 = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null;
          while (r7 !== null && r7.left !== null) {
            r7 = r7.left;
          }
        } else {
          r7 = /** @type {AbstractType<any>} */
          this.parent._start;
          this.parent._start = this;
        }
        this.right = r7;
      }
      if (this.right !== null) {
        this.right.left = this;
      } else if (this.parentSub !== null) {
        this.parent._map.set(this.parentSub, this);
        if (this.left !== null) {
          this.left.delete(transaction);
        }
      }
      if (this.parentSub === null && this.countable && !this.deleted) {
        this.parent._length += this.length;
      }
      addStruct(transaction.doc.store, this);
      this.content.integrate(transaction, this);
      addChangedTypeToTransaction(
        transaction,
        /** @type {AbstractType<any>} */
        this.parent,
        this.parentSub
      );
      if (
        /** @type {AbstractType<any>} */
        this.parent._item !== null && /** @type {AbstractType<any>} */
        this.parent._item.deleted || this.parentSub !== null && this.right !== null
      ) {
        this.delete(transaction);
      }
    } else {
      new GC(this.id, this.length).integrate(transaction, 0);
    }
  }
  /**
   * Returns the next non-deleted item
   */
  get next() {
    let n6 = this.right;
    while (n6 !== null && n6.deleted) {
      n6 = n6.right;
    }
    return n6;
  }
  /**
   * Returns the previous non-deleted item
   */
  get prev() {
    let n6 = this.left;
    while (n6 !== null && n6.deleted) {
      n6 = n6.left;
    }
    return n6;
  }
  /**
   * Computes the last content address of this Item.
   */
  get lastId() {
    return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1);
  }
  /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor === right.constructor && compareIDs(right.origin, this.lastId) && this.right === right && compareIDs(this.rightOrigin, right.rightOrigin) && this.id.client === right.id.client && this.id.clock + this.length === right.id.clock && this.deleted === right.deleted && this.redone === null && right.redone === null && this.content.constructor === right.content.constructor && this.content.mergeWith(right.content)) {
      const searchMarker = (
        /** @type {AbstractType<any>} */
        this.parent._searchMarker
      );
      if (searchMarker) {
        searchMarker.forEach((marker) => {
          if (marker.p === right) {
            marker.p = this;
            if (!this.deleted && this.countable) {
              marker.index -= this.length;
            }
          }
        });
      }
      if (right.keep) {
        this.keep = true;
      }
      this.right = right.right;
      if (this.right !== null) {
        this.right.left = this;
      }
      this.length += right.length;
      return true;
    }
    return false;
  }
  /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */
  delete(transaction) {
    if (!this.deleted) {
      const parent = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (this.countable && this.parentSub === null) {
        parent._length -= this.length;
      }
      this.markDeleted();
      addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);
      addChangedTypeToTransaction(transaction, parent, this.parentSub);
      this.content.delete(transaction);
    }
  }
  /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */
  gc(store2, parentGCd) {
    if (!this.deleted) {
      throw unexpectedCase();
    }
    this.content.gc(store2);
    if (parentGCd) {
      replaceStruct(store2, this, new GC(this.id, this.length));
    } else {
      this.content = new ContentDeleted(this.length);
    }
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */
  write(encoder, offset) {
    const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;
    const rightOrigin = this.rightOrigin;
    const parentSub = this.parentSub;
    const info = this.content.getRef() & BITS5 | (origin === null ? 0 : BIT8) | // origin is defined
    (rightOrigin === null ? 0 : BIT7) | // right origin is defined
    (parentSub === null ? 0 : BIT6);
    encoder.writeInfo(info);
    if (origin !== null) {
      encoder.writeLeftID(origin);
    }
    if (rightOrigin !== null) {
      encoder.writeRightID(rightOrigin);
    }
    if (origin === null && rightOrigin === null) {
      const parent = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (parent._item !== void 0) {
        const parentItem = parent._item;
        if (parentItem === null) {
          const ykey = findRootTypeKey(parent);
          encoder.writeParentInfo(true);
          encoder.writeString(ykey);
        } else {
          encoder.writeParentInfo(false);
          encoder.writeLeftID(parentItem.id);
        }
      } else if (parent.constructor === String) {
        encoder.writeParentInfo(true);
        encoder.writeString(parent);
      } else if (parent.constructor === ID) {
        encoder.writeParentInfo(false);
        encoder.writeLeftID(parent);
      } else {
        unexpectedCase();
      }
      if (parentSub !== null) {
        encoder.writeString(parentSub);
      }
    }
    this.content.write(encoder, offset);
  }
};
var readItemContent = (decoder, info) => contentRefs[info & BITS5](decoder);
var contentRefs = [
  () => {
    unexpectedCase();
  },
  // GC is not ItemContent
  readContentDeleted,
  // 1
  readContentJSON,
  // 2
  readContentBinary,
  // 3
  readContentString,
  // 4
  readContentEmbed,
  // 5
  readContentFormat,
  // 6
  readContentType,
  // 7
  readContentAny,
  // 8
  readContentDoc,
  // 9
  () => {
    unexpectedCase();
  }
  // 10 - Skip is not ItemContent
];
var structSkipRefNumber = 10;
var Skip = class extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  /**
   * @param {Skip} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    unexpectedCase();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeInfo(structSkipRefNumber);
    writeVarUint(encoder.restEncoder, this.length - offset);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store2) {
    return null;
  }
};
var glo = (
  /** @type {any} */
  typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {}
);
var importIdentifier = "__ $YJS$ __";
if (glo[importIdentifier] === true) {
  console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
}
glo[importIdentifier] = true;

// node_modules/js-base64/base64.mjs
var _hasBuffer = typeof Buffer === "function";
var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var b64chs = Array.prototype.slice.call(b64ch);
var b64tab = ((a3) => {
  let tab = {};
  a3.forEach((c5, i6) => tab[c5] = i6);
  return tab;
})(b64chs);
var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
var _fromCC = String.fromCharCode.bind(String);
var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));
var _mkUriSafe = (src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
var _tidyB64 = (s4) => s4.replace(/[^A-Za-z0-9\+\/]/g, "");
var btoaPolyfill = (bin) => {
  let u32, c0, c1, c22, asc = "";
  const pad = bin.length % 3;
  for (let i6 = 0; i6 < bin.length; ) {
    if ((c0 = bin.charCodeAt(i6++)) > 255 || (c1 = bin.charCodeAt(i6++)) > 255 || (c22 = bin.charCodeAt(i6++)) > 255)
      throw new TypeError("invalid character found");
    u32 = c0 << 16 | c1 << 8 | c22;
    asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
  }
  return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
var _btoa = typeof btoa === "function" ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, "binary").toString("base64") : btoaPolyfill;
var _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString("base64") : (u8a) => {
  const maxargs = 4096;
  let strs = [];
  for (let i6 = 0, l7 = u8a.length; i6 < l7; i6 += maxargs) {
    strs.push(_fromCC.apply(null, u8a.subarray(i6, i6 + maxargs)));
  }
  return _btoa(strs.join(""));
};
var fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
var atobPolyfill = (asc) => {
  asc = asc.replace(/\s+/g, "");
  if (!b64re.test(asc))
    throw new TypeError("malformed base64.");
  asc += "==".slice(2 - (asc.length & 3));
  let u24, bin = "", r1, r22;
  for (let i6 = 0; i6 < asc.length; ) {
    u24 = b64tab[asc.charAt(i6++)] << 18 | b64tab[asc.charAt(i6++)] << 12 | (r1 = b64tab[asc.charAt(i6++)]) << 6 | (r22 = b64tab[asc.charAt(i6++)]);
    bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r22 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
  }
  return bin;
};
var _atob = typeof atob === "function" ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, "base64").toString("binary") : atobPolyfill;
var _toUint8Array = _hasBuffer ? (a3) => _U8Afrom(Buffer.from(a3, "base64")) : (a3) => _U8Afrom(_atob(a3).split("").map((c5) => c5.charCodeAt(0)));
var toUint8Array2 = (a3) => _toUint8Array(_unURI(a3));
var _unURI = (a3) => _tidyB64(a3.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/"));

// node_modules/@react-stately/utils/dist/import.mjs
var import_react = __toESM(require_react(), 1);
function $458b0a5536c1a7cf$export$40bfa8c7b0832715(value2, defaultValue, onChange2) {
  let [stateValue, setStateValue] = (0, import_react.useState)(value2 || defaultValue);
  let isControlledRef = (0, import_react.useRef)(value2 !== void 0);
  let isControlled = value2 !== void 0;
  (0, import_react.useEffect)(() => {
    let wasControlled = isControlledRef.current;
    if (wasControlled !== isControlled)
      console.warn(`WARN: A component changed from ${wasControlled ? "controlled" : "uncontrolled"} to ${isControlled ? "controlled" : "uncontrolled"}.`);
    isControlledRef.current = isControlled;
  }, [
    isControlled
  ]);
  let currentValue = isControlled ? value2 : stateValue;
  let setValue = (0, import_react.useCallback)((value3, ...args2) => {
    let onChangeCaller = (value4, ...onChangeArgs) => {
      if (onChange2) {
        if (!Object.is(currentValue, value4))
          onChange2(value4, ...onChangeArgs);
      }
      if (!isControlled)
        currentValue = value4;
    };
    if (typeof value3 === "function") {
      console.warn("We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320");
      let updateFunction = (oldValue, ...functionArgs) => {
        let interceptedValue = value3(isControlled ? currentValue : oldValue, ...functionArgs);
        onChangeCaller(interceptedValue, ...args2);
        if (!isControlled)
          return interceptedValue;
        return oldValue;
      };
      setStateValue(updateFunction);
    } else {
      if (!isControlled)
        setStateValue(value3);
      onChangeCaller(value3, ...args2);
    }
  }, [
    isControlled,
    currentValue,
    onChange2
  ]);
  return [
    currentValue,
    setValue
  ];
}
function $9446cca9a3875146$export$7d15b64cf5a3a4c4(value2, min3 = -Infinity, max4 = Infinity) {
  let newValue = Math.min(Math.max(value2, min3), max4);
  return newValue;
}
function $9446cca9a3875146$export$cb6e0bb50bc19463(value2, min3, max4, step) {
  min3 = Number(min3);
  max4 = Number(max4);
  let remainder = (value2 - (isNaN(min3) ? 0 : min3)) % step;
  let snappedValue = Math.abs(remainder) * 2 >= step ? value2 + Math.sign(remainder) * (step - Math.abs(remainder)) : value2 - remainder;
  if (!isNaN(min3)) {
    if (snappedValue < min3)
      snappedValue = min3;
    else if (!isNaN(max4) && snappedValue > max4)
      snappedValue = min3 + Math.floor((max4 - min3) / step) * step;
  } else if (!isNaN(max4) && snappedValue > max4)
    snappedValue = Math.floor(max4 / step) * step;
  let string3 = step.toString();
  let index3 = string3.indexOf(".");
  let precision = index3 >= 0 ? string3.length - index3 : 0;
  if (precision > 0) {
    let pow2 = Math.pow(10, precision);
    snappedValue = Math.round(snappedValue * pow2) / pow2;
  }
  return snappedValue;
}

// node_modules/@react-aria/utils/dist/import.mjs
var import_react3 = __toESM(require_react(), 1);

// node_modules/@react-aria/ssr/dist/import.mjs
var import_react2 = __toESM(require_react(), 1);
var $b5e257d569688ac6$var$defaultContext = {
  prefix: String(Math.round(Math.random() * 1e10)),
  current: 0
};
var $b5e257d569688ac6$var$SSRContext = (0, import_react2.default).createContext($b5e257d569688ac6$var$defaultContext);
var $b5e257d569688ac6$var$IsSSRContext = (0, import_react2.default).createContext(false);
var $b5e257d569688ac6$var$canUseDOM = Boolean(typeof window !== "undefined" && window.document && window.document.createElement);
var $b5e257d569688ac6$var$componentIds = /* @__PURE__ */ new WeakMap();
function $b5e257d569688ac6$var$useCounter(isDisabled = false) {
  let ctx = (0, import_react2.useContext)($b5e257d569688ac6$var$SSRContext);
  let ref = (0, import_react2.useRef)(null);
  if (ref.current === null && !isDisabled) {
    var _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner, _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    let currentOwner = (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = (0, import_react2.default).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === void 0 ? void 0 : (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner = _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner === void 0 ? void 0 : _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner.current;
    if (currentOwner) {
      let prevComponentValue = $b5e257d569688ac6$var$componentIds.get(currentOwner);
      if (prevComponentValue == null)
        $b5e257d569688ac6$var$componentIds.set(currentOwner, {
          id: ctx.current,
          state: currentOwner.memoizedState
        });
      else if (currentOwner.memoizedState !== prevComponentValue.state) {
        ctx.current = prevComponentValue.id;
        $b5e257d569688ac6$var$componentIds.delete(currentOwner);
      }
    }
    ref.current = ++ctx.current;
  }
  return ref.current;
}
function $b5e257d569688ac6$var$useLegacySSRSafeId(defaultId) {
  let ctx = (0, import_react2.useContext)($b5e257d569688ac6$var$SSRContext);
  if (ctx === $b5e257d569688ac6$var$defaultContext && !$b5e257d569688ac6$var$canUseDOM)
    console.warn("When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.");
  let counter2 = $b5e257d569688ac6$var$useCounter(!!defaultId);
  let prefix4 = ctx === $b5e257d569688ac6$var$defaultContext && false ? "react-aria" : `react-aria${ctx.prefix}`;
  return defaultId || `${prefix4}-${counter2}`;
}
function $b5e257d569688ac6$var$useModernSSRSafeId(defaultId) {
  let id2 = (0, import_react2.default).useId();
  let [didSSR] = (0, import_react2.useState)($b5e257d569688ac6$export$535bd6ca7f90a273());
  let prefix4 = didSSR || false ? "react-aria" : `react-aria${$b5e257d569688ac6$var$defaultContext.prefix}`;
  return defaultId || `${prefix4}-${id2}`;
}
var $b5e257d569688ac6$export$619500959fc48b26 = typeof (0, import_react2.default)["useId"] === "function" ? $b5e257d569688ac6$var$useModernSSRSafeId : $b5e257d569688ac6$var$useLegacySSRSafeId;
function $b5e257d569688ac6$var$getSnapshot() {
  return false;
}
function $b5e257d569688ac6$var$getServerSnapshot() {
  return true;
}
function $b5e257d569688ac6$var$subscribe(onStoreChange) {
  return () => {
  };
}
function $b5e257d569688ac6$export$535bd6ca7f90a273() {
  if (typeof (0, import_react2.default)["useSyncExternalStore"] === "function")
    return (0, import_react2.default)["useSyncExternalStore"]($b5e257d569688ac6$var$subscribe, $b5e257d569688ac6$var$getSnapshot, $b5e257d569688ac6$var$getServerSnapshot);
  return (0, import_react2.useContext)($b5e257d569688ac6$var$IsSSRContext);
}

// node_modules/clsx/dist/clsx.mjs
function r2(e6) {
  var t5, f6, n6 = "";
  if ("string" == typeof e6 || "number" == typeof e6)
    n6 += e6;
  else if ("object" == typeof e6)
    if (Array.isArray(e6)) {
      var o5 = e6.length;
      for (t5 = 0; t5 < o5; t5++)
        e6[t5] && (f6 = r2(e6[t5])) && (n6 && (n6 += " "), n6 += f6);
    } else
      for (f6 in e6)
        e6[f6] && (n6 && (n6 += " "), n6 += f6);
  return n6;
}
function clsx() {
  for (var e6, t5, f6 = 0, n6 = "", o5 = arguments.length; f6 < o5; f6++)
    (e6 = arguments[f6]) && (t5 = r2(e6)) && (n6 && (n6 += " "), n6 += t5);
  return n6;
}
var clsx_default = clsx;

// node_modules/@react-aria/utils/dist/import.mjs
var $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = typeof document !== "undefined" ? (0, import_react3.default).useLayoutEffect : () => {
};
function $8ae05eaa5c114e9c$export$7f54fc3180508a52(fn2) {
  const ref = (0, import_react3.useRef)(null);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    ref.current = fn2;
  }, [
    fn2
  ]);
  return (0, import_react3.useCallback)((...args2) => {
    const f6 = ref.current;
    return f6 === null || f6 === void 0 ? void 0 : f6(...args2);
  }, []);
}
function $1dbecbe27a04f9af$export$14d238f342723f25(defaultValue) {
  let [value2, setValue] = (0, import_react3.useState)(defaultValue);
  let effect = (0, import_react3.useRef)(null);
  let nextRef = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(() => {
    if (!effect.current)
      return;
    let newValue = effect.current.next();
    if (newValue.done) {
      effect.current = null;
      return;
    }
    if (value2 === newValue.value)
      nextRef();
    else
      setValue(newValue.value);
  });
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (effect.current)
      nextRef();
  });
  let queue = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((fn2) => {
    effect.current = fn2(value2);
    nextRef();
  });
  return [
    value2,
    queue
  ];
}
var $bdb11010cef70236$var$canUseDOM = Boolean(typeof window !== "undefined" && window.document && window.document.createElement);
var $bdb11010cef70236$var$idsUpdaterMap = /* @__PURE__ */ new Map();
function $bdb11010cef70236$export$f680877a34711e37(defaultId) {
  let [value2, setValue] = (0, import_react3.useState)(defaultId);
  let nextId = (0, import_react3.useRef)(null);
  let res = (0, $b5e257d569688ac6$export$619500959fc48b26)(value2);
  let updateValue2 = (0, import_react3.useCallback)((val) => {
    nextId.current = val;
  }, []);
  if ($bdb11010cef70236$var$canUseDOM)
    $bdb11010cef70236$var$idsUpdaterMap.set(res, updateValue2);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    let r7 = res;
    return () => {
      $bdb11010cef70236$var$idsUpdaterMap.delete(r7);
    };
  }, [
    res
  ]);
  (0, import_react3.useEffect)(() => {
    let newId = nextId.current;
    if (newId) {
      nextId.current = null;
      setValue(newId);
    }
  });
  return res;
}
function $bdb11010cef70236$export$cd8c9cb68f842629(idA, idB) {
  if (idA === idB)
    return idA;
  let setIdA = $bdb11010cef70236$var$idsUpdaterMap.get(idA);
  if (setIdA) {
    setIdA(idB);
    return idB;
  }
  let setIdB = $bdb11010cef70236$var$idsUpdaterMap.get(idB);
  if (setIdB) {
    setIdB(idA);
    return idA;
  }
  return idB;
}
function $bdb11010cef70236$export$b4cc09c592e8fdb8(depArray = []) {
  let id2 = $bdb11010cef70236$export$f680877a34711e37();
  let [resolvedId, setResolvedId] = (0, $1dbecbe27a04f9af$export$14d238f342723f25)(id2);
  let updateId = (0, import_react3.useCallback)(() => {
    setResolvedId(function* () {
      yield id2;
      yield document.getElementById(id2) ? id2 : void 0;
    });
  }, [
    id2,
    setResolvedId
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(updateId, [
    id2,
    updateId,
    ...depArray
  ]);
  return resolvedId;
}
function $ff5963eb1fccf552$export$e08e3b67e392101e(...callbacks2) {
  return (...args2) => {
    for (let callback of callbacks2)
      if (typeof callback === "function")
        callback(...args2);
  };
}
var $431fbd86ca7dc216$export$b204af158042fbac = (el) => {
  var _el_ownerDocument;
  return (_el_ownerDocument = el === null || el === void 0 ? void 0 : el.ownerDocument) !== null && _el_ownerDocument !== void 0 ? _el_ownerDocument : document;
};
var $431fbd86ca7dc216$export$f21a1ffae260145a = (el) => {
  if (el && "window" in el && el.window === el)
    return el;
  const doc2 = $431fbd86ca7dc216$export$b204af158042fbac(el);
  return doc2.defaultView || window;
};
function $3ef42575df84b30b$export$9d1611c77c2fe928(...args2) {
  let result = {
    ...args2[0]
  };
  for (let i6 = 1; i6 < args2.length; i6++) {
    let props = args2[i6];
    for (let key in props) {
      let a3 = result[key];
      let b2 = props[key];
      if (typeof a3 === "function" && typeof b2 === "function" && // This is a lot faster than a regex.
      key[0] === "o" && key[1] === "n" && key.charCodeAt(2) >= /* 'A' */
      65 && key.charCodeAt(2) <= /* 'Z' */
      90)
        result[key] = (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(a3, b2);
      else if ((key === "className" || key === "UNSAFE_className") && typeof a3 === "string" && typeof b2 === "string")
        result[key] = (0, clsx_default)(a3, b2);
      else if (key === "id" && a3 && b2)
        result.id = (0, $bdb11010cef70236$export$cd8c9cb68f842629)(a3, b2);
      else
        result[key] = b2 !== void 0 ? b2 : a3;
    }
  }
  return result;
}
function $5dc95899b306f630$export$c9058316764c140e(...refs) {
  if (refs.length === 1)
    return refs[0];
  return (value2) => {
    for (let ref of refs) {
      if (typeof ref === "function")
        ref(value2);
      else if (ref != null)
        ref.current = value2;
    }
  };
}
var $65484d02dcb7eb3e$var$DOMPropNames = /* @__PURE__ */ new Set([
  "id"
]);
var $65484d02dcb7eb3e$var$labelablePropNames = /* @__PURE__ */ new Set([
  "aria-label",
  "aria-labelledby",
  "aria-describedby",
  "aria-details"
]);
var $65484d02dcb7eb3e$var$linkPropNames = /* @__PURE__ */ new Set([
  "href",
  "target",
  "rel",
  "download",
  "ping",
  "referrerPolicy"
]);
var $65484d02dcb7eb3e$var$propRe = /^(data-.*)$/;
function $65484d02dcb7eb3e$export$457c3d6518dd4c6f(props, opts = {}) {
  let { labelable, isLink, propNames } = opts;
  let filteredProps = {};
  for (const prop in props)
    if (Object.prototype.hasOwnProperty.call(props, prop) && ($65484d02dcb7eb3e$var$DOMPropNames.has(prop) || labelable && $65484d02dcb7eb3e$var$labelablePropNames.has(prop) || isLink && $65484d02dcb7eb3e$var$linkPropNames.has(prop) || (propNames === null || propNames === void 0 ? void 0 : propNames.has(prop)) || $65484d02dcb7eb3e$var$propRe.test(prop)))
      filteredProps[prop] = props[prop];
  return filteredProps;
}
function $7215afc6de606d6b$export$de79e2c695e052f3(element4) {
  if ($7215afc6de606d6b$var$supportsPreventScroll())
    element4.focus({
      preventScroll: true
    });
  else {
    let scrollableElements = $7215afc6de606d6b$var$getScrollableElements(element4);
    element4.focus();
    $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements);
  }
}
var $7215afc6de606d6b$var$supportsPreventScrollCached = null;
function $7215afc6de606d6b$var$supportsPreventScroll() {
  if ($7215afc6de606d6b$var$supportsPreventScrollCached == null) {
    $7215afc6de606d6b$var$supportsPreventScrollCached = false;
    try {
      let focusElem = document.createElement("div");
      focusElem.focus({
        get preventScroll() {
          $7215afc6de606d6b$var$supportsPreventScrollCached = true;
          return true;
        }
      });
    } catch (e6) {
    }
  }
  return $7215afc6de606d6b$var$supportsPreventScrollCached;
}
function $7215afc6de606d6b$var$getScrollableElements(element4) {
  let parent = element4.parentNode;
  let scrollableElements = [];
  let rootScrollingElement = document.scrollingElement || document.documentElement;
  while (parent instanceof HTMLElement && parent !== rootScrollingElement) {
    if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth)
      scrollableElements.push({
        element: parent,
        scrollTop: parent.scrollTop,
        scrollLeft: parent.scrollLeft
      });
    parent = parent.parentNode;
  }
  if (rootScrollingElement instanceof HTMLElement)
    scrollableElements.push({
      element: rootScrollingElement,
      scrollTop: rootScrollingElement.scrollTop,
      scrollLeft: rootScrollingElement.scrollLeft
    });
  return scrollableElements;
}
function $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements) {
  for (let { element: element4, scrollTop, scrollLeft } of scrollableElements) {
    element4.scrollTop = scrollTop;
    element4.scrollLeft = scrollLeft;
  }
}
function $c87311424ea30a05$var$testUserAgent(re) {
  var _window_navigator_userAgentData;
  if (typeof window === "undefined" || window.navigator == null)
    return false;
  return ((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((brand) => re.test(brand.brand))) || re.test(window.navigator.userAgent);
}
function $c87311424ea30a05$var$testPlatform(re) {
  var _window_navigator_userAgentData;
  return typeof window !== "undefined" && window.navigator != null ? re.test(((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : false;
}
function $c87311424ea30a05$export$9ac100e40613ea10() {
  return $c87311424ea30a05$var$testPlatform(/^Mac/i);
}
function $c87311424ea30a05$export$186c6964ca17d99() {
  return $c87311424ea30a05$var$testPlatform(/^iPhone/i);
}
function $c87311424ea30a05$export$7bef049ce92e4224() {
  return $c87311424ea30a05$var$testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  $c87311424ea30a05$export$9ac100e40613ea10() && navigator.maxTouchPoints > 1;
}
function $c87311424ea30a05$export$fedb369cb70207f1() {
  return $c87311424ea30a05$export$186c6964ca17d99() || $c87311424ea30a05$export$7bef049ce92e4224();
}
function $c87311424ea30a05$export$e1865c3bedcd822b() {
  return $c87311424ea30a05$export$9ac100e40613ea10() || $c87311424ea30a05$export$fedb369cb70207f1();
}
function $c87311424ea30a05$export$78551043582a6a98() {
  return $c87311424ea30a05$var$testUserAgent(/AppleWebKit/i) && !$c87311424ea30a05$export$6446a186d09e379e();
}
function $c87311424ea30a05$export$6446a186d09e379e() {
  return $c87311424ea30a05$var$testUserAgent(/Chrome/i);
}
function $c87311424ea30a05$export$a11b0059900ceec8() {
  return $c87311424ea30a05$var$testUserAgent(/Android/i);
}
function $c87311424ea30a05$export$b7d78993b74f766d() {
  return $c87311424ea30a05$var$testUserAgent(/Firefox/i);
}
var $ea8dcbcb9ea1b556$var$RouterContext = (0, import_react3.createContext)({
  isNative: true,
  open: $ea8dcbcb9ea1b556$var$openSyntheticLink
});
function $ea8dcbcb9ea1b556$export$323e4fc2fa4753fb(props) {
  let { children, navigate } = props;
  let ctx = (0, import_react3.useMemo)(() => ({
    isNative: false,
    open: (target, modifiers) => {
      $ea8dcbcb9ea1b556$var$getSyntheticLink(target, (link2) => {
        if ($ea8dcbcb9ea1b556$export$efa8c9099e530235(link2, modifiers))
          navigate(link2.pathname + link2.search + link2.hash);
        else
          $ea8dcbcb9ea1b556$export$95185d699e05d4d7(link2, modifiers);
      });
    }
  }), [
    navigate
  ]);
  return (0, import_react3.default).createElement($ea8dcbcb9ea1b556$var$RouterContext.Provider, {
    value: ctx
  }, children);
}
function $ea8dcbcb9ea1b556$export$9a302a45f65d0572() {
  return (0, import_react3.useContext)($ea8dcbcb9ea1b556$var$RouterContext);
}
function $ea8dcbcb9ea1b556$export$efa8c9099e530235(link2, modifiers) {
  let target = link2.getAttribute("target");
  return (!target || target === "_self") && link2.origin === location.origin && !link2.hasAttribute("download") && !modifiers.metaKey && // open in new tab (mac)
  !modifiers.ctrlKey && // open in new tab (windows)
  !modifiers.altKey && // download
  !modifiers.shiftKey;
}
function $ea8dcbcb9ea1b556$export$95185d699e05d4d7(target, modifiers, setOpening = true) {
  var _window_event_type, _window_event;
  let { metaKey, ctrlKey, altKey, shiftKey } = modifiers;
  if ((0, $c87311424ea30a05$export$b7d78993b74f766d)() && ((_window_event = window.event) === null || _window_event === void 0 ? void 0 : (_window_event_type = _window_event.type) === null || _window_event_type === void 0 ? void 0 : _window_event_type.startsWith("key")) && target.target === "_blank") {
    if ((0, $c87311424ea30a05$export$9ac100e40613ea10)())
      metaKey = true;
    else
      ctrlKey = true;
  }
  let event = (0, $c87311424ea30a05$export$78551043582a6a98)() && (0, $c87311424ea30a05$export$9ac100e40613ea10)() && !(0, $c87311424ea30a05$export$7bef049ce92e4224)() && true ? new KeyboardEvent("keydown", {
    keyIdentifier: "Enter",
    metaKey,
    ctrlKey,
    altKey,
    shiftKey
  }) : new MouseEvent("click", {
    metaKey,
    ctrlKey,
    altKey,
    shiftKey,
    bubbles: true,
    cancelable: true
  });
  $ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = setOpening;
  (0, $7215afc6de606d6b$export$de79e2c695e052f3)(target);
  target.dispatchEvent(event);
  $ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = false;
}
$ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = false;
function $ea8dcbcb9ea1b556$var$getSyntheticLink(target, open) {
  if (target instanceof HTMLAnchorElement)
    open(target);
  else if (target.hasAttribute("data-href")) {
    let link2 = document.createElement("a");
    link2.href = target.getAttribute("data-href");
    if (target.hasAttribute("data-target"))
      link2.target = target.getAttribute("data-target");
    if (target.hasAttribute("data-rel"))
      link2.rel = target.getAttribute("data-rel");
    if (target.hasAttribute("data-download"))
      link2.download = target.getAttribute("data-download");
    if (target.hasAttribute("data-ping"))
      link2.ping = target.getAttribute("data-ping");
    if (target.hasAttribute("data-referrer-policy"))
      link2.referrerPolicy = target.getAttribute("data-referrer-policy");
    target.appendChild(link2);
    open(link2);
    target.removeChild(link2);
  }
}
function $ea8dcbcb9ea1b556$var$openSyntheticLink(target, modifiers) {
  $ea8dcbcb9ea1b556$var$getSyntheticLink(target, (link2) => $ea8dcbcb9ea1b556$export$95185d699e05d4d7(link2, modifiers));
}
function $ea8dcbcb9ea1b556$export$51437d503373d223(props) {
  return {
    "data-href": props.href,
    "data-target": props.target,
    "data-rel": props.rel,
    "data-download": props.download,
    "data-ping": props.ping,
    "data-referrer-policy": props.referrerPolicy
  };
}
var $bbed8b41f857bcc0$var$transitionsByElement = /* @__PURE__ */ new Map();
var $bbed8b41f857bcc0$var$transitionCallbacks = /* @__PURE__ */ new Set();
function $bbed8b41f857bcc0$var$setupGlobalEvents() {
  if (typeof window === "undefined")
    return;
  function isTransitionEvent(event) {
    return "propertyName" in event;
  }
  let onTransitionStart = (e6) => {
    if (!isTransitionEvent(e6) || !e6.target)
      return;
    let transitions = $bbed8b41f857bcc0$var$transitionsByElement.get(e6.target);
    if (!transitions) {
      transitions = /* @__PURE__ */ new Set();
      $bbed8b41f857bcc0$var$transitionsByElement.set(e6.target, transitions);
      e6.target.addEventListener("transitioncancel", onTransitionEnd, {
        once: true
      });
    }
    transitions.add(e6.propertyName);
  };
  let onTransitionEnd = (e6) => {
    if (!isTransitionEvent(e6) || !e6.target)
      return;
    let properties = $bbed8b41f857bcc0$var$transitionsByElement.get(e6.target);
    if (!properties)
      return;
    properties.delete(e6.propertyName);
    if (properties.size === 0) {
      e6.target.removeEventListener("transitioncancel", onTransitionEnd);
      $bbed8b41f857bcc0$var$transitionsByElement.delete(e6.target);
    }
    if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) {
      for (let cb of $bbed8b41f857bcc0$var$transitionCallbacks)
        cb();
      $bbed8b41f857bcc0$var$transitionCallbacks.clear();
    }
  };
  document.body.addEventListener("transitionrun", onTransitionStart);
  document.body.addEventListener("transitionend", onTransitionEnd);
}
if (typeof document !== "undefined") {
  if (document.readyState !== "loading")
    $bbed8b41f857bcc0$var$setupGlobalEvents();
  else
    document.addEventListener("DOMContentLoaded", $bbed8b41f857bcc0$var$setupGlobalEvents);
}
function $bbed8b41f857bcc0$export$24490316f764c430(fn2) {
  requestAnimationFrame(() => {
    if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0)
      fn2();
    else
      $bbed8b41f857bcc0$var$transitionCallbacks.add(fn2);
  });
}
function $03deb23ff14920c4$export$4eaf04e54aa8eed6() {
  let globalListeners = (0, import_react3.useRef)(/* @__PURE__ */ new Map());
  let addGlobalListener = (0, import_react3.useCallback)((eventTarget, type2, listener, options) => {
    let fn2 = (options === null || options === void 0 ? void 0 : options.once) ? (...args2) => {
      globalListeners.current.delete(listener);
      listener(...args2);
    } : listener;
    globalListeners.current.set(listener, {
      type: type2,
      eventTarget,
      fn: fn2,
      options
    });
    eventTarget.addEventListener(type2, listener, options);
  }, []);
  let removeGlobalListener = (0, import_react3.useCallback)((eventTarget, type2, listener, options) => {
    var _globalListeners_current_get;
    let fn2 = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;
    eventTarget.removeEventListener(type2, fn2, options);
    globalListeners.current.delete(listener);
  }, []);
  let removeAllGlobalListeners = (0, import_react3.useCallback)(() => {
    globalListeners.current.forEach((value2, key) => {
      removeGlobalListener(value2.eventTarget, value2.type, key, value2.options);
    });
  }, [
    removeGlobalListener
  ]);
  (0, import_react3.useEffect)(() => {
    return removeAllGlobalListeners;
  }, [
    removeAllGlobalListeners
  ]);
  return {
    addGlobalListener,
    removeGlobalListener,
    removeAllGlobalListeners
  };
}
function $313b98861ee5dd6c$export$d6875122194c7b44(props, defaultLabel) {
  let { id: id2, "aria-label": label, "aria-labelledby": labelledBy } = props;
  id2 = (0, $bdb11010cef70236$export$f680877a34711e37)(id2);
  if (labelledBy && label) {
    let ids = /* @__PURE__ */ new Set([
      id2,
      ...labelledBy.trim().split(/\s+/)
    ]);
    labelledBy = [
      ...ids
    ].join(" ");
  } else if (labelledBy)
    labelledBy = labelledBy.trim().split(/\s+/).join(" ");
  if (!label && !labelledBy && defaultLabel)
    label = defaultLabel;
  return {
    id: id2,
    "aria-label": label,
    "aria-labelledby": labelledBy
  };
}
function $df56164dff5785e2$export$4338b53315abf666(forwardedRef) {
  const objRef = (0, import_react3.useRef)(null);
  return (0, import_react3.useMemo)(() => ({
    get current() {
      return objRef.current;
    },
    set current(value2) {
      objRef.current = value2;
      if (typeof forwardedRef === "function")
        forwardedRef(value2);
      else if (forwardedRef)
        forwardedRef.current = value2;
    }
  }), [
    forwardedRef
  ]);
}
function $4f58c5f72bcf79f7$export$496315a1608d9602(effect, dependencies) {
  const isInitialMount = (0, import_react3.useRef)(true);
  const lastDeps = (0, import_react3.useRef)(null);
  (0, import_react3.useEffect)(() => {
    isInitialMount.current = true;
    return () => {
      isInitialMount.current = false;
    };
  }, []);
  (0, import_react3.useEffect)(() => {
    if (isInitialMount.current)
      isInitialMount.current = false;
    else if (!lastDeps.current || dependencies.some((dep, i6) => !Object.is(dep, lastDeps[i6])))
      effect();
    lastDeps.current = dependencies;
  }, dependencies);
}
function $9daab02d461809db$var$hasResizeObserver() {
  return typeof window.ResizeObserver !== "undefined";
}
function $9daab02d461809db$export$683480f191c0e3ea(options) {
  const { ref, onResize } = options;
  (0, import_react3.useEffect)(() => {
    let element4 = ref === null || ref === void 0 ? void 0 : ref.current;
    if (!element4)
      return;
    if (!$9daab02d461809db$var$hasResizeObserver()) {
      window.addEventListener("resize", onResize, false);
      return () => {
        window.removeEventListener("resize", onResize, false);
      };
    } else {
      const resizeObserverInstance = new window.ResizeObserver((entries2) => {
        if (!entries2.length)
          return;
        onResize();
      });
      resizeObserverInstance.observe(element4);
      return () => {
        if (element4)
          resizeObserverInstance.unobserve(element4);
      };
    }
  }, [
    onResize,
    ref
  ]);
}
function $e7801be82b4b2a53$export$4debdb1a3f0fa79e(context, ref) {
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (context && context.ref && ref) {
      context.ref.current = ref.current;
      return () => {
        if (context.ref)
          context.ref.current = null;
      };
    }
  });
}
function $62d8ded9296f3872$export$cfa2225e87938781(node4, checkForOverflow) {
  let scrollableNode = node4;
  if ($62d8ded9296f3872$export$2bb74740c4e19def(scrollableNode, checkForOverflow))
    scrollableNode = scrollableNode.parentElement;
  while (scrollableNode && !$62d8ded9296f3872$export$2bb74740c4e19def(scrollableNode, checkForOverflow))
    scrollableNode = scrollableNode.parentElement;
  return scrollableNode || document.scrollingElement || document.documentElement;
}
function $62d8ded9296f3872$export$2bb74740c4e19def(node4, checkForOverflow) {
  let style = window.getComputedStyle(node4);
  let isScrollable = /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);
  if (isScrollable && checkForOverflow)
    isScrollable = node4.scrollHeight !== node4.clientHeight || node4.scrollWidth !== node4.clientWidth;
  return isScrollable;
}
var $5df64b3807dc15ee$var$visualViewport = typeof document !== "undefined" && window.visualViewport;
function $5df64b3807dc15ee$export$d699905dd57c73ca() {
  let isSSR = (0, $b5e257d569688ac6$export$535bd6ca7f90a273)();
  let [size3, setSize] = (0, import_react3.useState)(() => isSSR ? {
    width: 0,
    height: 0
  } : $5df64b3807dc15ee$var$getViewportSize());
  (0, import_react3.useEffect)(() => {
    let onResize = () => {
      setSize((size4) => {
        let newSize = $5df64b3807dc15ee$var$getViewportSize();
        if (newSize.width === size4.width && newSize.height === size4.height)
          return size4;
        return newSize;
      });
    };
    if (!$5df64b3807dc15ee$var$visualViewport)
      window.addEventListener("resize", onResize);
    else
      $5df64b3807dc15ee$var$visualViewport.addEventListener("resize", onResize);
    return () => {
      if (!$5df64b3807dc15ee$var$visualViewport)
        window.removeEventListener("resize", onResize);
      else
        $5df64b3807dc15ee$var$visualViewport.removeEventListener("resize", onResize);
    };
  }, []);
  return size3;
}
function $5df64b3807dc15ee$var$getViewportSize() {
  return {
    width: $5df64b3807dc15ee$var$visualViewport && ($5df64b3807dc15ee$var$visualViewport === null || $5df64b3807dc15ee$var$visualViewport === void 0 ? void 0 : $5df64b3807dc15ee$var$visualViewport.width) || window.innerWidth,
    height: $5df64b3807dc15ee$var$visualViewport && ($5df64b3807dc15ee$var$visualViewport === null || $5df64b3807dc15ee$var$visualViewport === void 0 ? void 0 : $5df64b3807dc15ee$var$visualViewport.height) || window.innerHeight
  };
}
var $ef06256079686ba0$var$descriptionId = 0;
var $ef06256079686ba0$var$descriptionNodes = /* @__PURE__ */ new Map();
function $ef06256079686ba0$export$f8aeda7b10753fa1(description) {
  let [id2, setId] = (0, import_react3.useState)();
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (!description)
      return;
    let desc = $ef06256079686ba0$var$descriptionNodes.get(description);
    if (!desc) {
      let id3 = `react-aria-description-${$ef06256079686ba0$var$descriptionId++}`;
      setId(id3);
      let node4 = document.createElement("div");
      node4.id = id3;
      node4.style.display = "none";
      node4.textContent = description;
      document.body.appendChild(node4);
      desc = {
        refCount: 0,
        element: node4
      };
      $ef06256079686ba0$var$descriptionNodes.set(description, desc);
    } else
      setId(desc.element.id);
    desc.refCount++;
    return () => {
      if (desc && --desc.refCount === 0) {
        desc.element.remove();
        $ef06256079686ba0$var$descriptionNodes.delete(description);
      }
    };
  }, [
    description
  ]);
  return {
    "aria-describedby": description ? id2 : void 0
  };
}
function $e9faafb641e167db$export$90fc3a17d93f704c(ref, event, handler, options) {
  let handleEvent = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(handler);
  let isDisabled = handler == null;
  (0, import_react3.useEffect)(() => {
    if (isDisabled || !ref.current)
      return;
    let element4 = ref.current;
    element4.addEventListener(event, handleEvent, options);
    return () => {
      element4.removeEventListener(event, handleEvent, options);
    };
  }, [
    ref,
    event,
    options,
    isDisabled,
    handleEvent
  ]);
}
function $2f04cbc44ee30ce0$export$53a0910f038337bd(scrollView, element4) {
  let offsetX = $2f04cbc44ee30ce0$var$relativeOffset(scrollView, element4, "left");
  let offsetY = $2f04cbc44ee30ce0$var$relativeOffset(scrollView, element4, "top");
  let width = element4.offsetWidth;
  let height = element4.offsetHeight;
  let x4 = scrollView.scrollLeft;
  let y4 = scrollView.scrollTop;
  let { borderTopWidth, borderLeftWidth } = getComputedStyle(scrollView);
  let borderAdjustedX = scrollView.scrollLeft + parseInt(borderLeftWidth, 10);
  let borderAdjustedY = scrollView.scrollTop + parseInt(borderTopWidth, 10);
  let maxX = borderAdjustedX + scrollView.clientWidth;
  let maxY = borderAdjustedY + scrollView.clientHeight;
  if (offsetX <= x4)
    x4 = offsetX - parseInt(borderLeftWidth, 10);
  else if (offsetX + width > maxX)
    x4 += offsetX + width - maxX;
  if (offsetY <= borderAdjustedY)
    y4 = offsetY - parseInt(borderTopWidth, 10);
  else if (offsetY + height > maxY)
    y4 += offsetY + height - maxY;
  scrollView.scrollLeft = x4;
  scrollView.scrollTop = y4;
}
function $2f04cbc44ee30ce0$var$relativeOffset(ancestor, child, axis) {
  const prop = axis === "left" ? "offsetLeft" : "offsetTop";
  let sum2 = 0;
  while (child.offsetParent) {
    sum2 += child[prop];
    if (child.offsetParent === ancestor)
      break;
    else if (child.offsetParent.contains(ancestor)) {
      sum2 -= ancestor[prop];
      break;
    }
    child = child.offsetParent;
  }
  return sum2;
}
function $2f04cbc44ee30ce0$export$c826860796309d1b(targetElement, opts) {
  if (document.contains(targetElement)) {
    let root = document.scrollingElement || document.documentElement;
    let isScrollPrevented = window.getComputedStyle(root).overflow === "hidden";
    if (!isScrollPrevented) {
      var _targetElement_scrollIntoView;
      let { left: originalLeft, top: originalTop } = targetElement.getBoundingClientRect();
      targetElement === null || targetElement === void 0 ? void 0 : (_targetElement_scrollIntoView = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView === void 0 ? void 0 : _targetElement_scrollIntoView.call(targetElement, {
        block: "nearest"
      });
      let { left: newLeft, top: newTop } = targetElement.getBoundingClientRect();
      if (Math.abs(originalLeft - newLeft) > 1 || Math.abs(originalTop - newTop) > 1) {
        var _opts_containingElement_scrollIntoView, _opts_containingElement, _targetElement_scrollIntoView1;
        opts === null || opts === void 0 ? void 0 : (_opts_containingElement = opts.containingElement) === null || _opts_containingElement === void 0 ? void 0 : (_opts_containingElement_scrollIntoView = _opts_containingElement.scrollIntoView) === null || _opts_containingElement_scrollIntoView === void 0 ? void 0 : _opts_containingElement_scrollIntoView.call(_opts_containingElement, {
          block: "center",
          inline: "center"
        });
        (_targetElement_scrollIntoView1 = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView1 === void 0 ? void 0 : _targetElement_scrollIntoView1.call(targetElement, {
          block: "nearest"
        });
      }
    } else {
      let scrollParent = (0, $62d8ded9296f3872$export$cfa2225e87938781)(targetElement);
      while (targetElement && scrollParent && targetElement !== root && scrollParent !== root) {
        $2f04cbc44ee30ce0$export$53a0910f038337bd(scrollParent, targetElement);
        targetElement = scrollParent;
        scrollParent = (0, $62d8ded9296f3872$export$cfa2225e87938781)(targetElement);
      }
    }
  }
}
function $6a7db85432448f7f$export$60278871457622de(event) {
  if (event.mozInputSource === 0 && event.isTrusted)
    return true;
  if ((0, $c87311424ea30a05$export$a11b0059900ceec8)() && event.pointerType)
    return event.type === "click" && event.buttons === 1;
  return event.detail === 0 && !event.pointerType;
}
function $6a7db85432448f7f$export$29bf1b5f2c56cf63(event) {
  return !(0, $c87311424ea30a05$export$a11b0059900ceec8)() && event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse";
}
function $99facab73266f662$export$5add1d006293d136(ref, initialValue, onReset) {
  let resetValue = (0, import_react3.useRef)(initialValue);
  let handleReset = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(() => {
    if (onReset)
      onReset(resetValue.current);
  });
  (0, import_react3.useEffect)(() => {
    var _ref_current;
    let form = ref === null || ref === void 0 ? void 0 : (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.form;
    form === null || form === void 0 ? void 0 : form.addEventListener("reset", handleReset);
    return () => {
      form === null || form === void 0 ? void 0 : form.removeEventListener("reset", handleReset);
    };
  }, [
    ref,
    handleReset
  ]);
}

// node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js
var weakMemoize = function weakMemoize2(func) {
  var cache3 = /* @__PURE__ */ new WeakMap();
  return function(arg) {
    if (cache3.has(arg)) {
      return cache3.get(arg);
    }
    var ret = func(arg);
    cache3.set(arg, ret);
    return ret;
  };
};

// node_modules/@emotion/sheet/dist/emotion-sheet.browser.esm.js
function sheetForTag(tag2) {
  if (tag2.sheet) {
    return tag2.sheet;
  }
  for (var i6 = 0; i6 < document.styleSheets.length; i6++) {
    if (document.styleSheets[i6].ownerNode === tag2) {
      return document.styleSheets[i6];
    }
  }
}
function createStyleElement(options) {
  var tag2 = document.createElement("style");
  tag2.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag2.setAttribute("nonce", options.nonce);
  }
  tag2.appendChild(document.createTextNode(""));
  tag2.setAttribute("data-s", "");
  return tag2;
}
var StyleSheet = function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag2) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag2, before);
      _this.tags.push(tag2);
    };
    this.isSpeedy = options.speedy === void 0 ? false : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate2(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag2 = this.tags[this.tags.length - 1];
    if (true) {
      var isImportRule3 = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;
      if (isImportRule3 && this._alreadyInsertedOrderInsensitiveRule) {
        console.error("You're attempting to insert the following rule:\n" + rule + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.");
      }
      this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule3;
    }
    if (this.isSpeedy) {
      var sheet2 = sheetForTag(tag2);
      try {
        sheet2.insertRule(rule, sheet2.cssRules.length);
      } catch (e6) {
        if (!/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(rule)) {
          console.error('There was a problem inserting the following rule: "' + rule + '"', e6);
        }
      }
    } else {
      tag2.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush2() {
    this.tags.forEach(function(tag2) {
      return tag2.parentNode && tag2.parentNode.removeChild(tag2);
    });
    this.tags = [];
    this.ctr = 0;
    if (true) {
      this._alreadyInsertedOrderInsensitiveRule = false;
    }
  };
  return StyleSheet2;
}();

// node_modules/stylis/src/Enum.js
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";

// node_modules/stylis/src/Utility.js
var abs2 = Math.abs;
var from3 = String.fromCharCode;
var assign2 = Object.assign;
function hash(value2, length4) {
  return charat(value2, 0) ^ 45 ? (((length4 << 2 ^ charat(value2, 0)) << 2 ^ charat(value2, 1)) << 2 ^ charat(value2, 2)) << 2 ^ charat(value2, 3) : 0;
}
function trim(value2) {
  return value2.trim();
}
function match(value2, pattern) {
  return (value2 = pattern.exec(value2)) ? value2[0] : value2;
}
function replace(value2, pattern, replacement) {
  return value2.replace(pattern, replacement);
}
function indexof(value2, search2) {
  return value2.indexOf(search2);
}
function charat(value2, index3) {
  return value2.charCodeAt(index3) | 0;
}
function substr(value2, begin, end) {
  return value2.slice(begin, end);
}
function strlen(value2) {
  return value2.length;
}
function sizeof(value2) {
  return value2.length;
}
function append2(value2, array) {
  return array.push(value2), value2;
}
function combine(array, callback) {
  return array.map(callback).join("");
}

// node_modules/stylis/src/Tokenizer.js
var line = 1;
var column = 1;
var length3 = 0;
var position = 0;
var character = 0;
var characters = "";
function node2(value2, root, parent, type2, props, children, length4) {
  return { value: value2, root, parent, type: type2, props, children, line, column, length: length4, return: "" };
}
function copy2(root, props) {
  return assign2(node2("", null, null, "", null, null, 0), root, { length: -root.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length3 ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type2) {
  switch (type2) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value2) {
  return line = column = 1, length3 = strlen(characters = value2), position = 0, [];
}
function dealloc(value2) {
  return characters = "", value2;
}
function delimit(type2) {
  return trim(slice(position - 1, delimiter(type2 === 91 ? type2 + 2 : type2 === 40 ? type2 + 1 : type2)));
}
function whitespace(type2) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type2) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index3, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index3, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type2) {
  while (next())
    switch (character) {
      case type2:
        return position;
      case 34:
      case 39:
        if (type2 !== 34 && type2 !== 39)
          delimiter(character);
        break;
      case 40:
        if (type2 === 41)
          delimiter(type2);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type2, index3) {
  while (next())
    if (type2 + character === 47 + 10)
      break;
    else if (type2 + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index3, position - 1) + "*" + from3(type2 === 47 ? type2 : next());
}
function identifier(index3) {
  while (!token(peek()))
    next();
  return slice(index3, position);
}

// node_modules/stylis/src/Parser.js
function compile(value2) {
  return dealloc(parse("", null, null, null, [""], value2 = alloc(value2), 0, [0], value2));
}
function parse(value2, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index3 = 0;
  var offset = 0;
  var length4 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous3 = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type2 = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type2;
  while (scanning)
    switch (previous3 = character2, character2 = next()) {
      case 40:
        if (previous3 != 108 && charat(characters2, length4 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous3);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append2(comment2(commenter(next(), caret()), root, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index3++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset:
            if (ampersand == -1)
              characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length4)
              append2(property > 32 ? declaration(characters2 + ";", rule, parent, length4 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length4 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append2(reference = ruleset(characters2, root, parent, index3, offset, rules, points, type2, props = [], children = [], length4), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse(characters2, root, reference, reference, props, rulesets, length4, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value2, reference, reference, rule && append2(ruleset(value2, reference, reference, 0, 0, rules, points, type2, rules, props = [], length4), children), rules, children, length4, points, rule ? props : children);
                    break;
                  default:
                    parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index3 = offset = property = 0, variable = ampersand = 1, type2 = characters2 = "", length4 = pseudo;
        break;
      case 58:
        length4 = 1 + strlen(characters2), property = previous3;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from3(character2), character2 * variable) {
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index3++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset = length4 = strlen(type2 = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous3 === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value2, root, parent, index3, offset, rules, points, type2, props, children, length4) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [""];
  var size3 = sizeof(rule);
  for (var i6 = 0, j4 = 0, k2 = 0; i6 < index3; ++i6)
    for (var x4 = 0, y4 = substr(value2, post + 1, post = abs2(j4 = points[i6])), z3 = value2; x4 < size3; ++x4)
      if (z3 = trim(j4 > 0 ? rule[x4] + " " + y4 : replace(y4, /&\f/g, rule[x4])))
        props[k2++] = z3;
  return node2(value2, root, parent, offset === 0 ? RULESET : type2, props, children, length4);
}
function comment2(value2, root, parent) {
  return node2(value2, root, parent, COMMENT, from3(char()), substr(value2, 2, -2), 0);
}
function declaration(value2, root, parent, length4) {
  return node2(value2, root, parent, DECLARATION, substr(value2, 0, length4), substr(value2, length4 + 1, -1), length4);
}

// node_modules/stylis/src/Serializer.js
function serialize(children, callback) {
  var output = "";
  var length4 = sizeof(children);
  for (var i6 = 0; i6 < length4; i6++)
    output += callback(children[i6], i6, children, callback) || "";
  return output;
}
function stringify2(element4, index3, children, callback) {
  switch (element4.type) {
    case LAYER:
      if (element4.children.length)
        break;
    case IMPORT:
    case DECLARATION:
      return element4.return = element4.return || element4.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element4.return = element4.value + "{" + serialize(element4.children, callback) + "}";
    case RULESET:
      element4.value = element4.props.join(",");
  }
  return strlen(children = serialize(element4.children, callback)) ? element4.return = element4.value + "{" + children + "}" : "";
}

// node_modules/stylis/src/Middleware.js
function middleware(collection2) {
  var length4 = sizeof(collection2);
  return function(element4, index3, children, callback) {
    var output = "";
    for (var i6 = 0; i6 < length4; i6++)
      output += collection2[i6](element4, index3, children, callback) || "";
    return output;
  };
}

// node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
function memoize(fn2) {
  var cache3 = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache3[arg] === void 0)
      cache3[arg] = fn2(arg);
    return cache3[arg];
  };
}

// node_modules/@emotion/cache/dist/emotion-cache.browser.esm.js
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index3) {
  var previous3 = 0;
  var character2 = 0;
  while (true) {
    previous3 = character2;
    character2 = peek();
    if (previous3 === 38 && character2 === 12) {
      points[index3] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index3 = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index3] = 1;
        }
        parsed[index3] += identifierWithPointTracking(position - 1, points, index3);
        break;
      case 2:
        parsed[index3] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index3] = peek() === 58 ? "&\f" : "";
          points[index3] = parsed[index3].length;
          break;
        }
      default:
        parsed[index3] += from3(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value2, points) {
  return dealloc(toRules(alloc(value2), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element4) {
  if (element4.type !== "rule" || !element4.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element4.length < 1) {
    return;
  }
  var value2 = element4.value, parent = element4.parent;
  var isImplicitRule = element4.column === parent.column && element4.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent)
      return;
  }
  if (element4.props.length === 1 && value2.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element4, true);
  var points = [];
  var rules = getRules(value2, points);
  var parentRules = parent.props;
  for (var i6 = 0, k2 = 0; i6 < rules.length; i6++) {
    for (var j4 = 0; j4 < parentRules.length; j4++, k2++) {
      element4.props[k2] = points[i6] ? rules[i6].replace(/&\f/g, parentRules[j4]) : parentRules[j4] + " " + rules[i6];
    }
  }
};
var removeLabel = function removeLabel2(element4) {
  if (element4.type === "decl") {
    var value2 = element4.value;
    if (
      // charcode for l
      value2.charCodeAt(0) === 108 && // charcode for b
      value2.charCodeAt(2) === 98
    ) {
      element4["return"] = "";
      element4.value = "";
    }
  }
};
var ignoreFlag = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason";
var isIgnoringComment = function isIgnoringComment2(element4) {
  return element4.type === "comm" && element4.children.indexOf(ignoreFlag) > -1;
};
var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm2(cache3) {
  return function(element4, index3, children) {
    if (element4.type !== "rule" || cache3.compat)
      return;
    var unsafePseudoClasses = element4.value.match(/(:first|:nth|:nth-last)-child/g);
    if (unsafePseudoClasses) {
      var isNested = !!element4.parent;
      var commentContainer = isNested ? element4.parent.children : (
        // global rule at the root level
        children
      );
      for (var i6 = commentContainer.length - 1; i6 >= 0; i6--) {
        var node4 = commentContainer[i6];
        if (node4.line < element4.line) {
          break;
        }
        if (node4.column < element4.column) {
          if (isIgnoringComment(node4)) {
            return;
          }
          break;
        }
      }
      unsafePseudoClasses.forEach(function(unsafePseudoClass) {
        console.error('The pseudo class "' + unsafePseudoClass + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + unsafePseudoClass.split("-child")[0] + '-of-type".');
      });
    }
  };
};
var isImportRule = function isImportRule2(element4) {
  return element4.type.charCodeAt(1) === 105 && element4.type.charCodeAt(0) === 64;
};
var isPrependedWithRegularRules = function isPrependedWithRegularRules2(index3, children) {
  for (var i6 = index3 - 1; i6 >= 0; i6--) {
    if (!isImportRule(children[i6])) {
      return true;
    }
  }
  return false;
};
var nullifyElement = function nullifyElement2(element4) {
  element4.type = "";
  element4.value = "";
  element4["return"] = "";
  element4.children = "";
  element4.props = "";
};
var incorrectImportAlarm = function incorrectImportAlarm2(element4, index3, children) {
  if (!isImportRule(element4)) {
    return;
  }
  if (element4.parent) {
    console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
    nullifyElement(element4);
  } else if (isPrependedWithRegularRules(index3, children)) {
    console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
    nullifyElement(element4);
  }
};
function prefix3(value2, length4) {
  switch (hash(value2, length4)) {
    case 5103:
      return WEBKIT + "print-" + value2 + value2;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value2 + value2;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value2 + MOZ + value2 + MS + value2 + value2;
    case 6828:
    case 4268:
      return WEBKIT + value2 + MS + value2 + value2;
    case 6165:
      return WEBKIT + value2 + MS + "flex-" + value2 + value2;
    case 5187:
      return WEBKIT + value2 + replace(value2, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value2;
    case 5443:
      return WEBKIT + value2 + MS + "flex-item-" + replace(value2, /flex-|-self/, "") + value2;
    case 4675:
      return WEBKIT + value2 + MS + "flex-line-pack" + replace(value2, /align-content|flex-|-self/, "") + value2;
    case 5548:
      return WEBKIT + value2 + MS + replace(value2, "shrink", "negative") + value2;
    case 5292:
      return WEBKIT + value2 + MS + replace(value2, "basis", "preferred-size") + value2;
    case 6060:
      return WEBKIT + "box-" + replace(value2, "-grow", "") + WEBKIT + value2 + MS + replace(value2, "grow", "positive") + value2;
    case 4554:
      return WEBKIT + replace(value2, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value2;
    case 6187:
      return replace(replace(replace(value2, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value2, "") + value2;
    case 5495:
    case 3959:
      return replace(value2, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value2, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value2 + value2;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value2, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value2;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value2) - 1 - length4 > 6)
        switch (charat(value2, length4 + 1)) {
          case 109:
            if (charat(value2, length4 + 4) !== 45)
              break;
          case 102:
            return replace(value2, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value2, length4 + 3) == 108 ? "$3" : "$2-$3")) + value2;
          case 115:
            return ~indexof(value2, "stretch") ? prefix3(replace(value2, "stretch", "fill-available"), length4) + value2 : value2;
        }
      break;
    case 4949:
      if (charat(value2, length4 + 1) !== 115)
        break;
    case 6444:
      switch (charat(value2, strlen(value2) - 3 - (~indexof(value2, "!important") && 10))) {
        case 107:
          return replace(value2, ":", ":" + WEBKIT) + value2;
        case 101:
          return replace(value2, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value2, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value2;
      }
      break;
    case 5936:
      switch (charat(value2, length4 + 11)) {
        case 114:
          return WEBKIT + value2 + MS + replace(value2, /[svh]\w+-[tblr]{2}/, "tb") + value2;
        case 108:
          return WEBKIT + value2 + MS + replace(value2, /[svh]\w+-[tblr]{2}/, "tb-rl") + value2;
        case 45:
          return WEBKIT + value2 + MS + replace(value2, /[svh]\w+-[tblr]{2}/, "lr") + value2;
      }
      return WEBKIT + value2 + MS + value2 + value2;
  }
  return value2;
}
var prefixer = function prefixer2(element4, index3, children, callback) {
  if (element4.length > -1) {
    if (!element4["return"])
      switch (element4.type) {
        case DECLARATION:
          element4["return"] = prefix3(element4.value, element4.length);
          break;
        case KEYFRAMES:
          return serialize([copy2(element4, {
            value: replace(element4.value, "@", "@" + WEBKIT)
          })], callback);
        case RULESET:
          if (element4.length)
            return combine(element4.props, function(value2) {
              switch (match(value2, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return serialize([copy2(element4, {
                    props: [replace(value2, /:(read-\w+)/, ":" + MOZ + "$1")]
                  })], callback);
                case "::placeholder":
                  return serialize([copy2(element4, {
                    props: [replace(value2, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                  }), copy2(element4, {
                    props: [replace(value2, /:(plac\w+)/, ":" + MOZ + "$1")]
                  }), copy2(element4, {
                    props: [replace(value2, /:(plac\w+)/, MS + "input-$1")]
                  })], callback);
              }
              return "";
            });
      }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key = options.key;
  if (!key) {
    throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\nIf multiple caches share the same key they might \"fight\" for each other's style elements.");
  }
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node4) {
      var dataEmotionAttribute = node4.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node4);
      node4.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  if (true) {
    if (/[^a-z-]/.test(key)) {
      throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + key + '" was passed');
    }
  }
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node4) {
        var attrib = node4.getAttribute("data-emotion").split(" ");
        for (var i6 = 1; i6 < attrib.length; i6++) {
          inserted[attrib[i6]] = true;
        }
        nodesToHydrate.push(node4);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  if (true) {
    omnipresentPlugins.push(createUnsafeSelectorsAlarm({
      get compat() {
        return cache3.compat;
      }
    }), incorrectImportAlarm);
  }
  {
    var currentSheet;
    var finalizingPlugins = [stringify2, true ? function(element4) {
      if (!element4.root) {
        if (element4["return"]) {
          currentSheet.insert(element4["return"]);
        } else if (element4.value && element4.type !== COMMENT) {
          currentSheet.insert(element4.value + "{}");
        }
      }
    } : rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize(compile(styles2), serializer);
    };
    _insert = function insert(selector, serialized, sheet2, shouldCache) {
      currentSheet = sheet2;
      if (serialized.map !== void 0) {
        currentSheet = {
          insert: function insert2(rule) {
            sheet2.insert(rule + serialized.map);
          }
        };
      }
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache3.inserted[serialized.name] = true;
      }
    };
  }
  var cache3 = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache3.sheet.hydrate(nodesToHydrate);
  return cache3;
};

// node_modules/@emotion/hash/dist/emotion-hash.esm.js
function murmur2(str) {
  var h3 = 0;
  var k2, i6 = 0, len = str.length;
  for (; len >= 4; ++i6, len -= 4) {
    k2 = str.charCodeAt(i6) & 255 | (str.charCodeAt(++i6) & 255) << 8 | (str.charCodeAt(++i6) & 255) << 16 | (str.charCodeAt(++i6) & 255) << 24;
    k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= /* k >>> r: */
    k2 >>> 24;
    h3 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h3 & 65535) * 1540483477 + ((h3 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h3 ^= (str.charCodeAt(i6 + 2) & 255) << 16;
    case 2:
      h3 ^= (str.charCodeAt(i6 + 1) & 255) << 8;
    case 1:
      h3 ^= str.charCodeAt(i6) & 255;
      h3 = /* Math.imul(h, m): */
      (h3 & 65535) * 1540483477 + ((h3 >>> 16) * 59797 << 16);
  }
  h3 ^= h3 >>> 13;
  h3 = /* Math.imul(h, m): */
  (h3 & 65535) * 1540483477 + ((h3 >>> 16) * 59797 << 16);
  return ((h3 ^ h3 >>> 15) >>> 0).toString(36);
}

// node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

// node_modules/@emotion/serialize/dist/emotion-serialize.browser.esm.js
var ILLEGAL_ESCAPE_SEQUENCE_ERROR = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`;
var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value2) {
  return value2 != null && typeof value2 !== "boolean";
};
var processStyleName = memoize(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value2) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value2 === "string") {
        return value2.replace(animationRegex, function(match3, p1, p22) {
          cursor = {
            name: p1,
            styles: p22,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value2 === "number" && value2 !== 0) {
    return value2 + "px";
  }
  return value2;
};
if (true) {
  contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
  contentValues = ["normal", "none", "initial", "inherit", "unset"];
  oldProcessStyleValue = processStyleValue;
  msPattern = /^-ms-/;
  hyphenPattern = /-(.)/g;
  hyphenatedCache = {};
  processStyleValue = function processStyleValue3(key, value2) {
    if (key === "content") {
      if (typeof value2 !== "string" || contentValues.indexOf(value2) === -1 && !contentValuePattern.test(value2) && (value2.charAt(0) !== value2.charAt(value2.length - 1) || value2.charAt(0) !== '"' && value2.charAt(0) !== "'")) {
        throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value2 + "\"'`");
      }
    }
    var processed = oldProcessStyleValue(key, value2);
    if (processed !== "" && !isCustomProperty(key) && key.indexOf("-") !== -1 && hyphenatedCache[key] === void 0) {
      hyphenatedCache[key] = true;
      console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, "ms-").replace(hyphenPattern, function(str, _char) {
        return _char.toUpperCase();
      }) + "?");
    }
    return processed;
  };
}
var contentValuePattern;
var contentValues;
var oldProcessStyleValue;
var msPattern;
var hyphenPattern;
var hyphenatedCache;
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    if (interpolation.toString() === "NO_COMPONENT_SELECTOR") {
      throw new Error(noComponentSelectorMessage);
    }
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next2 = interpolation.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles2 = interpolation.styles + ";";
        if (interpolation.map !== void 0) {
          styles2 += interpolation.map;
        }
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      } else if (true) {
        console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
      }
      break;
    }
    case "string":
      if (true) {
        var matched = [];
        var replaced = interpolation.replace(animationRegex, function(match3, p1, p22) {
          var fakeVarName = "animation" + matched.length;
          matched.push("const " + fakeVarName + " = keyframes`" + p22.replace(/^@keyframes animation-\w+/, "") + "`");
          return "${" + fakeVarName + "}";
        });
        if (matched.length) {
          console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(matched, ["`" + replaced + "`"]).join("\n") + "\n\nYou should wrap it with `css` like this:\n\n" + ("css`" + replaced + "`"));
        }
      }
      break;
  }
  if (registered == null) {
    return interpolation;
  }
  var cached = registered[interpolation];
  return cached !== void 0 ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string3 = "";
  if (Array.isArray(obj)) {
    for (var i6 = 0; i6 < obj.length; i6++) {
      string3 += handleInterpolation(mergedProps, registered, obj[i6]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value2 = obj[_key];
      if (typeof value2 !== "object") {
        if (registered != null && registered[value2] !== void 0) {
          string3 += _key + "{" + registered[value2] + "}";
        } else if (isProcessableValue(value2)) {
          string3 += processStyleName(_key) + ":" + processStyleValue(_key, value2) + ";";
        }
      } else {
        if (_key === "NO_COMPONENT_SELECTOR" && true) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value2) && typeof value2[0] === "string" && (registered == null || registered[value2[0]] === void 0)) {
          for (var _i = 0; _i < value2.length; _i++) {
            if (isProcessableValue(value2[_i])) {
              string3 += processStyleName(_key) + ":" + processStyleValue(_key, value2[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value2);
          switch (_key) {
            case "animation":
            case "animationName": {
              string3 += processStyleName(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              if (_key === "undefined") {
                console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
              }
              string3 += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string3;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var sourceMapPattern;
if (true) {
  sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
}
var cursor;
var serializeStyles = function serializeStyles2(args2, registered, mergedProps) {
  if (args2.length === 1 && typeof args2[0] === "object" && args2[0] !== null && args2[0].styles !== void 0) {
    return args2[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor = void 0;
  var strings = args2[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation(mergedProps, registered, strings);
  } else {
    if (strings[0] === void 0) {
      console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
    }
    styles2 += strings[0];
  }
  for (var i6 = 1; i6 < args2.length; i6++) {
    styles2 += handleInterpolation(mergedProps, registered, args2[i6]);
    if (stringMode) {
      if (strings[i6] === void 0) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
      }
      styles2 += strings[i6];
    }
  }
  var sourceMap;
  if (true) {
    styles2 = styles2.replace(sourceMapPattern, function(match4) {
      sourceMap = match4;
      return "";
    });
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match3;
  while ((match3 = labelPattern.exec(styles2)) !== null) {
    identifierName += "-" + // $FlowFixMe we know it's not null
    match3[1];
  }
  var name2 = murmur2(styles2) + identifierName;
  if (true) {
    return {
      name: name2,
      styles: styles2,
      map: sourceMap,
      next: cursor,
      toString: function toString3() {
        return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
      }
    };
  }
  return {
    name: name2,
    styles: styles2,
    next: cursor
  };
};

// node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js
var isBrowser2 = true;
function getRegisteredStyles(registered, registeredStyles, classNames2) {
  var rawClassName = "";
  classNames2.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache3, serialized, isStringTag) {
  var className = cache3.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser2 === false) && cache3.registered[className] === void 0
  ) {
    cache3.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache3, serialized, isStringTag) {
  registerStyles(cache3, serialized, isStringTag);
  var className = cache3.key + "-" + serialized.name;
  if (cache3.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache3.insert(serialized === current ? "." + className : "", current, cache3.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};

// node_modules/@emotion/css/create-instance/dist/emotion-css-create-instance.esm.js
function insertWithoutScoping(cache3, serialized) {
  if (cache3.inserted[serialized.name] === void 0) {
    return cache3.insert("", serialized, cache3.sheet, true);
  }
}
function merge(registered, css2, className) {
  var registeredStyles = [];
  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
  if (registeredStyles.length < 2) {
    return className;
  }
  return rawClassName + css2(registeredStyles);
}
var createEmotion = function createEmotion2(options) {
  var cache3 = createCache(options);
  cache3.sheet.speedy = function(value2) {
    if (this.ctr !== 0) {
      throw new Error("speedy must be changed before any rules are inserted");
    }
    this.isSpeedy = value2;
  };
  cache3.compat = true;
  var css2 = function css3() {
    for (var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++) {
      args2[_key] = arguments[_key];
    }
    var serialized = serializeStyles(args2, cache3.registered, void 0);
    insertStyles(cache3, serialized, false);
    return cache3.key + "-" + serialized.name;
  };
  var keyframes2 = function keyframes3() {
    for (var _len2 = arguments.length, args2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args2[_key2] = arguments[_key2];
    }
    var serialized = serializeStyles(args2, cache3.registered);
    var animation = "animation-" + serialized.name;
    insertWithoutScoping(cache3, {
      name: serialized.name,
      styles: "@keyframes " + animation + "{" + serialized.styles + "}"
    });
    return animation;
  };
  var injectGlobal2 = function injectGlobal3() {
    for (var _len3 = arguments.length, args2 = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args2[_key3] = arguments[_key3];
    }
    var serialized = serializeStyles(args2, cache3.registered);
    insertWithoutScoping(cache3, serialized);
  };
  var cx2 = function cx3() {
    for (var _len4 = arguments.length, args2 = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args2[_key4] = arguments[_key4];
    }
    return merge(cache3.registered, css2, classnames(args2));
  };
  return {
    css: css2,
    cx: cx2,
    injectGlobal: injectGlobal2,
    keyframes: keyframes2,
    hydrate: function hydrate2(ids) {
      ids.forEach(function(key) {
        cache3.inserted[key] = true;
      });
    },
    flush: function flush2() {
      cache3.registered = {};
      cache3.inserted = {};
      cache3.sheet.flush();
    },
    // $FlowFixMe
    sheet: cache3.sheet,
    cache: cache3,
    getRegisteredStyles: getRegisteredStyles.bind(null, cache3.registered),
    merge: merge.bind(null, cache3.registered, css2)
  };
};
var classnames = function classnames2(args2) {
  var cls = "";
  for (var i6 = 0; i6 < args2.length; i6++) {
    var arg = args2[i6];
    if (arg == null)
      continue;
    var toAdd = void 0;
    switch (typeof arg) {
      case "boolean":
        break;
      case "object": {
        if (Array.isArray(arg)) {
          toAdd = classnames2(arg);
        } else {
          toAdd = "";
          for (var k2 in arg) {
            if (arg[k2] && k2) {
              toAdd && (toAdd += " ");
              toAdd += k2;
            }
          }
        }
        break;
      }
      default: {
        toAdd = arg;
      }
    }
    if (toAdd) {
      cls && (cls += " ");
      cls += toAdd;
    }
  }
  return cls;
};

// node_modules/@emotion/css/dist/emotion-css.esm.js
var _createEmotion = createEmotion({
  key: "css"
});
var flush = _createEmotion.flush;
var hydrate = _createEmotion.hydrate;
var cx = _createEmotion.cx;
var merge2 = _createEmotion.merge;
var getRegisteredStyles2 = _createEmotion.getRegisteredStyles;
var injectGlobal = _createEmotion.injectGlobal;
var keyframes = _createEmotion.keyframes;
var css = _createEmotion.css;
var sheet = _createEmotion.sheet;
var cache = _createEmotion.cache;

// node_modules/@keystar/ui/dist/keystar-ui-primitives.js
var TOKEN_PREFIX = "kui";
var THEME_DEFAULT = `${TOKEN_PREFIX}-theme`;
var SCHEME_AUTO = `${TOKEN_PREFIX}-scheme--auto`;
var SCHEME_LIGHT = `${TOKEN_PREFIX}-scheme--light`;
var SCHEME_DARK = `${TOKEN_PREFIX}-scheme--dark`;

// node_modules/@keystar/ui/dist/keystar-ui-style.js
var import_react6 = __toESM(require_react());

// node_modules/facepaint/dist/index.es.js
var index = function(breakpoints2) {
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, literal = _ref.literal, overlap = _ref.overlap;
  var mq = literal ? breakpoints2 : ["&"].concat(breakpoints2);
  function flatten(obj) {
    if (typeof obj !== "object" || obj == null) {
      return [];
    }
    if (Array.isArray(obj)) {
      return obj.map(flatten);
    }
    var slots = {};
    var objects = {};
    var props = {};
    Object.keys(obj).forEach(function(key) {
      var item2 = obj[key];
      if (!Array.isArray(item2) && literal)
        item2 = [item2];
      if ((literal || Array.isArray(item2)) && key.charCodeAt(0) !== 38) {
        var prior = void 0;
        item2.forEach(function(v6, index3) {
          if (overlap && prior === v6) {
            return;
          }
          if (v6 == null) {
            return;
          }
          prior = v6;
          if (index3 === 0 && !literal) {
            props[key] = v6;
          } else if (slots[mq[index3]] === void 0) {
            var _slots$mq$index;
            slots[mq[index3]] = (_slots$mq$index = {}, _slots$mq$index[key] = v6, _slots$mq$index);
          } else {
            slots[mq[index3]][key] = v6;
          }
        });
      } else if (typeof item2 === "object") {
        objects[key] = flatten(item2);
      } else {
        props[key] = item2;
      }
    });
    mq.forEach(function(el) {
      if (slots[el]) {
        props[el] = slots[el];
      }
    });
    Object.assign(props, objects);
    return props;
  }
  return function() {
    for (var _len = arguments.length, values3 = Array(_len), _key = 0; _key < _len; _key++) {
      values3[_key] = arguments[_key];
    }
    return values3.map(flatten);
  };
};
var index_es_default = index;

// node_modules/@keystar/ui/dist/keystar-ui-style.js
var import_jsx_runtime = __toESM(require_jsx_runtime());

// node_modules/@react-aria/focus/dist/import.mjs
var import_react5 = __toESM(require_react(), 1);

// node_modules/@react-aria/interactions/dist/import.mjs
var import_react4 = __toESM(require_react(), 1);

// node_modules/@swc/helpers/esm/_class_apply_descriptor_get.js
function _class_apply_descriptor_get(receiver, descriptor) {
  if (descriptor.get)
    return descriptor.get.call(receiver);
  return descriptor.value;
}

// node_modules/@swc/helpers/esm/_class_extract_field_descriptor.js
function _class_extract_field_descriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver))
    throw new TypeError("attempted to " + action + " private field on non-instance");
  return privateMap.get(receiver);
}

// node_modules/@swc/helpers/esm/_class_private_field_get.js
function _class_private_field_get(receiver, privateMap) {
  var descriptor = _class_extract_field_descriptor(receiver, privateMap, "get");
  return _class_apply_descriptor_get(receiver, descriptor);
}

// node_modules/@swc/helpers/esm/_check_private_redeclaration.js
function _check_private_redeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}

// node_modules/@swc/helpers/esm/_class_private_field_init.js
function _class_private_field_init(obj, privateMap, value2) {
  _check_private_redeclaration(obj, privateMap);
  privateMap.set(obj, value2);
}

// node_modules/@swc/helpers/esm/_class_apply_descriptor_set.js
function _class_apply_descriptor_set(receiver, descriptor, value2) {
  if (descriptor.set)
    descriptor.set.call(receiver, value2);
  else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value2;
  }
}

// node_modules/@swc/helpers/esm/_class_private_field_set.js
function _class_private_field_set(receiver, privateMap, value2) {
  var descriptor = _class_extract_field_descriptor(receiver, privateMap, "set");
  _class_apply_descriptor_set(receiver, descriptor, value2);
  return value2;
}

// node_modules/@react-aria/interactions/dist/import.mjs
var $14c0b72509d70225$var$state = "default";
var $14c0b72509d70225$var$savedUserSelect = "";
var $14c0b72509d70225$var$modifiedElementMap = /* @__PURE__ */ new WeakMap();
function $14c0b72509d70225$export$16a4697467175487(target) {
  if ((0, $c87311424ea30a05$export$fedb369cb70207f1)()) {
    if ($14c0b72509d70225$var$state === "default") {
      const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac)(target);
      $14c0b72509d70225$var$savedUserSelect = documentObject.documentElement.style.webkitUserSelect;
      documentObject.documentElement.style.webkitUserSelect = "none";
    }
    $14c0b72509d70225$var$state = "disabled";
  } else if (target instanceof HTMLElement || target instanceof SVGElement) {
    $14c0b72509d70225$var$modifiedElementMap.set(target, target.style.userSelect);
    target.style.userSelect = "none";
  }
}
function $14c0b72509d70225$export$b0d6fa1ab32e3295(target) {
  if ((0, $c87311424ea30a05$export$fedb369cb70207f1)()) {
    if ($14c0b72509d70225$var$state !== "disabled")
      return;
    $14c0b72509d70225$var$state = "restoring";
    setTimeout(() => {
      (0, $bbed8b41f857bcc0$export$24490316f764c430)(() => {
        if ($14c0b72509d70225$var$state === "restoring") {
          const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac)(target);
          if (documentObject.documentElement.style.webkitUserSelect === "none")
            documentObject.documentElement.style.webkitUserSelect = $14c0b72509d70225$var$savedUserSelect || "";
          $14c0b72509d70225$var$savedUserSelect = "";
          $14c0b72509d70225$var$state = "default";
        }
      });
    }, 300);
  } else if (target instanceof HTMLElement || target instanceof SVGElement) {
    if (target && $14c0b72509d70225$var$modifiedElementMap.has(target)) {
      let targetOldUserSelect = $14c0b72509d70225$var$modifiedElementMap.get(target);
      if (target.style.userSelect === "none")
        target.style.userSelect = targetOldUserSelect;
      if (target.getAttribute("style") === "")
        target.removeAttribute("style");
      $14c0b72509d70225$var$modifiedElementMap.delete(target);
    }
  }
}
var $ae1eeba8b9eafd08$export$5165eccb35aaadb5 = (0, import_react4.default).createContext({
  register: () => {
  }
});
$ae1eeba8b9eafd08$export$5165eccb35aaadb5.displayName = "PressResponderContext";
function $f6c31cce2adf654f$var$usePressResponderContext(props) {
  let context = (0, import_react4.useContext)((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5));
  if (context) {
    let { register, ...contextProps } = context;
    props = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(contextProps, props);
    register();
  }
  (0, $e7801be82b4b2a53$export$4debdb1a3f0fa79e)(context, props.ref);
  return props;
}
var $f6c31cce2adf654f$var$_shouldStopPropagation = /* @__PURE__ */ new WeakMap();
var $f6c31cce2adf654f$var$PressEvent = class {
  continuePropagation() {
    (0, _class_private_field_set)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, false);
  }
  get shouldStopPropagation() {
    return (0, _class_private_field_get)(this, $f6c31cce2adf654f$var$_shouldStopPropagation);
  }
  constructor(type2, pointerType, originalEvent) {
    (0, _class_private_field_init)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, {
      writable: true,
      value: void 0
    });
    (0, _class_private_field_set)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, true);
    this.type = type2;
    this.pointerType = pointerType;
    this.target = originalEvent.currentTarget;
    this.shiftKey = originalEvent.shiftKey;
    this.metaKey = originalEvent.metaKey;
    this.ctrlKey = originalEvent.ctrlKey;
    this.altKey = originalEvent.altKey;
  }
};
var $f6c31cce2adf654f$var$LINK_CLICKED = Symbol("linkClicked");
function $f6c31cce2adf654f$export$45712eceda6fad21(props) {
  let {
    onPress,
    onPressChange,
    onPressStart,
    onPressEnd,
    onPressUp,
    isDisabled,
    isPressed: isPressedProp,
    preventFocusOnPress,
    shouldCancelOnPointerExit,
    allowTextSelectionOnPress,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ref: _2,
    ...domProps
  } = $f6c31cce2adf654f$var$usePressResponderContext(props);
  let [isPressed, setPressed] = (0, import_react4.useState)(false);
  let ref = (0, import_react4.useRef)({
    isPressed: false,
    ignoreEmulatedMouseEvents: false,
    ignoreClickAfterPress: false,
    didFirePressStart: false,
    isTriggeringEvent: false,
    activePointerId: null,
    target: null,
    isOverTarget: false,
    pointerType: null
  });
  let { addGlobalListener, removeAllGlobalListeners } = (0, $03deb23ff14920c4$export$4eaf04e54aa8eed6)();
  let triggerPressStart = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((originalEvent, pointerType) => {
    let state = ref.current;
    if (isDisabled || state.didFirePressStart)
      return false;
    let shouldStopPropagation = true;
    state.isTriggeringEvent = true;
    if (onPressStart) {
      let event = new $f6c31cce2adf654f$var$PressEvent("pressstart", pointerType, originalEvent);
      onPressStart(event);
      shouldStopPropagation = event.shouldStopPropagation;
    }
    if (onPressChange)
      onPressChange(true);
    state.isTriggeringEvent = false;
    state.didFirePressStart = true;
    setPressed(true);
    return shouldStopPropagation;
  });
  let triggerPressEnd = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((originalEvent, pointerType, wasPressed = true) => {
    let state = ref.current;
    if (!state.didFirePressStart)
      return false;
    state.ignoreClickAfterPress = true;
    state.didFirePressStart = false;
    state.isTriggeringEvent = true;
    let shouldStopPropagation = true;
    if (onPressEnd) {
      let event = new $f6c31cce2adf654f$var$PressEvent("pressend", pointerType, originalEvent);
      onPressEnd(event);
      shouldStopPropagation = event.shouldStopPropagation;
    }
    if (onPressChange)
      onPressChange(false);
    setPressed(false);
    if (onPress && wasPressed && !isDisabled) {
      let event = new $f6c31cce2adf654f$var$PressEvent("press", pointerType, originalEvent);
      onPress(event);
      shouldStopPropagation && (shouldStopPropagation = event.shouldStopPropagation);
    }
    state.isTriggeringEvent = false;
    return shouldStopPropagation;
  });
  let triggerPressUp = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((originalEvent, pointerType) => {
    let state = ref.current;
    if (isDisabled)
      return false;
    if (onPressUp) {
      state.isTriggeringEvent = true;
      let event = new $f6c31cce2adf654f$var$PressEvent("pressup", pointerType, originalEvent);
      onPressUp(event);
      state.isTriggeringEvent = false;
      return event.shouldStopPropagation;
    }
    return true;
  });
  let cancel = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    let state = ref.current;
    if (state.isPressed && state.target) {
      if (state.isOverTarget && state.pointerType != null)
        triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e6), state.pointerType, false);
      state.isPressed = false;
      state.isOverTarget = false;
      state.activePointerId = null;
      state.pointerType = null;
      removeAllGlobalListeners();
      if (!allowTextSelectionOnPress)
        (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);
    }
  });
  let cancelOnPointerExit = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    if (shouldCancelOnPointerExit)
      cancel(e6);
  });
  let pressProps = (0, import_react4.useMemo)(() => {
    let state = ref.current;
    let pressProps2 = {
      onKeyDown(e6) {
        if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e6.nativeEvent, e6.currentTarget) && e6.currentTarget.contains(e6.target)) {
          var _state_metaKeyEvents;
          if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(e6.target, e6.key))
            e6.preventDefault();
          let shouldStopPropagation = true;
          if (!state.isPressed && !e6.repeat) {
            state.target = e6.currentTarget;
            state.isPressed = true;
            shouldStopPropagation = triggerPressStart(e6, "keyboard");
            let originalTarget = e6.currentTarget;
            let pressUp = (e7) => {
              if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e7, originalTarget) && !e7.repeat && originalTarget.contains(e7.target) && state.target)
                triggerPressUp($f6c31cce2adf654f$var$createEvent(state.target, e7), "keyboard");
            };
            addGlobalListener((0, $431fbd86ca7dc216$export$b204af158042fbac)(e6.currentTarget), "keyup", (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(pressUp, onKeyUp), true);
          }
          if (shouldStopPropagation)
            e6.stopPropagation();
          if (e6.metaKey && (0, $c87311424ea30a05$export$9ac100e40613ea10)())
            (_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.set(e6.key, e6.nativeEvent);
        } else if (e6.key === "Meta")
          state.metaKeyEvents = /* @__PURE__ */ new Map();
      },
      onClick(e6) {
        if (e6 && !e6.currentTarget.contains(e6.target))
          return;
        if (e6 && e6.button === 0 && !state.isTriggeringEvent && !(0, $ea8dcbcb9ea1b556$export$95185d699e05d4d7).isOpening) {
          let shouldStopPropagation = true;
          if (isDisabled)
            e6.preventDefault();
          if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && !state.isPressed && (state.pointerType === "virtual" || (0, $6a7db85432448f7f$export$60278871457622de)(e6.nativeEvent))) {
            if (!isDisabled && !preventFocusOnPress)
              (0, $7215afc6de606d6b$export$de79e2c695e052f3)(e6.currentTarget);
            let stopPressStart = triggerPressStart(e6, "virtual");
            let stopPressUp = triggerPressUp(e6, "virtual");
            let stopPressEnd = triggerPressEnd(e6, "virtual");
            shouldStopPropagation = stopPressStart && stopPressUp && stopPressEnd;
          }
          state.ignoreEmulatedMouseEvents = false;
          state.ignoreClickAfterPress = false;
          if (shouldStopPropagation)
            e6.stopPropagation();
        }
      }
    };
    let onKeyUp = (e6) => {
      var _state_metaKeyEvents;
      if (state.isPressed && state.target && $f6c31cce2adf654f$var$isValidKeyboardEvent(e6, state.target)) {
        var _state_metaKeyEvents1;
        if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(e6.target, e6.key))
          e6.preventDefault();
        let target = e6.target;
        triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e6), "keyboard", state.target.contains(target));
        removeAllGlobalListeners();
        if (e6.key !== "Enter" && $f6c31cce2adf654f$var$isHTMLAnchorLink(state.target) && state.target.contains(target) && !e6[$f6c31cce2adf654f$var$LINK_CLICKED]) {
          e6[$f6c31cce2adf654f$var$LINK_CLICKED] = true;
          (0, $ea8dcbcb9ea1b556$export$95185d699e05d4d7)(state.target, e6, false);
        }
        state.isPressed = false;
        (_state_metaKeyEvents1 = state.metaKeyEvents) === null || _state_metaKeyEvents1 === void 0 ? void 0 : _state_metaKeyEvents1.delete(e6.key);
      } else if (e6.key === "Meta" && ((_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.size)) {
        var _state_target;
        let events2 = state.metaKeyEvents;
        state.metaKeyEvents = void 0;
        for (let event of events2.values())
          (_state_target = state.target) === null || _state_target === void 0 ? void 0 : _state_target.dispatchEvent(new KeyboardEvent("keyup", event));
      }
    };
    if (typeof PointerEvent !== "undefined") {
      pressProps2.onPointerDown = (e6) => {
        if (e6.button !== 0 || !e6.currentTarget.contains(e6.target))
          return;
        if ((0, $6a7db85432448f7f$export$29bf1b5f2c56cf63)(e6.nativeEvent)) {
          state.pointerType = "virtual";
          return;
        }
        if ($f6c31cce2adf654f$var$shouldPreventDefault(e6.currentTarget))
          e6.preventDefault();
        state.pointerType = e6.pointerType;
        let shouldStopPropagation = true;
        if (!state.isPressed) {
          state.isPressed = true;
          state.isOverTarget = true;
          state.activePointerId = e6.pointerId;
          state.target = e6.currentTarget;
          if (!isDisabled && !preventFocusOnPress)
            (0, $7215afc6de606d6b$export$de79e2c695e052f3)(e6.currentTarget);
          if (!allowTextSelectionOnPress)
            (0, $14c0b72509d70225$export$16a4697467175487)(state.target);
          shouldStopPropagation = triggerPressStart(e6, state.pointerType);
          addGlobalListener((0, $431fbd86ca7dc216$export$b204af158042fbac)(e6.currentTarget), "pointermove", onPointerMove, false);
          addGlobalListener((0, $431fbd86ca7dc216$export$b204af158042fbac)(e6.currentTarget), "pointerup", onPointerUp, false);
          addGlobalListener((0, $431fbd86ca7dc216$export$b204af158042fbac)(e6.currentTarget), "pointercancel", onPointerCancel, false);
        }
        if (shouldStopPropagation)
          e6.stopPropagation();
      };
      pressProps2.onMouseDown = (e6) => {
        if (!e6.currentTarget.contains(e6.target))
          return;
        if (e6.button === 0) {
          if ($f6c31cce2adf654f$var$shouldPreventDefault(e6.currentTarget))
            e6.preventDefault();
          e6.stopPropagation();
        }
      };
      pressProps2.onPointerUp = (e6) => {
        if (!e6.currentTarget.contains(e6.target) || state.pointerType === "virtual")
          return;
        if (e6.button === 0 && $f6c31cce2adf654f$var$isOverTarget(e6, e6.currentTarget))
          triggerPressUp(e6, state.pointerType || e6.pointerType);
      };
      let onPointerMove = (e6) => {
        if (e6.pointerId !== state.activePointerId)
          return;
        if (state.target && $f6c31cce2adf654f$var$isOverTarget(e6, state.target)) {
          if (!state.isOverTarget && state.pointerType != null) {
            state.isOverTarget = true;
            triggerPressStart($f6c31cce2adf654f$var$createEvent(state.target, e6), state.pointerType);
          }
        } else if (state.target && state.isOverTarget && state.pointerType != null) {
          state.isOverTarget = false;
          triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e6), state.pointerType, false);
          cancelOnPointerExit(e6);
        }
      };
      let onPointerUp = (e6) => {
        if (e6.pointerId === state.activePointerId && state.isPressed && e6.button === 0 && state.target) {
          if ($f6c31cce2adf654f$var$isOverTarget(e6, state.target) && state.pointerType != null)
            triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e6), state.pointerType);
          else if (state.isOverTarget && state.pointerType != null)
            triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e6), state.pointerType, false);
          state.isPressed = false;
          state.isOverTarget = false;
          state.activePointerId = null;
          state.pointerType = null;
          removeAllGlobalListeners();
          if (!allowTextSelectionOnPress)
            (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);
        }
      };
      let onPointerCancel = (e6) => {
        cancel(e6);
      };
      pressProps2.onDragStart = (e6) => {
        if (!e6.currentTarget.contains(e6.target))
          return;
        cancel(e6);
      };
    } else {
      pressProps2.onMouseDown = (e6) => {
        if (e6.button !== 0 || !e6.currentTarget.contains(e6.target))
          return;
        if ($f6c31cce2adf654f$var$shouldPreventDefault(e6.currentTarget))
          e6.preventDefault();
        if (state.ignoreEmulatedMouseEvents) {
          e6.stopPropagation();
          return;
        }
        state.isPressed = true;
        state.isOverTarget = true;
        state.target = e6.currentTarget;
        state.pointerType = (0, $6a7db85432448f7f$export$60278871457622de)(e6.nativeEvent) ? "virtual" : "mouse";
        if (!isDisabled && !preventFocusOnPress)
          (0, $7215afc6de606d6b$export$de79e2c695e052f3)(e6.currentTarget);
        let shouldStopPropagation = triggerPressStart(e6, state.pointerType);
        if (shouldStopPropagation)
          e6.stopPropagation();
        addGlobalListener((0, $431fbd86ca7dc216$export$b204af158042fbac)(e6.currentTarget), "mouseup", onMouseUp, false);
      };
      pressProps2.onMouseEnter = (e6) => {
        if (!e6.currentTarget.contains(e6.target))
          return;
        let shouldStopPropagation = true;
        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {
          state.isOverTarget = true;
          shouldStopPropagation = triggerPressStart(e6, state.pointerType);
        }
        if (shouldStopPropagation)
          e6.stopPropagation();
      };
      pressProps2.onMouseLeave = (e6) => {
        if (!e6.currentTarget.contains(e6.target))
          return;
        let shouldStopPropagation = true;
        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {
          state.isOverTarget = false;
          shouldStopPropagation = triggerPressEnd(e6, state.pointerType, false);
          cancelOnPointerExit(e6);
        }
        if (shouldStopPropagation)
          e6.stopPropagation();
      };
      pressProps2.onMouseUp = (e6) => {
        if (!e6.currentTarget.contains(e6.target))
          return;
        if (!state.ignoreEmulatedMouseEvents && e6.button === 0)
          triggerPressUp(e6, state.pointerType || "mouse");
      };
      let onMouseUp = (e6) => {
        if (e6.button !== 0)
          return;
        state.isPressed = false;
        removeAllGlobalListeners();
        if (state.ignoreEmulatedMouseEvents) {
          state.ignoreEmulatedMouseEvents = false;
          return;
        }
        if (state.target && $f6c31cce2adf654f$var$isOverTarget(e6, state.target) && state.pointerType != null)
          triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e6), state.pointerType);
        else if (state.target && state.isOverTarget && state.pointerType != null)
          triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e6), state.pointerType, false);
        state.isOverTarget = false;
      };
      pressProps2.onTouchStart = (e6) => {
        if (!e6.currentTarget.contains(e6.target))
          return;
        let touch = $f6c31cce2adf654f$var$getTouchFromEvent(e6.nativeEvent);
        if (!touch)
          return;
        state.activePointerId = touch.identifier;
        state.ignoreEmulatedMouseEvents = true;
        state.isOverTarget = true;
        state.isPressed = true;
        state.target = e6.currentTarget;
        state.pointerType = "touch";
        if (!isDisabled && !preventFocusOnPress)
          (0, $7215afc6de606d6b$export$de79e2c695e052f3)(e6.currentTarget);
        if (!allowTextSelectionOnPress)
          (0, $14c0b72509d70225$export$16a4697467175487)(state.target);
        let shouldStopPropagation = triggerPressStart(e6, state.pointerType);
        if (shouldStopPropagation)
          e6.stopPropagation();
        addGlobalListener((0, $431fbd86ca7dc216$export$f21a1ffae260145a)(e6.currentTarget), "scroll", onScroll, true);
      };
      pressProps2.onTouchMove = (e6) => {
        if (!e6.currentTarget.contains(e6.target))
          return;
        if (!state.isPressed) {
          e6.stopPropagation();
          return;
        }
        let touch = $f6c31cce2adf654f$var$getTouchById(e6.nativeEvent, state.activePointerId);
        let shouldStopPropagation = true;
        if (touch && $f6c31cce2adf654f$var$isOverTarget(touch, e6.currentTarget)) {
          if (!state.isOverTarget && state.pointerType != null) {
            state.isOverTarget = true;
            shouldStopPropagation = triggerPressStart(e6, state.pointerType);
          }
        } else if (state.isOverTarget && state.pointerType != null) {
          state.isOverTarget = false;
          shouldStopPropagation = triggerPressEnd(e6, state.pointerType, false);
          cancelOnPointerExit(e6);
        }
        if (shouldStopPropagation)
          e6.stopPropagation();
      };
      pressProps2.onTouchEnd = (e6) => {
        if (!e6.currentTarget.contains(e6.target))
          return;
        if (!state.isPressed) {
          e6.stopPropagation();
          return;
        }
        let touch = $f6c31cce2adf654f$var$getTouchById(e6.nativeEvent, state.activePointerId);
        let shouldStopPropagation = true;
        if (touch && $f6c31cce2adf654f$var$isOverTarget(touch, e6.currentTarget) && state.pointerType != null) {
          triggerPressUp(e6, state.pointerType);
          shouldStopPropagation = triggerPressEnd(e6, state.pointerType);
        } else if (state.isOverTarget && state.pointerType != null)
          shouldStopPropagation = triggerPressEnd(e6, state.pointerType, false);
        if (shouldStopPropagation)
          e6.stopPropagation();
        state.isPressed = false;
        state.activePointerId = null;
        state.isOverTarget = false;
        state.ignoreEmulatedMouseEvents = true;
        if (state.target && !allowTextSelectionOnPress)
          (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);
        removeAllGlobalListeners();
      };
      pressProps2.onTouchCancel = (e6) => {
        if (!e6.currentTarget.contains(e6.target))
          return;
        e6.stopPropagation();
        if (state.isPressed)
          cancel(e6);
      };
      let onScroll = (e6) => {
        if (state.isPressed && e6.target.contains(state.target))
          cancel({
            currentTarget: state.target,
            shiftKey: false,
            ctrlKey: false,
            metaKey: false,
            altKey: false
          });
      };
      pressProps2.onDragStart = (e6) => {
        if (!e6.currentTarget.contains(e6.target))
          return;
        cancel(e6);
      };
    }
    return pressProps2;
  }, [
    addGlobalListener,
    isDisabled,
    preventFocusOnPress,
    removeAllGlobalListeners,
    allowTextSelectionOnPress,
    cancel,
    cancelOnPointerExit,
    triggerPressEnd,
    triggerPressStart,
    triggerPressUp
  ]);
  (0, import_react4.useEffect)(() => {
    return () => {
      var _ref_current_target;
      if (!allowTextSelectionOnPress)
        (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)((_ref_current_target = ref.current.target) !== null && _ref_current_target !== void 0 ? _ref_current_target : void 0);
    };
  }, [
    allowTextSelectionOnPress
  ]);
  return {
    isPressed: isPressedProp || isPressed,
    pressProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, pressProps)
  };
}
function $f6c31cce2adf654f$var$isHTMLAnchorLink(target) {
  return target.tagName === "A" && target.hasAttribute("href");
}
function $f6c31cce2adf654f$var$isValidKeyboardEvent(event, currentTarget) {
  const { key, code: code3 } = event;
  const element4 = currentTarget;
  const role = element4.getAttribute("role");
  return (key === "Enter" || key === " " || key === "Spacebar" || code3 === "Space") && !(element4 instanceof (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(element4).HTMLInputElement && !$f6c31cce2adf654f$var$isValidInputKey(element4, key) || element4 instanceof (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(element4).HTMLTextAreaElement || element4.isContentEditable) && // Links should only trigger with Enter key
  !((role === "link" || !role && $f6c31cce2adf654f$var$isHTMLAnchorLink(element4)) && key !== "Enter");
}
function $f6c31cce2adf654f$var$getTouchFromEvent(event) {
  const { targetTouches } = event;
  if (targetTouches.length > 0)
    return targetTouches[0];
  return null;
}
function $f6c31cce2adf654f$var$getTouchById(event, pointerId) {
  const changedTouches = event.changedTouches;
  for (let i6 = 0; i6 < changedTouches.length; i6++) {
    const touch = changedTouches[i6];
    if (touch.identifier === pointerId)
      return touch;
  }
  return null;
}
function $f6c31cce2adf654f$var$createEvent(target, e6) {
  return {
    currentTarget: target,
    shiftKey: e6.shiftKey,
    ctrlKey: e6.ctrlKey,
    metaKey: e6.metaKey,
    altKey: e6.altKey
  };
}
function $f6c31cce2adf654f$var$getPointClientRect(point3) {
  let offsetX = 0;
  let offsetY = 0;
  if (point3.width !== void 0)
    offsetX = point3.width / 2;
  else if (point3.radiusX !== void 0)
    offsetX = point3.radiusX;
  if (point3.height !== void 0)
    offsetY = point3.height / 2;
  else if (point3.radiusY !== void 0)
    offsetY = point3.radiusY;
  return {
    top: point3.clientY - offsetY,
    right: point3.clientX + offsetX,
    bottom: point3.clientY + offsetY,
    left: point3.clientX - offsetX
  };
}
function $f6c31cce2adf654f$var$areRectanglesOverlapping(a3, b2) {
  if (a3.left > b2.right || b2.left > a3.right)
    return false;
  if (a3.top > b2.bottom || b2.top > a3.bottom)
    return false;
  return true;
}
function $f6c31cce2adf654f$var$isOverTarget(point3, target) {
  let rect = target.getBoundingClientRect();
  let pointRect = $f6c31cce2adf654f$var$getPointClientRect(point3);
  return $f6c31cce2adf654f$var$areRectanglesOverlapping(rect, pointRect);
}
function $f6c31cce2adf654f$var$shouldPreventDefault(target) {
  return !(target instanceof HTMLElement) || !target.hasAttribute("draggable");
}
function $f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(target, key) {
  if (target instanceof HTMLInputElement)
    return !$f6c31cce2adf654f$var$isValidInputKey(target, key);
  if (target instanceof HTMLButtonElement)
    return target.type !== "submit" && target.type !== "reset";
  if ($f6c31cce2adf654f$var$isHTMLAnchorLink(target))
    return false;
  return true;
}
var $f6c31cce2adf654f$var$nonTextInputTypes = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function $f6c31cce2adf654f$var$isValidInputKey(target, key) {
  return target.type === "checkbox" || target.type === "radio" ? key === " " : $f6c31cce2adf654f$var$nonTextInputTypes.has(target.type);
}
var $3b117e43dc0ca95d$export$27c701ed9e449e99 = (0, import_react4.default).forwardRef(({ children, ...props }, ref) => {
  ref = (0, $df56164dff5785e2$export$4338b53315abf666)(ref);
  let { pressProps } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    ...props,
    ref
  });
  let child = (0, import_react4.default).Children.only(children);
  return (0, import_react4.default).cloneElement(
    child,
    // @ts-ignore
    {
      ref,
      ...(0, $3ef42575df84b30b$export$9d1611c77c2fe928)(child.props, pressProps)
    }
  );
});
var $f1ab8c75478c6f73$export$3351871ee4b288b8 = (0, import_react4.default).forwardRef(({ children, ...props }, ref) => {
  let isRegistered = (0, import_react4.useRef)(false);
  let prevContext = (0, import_react4.useContext)((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5));
  ref = (0, $df56164dff5785e2$export$4338b53315abf666)(ref || (prevContext === null || prevContext === void 0 ? void 0 : prevContext.ref));
  let context = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(prevContext || {}, {
    ...props,
    ref,
    register() {
      isRegistered.current = true;
      if (prevContext)
        prevContext.register();
    }
  });
  (0, $e7801be82b4b2a53$export$4debdb1a3f0fa79e)(prevContext, ref);
  (0, import_react4.useEffect)(() => {
    if (!isRegistered.current) {
      console.warn("A PressResponder was rendered without a pressable child. Either call the usePress hook, or wrap your DOM node with <Pressable> component.");
      isRegistered.current = true;
    }
  }, []);
  return (0, import_react4.default).createElement((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5).Provider, {
    value: context
  }, children);
});
function $f1ab8c75478c6f73$export$cf75428e0b9ed1ea({ children }) {
  let context = (0, import_react4.useMemo)(() => ({
    register: () => {
    }
  }), []);
  return (0, import_react4.default).createElement((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5).Provider, {
    value: context
  }, children);
}
var $8a9cb279dc87e130$export$905e7fc544a71f36 = class {
  isDefaultPrevented() {
    return this.nativeEvent.defaultPrevented;
  }
  preventDefault() {
    this.defaultPrevented = true;
    this.nativeEvent.preventDefault();
  }
  stopPropagation() {
    this.nativeEvent.stopPropagation();
    this.isPropagationStopped = () => true;
  }
  isPropagationStopped() {
    return false;
  }
  persist() {
  }
  constructor(type2, nativeEvent) {
    this.nativeEvent = nativeEvent;
    this.target = nativeEvent.target;
    this.currentTarget = nativeEvent.currentTarget;
    this.relatedTarget = nativeEvent.relatedTarget;
    this.bubbles = nativeEvent.bubbles;
    this.cancelable = nativeEvent.cancelable;
    this.defaultPrevented = nativeEvent.defaultPrevented;
    this.eventPhase = nativeEvent.eventPhase;
    this.isTrusted = nativeEvent.isTrusted;
    this.timeStamp = nativeEvent.timeStamp;
    this.type = type2;
  }
};
function $8a9cb279dc87e130$export$715c682d09d639cc(onBlur) {
  let stateRef = (0, import_react4.useRef)({
    isFocused: false,
    observer: null
  });
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    const state = stateRef.current;
    return () => {
      if (state.observer) {
        state.observer.disconnect();
        state.observer = null;
      }
    };
  }, []);
  let dispatchBlur = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    onBlur === null || onBlur === void 0 ? void 0 : onBlur(e6);
  });
  return (0, import_react4.useCallback)((e6) => {
    if (e6.target instanceof HTMLButtonElement || e6.target instanceof HTMLInputElement || e6.target instanceof HTMLTextAreaElement || e6.target instanceof HTMLSelectElement) {
      stateRef.current.isFocused = true;
      let target = e6.target;
      let onBlurHandler = (e7) => {
        stateRef.current.isFocused = false;
        if (target.disabled)
          dispatchBlur(new $8a9cb279dc87e130$export$905e7fc544a71f36("blur", e7));
        if (stateRef.current.observer) {
          stateRef.current.observer.disconnect();
          stateRef.current.observer = null;
        }
      };
      target.addEventListener("focusout", onBlurHandler, {
        once: true
      });
      stateRef.current.observer = new MutationObserver(() => {
        if (stateRef.current.isFocused && target.disabled) {
          var _stateRef_current_observer;
          (_stateRef_current_observer = stateRef.current.observer) === null || _stateRef_current_observer === void 0 ? void 0 : _stateRef_current_observer.disconnect();
          let relatedTargetEl = target === document.activeElement ? null : document.activeElement;
          target.dispatchEvent(new FocusEvent("blur", {
            relatedTarget: relatedTargetEl
          }));
          target.dispatchEvent(new FocusEvent("focusout", {
            bubbles: true,
            relatedTarget: relatedTargetEl
          }));
        }
      });
      stateRef.current.observer.observe(target, {
        attributes: true,
        attributeFilter: [
          "disabled"
        ]
      });
    }
  }, [
    dispatchBlur
  ]);
}
function $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(props) {
  let { isDisabled, onFocus: onFocusProp, onBlur: onBlurProp, onFocusChange } = props;
  const onBlur = (0, import_react4.useCallback)((e6) => {
    if (e6.target === e6.currentTarget) {
      if (onBlurProp)
        onBlurProp(e6);
      if (onFocusChange)
        onFocusChange(false);
      return true;
    }
  }, [
    onBlurProp,
    onFocusChange
  ]);
  const onSyntheticFocus = (0, $8a9cb279dc87e130$export$715c682d09d639cc)(onBlur);
  const onFocus = (0, import_react4.useCallback)((e6) => {
    if (e6.target === e6.currentTarget && document.activeElement === e6.target) {
      if (onFocusProp)
        onFocusProp(e6);
      if (onFocusChange)
        onFocusChange(true);
      onSyntheticFocus(e6);
    }
  }, [
    onFocusChange,
    onFocusProp,
    onSyntheticFocus
  ]);
  return {
    focusProps: {
      onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : void 0,
      onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : void 0
    }
  };
}
var $507fabe10e71c6fb$var$currentModality = null;
var $507fabe10e71c6fb$var$changeHandlers = /* @__PURE__ */ new Set();
var $507fabe10e71c6fb$export$d90243b58daecda7 = /* @__PURE__ */ new Map();
var $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
var $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;
var $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: true,
  Escape: true
};
function $507fabe10e71c6fb$var$triggerChangeHandlers(modality, e6) {
  for (let handler of $507fabe10e71c6fb$var$changeHandlers)
    handler(modality, e6);
}
function $507fabe10e71c6fb$var$isValidKey(e6) {
  return !(e6.metaKey || !(0, $c87311424ea30a05$export$9ac100e40613ea10)() && e6.altKey || e6.ctrlKey || e6.key === "Control" || e6.key === "Shift" || e6.key === "Meta");
}
function $507fabe10e71c6fb$var$handleKeyboardEvent(e6) {
  $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
  if ($507fabe10e71c6fb$var$isValidKey(e6)) {
    $507fabe10e71c6fb$var$currentModality = "keyboard";
    $507fabe10e71c6fb$var$triggerChangeHandlers("keyboard", e6);
  }
}
function $507fabe10e71c6fb$var$handlePointerEvent(e6) {
  $507fabe10e71c6fb$var$currentModality = "pointer";
  if (e6.type === "mousedown" || e6.type === "pointerdown") {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
    $507fabe10e71c6fb$var$triggerChangeHandlers("pointer", e6);
  }
}
function $507fabe10e71c6fb$var$handleClickEvent(e6) {
  if ((0, $6a7db85432448f7f$export$60278871457622de)(e6)) {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
    $507fabe10e71c6fb$var$currentModality = "virtual";
  }
}
function $507fabe10e71c6fb$var$handleFocusEvent(e6) {
  if (e6.target === window || e6.target === document)
    return;
  if (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently) {
    $507fabe10e71c6fb$var$currentModality = "virtual";
    $507fabe10e71c6fb$var$triggerChangeHandlers("virtual", e6);
  }
  $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
  $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;
}
function $507fabe10e71c6fb$var$handleWindowBlur() {
  $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
  $507fabe10e71c6fb$var$hasBlurredWindowRecently = true;
}
function $507fabe10e71c6fb$var$setupGlobalFocusEvents(element4) {
  if (typeof window === "undefined" || $507fabe10e71c6fb$export$d90243b58daecda7.get((0, $431fbd86ca7dc216$export$f21a1ffae260145a)(element4)))
    return;
  const windowObject = (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(element4);
  const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac)(element4);
  let focus = windowObject.HTMLElement.prototype.focus;
  windowObject.HTMLElement.prototype.focus = function() {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
    focus.apply(this, arguments);
  };
  documentObject.addEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.addEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.addEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, true);
  windowObject.addEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, true);
  windowObject.addEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, false);
  if (typeof PointerEvent !== "undefined") {
    documentObject.addEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.addEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.addEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  } else {
    documentObject.addEventListener("mousedown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.addEventListener("mousemove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.addEventListener("mouseup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  }
  windowObject.addEventListener("beforeunload", () => {
    $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element4);
  }, {
    once: true
  });
  $507fabe10e71c6fb$export$d90243b58daecda7.set(windowObject, {
    focus
  });
}
var $507fabe10e71c6fb$var$tearDownWindowFocusTracking = (element4, loadListener) => {
  const windowObject = (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(element4);
  const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac)(element4);
  if (loadListener)
    documentObject.removeEventListener("DOMContentLoaded", loadListener);
  if (!$507fabe10e71c6fb$export$d90243b58daecda7.has(windowObject))
    return;
  windowObject.HTMLElement.prototype.focus = $507fabe10e71c6fb$export$d90243b58daecda7.get(windowObject).focus;
  documentObject.removeEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.removeEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.removeEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, true);
  windowObject.removeEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, true);
  windowObject.removeEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, false);
  if (typeof PointerEvent !== "undefined") {
    documentObject.removeEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.removeEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.removeEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  } else {
    documentObject.removeEventListener("mousedown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.removeEventListener("mousemove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.removeEventListener("mouseup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  }
  $507fabe10e71c6fb$export$d90243b58daecda7.delete(windowObject);
};
function $507fabe10e71c6fb$export$2f1888112f558a7d(element4) {
  const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac)(element4);
  let loadListener;
  if (documentObject.readyState !== "loading")
    $507fabe10e71c6fb$var$setupGlobalFocusEvents(element4);
  else {
    loadListener = () => {
      $507fabe10e71c6fb$var$setupGlobalFocusEvents(element4);
    };
    documentObject.addEventListener("DOMContentLoaded", loadListener);
  }
  return () => $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element4, loadListener);
}
if (typeof document !== "undefined")
  $507fabe10e71c6fb$export$2f1888112f558a7d();
function $507fabe10e71c6fb$export$b9b3dfddab17db27() {
  return $507fabe10e71c6fb$var$currentModality !== "pointer";
}
function $507fabe10e71c6fb$export$630ff653c5ada6a9() {
  return $507fabe10e71c6fb$var$currentModality;
}
function $507fabe10e71c6fb$export$8397ddfc504fdb9a(modality) {
  $507fabe10e71c6fb$var$currentModality = modality;
  $507fabe10e71c6fb$var$triggerChangeHandlers(modality, null);
}
function $507fabe10e71c6fb$export$98e20ec92f614cfe() {
  $507fabe10e71c6fb$var$setupGlobalFocusEvents();
  let [modality, setModality] = (0, import_react4.useState)($507fabe10e71c6fb$var$currentModality);
  (0, import_react4.useEffect)(() => {
    let handler = () => {
      setModality($507fabe10e71c6fb$var$currentModality);
    };
    $507fabe10e71c6fb$var$changeHandlers.add(handler);
    return () => {
      $507fabe10e71c6fb$var$changeHandlers.delete(handler);
    };
  }, []);
  return (0, $b5e257d569688ac6$export$535bd6ca7f90a273)() ? null : modality;
}
var $507fabe10e71c6fb$var$nonTextInputTypes = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function $507fabe10e71c6fb$var$isKeyboardFocusEvent(isTextInput, modality, e6) {
  var _e_target;
  const IHTMLInputElement = typeof window !== "undefined" ? (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(e6 === null || e6 === void 0 ? void 0 : e6.target).HTMLInputElement : HTMLInputElement;
  const IHTMLTextAreaElement = typeof window !== "undefined" ? (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(e6 === null || e6 === void 0 ? void 0 : e6.target).HTMLTextAreaElement : HTMLTextAreaElement;
  const IHTMLElement = typeof window !== "undefined" ? (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(e6 === null || e6 === void 0 ? void 0 : e6.target).HTMLElement : HTMLElement;
  const IKeyboardEvent = typeof window !== "undefined" ? (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(e6 === null || e6 === void 0 ? void 0 : e6.target).KeyboardEvent : KeyboardEvent;
  isTextInput = isTextInput || (e6 === null || e6 === void 0 ? void 0 : e6.target) instanceof IHTMLInputElement && !$507fabe10e71c6fb$var$nonTextInputTypes.has(e6 === null || e6 === void 0 ? void 0 : (_e_target = e6.target) === null || _e_target === void 0 ? void 0 : _e_target.type) || (e6 === null || e6 === void 0 ? void 0 : e6.target) instanceof IHTMLTextAreaElement || (e6 === null || e6 === void 0 ? void 0 : e6.target) instanceof IHTMLElement && (e6 === null || e6 === void 0 ? void 0 : e6.target.isContentEditable);
  return !(isTextInput && modality === "keyboard" && e6 instanceof IKeyboardEvent && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[e6.key]);
}
function $507fabe10e71c6fb$export$ec71b4b83ac08ec3(fn2, deps, opts) {
  $507fabe10e71c6fb$var$setupGlobalFocusEvents();
  (0, import_react4.useEffect)(() => {
    let handler = (modality, e6) => {
      if (!$507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(opts === null || opts === void 0 ? void 0 : opts.isTextInput), modality, e6))
        return;
      fn2($507fabe10e71c6fb$export$b9b3dfddab17db27());
    };
    $507fabe10e71c6fb$var$changeHandlers.add(handler);
    return () => {
      $507fabe10e71c6fb$var$changeHandlers.delete(handler);
    };
  }, deps);
}
function $9ab94262bd0047c7$export$420e68273165f4ec(props) {
  let { isDisabled, onBlurWithin, onFocusWithin, onFocusWithinChange } = props;
  let state = (0, import_react4.useRef)({
    isFocusWithin: false
  });
  let onBlur = (0, import_react4.useCallback)((e6) => {
    if (state.current.isFocusWithin && !e6.currentTarget.contains(e6.relatedTarget)) {
      state.current.isFocusWithin = false;
      if (onBlurWithin)
        onBlurWithin(e6);
      if (onFocusWithinChange)
        onFocusWithinChange(false);
    }
  }, [
    onBlurWithin,
    onFocusWithinChange,
    state
  ]);
  let onSyntheticFocus = (0, $8a9cb279dc87e130$export$715c682d09d639cc)(onBlur);
  let onFocus = (0, import_react4.useCallback)((e6) => {
    if (!state.current.isFocusWithin && document.activeElement === e6.target) {
      if (onFocusWithin)
        onFocusWithin(e6);
      if (onFocusWithinChange)
        onFocusWithinChange(true);
      state.current.isFocusWithin = true;
      onSyntheticFocus(e6);
    }
  }, [
    onFocusWithin,
    onFocusWithinChange,
    onSyntheticFocus
  ]);
  if (isDisabled)
    return {
      focusWithinProps: {
        // These should not have been null, that would conflict in mergeProps
        onFocus: void 0,
        onBlur: void 0
      }
    };
  return {
    focusWithinProps: {
      onFocus,
      onBlur
    }
  };
}
var $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;
var $6179b936705e76d3$var$hoverCount = 0;
function $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {
  $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = true;
  setTimeout(() => {
    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;
  }, 50);
}
function $6179b936705e76d3$var$handleGlobalPointerEvent(e6) {
  if (e6.pointerType === "touch")
    $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();
}
function $6179b936705e76d3$var$setupGlobalTouchEvents() {
  if (typeof document === "undefined")
    return;
  if (typeof PointerEvent !== "undefined")
    document.addEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent);
  else
    document.addEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);
  $6179b936705e76d3$var$hoverCount++;
  return () => {
    $6179b936705e76d3$var$hoverCount--;
    if ($6179b936705e76d3$var$hoverCount > 0)
      return;
    if (typeof PointerEvent !== "undefined")
      document.removeEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent);
    else
      document.removeEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);
  };
}
function $6179b936705e76d3$export$ae780daf29e6d456(props) {
  let { onHoverStart, onHoverChange, onHoverEnd, isDisabled } = props;
  let [isHovered, setHovered] = (0, import_react4.useState)(false);
  let state = (0, import_react4.useRef)({
    isHovered: false,
    ignoreEmulatedMouseEvents: false,
    pointerType: "",
    target: null
  }).current;
  (0, import_react4.useEffect)($6179b936705e76d3$var$setupGlobalTouchEvents, []);
  let { hoverProps, triggerHoverEnd } = (0, import_react4.useMemo)(() => {
    let triggerHoverStart = (event, pointerType) => {
      state.pointerType = pointerType;
      if (isDisabled || pointerType === "touch" || state.isHovered || !event.currentTarget.contains(event.target))
        return;
      state.isHovered = true;
      let target = event.currentTarget;
      state.target = target;
      if (onHoverStart)
        onHoverStart({
          type: "hoverstart",
          target,
          pointerType
        });
      if (onHoverChange)
        onHoverChange(true);
      setHovered(true);
    };
    let triggerHoverEnd2 = (event, pointerType) => {
      state.pointerType = "";
      state.target = null;
      if (pointerType === "touch" || !state.isHovered)
        return;
      state.isHovered = false;
      let target = event.currentTarget;
      if (onHoverEnd)
        onHoverEnd({
          type: "hoverend",
          target,
          pointerType
        });
      if (onHoverChange)
        onHoverChange(false);
      setHovered(false);
    };
    let hoverProps2 = {};
    if (typeof PointerEvent !== "undefined") {
      hoverProps2.onPointerEnter = (e6) => {
        if ($6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && e6.pointerType === "mouse")
          return;
        triggerHoverStart(e6, e6.pointerType);
      };
      hoverProps2.onPointerLeave = (e6) => {
        if (!isDisabled && e6.currentTarget.contains(e6.target))
          triggerHoverEnd2(e6, e6.pointerType);
      };
    } else {
      hoverProps2.onTouchStart = () => {
        state.ignoreEmulatedMouseEvents = true;
      };
      hoverProps2.onMouseEnter = (e6) => {
        if (!state.ignoreEmulatedMouseEvents && !$6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents)
          triggerHoverStart(e6, "mouse");
        state.ignoreEmulatedMouseEvents = false;
      };
      hoverProps2.onMouseLeave = (e6) => {
        if (!isDisabled && e6.currentTarget.contains(e6.target))
          triggerHoverEnd2(e6, "mouse");
      };
    }
    return {
      hoverProps: hoverProps2,
      triggerHoverEnd: triggerHoverEnd2
    };
  }, [
    onHoverStart,
    onHoverChange,
    onHoverEnd,
    isDisabled,
    state
  ]);
  (0, import_react4.useEffect)(() => {
    if (isDisabled)
      triggerHoverEnd({
        currentTarget: state.target
      }, state.pointerType);
  }, [
    isDisabled
  ]);
  return {
    hoverProps,
    isHovered
  };
}
function $e0b6e0b68ec7f50f$export$872b660ac5a1ff98(props) {
  let { ref, onInteractOutside, isDisabled, onInteractOutsideStart } = props;
  let stateRef = (0, import_react4.useRef)({
    isPointerDown: false,
    ignoreEmulatedMouseEvents: false
  });
  let onPointerDown = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    if (onInteractOutside && $e0b6e0b68ec7f50f$var$isValidEvent(e6, ref)) {
      if (onInteractOutsideStart)
        onInteractOutsideStart(e6);
      stateRef.current.isPointerDown = true;
    }
  });
  let triggerInteractOutside = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    if (onInteractOutside)
      onInteractOutside(e6);
  });
  (0, import_react4.useEffect)(() => {
    let state = stateRef.current;
    if (isDisabled)
      return;
    const element4 = ref.current;
    const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac)(element4);
    if (typeof PointerEvent !== "undefined") {
      let onPointerUp = (e6) => {
        if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e6, ref))
          triggerInteractOutside(e6);
        state.isPointerDown = false;
      };
      documentObject.addEventListener("pointerdown", onPointerDown, true);
      documentObject.addEventListener("pointerup", onPointerUp, true);
      return () => {
        documentObject.removeEventListener("pointerdown", onPointerDown, true);
        documentObject.removeEventListener("pointerup", onPointerUp, true);
      };
    } else {
      let onMouseUp = (e6) => {
        if (state.ignoreEmulatedMouseEvents)
          state.ignoreEmulatedMouseEvents = false;
        else if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e6, ref))
          triggerInteractOutside(e6);
        state.isPointerDown = false;
      };
      let onTouchEnd = (e6) => {
        state.ignoreEmulatedMouseEvents = true;
        if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e6, ref))
          triggerInteractOutside(e6);
        state.isPointerDown = false;
      };
      documentObject.addEventListener("mousedown", onPointerDown, true);
      documentObject.addEventListener("mouseup", onMouseUp, true);
      documentObject.addEventListener("touchstart", onPointerDown, true);
      documentObject.addEventListener("touchend", onTouchEnd, true);
      return () => {
        documentObject.removeEventListener("mousedown", onPointerDown, true);
        documentObject.removeEventListener("mouseup", onMouseUp, true);
        documentObject.removeEventListener("touchstart", onPointerDown, true);
        documentObject.removeEventListener("touchend", onTouchEnd, true);
      };
    }
  }, [
    ref,
    isDisabled,
    onPointerDown,
    triggerInteractOutside
  ]);
}
function $e0b6e0b68ec7f50f$var$isValidEvent(event, ref) {
  if (event.button > 0)
    return false;
  if (event.target) {
    const ownerDocument = event.target.ownerDocument;
    if (!ownerDocument || !ownerDocument.documentElement.contains(event.target))
      return false;
    if (event.target.closest("[data-react-aria-top-layer]"))
      return false;
  }
  return ref.current && !ref.current.contains(event.target);
}
function $93925083ecbb358c$export$48d1ea6320830260(handler) {
  if (!handler)
    return void 0;
  let shouldStopPropagation = true;
  return (e6) => {
    let event = {
      ...e6,
      preventDefault() {
        e6.preventDefault();
      },
      isDefaultPrevented() {
        return e6.isDefaultPrevented();
      },
      stopPropagation() {
        console.error("stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.");
      },
      continuePropagation() {
        shouldStopPropagation = false;
      }
    };
    handler(event);
    if (shouldStopPropagation)
      e6.stopPropagation();
  };
}
function $46d819fcbaf35654$export$8f71654801c2f7cd(props) {
  return {
    keyboardProps: props.isDisabled ? {} : {
      onKeyDown: (0, $93925083ecbb358c$export$48d1ea6320830260)(props.onKeyDown),
      onKeyUp: (0, $93925083ecbb358c$export$48d1ea6320830260)(props.onKeyUp)
    }
  };
}
function $7d0a636d7a4dcefd$export$2123ff2b87c81ca(props, ref) {
  let { onScroll, isDisabled } = props;
  let onScrollHandler = (0, import_react4.useCallback)((e6) => {
    if (e6.ctrlKey)
      return;
    e6.preventDefault();
    e6.stopPropagation();
    if (onScroll)
      onScroll({
        deltaX: e6.deltaX,
        deltaY: e6.deltaY
      });
  }, [
    onScroll
  ]);
  (0, $e9faafb641e167db$export$90fc3a17d93f704c)(ref, "wheel", isDisabled ? void 0 : onScrollHandler);
}
var $8a26561d2877236e$var$DEFAULT_THRESHOLD = 500;
function $8a26561d2877236e$export$c24ed0104d07eab9(props) {
  let { isDisabled, onLongPressStart, onLongPressEnd, onLongPress, threshold = $8a26561d2877236e$var$DEFAULT_THRESHOLD, accessibilityDescription } = props;
  const timeRef = (0, import_react4.useRef)();
  let { addGlobalListener, removeGlobalListener } = (0, $03deb23ff14920c4$export$4eaf04e54aa8eed6)();
  let { pressProps } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    isDisabled,
    onPressStart(e6) {
      e6.continuePropagation();
      if (e6.pointerType === "mouse" || e6.pointerType === "touch") {
        if (onLongPressStart)
          onLongPressStart({
            ...e6,
            type: "longpressstart"
          });
        timeRef.current = setTimeout(() => {
          e6.target.dispatchEvent(new PointerEvent("pointercancel", {
            bubbles: true
          }));
          if (onLongPress)
            onLongPress({
              ...e6,
              type: "longpress"
            });
          timeRef.current = void 0;
        }, threshold);
        if (e6.pointerType === "touch") {
          let onContextMenu = (e7) => {
            e7.preventDefault();
          };
          addGlobalListener(e6.target, "contextmenu", onContextMenu, {
            once: true
          });
          addGlobalListener(window, "pointerup", () => {
            setTimeout(() => {
              removeGlobalListener(e6.target, "contextmenu", onContextMenu);
            }, 30);
          }, {
            once: true
          });
        }
      }
    },
    onPressEnd(e6) {
      if (timeRef.current)
        clearTimeout(timeRef.current);
      if (onLongPressEnd && (e6.pointerType === "mouse" || e6.pointerType === "touch"))
        onLongPressEnd({
          ...e6,
          type: "longpressend"
        });
    }
  });
  let descriptionProps = (0, $ef06256079686ba0$export$f8aeda7b10753fa1)(onLongPress && !isDisabled ? accessibilityDescription : void 0);
  return {
    longPressProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(pressProps, descriptionProps)
  };
}

// node_modules/@react-aria/focus/dist/import.mjs
function $6a99195332edec8b$export$80f3e147d781571c(element4) {
  const ownerDocument = (0, $431fbd86ca7dc216$export$b204af158042fbac)(element4);
  if ((0, $507fabe10e71c6fb$export$630ff653c5ada6a9)() === "virtual") {
    let lastFocusedElement = ownerDocument.activeElement;
    (0, $bbed8b41f857bcc0$export$24490316f764c430)(() => {
      if (ownerDocument.activeElement === lastFocusedElement && element4.isConnected)
        (0, $7215afc6de606d6b$export$de79e2c695e052f3)(element4);
    });
  } else
    (0, $7215afc6de606d6b$export$de79e2c695e052f3)(element4);
}
function $645f2e67b85a24c9$var$isStyleVisible(element4) {
  const windowObject = (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(element4);
  if (!(element4 instanceof windowObject.HTMLElement) && !(element4 instanceof windowObject.SVGElement))
    return false;
  let { display, visibility } = element4.style;
  let isVisible2 = display !== "none" && visibility !== "hidden" && visibility !== "collapse";
  if (isVisible2) {
    const { getComputedStyle: getComputedStyle2 } = element4.ownerDocument.defaultView;
    let { display: computedDisplay, visibility: computedVisibility } = getComputedStyle2(element4);
    isVisible2 = computedDisplay !== "none" && computedVisibility !== "hidden" && computedVisibility !== "collapse";
  }
  return isVisible2;
}
function $645f2e67b85a24c9$var$isAttributeVisible(element4, childElement) {
  return !element4.hasAttribute("hidden") && (element4.nodeName === "DETAILS" && childElement && childElement.nodeName !== "SUMMARY" ? element4.hasAttribute("open") : true);
}
function $645f2e67b85a24c9$export$e989c0fffaa6b27a(element4, childElement) {
  return element4.nodeName !== "#comment" && $645f2e67b85a24c9$var$isStyleVisible(element4) && $645f2e67b85a24c9$var$isAttributeVisible(element4, childElement) && (!element4.parentElement || $645f2e67b85a24c9$export$e989c0fffaa6b27a(element4.parentElement, element4));
}
var $9bf71ea28793e738$var$FocusContext = (0, import_react5.default).createContext(null);
var $9bf71ea28793e738$var$activeScope = null;
function $9bf71ea28793e738$export$20e40289641fbbb6(props) {
  let { children, contain, restoreFocus, autoFocus } = props;
  let startRef = (0, import_react5.useRef)(null);
  let endRef = (0, import_react5.useRef)(null);
  let scopeRef = (0, import_react5.useRef)([]);
  let { parentNode } = (0, import_react5.useContext)($9bf71ea28793e738$var$FocusContext) || {};
  let node4 = (0, import_react5.useMemo)(() => new $9bf71ea28793e738$var$TreeNode({
    scopeRef
  }), [
    scopeRef
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    let parent = parentNode || $9bf71ea28793e738$export$d06fae2ee68b101e.root;
    if ($9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(parent.scopeRef) && $9bf71ea28793e738$var$activeScope && !$9bf71ea28793e738$var$isAncestorScope($9bf71ea28793e738$var$activeScope, parent.scopeRef)) {
      let activeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode($9bf71ea28793e738$var$activeScope);
      if (activeNode)
        parent = activeNode;
    }
    parent.addChild(node4);
    $9bf71ea28793e738$export$d06fae2ee68b101e.addNode(node4);
  }, [
    node4,
    parentNode
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    let node5 = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);
    if (node5)
      node5.contain = !!contain;
  }, [
    contain
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    var _startRef_current;
    let node5 = (_startRef_current = startRef.current) === null || _startRef_current === void 0 ? void 0 : _startRef_current.nextSibling;
    let nodes = [];
    while (node5 && node5 !== endRef.current) {
      nodes.push(node5);
      node5 = node5.nextSibling;
    }
    scopeRef.current = nodes;
  }, [
    children
  ]);
  $9bf71ea28793e738$var$useActiveScopeTracker(scopeRef, restoreFocus, contain);
  $9bf71ea28793e738$var$useFocusContainment(scopeRef, contain);
  $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain);
  $9bf71ea28793e738$var$useAutoFocus(scopeRef, autoFocus);
  (0, import_react5.useEffect)(() => {
    const activeElement = (0, $431fbd86ca7dc216$export$b204af158042fbac)(scopeRef.current ? scopeRef.current[0] : void 0).activeElement;
    let scope = null;
    if ($9bf71ea28793e738$var$isElementInScope(activeElement, scopeRef.current)) {
      for (let node5 of $9bf71ea28793e738$export$d06fae2ee68b101e.traverse())
        if (node5.scopeRef && $9bf71ea28793e738$var$isElementInScope(activeElement, node5.scopeRef.current))
          scope = node5;
      if (scope === $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef))
        $9bf71ea28793e738$var$activeScope = scope.scopeRef;
    }
  }, [
    scopeRef
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    return () => {
      var _focusScopeTree_getTreeNode_parent, _focusScopeTree_getTreeNode;
      var _focusScopeTree_getTreeNode_parent_scopeRef;
      let parentScope = (_focusScopeTree_getTreeNode_parent_scopeRef = (_focusScopeTree_getTreeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef)) === null || _focusScopeTree_getTreeNode === void 0 ? void 0 : (_focusScopeTree_getTreeNode_parent = _focusScopeTree_getTreeNode.parent) === null || _focusScopeTree_getTreeNode_parent === void 0 ? void 0 : _focusScopeTree_getTreeNode_parent.scopeRef) !== null && _focusScopeTree_getTreeNode_parent_scopeRef !== void 0 ? _focusScopeTree_getTreeNode_parent_scopeRef : null;
      if ((scopeRef === $9bf71ea28793e738$var$activeScope || $9bf71ea28793e738$var$isAncestorScope(scopeRef, $9bf71ea28793e738$var$activeScope)) && (!parentScope || $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(parentScope)))
        $9bf71ea28793e738$var$activeScope = parentScope;
      $9bf71ea28793e738$export$d06fae2ee68b101e.removeTreeNode(scopeRef);
    };
  }, [
    scopeRef
  ]);
  let focusManager = (0, import_react5.useMemo)(() => $9bf71ea28793e738$var$createFocusManagerForScope(scopeRef), []);
  let value2 = (0, import_react5.useMemo)(() => ({
    focusManager,
    parentNode: node4
  }), [
    node4,
    focusManager
  ]);
  return (0, import_react5.default).createElement($9bf71ea28793e738$var$FocusContext.Provider, {
    value: value2
  }, (0, import_react5.default).createElement("span", {
    "data-focus-scope-start": true,
    hidden: true,
    ref: startRef
  }), children, (0, import_react5.default).createElement("span", {
    "data-focus-scope-end": true,
    hidden: true,
    ref: endRef
  }));
}
function $9bf71ea28793e738$var$createFocusManagerForScope(scopeRef) {
  return {
    focusNext(opts = {}) {
      let scope = scopeRef.current;
      let { from: from4, tabbable, wrap: wrap3, accept } = opts;
      let node4 = from4 || (0, $431fbd86ca7dc216$export$b204af158042fbac)(scope[0]).activeElement;
      let sentinel = scope[0].previousElementSibling;
      let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {
        tabbable,
        accept
      }, scope);
      walker.currentNode = $9bf71ea28793e738$var$isElementInScope(node4, scope) ? node4 : sentinel;
      let nextNode = walker.nextNode();
      if (!nextNode && wrap3) {
        walker.currentNode = sentinel;
        nextNode = walker.nextNode();
      }
      if (nextNode)
        $9bf71ea28793e738$var$focusElement(nextNode, true);
      return nextNode;
    },
    focusPrevious(opts = {}) {
      let scope = scopeRef.current;
      let { from: from4, tabbable, wrap: wrap3, accept } = opts;
      let node4 = from4 || (0, $431fbd86ca7dc216$export$b204af158042fbac)(scope[0]).activeElement;
      let sentinel = scope[scope.length - 1].nextElementSibling;
      let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {
        tabbable,
        accept
      }, scope);
      walker.currentNode = $9bf71ea28793e738$var$isElementInScope(node4, scope) ? node4 : sentinel;
      let previousNode = walker.previousNode();
      if (!previousNode && wrap3) {
        walker.currentNode = sentinel;
        previousNode = walker.previousNode();
      }
      if (previousNode)
        $9bf71ea28793e738$var$focusElement(previousNode, true);
      return previousNode;
    },
    focusFirst(opts = {}) {
      let scope = scopeRef.current;
      let { tabbable, accept } = opts;
      let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {
        tabbable,
        accept
      }, scope);
      walker.currentNode = scope[0].previousElementSibling;
      let nextNode = walker.nextNode();
      if (nextNode)
        $9bf71ea28793e738$var$focusElement(nextNode, true);
      return nextNode;
    },
    focusLast(opts = {}) {
      let scope = scopeRef.current;
      let { tabbable, accept } = opts;
      let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {
        tabbable,
        accept
      }, scope);
      walker.currentNode = scope[scope.length - 1].nextElementSibling;
      let previousNode = walker.previousNode();
      if (previousNode)
        $9bf71ea28793e738$var$focusElement(previousNode, true);
      return previousNode;
    }
  };
}
var $9bf71ea28793e738$var$focusableElements = [
  "input:not([disabled]):not([type=hidden])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  "button:not([disabled])",
  "a[href]",
  "area[href]",
  "summary",
  "iframe",
  "object",
  "embed",
  "audio[controls]",
  "video[controls]",
  "[contenteditable]"
];
var $9bf71ea28793e738$var$FOCUSABLE_ELEMENT_SELECTOR = $9bf71ea28793e738$var$focusableElements.join(":not([hidden]),") + ",[tabindex]:not([disabled]):not([hidden])";
$9bf71ea28793e738$var$focusableElements.push('[tabindex]:not([tabindex="-1"]):not([disabled])');
var $9bf71ea28793e738$var$TABBABLE_ELEMENT_SELECTOR = $9bf71ea28793e738$var$focusableElements.join(':not([hidden]):not([tabindex="-1"]),');
function $9bf71ea28793e738$var$getScopeRoot(scope) {
  return scope[0].parentElement;
}
function $9bf71ea28793e738$var$shouldContainFocus(scopeRef) {
  let scope = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode($9bf71ea28793e738$var$activeScope);
  while (scope && scope.scopeRef !== scopeRef) {
    if (scope.contain)
      return false;
    scope = scope.parent;
  }
  return true;
}
function $9bf71ea28793e738$var$useFocusContainment(scopeRef, contain) {
  let focusedNode = (0, import_react5.useRef)();
  let raf = (0, import_react5.useRef)();
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    let scope = scopeRef.current;
    if (!contain) {
      if (raf.current) {
        cancelAnimationFrame(raf.current);
        raf.current = void 0;
      }
      return;
    }
    const ownerDocument = (0, $431fbd86ca7dc216$export$b204af158042fbac)(scope ? scope[0] : void 0);
    let onKeyDown = (e6) => {
      if (e6.key !== "Tab" || e6.altKey || e6.ctrlKey || e6.metaKey || !$9bf71ea28793e738$var$shouldContainFocus(scopeRef))
        return;
      let focusedElement = ownerDocument.activeElement;
      let scope2 = scopeRef.current;
      if (!scope2 || !$9bf71ea28793e738$var$isElementInScope(focusedElement, scope2))
        return;
      let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope2);
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {
        tabbable: true
      }, scope2);
      if (!focusedElement)
        return;
      walker.currentNode = focusedElement;
      let nextElement = e6.shiftKey ? walker.previousNode() : walker.nextNode();
      if (!nextElement) {
        walker.currentNode = e6.shiftKey ? scope2[scope2.length - 1].nextElementSibling : scope2[0].previousElementSibling;
        nextElement = e6.shiftKey ? walker.previousNode() : walker.nextNode();
      }
      e6.preventDefault();
      if (nextElement)
        $9bf71ea28793e738$var$focusElement(nextElement, true);
    };
    let onFocus = (e6) => {
      if ((!$9bf71ea28793e738$var$activeScope || $9bf71ea28793e738$var$isAncestorScope($9bf71ea28793e738$var$activeScope, scopeRef)) && $9bf71ea28793e738$var$isElementInScope(e6.target, scopeRef.current)) {
        $9bf71ea28793e738$var$activeScope = scopeRef;
        focusedNode.current = e6.target;
      } else if ($9bf71ea28793e738$var$shouldContainFocus(scopeRef) && !$9bf71ea28793e738$var$isElementInChildScope(e6.target, scopeRef)) {
        if (focusedNode.current)
          focusedNode.current.focus();
        else if ($9bf71ea28793e738$var$activeScope && $9bf71ea28793e738$var$activeScope.current)
          $9bf71ea28793e738$var$focusFirstInScope($9bf71ea28793e738$var$activeScope.current);
      } else if ($9bf71ea28793e738$var$shouldContainFocus(scopeRef))
        focusedNode.current = e6.target;
    };
    let onBlur = (e6) => {
      if (raf.current)
        cancelAnimationFrame(raf.current);
      raf.current = requestAnimationFrame(() => {
        if (ownerDocument.activeElement && $9bf71ea28793e738$var$shouldContainFocus(scopeRef) && !$9bf71ea28793e738$var$isElementInChildScope(ownerDocument.activeElement, scopeRef)) {
          $9bf71ea28793e738$var$activeScope = scopeRef;
          if (ownerDocument.body.contains(e6.target)) {
            var _focusedNode_current;
            focusedNode.current = e6.target;
            (_focusedNode_current = focusedNode.current) === null || _focusedNode_current === void 0 ? void 0 : _focusedNode_current.focus();
          } else if ($9bf71ea28793e738$var$activeScope.current)
            $9bf71ea28793e738$var$focusFirstInScope($9bf71ea28793e738$var$activeScope.current);
        }
      });
    };
    ownerDocument.addEventListener("keydown", onKeyDown, false);
    ownerDocument.addEventListener("focusin", onFocus, false);
    scope === null || scope === void 0 ? void 0 : scope.forEach((element4) => element4.addEventListener("focusin", onFocus, false));
    scope === null || scope === void 0 ? void 0 : scope.forEach((element4) => element4.addEventListener("focusout", onBlur, false));
    return () => {
      ownerDocument.removeEventListener("keydown", onKeyDown, false);
      ownerDocument.removeEventListener("focusin", onFocus, false);
      scope === null || scope === void 0 ? void 0 : scope.forEach((element4) => element4.removeEventListener("focusin", onFocus, false));
      scope === null || scope === void 0 ? void 0 : scope.forEach((element4) => element4.removeEventListener("focusout", onBlur, false));
    };
  }, [
    scopeRef,
    contain
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    return () => {
      if (raf.current)
        cancelAnimationFrame(raf.current);
    };
  }, [
    raf
  ]);
}
function $9bf71ea28793e738$var$isElementInAnyScope(element4) {
  return $9bf71ea28793e738$var$isElementInChildScope(element4);
}
function $9bf71ea28793e738$var$isElementInScope(element4, scope) {
  if (!element4)
    return false;
  if (!scope)
    return false;
  return scope.some((node4) => node4.contains(element4));
}
function $9bf71ea28793e738$var$isElementInChildScope(element4, scope = null) {
  if (element4 instanceof Element && element4.closest("[data-react-aria-top-layer]"))
    return true;
  for (let { scopeRef: s4 } of $9bf71ea28793e738$export$d06fae2ee68b101e.traverse($9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scope))) {
    if (s4 && $9bf71ea28793e738$var$isElementInScope(element4, s4.current))
      return true;
  }
  return false;
}
function $9bf71ea28793e738$export$1258395f99bf9cbf(element4) {
  return $9bf71ea28793e738$var$isElementInChildScope(element4, $9bf71ea28793e738$var$activeScope);
}
function $9bf71ea28793e738$var$isAncestorScope(ancestor, scope) {
  var _focusScopeTree_getTreeNode;
  let parent = (_focusScopeTree_getTreeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scope)) === null || _focusScopeTree_getTreeNode === void 0 ? void 0 : _focusScopeTree_getTreeNode.parent;
  while (parent) {
    if (parent.scopeRef === ancestor)
      return true;
    parent = parent.parent;
  }
  return false;
}
function $9bf71ea28793e738$var$focusElement(element4, scroll = false) {
  if (element4 != null && !scroll)
    try {
      (0, $6a99195332edec8b$export$80f3e147d781571c)(element4);
    } catch (err) {
    }
  else if (element4 != null)
    try {
      element4.focus();
    } catch (err) {
    }
}
function $9bf71ea28793e738$var$focusFirstInScope(scope, tabbable = true) {
  let sentinel = scope[0].previousElementSibling;
  let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);
  let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {
    tabbable
  }, scope);
  walker.currentNode = sentinel;
  let nextNode = walker.nextNode();
  if (tabbable && !nextNode) {
    scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);
    walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {
      tabbable: false
    }, scope);
    walker.currentNode = sentinel;
    nextNode = walker.nextNode();
  }
  $9bf71ea28793e738$var$focusElement(nextNode);
}
function $9bf71ea28793e738$var$useAutoFocus(scopeRef, autoFocus) {
  const autoFocusRef = (0, import_react5.default).useRef(autoFocus);
  (0, import_react5.useEffect)(() => {
    if (autoFocusRef.current) {
      $9bf71ea28793e738$var$activeScope = scopeRef;
      const ownerDocument = (0, $431fbd86ca7dc216$export$b204af158042fbac)(scopeRef.current ? scopeRef.current[0] : void 0);
      if (!$9bf71ea28793e738$var$isElementInScope(ownerDocument.activeElement, $9bf71ea28793e738$var$activeScope.current) && scopeRef.current)
        $9bf71ea28793e738$var$focusFirstInScope(scopeRef.current);
    }
    autoFocusRef.current = false;
  }, [
    scopeRef
  ]);
}
function $9bf71ea28793e738$var$useActiveScopeTracker(scopeRef, restore, contain) {
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (restore || contain)
      return;
    let scope = scopeRef.current;
    const ownerDocument = (0, $431fbd86ca7dc216$export$b204af158042fbac)(scope ? scope[0] : void 0);
    let onFocus = (e6) => {
      let target = e6.target;
      if ($9bf71ea28793e738$var$isElementInScope(target, scopeRef.current))
        $9bf71ea28793e738$var$activeScope = scopeRef;
      else if (!$9bf71ea28793e738$var$isElementInAnyScope(target))
        $9bf71ea28793e738$var$activeScope = null;
    };
    ownerDocument.addEventListener("focusin", onFocus, false);
    scope === null || scope === void 0 ? void 0 : scope.forEach((element4) => element4.addEventListener("focusin", onFocus, false));
    return () => {
      ownerDocument.removeEventListener("focusin", onFocus, false);
      scope === null || scope === void 0 ? void 0 : scope.forEach((element4) => element4.removeEventListener("focusin", onFocus, false));
    };
  }, [
    scopeRef,
    restore,
    contain
  ]);
}
function $9bf71ea28793e738$var$shouldRestoreFocus(scopeRef) {
  let scope = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode($9bf71ea28793e738$var$activeScope);
  while (scope && scope.scopeRef !== scopeRef) {
    if (scope.nodeToRestore)
      return false;
    scope = scope.parent;
  }
  return (scope === null || scope === void 0 ? void 0 : scope.scopeRef) === scopeRef;
}
function $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain) {
  const nodeToRestoreRef = (0, import_react5.useRef)(typeof document !== "undefined" ? (0, $431fbd86ca7dc216$export$b204af158042fbac)(scopeRef.current ? scopeRef.current[0] : void 0).activeElement : null);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    let scope = scopeRef.current;
    const ownerDocument = (0, $431fbd86ca7dc216$export$b204af158042fbac)(scope ? scope[0] : void 0);
    if (!restoreFocus || contain)
      return;
    let onFocus = () => {
      if ((!$9bf71ea28793e738$var$activeScope || $9bf71ea28793e738$var$isAncestorScope($9bf71ea28793e738$var$activeScope, scopeRef)) && $9bf71ea28793e738$var$isElementInScope(ownerDocument.activeElement, scopeRef.current))
        $9bf71ea28793e738$var$activeScope = scopeRef;
    };
    ownerDocument.addEventListener("focusin", onFocus, false);
    scope === null || scope === void 0 ? void 0 : scope.forEach((element4) => element4.addEventListener("focusin", onFocus, false));
    return () => {
      ownerDocument.removeEventListener("focusin", onFocus, false);
      scope === null || scope === void 0 ? void 0 : scope.forEach((element4) => element4.removeEventListener("focusin", onFocus, false));
    };
  }, [
    scopeRef,
    contain
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    const ownerDocument = (0, $431fbd86ca7dc216$export$b204af158042fbac)(scopeRef.current ? scopeRef.current[0] : void 0);
    if (!restoreFocus)
      return;
    let onKeyDown = (e6) => {
      if (e6.key !== "Tab" || e6.altKey || e6.ctrlKey || e6.metaKey || !$9bf71ea28793e738$var$shouldContainFocus(scopeRef))
        return;
      let focusedElement = ownerDocument.activeElement;
      if (!$9bf71ea28793e738$var$isElementInScope(focusedElement, scopeRef.current))
        return;
      let treeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);
      if (!treeNode)
        return;
      let nodeToRestore = treeNode.nodeToRestore;
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(ownerDocument.body, {
        tabbable: true
      });
      walker.currentNode = focusedElement;
      let nextElement = e6.shiftKey ? walker.previousNode() : walker.nextNode();
      if (!nodeToRestore || !ownerDocument.body.contains(nodeToRestore) || nodeToRestore === ownerDocument.body) {
        nodeToRestore = void 0;
        treeNode.nodeToRestore = void 0;
      }
      if ((!nextElement || !$9bf71ea28793e738$var$isElementInScope(nextElement, scopeRef.current)) && nodeToRestore) {
        walker.currentNode = nodeToRestore;
        do
          nextElement = e6.shiftKey ? walker.previousNode() : walker.nextNode();
        while ($9bf71ea28793e738$var$isElementInScope(nextElement, scopeRef.current));
        e6.preventDefault();
        e6.stopPropagation();
        if (nextElement)
          $9bf71ea28793e738$var$focusElement(nextElement, true);
        else if (!$9bf71ea28793e738$var$isElementInAnyScope(nodeToRestore))
          focusedElement.blur();
        else
          $9bf71ea28793e738$var$focusElement(nodeToRestore, true);
      }
    };
    if (!contain)
      ownerDocument.addEventListener("keydown", onKeyDown, true);
    return () => {
      if (!contain)
        ownerDocument.removeEventListener("keydown", onKeyDown, true);
    };
  }, [
    scopeRef,
    restoreFocus,
    contain
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    const ownerDocument = (0, $431fbd86ca7dc216$export$b204af158042fbac)(scopeRef.current ? scopeRef.current[0] : void 0);
    if (!restoreFocus)
      return;
    let treeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);
    if (!treeNode)
      return;
    var _nodeToRestoreRef_current;
    treeNode.nodeToRestore = (_nodeToRestoreRef_current = nodeToRestoreRef.current) !== null && _nodeToRestoreRef_current !== void 0 ? _nodeToRestoreRef_current : void 0;
    return () => {
      let treeNode2 = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);
      if (!treeNode2)
        return;
      let nodeToRestore = treeNode2.nodeToRestore;
      if (restoreFocus && nodeToRestore && // eslint-disable-next-line react-hooks/exhaustive-deps
      ($9bf71ea28793e738$var$isElementInScope(ownerDocument.activeElement, scopeRef.current) || ownerDocument.activeElement === ownerDocument.body && $9bf71ea28793e738$var$shouldRestoreFocus(scopeRef))) {
        let clonedTree = $9bf71ea28793e738$export$d06fae2ee68b101e.clone();
        requestAnimationFrame(() => {
          if (ownerDocument.activeElement === ownerDocument.body) {
            let treeNode3 = clonedTree.getTreeNode(scopeRef);
            while (treeNode3) {
              if (treeNode3.nodeToRestore && treeNode3.nodeToRestore.isConnected) {
                $9bf71ea28793e738$var$focusElement(treeNode3.nodeToRestore);
                return;
              }
              treeNode3 = treeNode3.parent;
            }
            treeNode3 = clonedTree.getTreeNode(scopeRef);
            while (treeNode3) {
              if (treeNode3.scopeRef && treeNode3.scopeRef.current && $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(treeNode3.scopeRef)) {
                $9bf71ea28793e738$var$focusFirstInScope(treeNode3.scopeRef.current, true);
                return;
              }
              treeNode3 = treeNode3.parent;
            }
          }
        });
      }
    };
  }, [
    scopeRef,
    restoreFocus
  ]);
}
function $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, opts, scope) {
  let selector = (opts === null || opts === void 0 ? void 0 : opts.tabbable) ? $9bf71ea28793e738$var$TABBABLE_ELEMENT_SELECTOR : $9bf71ea28793e738$var$FOCUSABLE_ELEMENT_SELECTOR;
  let walker = (0, $431fbd86ca7dc216$export$b204af158042fbac)(root).createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
    acceptNode(node4) {
      var _opts_from;
      if (opts === null || opts === void 0 ? void 0 : (_opts_from = opts.from) === null || _opts_from === void 0 ? void 0 : _opts_from.contains(node4))
        return NodeFilter.FILTER_REJECT;
      if (node4.matches(selector) && (0, $645f2e67b85a24c9$export$e989c0fffaa6b27a)(node4) && (!scope || $9bf71ea28793e738$var$isElementInScope(node4, scope)) && (!(opts === null || opts === void 0 ? void 0 : opts.accept) || opts.accept(node4)))
        return NodeFilter.FILTER_ACCEPT;
      return NodeFilter.FILTER_SKIP;
    }
  });
  if (opts === null || opts === void 0 ? void 0 : opts.from)
    walker.currentNode = opts.from;
  return walker;
}
function $9bf71ea28793e738$export$c5251b9e124bf29(ref, defaultOptions = {}) {
  return {
    focusNext(opts = {}) {
      let root = ref.current;
      if (!root)
        return null;
      let { from: from4, tabbable = defaultOptions.tabbable, wrap: wrap3 = defaultOptions.wrap, accept = defaultOptions.accept } = opts;
      let node4 = from4 || (0, $431fbd86ca7dc216$export$b204af158042fbac)(root).activeElement;
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {
        tabbable,
        accept
      });
      if (root.contains(node4))
        walker.currentNode = node4;
      let nextNode = walker.nextNode();
      if (!nextNode && wrap3) {
        walker.currentNode = root;
        nextNode = walker.nextNode();
      }
      if (nextNode)
        $9bf71ea28793e738$var$focusElement(nextNode, true);
      return nextNode;
    },
    focusPrevious(opts = defaultOptions) {
      let root = ref.current;
      if (!root)
        return null;
      let { from: from4, tabbable = defaultOptions.tabbable, wrap: wrap3 = defaultOptions.wrap, accept = defaultOptions.accept } = opts;
      let node4 = from4 || (0, $431fbd86ca7dc216$export$b204af158042fbac)(root).activeElement;
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {
        tabbable,
        accept
      });
      if (root.contains(node4))
        walker.currentNode = node4;
      else {
        let next2 = $9bf71ea28793e738$var$last(walker);
        if (next2)
          $9bf71ea28793e738$var$focusElement(next2, true);
        return next2 !== null && next2 !== void 0 ? next2 : null;
      }
      let previousNode = walker.previousNode();
      if (!previousNode && wrap3) {
        walker.currentNode = root;
        let lastNode = $9bf71ea28793e738$var$last(walker);
        if (!lastNode)
          return null;
        previousNode = lastNode;
      }
      if (previousNode)
        $9bf71ea28793e738$var$focusElement(previousNode, true);
      return previousNode !== null && previousNode !== void 0 ? previousNode : null;
    },
    focusFirst(opts = defaultOptions) {
      let root = ref.current;
      if (!root)
        return null;
      let { tabbable = defaultOptions.tabbable, accept = defaultOptions.accept } = opts;
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {
        tabbable,
        accept
      });
      let nextNode = walker.nextNode();
      if (nextNode)
        $9bf71ea28793e738$var$focusElement(nextNode, true);
      return nextNode;
    },
    focusLast(opts = defaultOptions) {
      let root = ref.current;
      if (!root)
        return null;
      let { tabbable = defaultOptions.tabbable, accept = defaultOptions.accept } = opts;
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {
        tabbable,
        accept
      });
      let next2 = $9bf71ea28793e738$var$last(walker);
      if (next2)
        $9bf71ea28793e738$var$focusElement(next2, true);
      return next2 !== null && next2 !== void 0 ? next2 : null;
    }
  };
}
function $9bf71ea28793e738$var$last(walker) {
  let next2 = void 0;
  let last2;
  do {
    last2 = walker.lastChild();
    if (last2)
      next2 = last2;
  } while (last2);
  return next2;
}
var $9bf71ea28793e738$var$Tree = class _$9bf71ea28793e738$var$Tree {
  get size() {
    return this.fastMap.size;
  }
  getTreeNode(data) {
    return this.fastMap.get(data);
  }
  addTreeNode(scopeRef, parent, nodeToRestore) {
    let parentNode = this.fastMap.get(parent !== null && parent !== void 0 ? parent : null);
    if (!parentNode)
      return;
    let node4 = new $9bf71ea28793e738$var$TreeNode({
      scopeRef
    });
    parentNode.addChild(node4);
    node4.parent = parentNode;
    this.fastMap.set(scopeRef, node4);
    if (nodeToRestore)
      node4.nodeToRestore = nodeToRestore;
  }
  addNode(node4) {
    this.fastMap.set(node4.scopeRef, node4);
  }
  removeTreeNode(scopeRef) {
    if (scopeRef === null)
      return;
    let node4 = this.fastMap.get(scopeRef);
    if (!node4)
      return;
    let parentNode = node4.parent;
    for (let current of this.traverse())
      if (current !== node4 && node4.nodeToRestore && current.nodeToRestore && node4.scopeRef && node4.scopeRef.current && $9bf71ea28793e738$var$isElementInScope(current.nodeToRestore, node4.scopeRef.current))
        current.nodeToRestore = node4.nodeToRestore;
    let children = node4.children;
    if (parentNode) {
      parentNode.removeChild(node4);
      if (children.size > 0)
        children.forEach((child) => parentNode && parentNode.addChild(child));
    }
    this.fastMap.delete(node4.scopeRef);
  }
  // Pre Order Depth First
  *traverse(node4 = this.root) {
    if (node4.scopeRef != null)
      yield node4;
    if (node4.children.size > 0)
      for (let child of node4.children)
        yield* this.traverse(child);
  }
  clone() {
    var _node_parent;
    let newTree = new _$9bf71ea28793e738$var$Tree();
    var _node_parent_scopeRef;
    for (let node4 of this.traverse())
      newTree.addTreeNode(node4.scopeRef, (_node_parent_scopeRef = (_node_parent = node4.parent) === null || _node_parent === void 0 ? void 0 : _node_parent.scopeRef) !== null && _node_parent_scopeRef !== void 0 ? _node_parent_scopeRef : null, node4.nodeToRestore);
    return newTree;
  }
  constructor() {
    this.fastMap = /* @__PURE__ */ new Map();
    this.root = new $9bf71ea28793e738$var$TreeNode({
      scopeRef: null
    });
    this.fastMap.set(null, this.root);
  }
};
var $9bf71ea28793e738$var$TreeNode = class {
  addChild(node4) {
    this.children.add(node4);
    node4.parent = this;
  }
  removeChild(node4) {
    this.children.delete(node4);
    node4.parent = void 0;
  }
  constructor(props) {
    this.children = /* @__PURE__ */ new Set();
    this.contain = false;
    this.scopeRef = props.scopeRef;
  }
};
var $9bf71ea28793e738$export$d06fae2ee68b101e = new $9bf71ea28793e738$var$Tree();
function $f7dceffc5ad7768b$export$4e328f61c538687f(props = {}) {
  let { autoFocus = false, isTextInput, within } = props;
  let state = (0, import_react5.useRef)({
    isFocused: false,
    isFocusVisible: autoFocus || (0, $507fabe10e71c6fb$export$b9b3dfddab17db27)()
  });
  let [isFocused, setFocused] = (0, import_react5.useState)(false);
  let [isFocusVisibleState, setFocusVisible] = (0, import_react5.useState)(() => state.current.isFocused && state.current.isFocusVisible);
  let updateState = (0, import_react5.useCallback)(() => setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []);
  let onFocusChange = (0, import_react5.useCallback)((isFocused2) => {
    state.current.isFocused = isFocused2;
    setFocused(isFocused2);
    updateState();
  }, [
    updateState
  ]);
  (0, $507fabe10e71c6fb$export$ec71b4b83ac08ec3)((isFocusVisible) => {
    state.current.isFocusVisible = isFocusVisible;
    updateState();
  }, [], {
    isTextInput
  });
  let { focusProps } = (0, $a1ea59d68270f0dd$export$f8168d8dd8fd66e6)({
    isDisabled: within,
    onFocusChange
  });
  let { focusWithinProps } = (0, $9ab94262bd0047c7$export$420e68273165f4ec)({
    isDisabled: !within,
    onFocusWithinChange: onFocusChange
  });
  return {
    isFocused,
    isFocusVisible: isFocusVisibleState,
    focusProps: within ? focusWithinProps : focusProps
  };
}
var $e6afbd83fe6ebbd2$var$FocusableContext = (0, import_react5.default).createContext(null);
function $e6afbd83fe6ebbd2$var$useFocusableContext(ref) {
  let context = (0, import_react5.useContext)($e6afbd83fe6ebbd2$var$FocusableContext) || {};
  (0, $e7801be82b4b2a53$export$4debdb1a3f0fa79e)(context, ref);
  let { ref: _2, ...otherProps } = context;
  return otherProps;
}
function $e6afbd83fe6ebbd2$var$FocusableProvider(props, ref) {
  let { children, ...otherProps } = props;
  let objRef = (0, $df56164dff5785e2$export$4338b53315abf666)(ref);
  let context = {
    ...otherProps,
    ref: objRef
  };
  return (0, import_react5.default).createElement($e6afbd83fe6ebbd2$var$FocusableContext.Provider, {
    value: context
  }, children);
}
var $e6afbd83fe6ebbd2$export$13f3202a3e5ddd5 = (0, import_react5.default).forwardRef($e6afbd83fe6ebbd2$var$FocusableProvider);
function $e6afbd83fe6ebbd2$export$4c014de7c8940b4c(props, domRef) {
  let { focusProps } = (0, $a1ea59d68270f0dd$export$f8168d8dd8fd66e6)(props);
  let { keyboardProps } = (0, $46d819fcbaf35654$export$8f71654801c2f7cd)(props);
  let interactions = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(focusProps, keyboardProps);
  let domProps = $e6afbd83fe6ebbd2$var$useFocusableContext(domRef);
  let interactionProps = props.isDisabled ? {} : domProps;
  let autoFocusRef = (0, import_react5.useRef)(props.autoFocus);
  (0, import_react5.useEffect)(() => {
    if (autoFocusRef.current && domRef.current)
      (0, $6a99195332edec8b$export$80f3e147d781571c)(domRef.current);
    autoFocusRef.current = false;
  }, [
    domRef
  ]);
  return {
    focusableProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)({
      ...interactions,
      tabIndex: props.excludeFromTabOrder && !props.isDisabled ? -1 : void 0
    }, interactionProps)
  };
}
function $83013635b024ae3d$export$eac1895992b9f3d6(ref, options) {
  let isDisabled = options === null || options === void 0 ? void 0 : options.isDisabled;
  let [hasTabbableChild, setHasTabbableChild] = (0, import_react5.useState)(false);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if ((ref === null || ref === void 0 ? void 0 : ref.current) && !isDisabled) {
      let update = () => {
        if (ref.current) {
          let walker = (0, $9bf71ea28793e738$export$2d6ec8fc375ceafa)(ref.current, {
            tabbable: true
          });
          setHasTabbableChild(!!walker.nextNode());
        }
      };
      update();
      let observer = new MutationObserver(update);
      observer.observe(ref.current, {
        subtree: true,
        childList: true,
        attributes: true,
        attributeFilter: [
          "tabIndex",
          "disabled"
        ]
      });
      return () => {
        observer.disconnect();
      };
    }
  });
  return isDisabled ? false : hasTabbableChild;
}

// node_modules/@keystar/ui/dist/keystar-ui-style.js
var tokenSchema = {
  animation: {
    duration: {
      short: "var(--kui-animation-duration-short)",
      regular: "var(--kui-animation-duration-regular)",
      long: "var(--kui-animation-duration-long)",
      xlong: "var(--kui-animation-duration-xlong)"
    },
    easing: {
      easeInOut: "var(--kui-animation-easing-ease-in-out)",
      easeIn: "var(--kui-animation-easing-ease-in)",
      easeOut: "var(--kui-animation-easing-ease-out)"
    }
  },
  size: {
    alias: {
      focusRing: "var(--kui-size-alias-focus-ring)",
      focusRingGap: "var(--kui-size-alias-focus-ring-gap)",
      singleLineHeight: "var(--kui-size-alias-single-line-height)",
      singleLineWidth: "var(--kui-size-alias-single-line-width)"
    },
    element: {
      xsmall: "var(--kui-size-element-xsmall)",
      small: "var(--kui-size-element-small)",
      regular: "var(--kui-size-element-regular)",
      medium: "var(--kui-size-element-medium)",
      large: "var(--kui-size-element-large)",
      xlarge: "var(--kui-size-element-xlarge)"
    },
    icon: {
      small: "var(--kui-size-icon-small)",
      regular: "var(--kui-size-icon-regular)",
      medium: "var(--kui-size-icon-medium)",
      large: "var(--kui-size-icon-large)"
    },
    container: {
      xsmall: "var(--kui-size-container-xsmall)",
      small: "var(--kui-size-container-small)",
      medium: "var(--kui-size-container-medium)",
      large: "var(--kui-size-container-large)",
      xlarge: "var(--kui-size-container-xlarge)"
    },
    dialog: {
      xsmall: "var(--kui-size-dialog-xsmall)",
      small: "var(--kui-size-dialog-small)",
      medium: "var(--kui-size-dialog-medium)",
      large: "var(--kui-size-dialog-large)"
    },
    border: {
      regular: "var(--kui-size-border-regular)",
      medium: "var(--kui-size-border-medium)",
      large: "var(--kui-size-border-large)"
    },
    radius: {
      full: "var(--kui-size-radius-full)",
      xsmall: "var(--kui-size-radius-xsmall)",
      small: "var(--kui-size-radius-small)",
      regular: "var(--kui-size-radius-regular)",
      medium: "var(--kui-size-radius-medium)",
      large: "var(--kui-size-radius-large)",
      xlarge: "var(--kui-size-radius-xlarge)"
    },
    shadow: {
      small: "var(--kui-size-shadow-small)",
      medium: "var(--kui-size-shadow-medium)",
      large: "var(--kui-size-shadow-large)"
    },
    space: {
      xsmall: "var(--kui-size-space-xsmall)",
      small: "var(--kui-size-space-small)",
      regular: "var(--kui-size-space-regular)",
      medium: "var(--kui-size-space-medium)",
      large: "var(--kui-size-space-large)",
      xlarge: "var(--kui-size-space-xlarge)",
      xxlarge: "var(--kui-size-space-xxlarge)"
    },
    scale: {
      "0": "var(--kui-size-scale-0)",
      "10": "var(--kui-size-scale-10)",
      "25": "var(--kui-size-scale-25)",
      "40": "var(--kui-size-scale-40)",
      "50": "var(--kui-size-scale-50)",
      "65": "var(--kui-size-scale-65)",
      "75": "var(--kui-size-scale-75)",
      "85": "var(--kui-size-scale-85)",
      "100": "var(--kui-size-scale-100)",
      "115": "var(--kui-size-scale-115)",
      "125": "var(--kui-size-scale-125)",
      "130": "var(--kui-size-scale-130)",
      "150": "var(--kui-size-scale-150)",
      "160": "var(--kui-size-scale-160)",
      "175": "var(--kui-size-scale-175)",
      "200": "var(--kui-size-scale-200)",
      "225": "var(--kui-size-scale-225)",
      "250": "var(--kui-size-scale-250)",
      "275": "var(--kui-size-scale-275)",
      "300": "var(--kui-size-scale-300)",
      "325": "var(--kui-size-scale-325)",
      "350": "var(--kui-size-scale-350)",
      "400": "var(--kui-size-scale-400)",
      "450": "var(--kui-size-scale-450)",
      "500": "var(--kui-size-scale-500)",
      "550": "var(--kui-size-scale-550)",
      "600": "var(--kui-size-scale-600)",
      "675": "var(--kui-size-scale-675)",
      "700": "var(--kui-size-scale-700)",
      "800": "var(--kui-size-scale-800)",
      "900": "var(--kui-size-scale-900)",
      "1000": "var(--kui-size-scale-1000)",
      "1200": "var(--kui-size-scale-1200)",
      "1250": "var(--kui-size-scale-1250)",
      "1600": "var(--kui-size-scale-1600)",
      "1700": "var(--kui-size-scale-1700)",
      "2000": "var(--kui-size-scale-2000)",
      "2400": "var(--kui-size-scale-2400)",
      "3000": "var(--kui-size-scale-3000)",
      "3400": "var(--kui-size-scale-3400)",
      "3600": "var(--kui-size-scale-3600)",
      "4600": "var(--kui-size-scale-4600)",
      "5000": "var(--kui-size-scale-5000)",
      "6000": "var(--kui-size-scale-6000)"
    }
  },
  typography: {
    fontFamily: {
      base: "var(--kui-typography-font-family-base)",
      code: "var(--kui-typography-font-family-code)"
    },
    fontWeight: {
      regular: "var(--kui-typography-font-weight-regular)",
      medium: "var(--kui-typography-font-weight-medium)",
      semibold: "var(--kui-typography-font-weight-semibold)",
      bold: "var(--kui-typography-font-weight-bold)"
    },
    lineheight: {
      large: "var(--kui-typography-lineheight-large)",
      medium: "var(--kui-typography-lineheight-medium)",
      small: "var(--kui-typography-lineheight-small)"
    },
    text: {
      small: {
        size: "var(--kui-typography-text-small-size)",
        lineheight: "var(--kui-typography-text-small-lineheight)",
        baselineTrim: "var(--kui-typography-text-small-baseline-trim)",
        capheightTrim: "var(--kui-typography-text-small-capheight-trim)",
        capheight: "var(--kui-typography-text-small-capheight)"
      },
      regular: {
        size: "var(--kui-typography-text-regular-size)",
        lineheight: "var(--kui-typography-text-regular-lineheight)",
        baselineTrim: "var(--kui-typography-text-regular-baseline-trim)",
        capheightTrim: "var(--kui-typography-text-regular-capheight-trim)",
        capheight: "var(--kui-typography-text-regular-capheight)"
      },
      medium: {
        size: "var(--kui-typography-text-medium-size)",
        lineheight: "var(--kui-typography-text-medium-lineheight)",
        baselineTrim: "var(--kui-typography-text-medium-baseline-trim)",
        capheightTrim: "var(--kui-typography-text-medium-capheight-trim)",
        capheight: "var(--kui-typography-text-medium-capheight)"
      },
      large: {
        size: "var(--kui-typography-text-large-size)",
        lineheight: "var(--kui-typography-text-large-lineheight)",
        baselineTrim: "var(--kui-typography-text-large-baseline-trim)",
        capheightTrim: "var(--kui-typography-text-large-capheight-trim)",
        capheight: "var(--kui-typography-text-large-capheight)"
      }
    },
    heading: {
      small: {
        size: "var(--kui-typography-heading-small-size)",
        lineheight: "var(--kui-typography-heading-small-lineheight)",
        baselineTrim: "var(--kui-typography-heading-small-baseline-trim)",
        capheightTrim: "var(--kui-typography-heading-small-capheight-trim)",
        capheight: "var(--kui-typography-heading-small-capheight)"
      },
      regular: {
        size: "var(--kui-typography-heading-regular-size)",
        lineheight: "var(--kui-typography-heading-regular-lineheight)",
        baselineTrim: "var(--kui-typography-heading-regular-baseline-trim)",
        capheightTrim: "var(--kui-typography-heading-regular-capheight-trim)",
        capheight: "var(--kui-typography-heading-regular-capheight)"
      },
      medium: {
        size: "var(--kui-typography-heading-medium-size)",
        lineheight: "var(--kui-typography-heading-medium-lineheight)",
        baselineTrim: "var(--kui-typography-heading-medium-baseline-trim)",
        capheightTrim: "var(--kui-typography-heading-medium-capheight-trim)",
        capheight: "var(--kui-typography-heading-medium-capheight)"
      },
      large: {
        size: "var(--kui-typography-heading-large-size)",
        lineheight: "var(--kui-typography-heading-large-lineheight)",
        baselineTrim: "var(--kui-typography-heading-large-baseline-trim)",
        capheightTrim: "var(--kui-typography-heading-large-capheight-trim)",
        capheight: "var(--kui-typography-heading-large-capheight)"
      }
    }
  },
  color: {
    alias: {
      blanket: "var(--kui-color-alias-blanket)",
      backgroundIdle: "var(--kui-color-alias-background-idle)",
      backgroundDisabled: "var(--kui-color-alias-background-disabled)",
      backgroundHovered: "var(--kui-color-alias-background-hovered)",
      backgroundFocused: "var(--kui-color-alias-background-focused)",
      backgroundPressed: "var(--kui-color-alias-background-pressed)",
      backgroundSelected: "var(--kui-color-alias-background-selected)",
      backgroundSelectedHovered: "var(--kui-color-alias-background-selected-hovered)",
      focusRing: "var(--kui-color-alias-focus-ring)",
      borderIdle: "var(--kui-color-alias-border-idle)",
      borderHovered: "var(--kui-color-alias-border-hovered)",
      borderPressed: "var(--kui-color-alias-border-pressed)",
      borderFocused: "var(--kui-color-alias-border-focused)",
      borderDisabled: "var(--kui-color-alias-border-disabled)",
      borderSelected: "var(--kui-color-alias-border-selected)",
      borderInvalid: "var(--kui-color-alias-border-invalid)",
      foregroundIdle: "var(--kui-color-alias-foreground-idle)",
      foregroundHovered: "var(--kui-color-alias-foreground-hovered)",
      foregroundPressed: "var(--kui-color-alias-foreground-pressed)",
      foregroundFocused: "var(--kui-color-alias-foreground-focused)",
      foregroundDisabled: "var(--kui-color-alias-foreground-disabled)",
      foregroundSelected: "var(--kui-color-alias-foreground-selected)"
    },
    background: {
      canvas: "var(--kui-color-background-canvas)",
      surface: "var(--kui-color-background-surface)",
      surfaceSecondary: "var(--kui-color-background-surface-secondary)",
      surfaceTertiary: "var(--kui-color-background-surface-tertiary)",
      inverse: "var(--kui-color-background-inverse)",
      accent: "var(--kui-color-background-accent)",
      accentEmphasis: "var(--kui-color-background-accent-emphasis)",
      positive: "var(--kui-color-background-positive)",
      positiveEmphasis: "var(--kui-color-background-positive-emphasis)",
      caution: "var(--kui-color-background-caution)",
      cautionEmphasis: "var(--kui-color-background-caution-emphasis)",
      critical: "var(--kui-color-background-critical)",
      criticalEmphasis: "var(--kui-color-background-critical-emphasis)",
      pending: "var(--kui-color-background-pending)",
      pendingEmphasis: "var(--kui-color-background-pending-emphasis)",
      highlight: "var(--kui-color-background-highlight)",
      highlightEmphasis: "var(--kui-color-background-highlight-emphasis)"
    },
    border: {
      muted: "var(--kui-color-border-muted)",
      neutral: "var(--kui-color-border-neutral)",
      emphasis: "var(--kui-color-border-emphasis)",
      accent: "var(--kui-color-border-accent)",
      positive: "var(--kui-color-border-positive)",
      caution: "var(--kui-color-border-caution)",
      critical: "var(--kui-color-border-critical)",
      pending: "var(--kui-color-border-pending)",
      highlight: "var(--kui-color-border-highlight)"
    },
    foreground: {
      neutral: "var(--kui-color-foreground-neutral)",
      neutralEmphasis: "var(--kui-color-foreground-neutral-emphasis)",
      neutralSecondary: "var(--kui-color-foreground-neutral-secondary)",
      neutralTertiary: "var(--kui-color-foreground-neutral-tertiary)",
      onEmphasis: "var(--kui-color-foreground-on-emphasis)",
      inverse: "var(--kui-color-foreground-inverse)",
      inverseSecondary: "var(--kui-color-foreground-inverse-secondary)",
      accent: "var(--kui-color-foreground-accent)",
      positive: "var(--kui-color-foreground-positive)",
      caution: "var(--kui-color-foreground-caution)",
      critical: "var(--kui-color-foreground-critical)",
      pending: "var(--kui-color-foreground-pending)",
      highlight: "var(--kui-color-foreground-highlight)"
    },
    shadow: {
      muted: "var(--kui-color-shadow-muted)",
      regular: "var(--kui-color-shadow-regular)",
      emphasis: "var(--kui-color-shadow-emphasis)"
    },
    scale: {
      black: "var(--kui-color-scale-black)",
      white: "var(--kui-color-scale-white)",
      amber1: "var(--kui-color-scale-amber1)",
      amber2: "var(--kui-color-scale-amber2)",
      amber3: "var(--kui-color-scale-amber3)",
      amber4: "var(--kui-color-scale-amber4)",
      amber5: "var(--kui-color-scale-amber5)",
      amber6: "var(--kui-color-scale-amber6)",
      amber7: "var(--kui-color-scale-amber7)",
      amber8: "var(--kui-color-scale-amber8)",
      amber9: "var(--kui-color-scale-amber9)",
      amber10: "var(--kui-color-scale-amber10)",
      amber11: "var(--kui-color-scale-amber11)",
      green1: "var(--kui-color-scale-green1)",
      green2: "var(--kui-color-scale-green2)",
      green3: "var(--kui-color-scale-green3)",
      green4: "var(--kui-color-scale-green4)",
      green5: "var(--kui-color-scale-green5)",
      green6: "var(--kui-color-scale-green6)",
      green7: "var(--kui-color-scale-green7)",
      green8: "var(--kui-color-scale-green8)",
      green9: "var(--kui-color-scale-green9)",
      green10: "var(--kui-color-scale-green10)",
      green11: "var(--kui-color-scale-green11)",
      indigo1: "var(--kui-color-scale-indigo1)",
      indigo2: "var(--kui-color-scale-indigo2)",
      indigo3: "var(--kui-color-scale-indigo3)",
      indigo4: "var(--kui-color-scale-indigo4)",
      indigo5: "var(--kui-color-scale-indigo5)",
      indigo6: "var(--kui-color-scale-indigo6)",
      indigo7: "var(--kui-color-scale-indigo7)",
      indigo8: "var(--kui-color-scale-indigo8)",
      indigo9: "var(--kui-color-scale-indigo9)",
      indigo10: "var(--kui-color-scale-indigo10)",
      indigo11: "var(--kui-color-scale-indigo11)",
      pink1: "var(--kui-color-scale-pink1)",
      pink2: "var(--kui-color-scale-pink2)",
      pink3: "var(--kui-color-scale-pink3)",
      pink4: "var(--kui-color-scale-pink4)",
      pink5: "var(--kui-color-scale-pink5)",
      pink6: "var(--kui-color-scale-pink6)",
      pink7: "var(--kui-color-scale-pink7)",
      pink8: "var(--kui-color-scale-pink8)",
      pink9: "var(--kui-color-scale-pink9)",
      pink10: "var(--kui-color-scale-pink10)",
      pink11: "var(--kui-color-scale-pink11)",
      purple1: "var(--kui-color-scale-purple1)",
      purple2: "var(--kui-color-scale-purple2)",
      purple3: "var(--kui-color-scale-purple3)",
      purple4: "var(--kui-color-scale-purple4)",
      purple5: "var(--kui-color-scale-purple5)",
      purple6: "var(--kui-color-scale-purple6)",
      purple7: "var(--kui-color-scale-purple7)",
      purple8: "var(--kui-color-scale-purple8)",
      purple9: "var(--kui-color-scale-purple9)",
      purple10: "var(--kui-color-scale-purple10)",
      purple11: "var(--kui-color-scale-purple11)",
      red1: "var(--kui-color-scale-red1)",
      red2: "var(--kui-color-scale-red2)",
      red3: "var(--kui-color-scale-red3)",
      red4: "var(--kui-color-scale-red4)",
      red5: "var(--kui-color-scale-red5)",
      red6: "var(--kui-color-scale-red6)",
      red7: "var(--kui-color-scale-red7)",
      red8: "var(--kui-color-scale-red8)",
      red9: "var(--kui-color-scale-red9)",
      red10: "var(--kui-color-scale-red10)",
      red11: "var(--kui-color-scale-red11)",
      slate1: "var(--kui-color-scale-slate1)",
      slate2: "var(--kui-color-scale-slate2)",
      slate3: "var(--kui-color-scale-slate3)",
      slate4: "var(--kui-color-scale-slate4)",
      slate5: "var(--kui-color-scale-slate5)",
      slate6: "var(--kui-color-scale-slate6)",
      slate7: "var(--kui-color-scale-slate7)",
      slate8: "var(--kui-color-scale-slate8)",
      slate9: "var(--kui-color-scale-slate9)",
      slate10: "var(--kui-color-scale-slate10)",
      slate11: "var(--kui-color-scale-slate11)"
    }
  }
};
function transition(prop, options = {}) {
  let {
    delay = 0,
    duration = "short",
    easing = "easeInOut"
  } = options;
  let easingValue = easing === "linear" ? "linear" : tokenSchema.animation.easing[easing];
  let durationValue = resolveDuration(duration);
  if (Array.isArray(prop)) {
    return prop.map((p5) => transition(p5, options)).join(", ");
  }
  return `${prop} ${durationValue} ${easingValue}` + (delay ? ` ${resolveDuration(delay)}` : "");
}
function resolveDuration(duration) {
  return isNumber(duration) ? `${duration}ms` : tokenSchema.animation.duration[duration];
}
var classNamePrefix = TOKEN_PREFIX;
var resetClassName = voussoirClassName("reset");
function voussoirClassName(className) {
  return `${classNamePrefix}:${className}`;
}
function classNames(...inputs) {
  let resolved = cx(inputs);
  if (resolved.includes(resetClassName)) {
    return resolved;
  }
  return cx(resetClassName, resolved);
}
var _componentName, _root, _elements;
var ClassList = class {
  constructor(componentName, elements = []) {
    /** The component name for this class list. */
    __privateAdd(this, _componentName, void 0);
    /** The root class name. */
    __privateAdd(this, _root, void 0);
    /** The list of element class names. */
    __privateAdd(this, _elements, void 0);
    __privateSet(this, _componentName, componentName);
    __privateSet(this, _root, voussoirClassName(componentName));
    __privateSet(this, _elements, new Map(elements.map((element4) => [element4, `${__privateGet(this, _root)}-${element4}`])));
  }
  element(name2) {
    if (name2 === "root") {
      return __privateGet(this, _root);
    }
    let className = __privateGet(this, _elements).get(name2);
    assert(!!className, `Element "${name2}" not found in "${__privateGet(this, _componentName)}" class list. All elements must be defined when the ClassList is instantiated.`);
    return className;
  }
  selector(element4, combinator) {
    let className = this.element(element4);
    if (!combinator) {
      return safeClassName(className);
    }
    return combinators[combinator] + safeClassName(className);
  }
};
_componentName = new WeakMap();
_root = new WeakMap();
_elements = new WeakMap();
function safeClassName(className) {
  return `.${className.replace(/:/g, "\\:")}`;
}
var combinators = {
  descendant: "& ",
  child: "& > ",
  sibling: "& ~ ",
  "adjacent-sibling": "& + "
};
var breakpoints = {
  mobile: 0,
  tablet: 740,
  desktop: 992,
  wide: 1200
};
var mediaAbove = (bp) => `@media (min-width: ${bp}px)`;
var mediaBelow = (bp) => `@media (max-width: ${bp - 1}px)`;
var containerAbove = (bp) => `@container (min-width: ${bp}px)`;
var containerBelow = (bp) => `@container (max-width: ${bp - 1}px)`;
var breakpointQueries$1 = {
  above: {
    mobile: mediaAbove(breakpoints.tablet),
    tablet: mediaAbove(breakpoints.desktop),
    desktop: mediaAbove(breakpoints.wide)
  },
  below: {
    tablet: mediaBelow(breakpoints.tablet),
    desktop: mediaBelow(breakpoints.desktop),
    wide: mediaBelow(breakpoints.wide)
  }
};
var containerQueries = {
  above: {
    mobile: containerAbove(breakpoints.tablet),
    tablet: containerAbove(breakpoints.desktop),
    desktop: containerAbove(breakpoints.wide)
  },
  below: {
    tablet: containerBelow(breakpoints.tablet),
    desktop: containerBelow(breakpoints.desktop),
    wide: containerBelow(breakpoints.wide)
  }
};
var breakpointNames = typedKeys(breakpoints);
var {
  mobile: _mobile$1,
  ...breakpointsWithoutMobile$1
} = breakpoints;
var mediaQueries = Object.values(breakpointsWithoutMobile$1).map(mediaAbove);
var mapToMediaQueries = index_es_default(mediaQueries);
function mapResponsiveValue(propResolver, value2) {
  if (value2 == null) {
    return null;
  }
  if (typeof value2 === "object" && !Array.isArray(value2)) {
    return objectToArray(propResolver, value2);
  }
  return propResolver(value2);
}
function objectToArray(propResolver, value2) {
  const valueArray = [];
  for (let i6 = 0; i6 < breakpointNames.length; i6++) {
    const key = breakpointNames[i6];
    valueArray.push(value2[key] != null ? propResolver(value2[key]) : null);
  }
  return valueArray;
}
function getResponsiveProp(prop, matchedBreakpoints) {
  if (typeof prop === "object" && prop !== null) {
    for (let i6 = 0; i6 < matchedBreakpoints.length; i6++) {
      let value2 = prop[matchedBreakpoints[i6]];
      if (value2 != null) {
        return value2;
      }
    }
    return prop.mobile;
  }
  return prop;
}
function getResponsiveRange(range, matchedBreakpoints) {
  if (typeof range === "boolean") {
    return range;
  }
  if (!("above" in range) && !("below" in range)) {
    return getResponsiveProp(range, matchedBreakpoints);
  }
  const startIndex = "above" in range ? breakpointNames.indexOf(range.above) + 1 : 0;
  const endIndex = "below" in range ? breakpointNames.indexOf(range.below) - 1 : breakpointNames.length - 1;
  const prop = Object.fromEntries(breakpointNames.map((key, index3) => {
    return [key, index3 >= startIndex && index3 <= endIndex];
  }));
  return getResponsiveProp(prop, matchedBreakpoints);
}
var Context = import_react6.default.createContext(["mobile"]);
function BreakpointProvider(props) {
  const {
    children,
    value: value2
  } = props;
  return (0, import_jsx_runtime.jsx)(Context.Provider, {
    value: value2,
    children
  });
}
function useBreakpoint() {
  return (0, import_react6.useContext)(Context);
}
var {
  mobile: _mobile,
  ...breakpointsWithoutMobile
} = breakpoints;
var breakpointEntries = typedEntries(breakpointsWithoutMobile).sort(([, valueA], [, valueB]) => valueB - valueA);
var breakpointQueries = breakpointEntries.map(([, value2]) => `(min-width: ${value2}px)`);
var useLayoutEffectIgnoreOnServer = typeof window === "undefined" ? () => {
} : import_react6.useLayoutEffect;
var supportsMatchMedia = typeof window !== "undefined" && typeof window.matchMedia === "function";
function useMatchedBreakpoints() {
  const [breakpoint, setBreakpoint] = (0, import_react6.useState)(() => ["mobile"]);
  useLayoutEffectIgnoreOnServer(() => {
    if (!supportsMatchMedia) {
      return;
    }
    const onResize = () => {
      setBreakpoint((prevMatchedBreakpoints) => {
        const matched = [];
        for (let i6 in breakpointQueries) {
          let query = breakpointQueries[i6];
          if (window.matchMedia(query).matches) {
            matched.push(breakpointEntries[i6][0]);
          }
        }
        matched.push("mobile");
        if (prevMatchedBreakpoints.length !== matched.length || prevMatchedBreakpoints.some((breakpoint2, idx) => breakpoint2 !== matched[idx])) {
          return matched;
        }
        return prevMatchedBreakpoints;
      });
    };
    onResize();
    window.addEventListener("resize", onResize);
    return () => {
      window.removeEventListener("resize", onResize);
    };
  }, []);
  return breakpoint;
}
function useResponsiveRange() {
  let matchedBreakpoints = useBreakpoint();
  return function responsiveRange(range) {
    return getResponsiveRange(range, matchedBreakpoints);
  };
}
function get(val, path3) {
  for (const part of path3.split(".")) {
    if (typeof val !== "object" || val === null || !Object.prototype.hasOwnProperty.call(val, part)) {
      return;
    }
    val = val[part];
  }
  return val;
}
function maybeTokenByKey(path3, keyOrValue) {
  var _get;
  if (typeof keyOrValue !== "string") {
    return keyOrValue;
  }
  path3 = keyOrValue.includes(".") ? keyOrValue : `${path3}.${keyOrValue}`;
  return (_get = get(tokenSchema, path3)) !== null && _get !== void 0 ? _get : keyOrValue;
}
function resolvePropWithPath(prop, path3) {
  const resolver2 = (value2) => maybeTokenByKey(path3, value2);
  return [prop, resolver2];
}
var identity = (value2) => value2;
function resolveProp(prop, fn2 = identity) {
  return [prop, fn2];
}
function border(prop) {
  const resolver2 = (value2) => {
    const color2 = maybeTokenByKey("color.border", value2);
    return `${tokenSchema.size.border.regular} solid ${color2}`;
  };
  return [prop, resolver2];
}
function isDimensionKey(value2) {
  let [prop, key] = value2.split(".");
  if (!prop || !key) {
    return false;
  }
  return !!tokenSchema.size[prop][key];
}
function sizeResolver(value2) {
  if (typeof value2 === "number") {
    if (value2 === 0) {
      return `${value2}px`;
    }
    assertNever(value2);
  }
  if (isDimensionKey(value2)) {
    let [prop, key] = value2.split(".");
    return tokenSchema.size[prop][key];
  }
  if (value2 === "auto" || value2 === "inherit" || value2 === "100%" || value2 === "100vh" || value2 === "100vw") {
    return value2;
  }
  assertNever(value2);
}
function size(cssProp) {
  return [cssProp, sizeResolver];
}
function space(prop) {
  return resolvePropWithPath(prop, "size.space");
}
function radius(prop) {
  return resolvePropWithPath(prop, "size.radius");
}
var defaultStyleProps = {
  // color
  backgroundColor: resolvePropWithPath("backgroundColor", "color.background"),
  boxShadow: ["boxShadow", boxShadowResolver],
  // dimension
  height: size("height"),
  maxHeight: size("maxHeight"),
  minHeight: size("minHeight"),
  maxWidth: size("maxWidth"),
  minWidth: size("minWidth"),
  width: size("width"),
  // space
  margin: space("margin"),
  marginStart: space("marginInlineStart"),
  marginEnd: space("marginInlineEnd"),
  marginTop: space("marginBlockStart"),
  marginBottom: space("marginBlockEnd"),
  marginX: space("marginInline"),
  marginY: space("marginBlock"),
  padding: space("padding"),
  paddingStart: space("paddingInlineStart"),
  paddingEnd: space("paddingInlineEnd"),
  paddingTop: space("paddingBlockStart"),
  paddingBottom: space("paddingBlockEnd"),
  paddingX: space("paddingInline"),
  paddingY: space("paddingBlock"),
  // border
  border: border("border"),
  borderStart: border("borderInlineStart"),
  borderEnd: border("borderInlineEnd"),
  borderTop: border("borderTop"),
  borderBottom: border("borderBottom"),
  borderColor: resolvePropWithPath("borderColor", "color.border"),
  borderStartColor: resolvePropWithPath("borderInlineStartColor", "color.border"),
  borderEndColor: resolvePropWithPath("borderInlineEndColor", "color.border"),
  borderTopColor: resolvePropWithPath("borderTopColor", "color.border"),
  borderBottomColor: resolvePropWithPath("borderBottomColor", "color.border"),
  borderStyle: resolveProp("borderStyle"),
  borderStartStyle: resolveProp("borderInlineStartStyle"),
  borderEndStyle: resolveProp("borderInlineEndStyle"),
  borderTopStyle: resolveProp("borderTopStyle"),
  borderBottomStyle: resolveProp("borderBottomStyle"),
  borderWidth: resolvePropWithPath("borderWidth", "size.border"),
  borderStartWidth: resolvePropWithPath("borderInlineStartWidth", "size.border"),
  borderEndWidth: resolvePropWithPath("borderInlineEndWidth", "size.border"),
  borderTopWidth: resolvePropWithPath("borderTopWidth", "size.border"),
  borderBottomWidth: resolvePropWithPath("borderBottomWidth", "size.border"),
  borderRadius: radius("borderRadius"),
  borderTopStartRadius: radius("borderStartStartRadius"),
  borderTopEndRadius: radius("borderStartEndRadius"),
  borderBottomStartRadius: radius("borderEndStartRadius"),
  borderBottomEndRadius: radius("borderEndEndRadius"),
  borderTopRadius: radius(["borderStartStartRadius", "borderStartEndRadius"]),
  borderBottomRadius: radius(["borderEndStartRadius", "borderEndEndRadius"]),
  borderStartRadius: radius(["borderStartStartRadius", "borderEndStartRadius"]),
  borderEndRadius: radius(["borderEndEndRadius", "borderStartEndRadius"]),
  // position
  inset: space("inset"),
  insetBottom: space("insetBlockEnd"),
  insetEnd: space("insetInlineEnd"),
  insetStart: space("insetInlineStart"),
  insetTop: space("insetBlockStart"),
  insetX: space("insetInline"),
  insetY: space("insetBlock"),
  position: resolveProp("position"),
  zIndex: resolveProp("zIndex"),
  // flex child
  order: resolveProp("order"),
  alignSelf: resolveProp("alignSelf"),
  flex: resolveProp("flex", flexResolver),
  flexBasis: size("flexBasis"),
  flexGrow: resolveProp("flexGrow", flexResolver),
  flexShrink: resolveProp("flexShrink", flexResolver),
  justifySelf: resolveProp("justifySelf"),
  // grid child
  gridArea: resolveProp("gridArea"),
  gridColumn: resolveProp("gridColumn"),
  gridColumnEnd: resolveProp("gridColumnEnd"),
  gridColumnStart: resolveProp("gridColumnStart"),
  gridRow: resolveProp("gridRow"),
  gridRowEnd: resolveProp("gridRowEnd"),
  gridRowStart: resolveProp("gridRowStart"),
  // misc. non-theme related
  cursor: resolveProp("cursor"),
  opacity: resolveProp("opacity"),
  pointerEvents: resolveProp("pointerEvents"),
  overflow: resolveProp("overflow"),
  userSelect: resolveProp("userSelect")
};
function flexResolver(value2) {
  if (typeof value2 === "boolean") {
    return value2 ? "1" : void 0;
  }
  return "" + value2;
}
function boxShadowResolver(value2) {
  const sizeToColorKey = {
    small: "muted",
    medium: "regular",
    large: "emphasis"
  };
  const [sizeKey, maybeColorKey] = value2.split(" ");
  const color2 = maybeTokenByKey("color.shadow", maybeColorKey !== null && maybeColorKey !== void 0 ? maybeColorKey : sizeToColorKey[sizeKey]);
  const size3 = maybeTokenByKey("size.shadow", sizeKey);
  return `${size3} ${color2}`;
}
var defaultStyleKeys = Object.keys(defaultStyleProps);
function filterStyleProps(props, otherPropNames = []) {
  let filteredProps = {};
  let omit = /* @__PURE__ */ new Set(["isHidden", "UNSAFE_className", "UNSAFE_style", ...defaultStyleKeys, ...otherPropNames]);
  for (const prop in props) {
    if (Object.prototype.hasOwnProperty.call(props, prop) && !omit.has(prop)) {
      filteredProps[prop] = props[prop];
    }
  }
  return filteredProps;
}
function onlyStyleProps(props) {
  let filteredProps = {};
  let include = /* @__PURE__ */ new Set(["isHidden", "UNSAFE_className", "UNSAFE_style", ...defaultStyleKeys]);
  for (const prop in props) {
    if (Object.prototype.hasOwnProperty.call(props, prop) && include.has(prop)) {
      filteredProps[prop] = props[prop];
    }
  }
  return filteredProps;
}
function toDataAttributes(data, options = {}) {
  let dataAttributes = {};
  for (let key in data) {
    let prop = key;
    let value2 = data[key];
    if (value2 == null || options.omitFalsyValues && (value2 === false || value2 === "")) {
      continue;
    }
    if (options.trimBooleanKeys && key.startsWith("is")) {
      prop = prop.charAt(2).toLowerCase() + prop.slice(3);
    }
    prop = prop.replace(/[A-Z]/g, (char2) => `-${char2.toLowerCase()}`);
    dataAttributes[`data-${prop}`] = value2;
  }
  return dataAttributes;
}
function FocusRing(props) {
  let {
    children
  } = props;
  let {
    isFocused,
    isFocusVisible,
    focusProps
  } = $f7dceffc5ad7768b$export$4e328f61c538687f(props);
  let child = import_react6.Children.only(children);
  return (0, import_react6.cloneElement)(child, $3ef42575df84b30b$export$9d1611c77c2fe928(child.props, {
    ...focusProps,
    ...toDataAttributes({
      focus: isFocusVisible ? "visible" : props.within ? "within" : isFocused || void 0
    })
  }));
}
function useIsMobileDevice() {
  let isSSR = $b5e257d569688ac6$export$535bd6ca7f90a273();
  if (isSSR || typeof window === "undefined") {
    return false;
  }
  return window.screen.width <= breakpoints.tablet;
}
function useMediaQuery(query) {
  query = normalizeQuery(query);
  let supportsMatchMedia2 = typeof window !== "undefined" && typeof window.matchMedia === "function";
  let [matches, setMatches] = (0, import_react6.useState)(() => supportsMatchMedia2 ? window.matchMedia(query).matches : false);
  (0, import_react6.useEffect)(() => {
    if (!supportsMatchMedia2) {
      return;
    }
    let mediaQueryList = window.matchMedia(query);
    let supportsEventListener = typeof mediaQueryList.addEventListener === "function";
    let onChange2 = (evt) => {
      setMatches(evt.matches);
    };
    if (supportsEventListener) {
      mediaQueryList.addEventListener("change", onChange2);
    } else {
      mediaQueryList.addListener(onChange2);
    }
    return () => {
      if (supportsEventListener) {
        mediaQueryList.removeEventListener("change", onChange2);
      } else {
        mediaQueryList.removeListener(onChange2);
      }
    };
  }, [supportsMatchMedia2, query]);
  let isSSR = $b5e257d569688ac6$export$535bd6ca7f90a273();
  return isSSR ? false : matches;
}
function normalizeQuery(query) {
  return query.replace(/^@media( ?)/m, "");
}
function convertStyleProps(props, propResolvers) {
  let style = {};
  for (let key in props) {
    let styleProp = propResolvers[key];
    if (!styleProp || props[key] == null) {
      continue;
    }
    let [name2, convert2] = styleProp;
    let value2 = mapResponsiveValue(convert2, props[key]);
    if (Array.isArray(name2)) {
      for (let k2 of name2) {
        style[k2] = value2;
      }
    } else {
      style[name2] = value2;
    }
  }
  return style;
}
function useStyleProps(props, customResolvers = {}) {
  let propResolvers = {
    ...defaultStyleProps,
    ...customResolvers
  };
  let {
    isHidden: isHidden2,
    UNSAFE_className,
    UNSAFE_style,
    ...otherProps
  } = props;
  let convertedProps = convertStyleProps(props, propResolvers);
  let resolvedStyles = mapToMediaQueries(convertedProps);
  warning(
    // @ts-ignore
    !otherProps.className,
    "The className prop is unsafe and is unsupported. Please use style props, or UNSAFE_className if you absolutely must do something custom. Note that this may break in future versions due to DOM structure changes."
  );
  warning(
    // @ts-ignore
    !otherProps.style,
    "The style prop is unsafe and is unsupported. Please use style props, or UNSAFE_style if you absolutely must do something custom. Note that this may break in future versions due to DOM structure changes."
  );
  let hiddenStyles = [];
  if (isHidden2) {
    if (isHidden2 === true) {
      hiddenStyles.push({
        display: "none"
      });
    } else {
      const styles2 = {};
      if ("above" in isHidden2) {
        styles2[breakpointQueries$1.above[isHidden2.above]] = {
          display: "none"
        };
      }
      if ("below" in isHidden2) {
        styles2[breakpointQueries$1.below[isHidden2.below]] = {
          display: "none"
        };
      }
      hiddenStyles.push(styles2);
    }
  }
  return {
    className: classNames(
      css(resolvedStyles),
      UNSAFE_className,
      css(hiddenStyles)
      // must be last
    ),
    style: UNSAFE_style
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-slots.js
var import_react8 = __toESM(require_react());
var import_jsx_runtime2 = __toESM(require_jsx_runtime());

// node_modules/@keystar/ui/dist/keystar-ui-utils-ts.js
var import_react7 = __toESM(require_react());
function forwardRefWithAs(render3) {
  return (0, import_react7.forwardRef)(render3);
}

// node_modules/@keystar/ui/dist/keystar-ui-slots.js
var SlotContext = import_react8.default.createContext({});
function useSlotProps(props, defaultSlot) {
  let slot2 = props.slot || defaultSlot;
  let {
    [slot2]: slotProps = {}
  } = (0, import_react8.useContext)(SlotContext);
  return $3ef42575df84b30b$export$9d1611c77c2fe928(props, $3ef42575df84b30b$export$9d1611c77c2fe928(slotProps, {
    id: props.id
  }));
}
var SlotProvider = (props) => {
  let {
    children,
    slots
  } = props;
  let parentSlots = (0, import_react8.useContext)(SlotContext);
  let value2 = (0, import_react8.useMemo)(() => Object.keys(parentSlots).concat(Object.keys(slots)).reduce((obj, key) => ({
    ...obj,
    [key]: $3ef42575df84b30b$export$9d1611c77c2fe928(parentSlots[key], slots[key])
  }), {}), [parentSlots, slots]);
  return (0, import_jsx_runtime2.jsx)(SlotContext.Provider, {
    value: value2,
    children
  });
};
var ClearSlots = ({
  children
}) => {
  return (0, import_jsx_runtime2.jsx)(SlotContext.Provider, {
    value: {},
    children
  });
};
var Content = forwardRefWithAs((props, ref) => {
  props = useSlotProps(props, "content");
  let {
    elementType: Element4 = "section",
    children,
    ...otherProps
  } = props;
  let styleProps = useStyleProps(otherProps);
  return (0, import_jsx_runtime2.jsx)(Element4, {
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
    ...styleProps,
    ref,
    children
  });
});
var Footer = forwardRefWithAs((props, ref) => {
  props = useSlotProps(props, "footer");
  let {
    elementType: Element4 = "footer",
    children,
    ...otherProps
  } = props;
  let styleProps = useStyleProps(otherProps);
  return (0, import_jsx_runtime2.jsx)(Element4, {
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
    ...styleProps,
    ref,
    children
  });
});
var Header = forwardRefWithAs((props, ref) => {
  props = useSlotProps(props, "header");
  let {
    elementType: Element4 = "header",
    children,
    ...otherProps
  } = props;
  let styleProps = useStyleProps(otherProps);
  return (0, import_jsx_runtime2.jsx)(Element4, {
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
    ...styleProps,
    ref,
    children
  });
});

// node_modules/@keystar/ui/dist/keystar-ui-layout.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());

// node_modules/@react-aria/separator/dist/import.mjs
function $f4b273590fab9f93$export$52210f68a14655d0(props) {
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let ariaOrientation;
  if (props.orientation === "vertical")
    ariaOrientation = "vertical";
  if (props.elementType !== "hr")
    return {
      separatorProps: {
        ...domProps,
        role: "separator",
        "aria-orientation": ariaOrientation
      }
    };
  return {
    separatorProps: domProps
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-layout.js
var import_react9 = __toESM(require_react());
var Box = forwardRefWithAs((props, forwardedRef) => {
  const {
    elementType: ElementType = "div",
    children,
    ...otherProps
  } = props;
  const styleProps = useStyleProps(otherProps);
  return (0, import_jsx_runtime3.jsx)(ElementType, {
    ref: forwardedRef,
    ...filterStyleProps(otherProps),
    ...styleProps,
    children
  });
});
var dividerClassList = new ClassList("Divider");
var filterOptions = {
  propNames: /* @__PURE__ */ new Set(["role"])
};
var Divider = forwardRefWithAs((props, forwardedRef) => {
  props = useSlotProps(props, "divider");
  const {
    orientation = "horizontal",
    elementType: Element4 = orientation === "vertical" ? "div" : "hr",
    size: size3 = "regular",
    ...otherProps
  } = props;
  const styleProps = useStyleProps(otherProps);
  let {
    separatorProps
  } = $f4b273590fab9f93$export$52210f68a14655d0({
    ...props,
    // FIXME: `forwardRefWithAs` yields `React.ElementType<any>` which is
    // incompatible with react-aria's expectations for `elementType`.
    elementType: Element4
  });
  return (0, import_jsx_runtime3.jsx)(Element4, {
    ...styleProps,
    ...separatorProps,
    ...toDataAttributes({
      orientation,
      size: size3
    }),
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps, filterOptions),
    ref: forwardedRef,
    className: classNames(dividerClassList.element("root"), css({
      alignSelf: "stretch",
      backgroundColor: tokenSchema.color.border.neutral,
      borderRadius: "var(--size)",
      "&[data-size=regular]": {
        "--size": tokenSchema.size.border.regular
      },
      "&[data-size=medium]": {
        "--size": tokenSchema.size.border.medium
      },
      "&[data-size=large]": {
        "--size": tokenSchema.size.border.large
      },
      "&[data-orientation=horizontal]": {
        height: "var(--size)"
      },
      "&[data-orientation=vertical]": {
        width: "var(--size)"
      }
    }), styleProps.className)
  });
});
var sharedStyleProps = {
  gap: resolvePropWithPath("gap", "size.space"),
  columnGap: resolvePropWithPath("columnGap", "size.space"),
  rowGap: resolvePropWithPath("rowGap", "size.space"),
  alignContent: resolveProp("alignContent", flexAlignValue),
  alignItems: resolveProp("alignItems", flexAlignValue),
  direction: resolveProp("flexDirection"),
  justifyContent: resolveProp("justifyContent", flexAlignValue)
};
function displayInline(block5) {
  const resolver2 = (inline4) => inline4 ? `inline-${block5}` : block5;
  return resolver2;
}
function useFlexStyleProps(props) {
  return useStyleProps({
    inline: false,
    ...props
  }, flexStyleProps);
}
var flexStyleProps = {
  ...sharedStyleProps,
  direction: resolveProp("flexDirection"),
  inline: resolveProp("display", displayInline("flex")),
  wrap: resolveProp("flexWrap", flexWrapValue)
};
function flexAlignValue(value2) {
  if (value2 === "start") {
    return "flex-start";
  }
  if (value2 === "end") {
    return "flex-end";
  }
  return value2;
}
function flexWrapValue(value2) {
  if (typeof value2 === "boolean") {
    return value2 ? "wrap" : "nowrap";
  }
  return value2;
}
function isFractionUnit(value2) {
  return value2.endsWith("fr");
}
function gridSizeResolver(value2) {
  if (typeof value2 === "number") {
    return value2;
  }
  if (isFractionUnit(value2)) {
    return value2;
  }
  return sizeResolver(value2);
}
function useGridStyleProps(props) {
  return useStyleProps({
    inline: false,
    ...props
  }, gridStyleProps);
}
var gridStyleProps = {
  ...sharedStyleProps,
  inline: resolveProp("display", displayInline("grid")),
  autoFlow: resolveProp("gridAutoFlow"),
  // @ts-ignore FIXME: The `StyleResolver` type is not generic enough to support this.
  autoColumns: resolveProp("gridAutoColumns", sizeResolver),
  // @ts-ignore FIXME: The `StyleResolver` type is not generic enough to support this.
  autoRows: resolveProp("gridAutoRows", sizeResolver),
  // @ts-ignore FIXME: The `StyleResolver` type is not generic enough to support this.
  areas: resolveProp("gridTemplateAreas", gridTemplateAreasValue),
  // @ts-ignore FIXME: The `StyleResolver` type is not generic enough to support this.
  columns: resolveProp("gridTemplateColumns", gridTemplateValue),
  // @ts-ignore FIXME: The `StyleResolver` type is not generic enough to support this.
  rows: resolveProp("gridTemplateRows", gridTemplateValue),
  justifyItems: resolveProp("justifyItems"),
  justifyContent: resolveProp("justifyContent"),
  alignItems: resolveProp("alignItems"),
  alignContent: resolveProp("alignContent")
};
function gridTemplateAreasValue(values3) {
  return values3.map((value2) => `"${value2}"`).join("\n");
}
function gridTemplateValue(value2) {
  if (Array.isArray(value2)) {
    return value2.map(gridSizeResolver).join(" ");
  }
  return value2;
}
function minmax(min3, max4) {
  return `minmax(${gridSizeResolver(min3)}, ${gridSizeResolver(max4)})`;
}
var Flex = forwardRefWithAs((props, forwardedRef) => {
  const {
    elementType: ElementType = "div",
    children,
    ...otherProps
  } = props;
  const styleProps = useFlexStyleProps(otherProps);
  return (0, import_jsx_runtime3.jsx)(ElementType, {
    ref: forwardedRef,
    ...filterStyleProps(otherProps, Object.keys(flexStyleProps)),
    ...styleProps,
    children
  });
});
var Grid = forwardRefWithAs((props, forwardedRef) => {
  const {
    elementType: ElementType = "div",
    children,
    ...otherProps
  } = props;
  const styleProps = useGridStyleProps(otherProps);
  return (0, import_jsx_runtime3.jsx)(ElementType, {
    ref: forwardedRef,
    ...filterStyleProps(otherProps, Object.keys(gridStyleProps)),
    ...styleProps,
    children
  });
});
var ScrollView = (0, import_react9.forwardRef)(function ScrollView2(props, forwardedRef) {
  let {
    children,
    direction = "vertical",
    ...otherProps
  } = props;
  let ref = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let [scrollIndicator, setScrollIndicator] = (0, import_react9.useState)("none");
  let styleProps = useGridStyleProps(otherProps);
  let updateScrollPosition = (0, import_react9.useCallback)(() => {
    let node4 = ref.current;
    if (!node4) {
      return;
    }
    let {
      clientDimension,
      scrollDimension,
      scrollStart
    } = getScrollProps(direction, node4);
    let indicator = "none";
    if (scrollDimension > clientDimension) {
      if (scrollStart === 0) {
        indicator = "end";
      } else if (Math.ceil(scrollStart + clientDimension) >= scrollDimension) {
        indicator = "start";
      } else if (scrollStart > 0) {
        indicator = "both";
      }
    }
    setScrollIndicator(indicator);
  }, [direction, ref]);
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    updateScrollPosition();
  }, [updateScrollPosition]);
  $9daab02d461809db$export$683480f191c0e3ea({
    ref,
    onResize: updateScrollPosition
  });
  return (0, import_jsx_runtime3.jsx)("div", {
    ...styleProps,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(props),
    onScroll: updateScrollPosition,
    ref,
    "data-scroll-indicator": scrollIndicator,
    "data-scroll-direction": direction,
    className: classNames(css({
      height: "100%",
      width: "100%",
      minHeight: 0,
      minWidth: 0,
      transition: transition("border-color", {
        duration: "regular"
      }),
      WebkitOverflowScrolling: "touch",
      "&[data-scroll-direction=vertical]": {
        borderBlock: `${tokenSchema.size.border.regular} solid transparent`,
        // marginBlock: `calc(${tokenSchema.size.border.regular} * -1)`,
        overflowX: "hidden",
        overflowY: "auto",
        "&[data-scroll-indicator=both]": {
          borderBlockColor: tokenSchema.color.border.neutral
        },
        "&[data-scroll-indicator=start]": {
          borderBlockStartColor: tokenSchema.color.border.neutral
        },
        "&[data-scroll-indicator=end]": {
          borderBlockEndColor: tokenSchema.color.border.neutral
        }
      },
      "&[data-scroll-direction=horizontal]": {
        borderInline: `${tokenSchema.size.border.regular} solid transparent`,
        // marginInline: `calc(${tokenSchema.size.border.regular} * -1)`,
        gridAutoFlow: "column",
        overflowX: "auto",
        overflowY: "hidden",
        "&[data-scroll-indicator=both]": {
          borderInlineColor: tokenSchema.color.border.neutral
        },
        "&[data-scroll-indicator=start]": {
          borderInlineStartColor: tokenSchema.color.border.neutral
        },
        "&[data-scroll-indicator=end]": {
          borderInlineEndColor: tokenSchema.color.border.neutral
        }
      }
    }), styleProps.className),
    children
  });
});
function getScrollProps(direction, node4) {
  let scrollStart = direction === "horizontal" ? node4.scrollLeft : node4.scrollTop;
  let scrollDimension = direction === "horizontal" ? node4.scrollWidth : node4.scrollHeight;
  let clientDimension = direction === "horizontal" ? node4.clientWidth : node4.clientHeight;
  return {
    clientDimension,
    scrollDimension,
    scrollStart
  };
}
var VStack = forwardRefWithAs((props, forwardedRef) => {
  const {
    elementType: ElementType = "div",
    children,
    ...otherProps
  } = props;
  const styleProps = useFlexStyleProps({
    direction: "column",
    ...otherProps
  });
  return (0, import_jsx_runtime3.jsx)(ElementType, {
    ref: forwardedRef,
    ...filterStyleProps(otherProps, Object.keys(flexStyleProps)),
    ...styleProps,
    children
  });
});
var HStack = forwardRefWithAs((props, forwardedRef) => {
  const {
    elementType: ElementType = "div",
    children,
    ...otherProps
  } = props;
  const styleProps = useFlexStyleProps({
    direction: "row",
    ...otherProps
  });
  return (0, import_jsx_runtime3.jsx)(ElementType, {
    ref: forwardedRef,
    ...filterStyleProps(otherProps, Object.keys(flexStyleProps)),
    ...styleProps,
    children
  });
});
var levels = ["one", "two", "three"];
var MAX_LEVEL = levels.length - 1;
var SurfaceContext = (0, import_react9.createContext)(1);
var Surface = forwardRefWithAs((props, forwardedRef) => {
  const {
    elementType: ElementType = "div",
    children,
    level: overrideLevel,
    ...otherProps
  } = props;
  const contextLevel = (0, import_react9.useContext)(SurfaceContext);
  const level = overrideLevel !== null && overrideLevel !== void 0 ? overrideLevel : contextLevel;
  const levelClassName = `${TOKEN_PREFIX}--surface-${levels[level]}`;
  const value2 = Math.max(0, Math.min(level + 1, MAX_LEVEL));
  const styleProps = useStyleProps(otherProps);
  return (0, import_jsx_runtime3.jsx)(SurfaceContext.Provider, {
    value: value2,
    children: (0, import_jsx_runtime3.jsx)(ElementType, {
      ref: forwardedRef,
      ...filterStyleProps(otherProps),
      ...styleProps,
      className: classNames(levelClassName, styleProps.className),
      children
    })
  });
});

// node_modules/@keystar/ui/dist/children-71759cb3.js
var import_react10 = __toESM(require_react(), 1);
function useHasChild(query, ref) {
  let [hasChild, setHasChild] = (0, import_react10.useState)(true);
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    setHasChild(!!(ref.current && ref.current.querySelector(query)));
  }, [setHasChild, query, ref]);
  return hasChild;
}
function cloneValidElement(child, props) {
  if (!(0, import_react10.isValidElement)(child)) {
    return null;
  }
  return (0, import_react10.cloneElement)(child, props);
}

// node_modules/@keystar/ui/dist/keystar-ui-utils.js
var import_react11 = __toESM(require_react());
function isReactText(value2) {
  if (Array.isArray(value2)) {
    return value2.every(isReactText);
  }
  return typeof value2 === "string" || typeof value2 === "number";
}
function useId(id2) {
  let generatedId = import_react11.default.useId();
  return id2 || generatedId;
}
function useIsMounted() {
  const isMounted = (0, import_react11.useRef)(false);
  (0, import_react11.useEffect)(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return (0, import_react11.useCallback)(() => isMounted.current, []);
}
function usePrevious(value2) {
  const ref = (0, import_react11.useRef)();
  (0, import_react11.useEffect)(() => {
    ref.current = value2;
  });
  return ref.current;
}
function useRenderProps(props, values3) {
  if (typeof props.children === "function") {
    return props.children(values3);
  } else {
    return props.children;
  }
}

// node_modules/@react-aria/i18n/dist/real-module.mjs
var import_react12 = __toESM(require_react(), 1);

// node_modules/@internationalized/string/dist/import.mjs
var $5b160d28a433310d$var$localeSymbol = Symbol.for("react-aria.i18n.locale");
var $5b160d28a433310d$var$stringsSymbol = Symbol.for("react-aria.i18n.strings");
var $5b160d28a433310d$var$cachedGlobalStrings = void 0;
var $5b160d28a433310d$export$c17fa47878dc55b6 = class _$5b160d28a433310d$export$c17fa47878dc55b6 {
  /** Returns a localized string for the given key and locale. */
  getStringForLocale(key, locale) {
    let strings = this.getStringsForLocale(locale);
    let string3 = strings[key];
    if (!string3)
      throw new Error(`Could not find intl message ${key} in ${locale} locale`);
    return string3;
  }
  /** Returns all localized strings for the given locale. */
  getStringsForLocale(locale) {
    let strings = this.strings[locale];
    if (!strings) {
      strings = $5b160d28a433310d$var$getStringsForLocale(locale, this.strings, this.defaultLocale);
      this.strings[locale] = strings;
    }
    return strings;
  }
  static getGlobalDictionaryForPackage(packageName) {
    if (typeof window === "undefined")
      return null;
    let locale = window[$5b160d28a433310d$var$localeSymbol];
    if ($5b160d28a433310d$var$cachedGlobalStrings === void 0) {
      let globalStrings = window[$5b160d28a433310d$var$stringsSymbol];
      if (!globalStrings)
        return null;
      $5b160d28a433310d$var$cachedGlobalStrings = {};
      for (let pkg in globalStrings)
        $5b160d28a433310d$var$cachedGlobalStrings[pkg] = new _$5b160d28a433310d$export$c17fa47878dc55b6({
          [locale]: globalStrings[pkg]
        }, locale);
    }
    let dictionary = $5b160d28a433310d$var$cachedGlobalStrings === null || $5b160d28a433310d$var$cachedGlobalStrings === void 0 ? void 0 : $5b160d28a433310d$var$cachedGlobalStrings[packageName];
    if (!dictionary)
      throw new Error(`Strings for package "${packageName}" were not included by LocalizedStringProvider. Please add it to the list passed to createLocalizedStringDictionary.`);
    return dictionary;
  }
  constructor(messages, defaultLocale = "en-US") {
    this.strings = {
      ...messages
    };
    this.defaultLocale = defaultLocale;
  }
};
function $5b160d28a433310d$var$getStringsForLocale(locale, strings, defaultLocale = "en-US") {
  if (strings[locale])
    return strings[locale];
  let language = $5b160d28a433310d$var$getLanguage(locale);
  if (strings[language])
    return strings[language];
  for (let key in strings) {
    if (key.startsWith(language + "-"))
      return strings[key];
  }
  return strings[defaultLocale];
}
function $5b160d28a433310d$var$getLanguage(locale) {
  if (Intl.Locale)
    return new Intl.Locale(locale).language;
  return locale.split("-")[0];
}
var $6db58dc88e78b024$var$pluralRulesCache = /* @__PURE__ */ new Map();
var $6db58dc88e78b024$var$numberFormatCache = /* @__PURE__ */ new Map();
var $6db58dc88e78b024$export$2f817fcdc4b89ae0 = class {
  /** Formats a localized string for the given key with the provided variables. */
  format(key, variables) {
    let message = this.strings.getStringForLocale(key, this.locale);
    return typeof message === "function" ? message(variables, this) : message;
  }
  plural(count, options, type2 = "cardinal") {
    let opt = options["=" + count];
    if (opt)
      return typeof opt === "function" ? opt() : opt;
    let key = this.locale + ":" + type2;
    let pluralRules = $6db58dc88e78b024$var$pluralRulesCache.get(key);
    if (!pluralRules) {
      pluralRules = new Intl.PluralRules(this.locale, {
        type: type2
      });
      $6db58dc88e78b024$var$pluralRulesCache.set(key, pluralRules);
    }
    let selected = pluralRules.select(count);
    opt = options[selected] || options.other;
    return typeof opt === "function" ? opt() : opt;
  }
  number(value2) {
    let numberFormat = $6db58dc88e78b024$var$numberFormatCache.get(this.locale);
    if (!numberFormat) {
      numberFormat = new Intl.NumberFormat(this.locale);
      $6db58dc88e78b024$var$numberFormatCache.set(this.locale, numberFormat);
    }
    return numberFormat.format(value2);
  }
  select(options, value2) {
    let opt = options[value2] || options.other;
    return typeof opt === "function" ? opt() : opt;
  }
  constructor(locale, strings) {
    this.locale = locale;
    this.strings = strings;
  }
};

// node_modules/@internationalized/date/dist/import.mjs
var $fae977aafc393c5c$var$requiredDurationTimeGroups = [
  "hours",
  "minutes",
  "seconds"
];
var $fae977aafc393c5c$var$requiredDurationGroups = [
  "years",
  "months",
  "weeks",
  "days",
  ...$fae977aafc393c5c$var$requiredDurationTimeGroups
];
var $7c5f6fbf42389787$var$HOUR_PARTS = 1080;
var $7c5f6fbf42389787$var$DAY_PARTS = 24 * $7c5f6fbf42389787$var$HOUR_PARTS;
var $7c5f6fbf42389787$var$MONTH_DAYS = 29;
var $7c5f6fbf42389787$var$MONTH_FRACT = 12 * $7c5f6fbf42389787$var$HOUR_PARTS + 793;
var $7c5f6fbf42389787$var$MONTH_PARTS = $7c5f6fbf42389787$var$MONTH_DAYS * $7c5f6fbf42389787$var$DAY_PARTS + $7c5f6fbf42389787$var$MONTH_FRACT;

// node_modules/@internationalized/number/dist/import.mjs
var $488c6ddbf4ef74c2$var$formatterCache = /* @__PURE__ */ new Map();
var $488c6ddbf4ef74c2$var$supportsSignDisplay = false;
try {
  $488c6ddbf4ef74c2$var$supportsSignDisplay = new Intl.NumberFormat("de-DE", {
    signDisplay: "exceptZero"
  }).resolvedOptions().signDisplay === "exceptZero";
} catch (e6) {
}
var $488c6ddbf4ef74c2$var$supportsUnit = false;
try {
  $488c6ddbf4ef74c2$var$supportsUnit = new Intl.NumberFormat("de-DE", {
    style: "unit",
    unit: "degree"
  }).resolvedOptions().style === "unit";
} catch (e6) {
}
var $488c6ddbf4ef74c2$var$UNITS = {
  degree: {
    narrow: {
      default: "°",
      "ja-JP": " 度",
      "zh-TW": "度",
      "sl-SI": " °"
    }
  }
};
var $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 = class {
  /** Formats a number value as a string, according to the locale and options provided to the constructor. */
  format(value2) {
    let res = "";
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null)
      res = $488c6ddbf4ef74c2$export$711b50b3c525e0f2(this.numberFormatter, this.options.signDisplay, value2);
    else
      res = this.numberFormatter.format(value2);
    if (this.options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
      var _UNITS_unit;
      let { unit, unitDisplay = "short", locale } = this.resolvedOptions();
      if (!unit)
        return res;
      let values3 = (_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay];
      res += values3[locale] || values3.default;
    }
    return res;
  }
  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */
  formatToParts(value2) {
    return this.numberFormatter.formatToParts(value2);
  }
  /** Formats a number range as a string. */
  formatRange(start2, end) {
    if (typeof this.numberFormatter.formatRange === "function")
      return this.numberFormatter.formatRange(start2, end);
    if (end < start2)
      throw new RangeError("End date must be >= start date");
    return `${this.format(start2)} – ${this.format(end)}`;
  }
  /** Formats a number range as an array of parts. */
  formatRangeToParts(start2, end) {
    if (typeof this.numberFormatter.formatRangeToParts === "function")
      return this.numberFormatter.formatRangeToParts(start2, end);
    if (end < start2)
      throw new RangeError("End date must be >= start date");
    let startParts = this.numberFormatter.formatToParts(start2);
    let endParts = this.numberFormatter.formatToParts(end);
    return [
      ...startParts.map((p5) => ({
        ...p5,
        source: "startRange"
      })),
      {
        type: "literal",
        value: " – ",
        source: "shared"
      },
      ...endParts.map((p5) => ({
        ...p5,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let options = this.numberFormatter.resolvedOptions();
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null)
      options = {
        ...options,
        signDisplay: this.options.signDisplay
      };
    if (!$488c6ddbf4ef74c2$var$supportsUnit && this.options.style === "unit")
      options = {
        ...options,
        style: "unit",
        unit: this.options.unit,
        unitDisplay: this.options.unitDisplay
      };
    return options;
  }
  constructor(locale, options = {}) {
    this.numberFormatter = $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options);
    this.options = options;
  }
};
function $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options = {}) {
  let { numberingSystem } = options;
  if (numberingSystem && locale.includes("-nu-")) {
    if (!locale.includes("-u-"))
      locale += "-u-";
    locale += `-nu-${numberingSystem}`;
  }
  if (options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
    var _UNITS_unit;
    let { unit, unitDisplay = "short" } = options;
    if (!unit)
      throw new Error('unit option must be provided with style: "unit"');
    if (!((_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay]))
      throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);
    options = {
      ...options,
      style: "decimal"
    };
  }
  let cacheKey = locale + (options ? Object.entries(options).sort((a3, b2) => a3[0] < b2[0] ? -1 : 1).join() : "");
  if ($488c6ddbf4ef74c2$var$formatterCache.has(cacheKey))
    return $488c6ddbf4ef74c2$var$formatterCache.get(cacheKey);
  let numberFormatter = new Intl.NumberFormat(locale, options);
  $488c6ddbf4ef74c2$var$formatterCache.set(cacheKey, numberFormatter);
  return numberFormatter;
}
function $488c6ddbf4ef74c2$export$711b50b3c525e0f2(numberFormat, signDisplay, num) {
  if (signDisplay === "auto")
    return numberFormat.format(num);
  else if (signDisplay === "never")
    return numberFormat.format(Math.abs(num));
  else {
    let needsPositiveSign = false;
    if (signDisplay === "always")
      needsPositiveSign = num > 0 || Object.is(num, 0);
    else if (signDisplay === "exceptZero") {
      if (Object.is(num, -0) || Object.is(num, 0))
        num = Math.abs(num);
      else
        needsPositiveSign = num > 0;
    }
    if (needsPositiveSign) {
      let negative = numberFormat.format(-num);
      let noSign = numberFormat.format(num);
      let minus = negative.replace(noSign, "").replace(/\u200e|\u061C/, "");
      if ([
        ...minus
      ].length !== 1)
        console.warn("@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case");
      let positive = negative.replace(noSign, "!!!").replace(minus, "+").replace("!!!", noSign);
      return positive;
    } else
      return numberFormat.format(num);
  }
}
var $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp("^.*\\(.*\\).*$");
var $6c7bd7858deea686$var$NUMBERING_SYSTEMS = [
  "latn",
  "arab",
  "hanidec"
];
var $6c7bd7858deea686$export$cd11ab140839f11d = class {
  /**
  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
  */
  parse(value2) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value2).parse(value2);
  }
  /**
  * Returns whether the given string could potentially be a valid number. This should be used to
  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
  * of the minus/plus sign characters can be checked.
  */
  isValidPartialNumber(value2, minValue, maxValue) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value2).isValidPartialNumber(value2, minValue, maxValue);
  }
  /**
  * Returns a numbering system for which the given string is valid in the current locale.
  * If no numbering system could be detected, the default numbering system for the current
  * locale is returned.
  */
  getNumberingSystem(value2) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value2).options.numberingSystem;
  }
  constructor(locale, options = {}) {
    this.locale = locale;
    this.options = options;
  }
};
var $6c7bd7858deea686$var$numberParserCache = /* @__PURE__ */ new Map();
function $6c7bd7858deea686$var$getNumberParserImpl(locale, options, value2) {
  let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options);
  if (!locale.includes("-nu-") && !defaultParser.isValidPartialNumber(value2)) {
    for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS)
      if (numberingSystem !== defaultParser.options.numberingSystem) {
        let parser2 = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes("-u-") ? "-nu-" : "-u-nu-") + numberingSystem, options);
        if (parser2.isValidPartialNumber(value2))
          return parser2;
      }
  }
  return defaultParser;
}
function $6c7bd7858deea686$var$getCachedNumberParser(locale, options) {
  let cacheKey = locale + (options ? Object.entries(options).sort((a3, b2) => a3[0] < b2[0] ? -1 : 1).join() : "");
  let parser2 = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);
  if (!parser2) {
    parser2 = new $6c7bd7858deea686$var$NumberParserImpl(locale, options);
    $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser2);
  }
  return parser2;
}
var $6c7bd7858deea686$var$NumberParserImpl = class {
  parse(value2) {
    let fullySanitizedValue = this.sanitize(value2);
    if (this.symbols.group)
      fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, "");
    if (this.symbols.decimal)
      fullySanitizedValue = fullySanitizedValue.replace(this.symbols.decimal, ".");
    if (this.symbols.minusSign)
      fullySanitizedValue = fullySanitizedValue.replace(this.symbols.minusSign, "-");
    fullySanitizedValue = fullySanitizedValue.replace(this.symbols.numeral, this.symbols.index);
    if (this.options.style === "percent") {
      let isNegative2 = fullySanitizedValue.indexOf("-");
      fullySanitizedValue = fullySanitizedValue.replace("-", "");
      let index3 = fullySanitizedValue.indexOf(".");
      if (index3 === -1)
        index3 = fullySanitizedValue.length;
      fullySanitizedValue = fullySanitizedValue.replace(".", "");
      if (index3 - 2 === 0)
        fullySanitizedValue = `0.${fullySanitizedValue}`;
      else if (index3 - 2 === -1)
        fullySanitizedValue = `0.0${fullySanitizedValue}`;
      else if (index3 - 2 === -2)
        fullySanitizedValue = "0.00";
      else
        fullySanitizedValue = `${fullySanitizedValue.slice(0, index3 - 2)}.${fullySanitizedValue.slice(index3 - 2)}`;
      if (isNegative2 > -1)
        fullySanitizedValue = `-${fullySanitizedValue}`;
    }
    let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;
    if (isNaN(newValue))
      return NaN;
    if (this.options.style === "percent") {
      let options = {
        ...this.options,
        style: "decimal",
        minimumFractionDigits: Math.min(this.options.minimumFractionDigits + 2, 20),
        maximumFractionDigits: Math.min(this.options.maximumFractionDigits + 2, 20)
      };
      return new $6c7bd7858deea686$export$cd11ab140839f11d(this.locale, options).parse(new (0, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(this.locale, options).format(newValue));
    }
    if (this.options.currencySign === "accounting" && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value2))
      newValue = -1 * newValue;
    return newValue;
  }
  sanitize(value2) {
    value2 = value2.replace(this.symbols.literals, "");
    if (this.symbols.minusSign)
      value2 = value2.replace("-", this.symbols.minusSign);
    if (this.options.numberingSystem === "arab") {
      if (this.symbols.decimal) {
        value2 = value2.replace(",", this.symbols.decimal);
        value2 = value2.replace(String.fromCharCode(1548), this.symbols.decimal);
      }
      if (this.symbols.group)
        value2 = $6c7bd7858deea686$var$replaceAll(value2, ".", this.symbols.group);
    }
    if (this.options.locale === "fr-FR")
      value2 = $6c7bd7858deea686$var$replaceAll(value2, ".", String.fromCharCode(8239));
    return value2;
  }
  isValidPartialNumber(value2, minValue = -Infinity, maxValue = Infinity) {
    value2 = this.sanitize(value2);
    if (this.symbols.minusSign && value2.startsWith(this.symbols.minusSign) && minValue < 0)
      value2 = value2.slice(this.symbols.minusSign.length);
    else if (this.symbols.plusSign && value2.startsWith(this.symbols.plusSign) && maxValue > 0)
      value2 = value2.slice(this.symbols.plusSign.length);
    if (this.symbols.group && value2.startsWith(this.symbols.group))
      return false;
    if (this.symbols.decimal && value2.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0)
      return false;
    if (this.symbols.group)
      value2 = $6c7bd7858deea686$var$replaceAll(value2, this.symbols.group, "");
    value2 = value2.replace(this.symbols.numeral, "");
    if (this.symbols.decimal)
      value2 = value2.replace(this.symbols.decimal, "");
    return value2.length === 0;
  }
  constructor(locale, options = {}) {
    this.locale = locale;
    this.formatter = new Intl.NumberFormat(locale, options);
    this.options = this.formatter.resolvedOptions();
    this.symbols = $6c7bd7858deea686$var$getSymbols(locale, this.formatter, this.options, options);
    var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
    if (this.options.style === "percent" && (((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) > 18 || ((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) > 18))
      console.warn("NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.");
  }
};
var $6c7bd7858deea686$var$nonLiteralParts = /* @__PURE__ */ new Set([
  "decimal",
  "fraction",
  "integer",
  "minusSign",
  "plusSign",
  "group"
]);
var $6c7bd7858deea686$var$pluralNumbers = [
  0,
  4,
  2,
  1,
  11,
  20,
  3,
  7,
  100,
  21,
  0.1,
  1.1
];
function $6c7bd7858deea686$var$getSymbols(locale, formatter, intlOptions, originalOptions) {
  var _allParts_find, _posAllParts_find, _decimalParts_find, _allParts_find1;
  let symbolFormatter = new Intl.NumberFormat(locale, {
    ...intlOptions,
    minimumSignificantDigits: 1,
    maximumSignificantDigits: 21
  });
  let allParts = symbolFormatter.formatToParts(-10000.111);
  let posAllParts = symbolFormatter.formatToParts(10000.111);
  let pluralParts = $6c7bd7858deea686$var$pluralNumbers.map((n6) => symbolFormatter.formatToParts(n6));
  var _allParts_find_value;
  let minusSign = (_allParts_find_value = (_allParts_find = allParts.find((p5) => p5.type === "minusSign")) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : "-";
  let plusSign = (_posAllParts_find = posAllParts.find((p5) => p5.type === "plusSign")) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value;
  if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "exceptZero" || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "always"))
    plusSign = "+";
  let decimalParts = new Intl.NumberFormat(locale, {
    ...intlOptions,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).formatToParts(1e-3);
  let decimal = (_decimalParts_find = decimalParts.find((p5) => p5.type === "decimal")) === null || _decimalParts_find === void 0 ? void 0 : _decimalParts_find.value;
  let group = (_allParts_find1 = allParts.find((p5) => p5.type === "group")) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value;
  let allPartsLiterals = allParts.filter((p5) => !$6c7bd7858deea686$var$nonLiteralParts.has(p5.type)).map((p5) => $6c7bd7858deea686$var$escapeRegex(p5.value));
  let pluralPartsLiterals = pluralParts.flatMap((p5) => p5.filter((p6) => !$6c7bd7858deea686$var$nonLiteralParts.has(p6.type)).map((p6) => $6c7bd7858deea686$var$escapeRegex(p6.value)));
  let sortedLiterals = [
    .../* @__PURE__ */ new Set([
      ...allPartsLiterals,
      ...pluralPartsLiterals
    ])
  ].sort((a3, b2) => b2.length - a3.length);
  let literals = sortedLiterals.length === 0 ? new RegExp("[\\p{White_Space}]", "gu") : new RegExp(`${sortedLiterals.join("|")}|[\\p{White_Space}]`, "gu");
  let numerals = [
    ...new Intl.NumberFormat(intlOptions.locale, {
      useGrouping: false
    }).format(9876543210)
  ].reverse();
  let indexes = new Map(numerals.map((d5, i6) => [
    d5,
    i6
  ]));
  let numeral = new RegExp(`[${numerals.join("")}]`, "g");
  let index3 = (d5) => String(indexes.get(d5));
  return {
    minusSign,
    plusSign,
    decimal,
    group,
    literals,
    numeral,
    index: index3
  };
}
function $6c7bd7858deea686$var$replaceAll(str, find2, replace2) {
  if (str.replaceAll)
    return str.replaceAll(find2, replace2);
  return str.split(find2).join(replace2);
}
function $6c7bd7858deea686$var$escapeRegex(string3) {
  return string3.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

// node_modules/@react-aria/i18n/dist/real-module.mjs
var $148a7a147e38ea7f$var$RTL_SCRIPTS = /* @__PURE__ */ new Set([
  "Arab",
  "Syrc",
  "Samr",
  "Mand",
  "Thaa",
  "Mend",
  "Nkoo",
  "Adlm",
  "Rohg",
  "Hebr"
]);
var $148a7a147e38ea7f$var$RTL_LANGS = /* @__PURE__ */ new Set([
  "ae",
  "ar",
  "arc",
  "bcc",
  "bqi",
  "ckb",
  "dv",
  "fa",
  "glk",
  "he",
  "ku",
  "mzn",
  "nqo",
  "pnb",
  "ps",
  "sd",
  "ug",
  "ur",
  "yi"
]);
function $148a7a147e38ea7f$export$702d680b21cbd764(localeString) {
  if (Intl.Locale) {
    let locale = new Intl.Locale(localeString).maximize();
    let textInfo = typeof locale.getTextInfo === "function" ? locale.getTextInfo() : locale.textInfo;
    if (textInfo)
      return textInfo.direction === "rtl";
    if (locale.script)
      return $148a7a147e38ea7f$var$RTL_SCRIPTS.has(locale.script);
  }
  let lang = localeString.split("-")[0];
  return $148a7a147e38ea7f$var$RTL_LANGS.has(lang);
}
var $1e5a04cdaf7d1af8$var$localeSymbol = Symbol.for("react-aria.i18n.locale");
function $1e5a04cdaf7d1af8$export$f09106e7c6677ec5() {
  let locale = typeof window !== "undefined" && window[$1e5a04cdaf7d1af8$var$localeSymbol] || typeof navigator !== "undefined" && (navigator.language || navigator.userLanguage) || "en-US";
  try {
    Intl.DateTimeFormat.supportedLocalesOf([
      locale
    ]);
  } catch (_err) {
    locale = "en-US";
  }
  return {
    locale,
    direction: (0, $148a7a147e38ea7f$export$702d680b21cbd764)(locale) ? "rtl" : "ltr"
  };
}
var $1e5a04cdaf7d1af8$var$currentLocale = $1e5a04cdaf7d1af8$export$f09106e7c6677ec5();
var $1e5a04cdaf7d1af8$var$listeners = /* @__PURE__ */ new Set();
function $1e5a04cdaf7d1af8$var$updateLocale() {
  $1e5a04cdaf7d1af8$var$currentLocale = $1e5a04cdaf7d1af8$export$f09106e7c6677ec5();
  for (let listener of $1e5a04cdaf7d1af8$var$listeners)
    listener($1e5a04cdaf7d1af8$var$currentLocale);
}
function $1e5a04cdaf7d1af8$export$188ec29ebc2bdc3a() {
  let isSSR = (0, $b5e257d569688ac6$export$535bd6ca7f90a273)();
  let [defaultLocale, setDefaultLocale] = (0, import_react12.useState)($1e5a04cdaf7d1af8$var$currentLocale);
  (0, import_react12.useEffect)(() => {
    if ($1e5a04cdaf7d1af8$var$listeners.size === 0)
      window.addEventListener("languagechange", $1e5a04cdaf7d1af8$var$updateLocale);
    $1e5a04cdaf7d1af8$var$listeners.add(setDefaultLocale);
    return () => {
      $1e5a04cdaf7d1af8$var$listeners.delete(setDefaultLocale);
      if ($1e5a04cdaf7d1af8$var$listeners.size === 0)
        window.removeEventListener("languagechange", $1e5a04cdaf7d1af8$var$updateLocale);
    };
  }, []);
  if (isSSR)
    return {
      locale: "en-US",
      direction: "ltr"
    };
  return defaultLocale;
}
var $18f2051aff69b9bf$var$I18nContext = (0, import_react12.default).createContext(null);
function $18f2051aff69b9bf$export$a54013f0d02a8f82(props) {
  let { locale, children } = props;
  let defaultLocale = (0, $1e5a04cdaf7d1af8$export$188ec29ebc2bdc3a)();
  let value2 = locale ? {
    locale,
    direction: (0, $148a7a147e38ea7f$export$702d680b21cbd764)(locale) ? "rtl" : "ltr"
  } : defaultLocale;
  return (0, import_react12.default).createElement($18f2051aff69b9bf$var$I18nContext.Provider, {
    value: value2
  }, children);
}
function $18f2051aff69b9bf$export$43bb16f9c6d9e3f7() {
  let defaultLocale = (0, $1e5a04cdaf7d1af8$export$188ec29ebc2bdc3a)();
  let context = (0, import_react12.useContext)($18f2051aff69b9bf$var$I18nContext);
  return context || defaultLocale;
}
var $fca6afa0e843324b$var$cache = /* @__PURE__ */ new WeakMap();
function $fca6afa0e843324b$var$getCachedDictionary(strings) {
  let dictionary = $fca6afa0e843324b$var$cache.get(strings);
  if (!dictionary) {
    dictionary = new (0, $5b160d28a433310d$export$c17fa47878dc55b6)(strings);
    $fca6afa0e843324b$var$cache.set(strings, dictionary);
  }
  return dictionary;
}
function $fca6afa0e843324b$export$87b761675e8eaa10(strings, packageName) {
  return packageName && (0, $5b160d28a433310d$export$c17fa47878dc55b6).getGlobalDictionaryForPackage(packageName) || $fca6afa0e843324b$var$getCachedDictionary(strings);
}
function $fca6afa0e843324b$export$f12b703ca79dfbb1(strings, packageName) {
  let { locale } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let dictionary = $fca6afa0e843324b$export$87b761675e8eaa10(strings, packageName);
  return (0, import_react12.useMemo)(() => new (0, $6db58dc88e78b024$export$2f817fcdc4b89ae0)(locale, dictionary), [
    locale,
    dictionary
  ]);
}
function $a916eb452884faea$export$b7a616150fdb9f44(options = {}) {
  let { locale } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  return (0, import_react12.useMemo)(() => new (0, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(locale, options), [
    locale,
    options
  ]);
}
var $325a3faab7a68acd$var$cache = /* @__PURE__ */ new Map();
function $325a3faab7a68acd$export$a16aca283550c30d(options) {
  let { locale } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let cacheKey = locale + (options ? Object.entries(options).sort((a3, b2) => a3[0] < b2[0] ? -1 : 1).join() : "");
  if ($325a3faab7a68acd$var$cache.has(cacheKey))
    return $325a3faab7a68acd$var$cache.get(cacheKey);
  let formatter = new Intl.Collator(locale, options);
  $325a3faab7a68acd$var$cache.set(cacheKey, formatter);
  return formatter;
}
function $bb77f239b46e8c72$export$3274cf84b703fff(options) {
  let collator = (0, $325a3faab7a68acd$export$a16aca283550c30d)({
    usage: "search",
    ...options
  });
  let startsWith4 = (0, import_react12.useCallback)((string3, substring) => {
    if (substring.length === 0)
      return true;
    string3 = string3.normalize("NFC");
    substring = substring.normalize("NFC");
    return collator.compare(string3.slice(0, substring.length), substring) === 0;
  }, [
    collator
  ]);
  let endsWith = (0, import_react12.useCallback)((string3, substring) => {
    if (substring.length === 0)
      return true;
    string3 = string3.normalize("NFC");
    substring = substring.normalize("NFC");
    return collator.compare(string3.slice(-substring.length), substring) === 0;
  }, [
    collator
  ]);
  let contains = (0, import_react12.useCallback)((string3, substring) => {
    if (substring.length === 0)
      return true;
    string3 = string3.normalize("NFC");
    substring = substring.normalize("NFC");
    let scan = 0;
    let sliceLen = substring.length;
    for (; scan + sliceLen <= string3.length; scan++) {
      let slice2 = string3.slice(scan, scan + sliceLen);
      if (collator.compare(substring, slice2) === 0)
        return true;
    }
    return false;
  }, [
    collator
  ]);
  return (0, import_react12.useMemo)(() => ({
    startsWith: startsWith4,
    endsWith,
    contains
  }), [
    startsWith4,
    endsWith,
    contains
  ]);
}

// node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d5, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d6, b3) {
    d6.__proto__ = b3;
  } || function(d6, b3) {
    for (var p5 in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p5))
        d6[p5] = b3[p5];
  };
  return extendStatics(d5, b2);
};
function __extends(d5, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d5, b2);
  function __() {
    this.constructor = d5;
  }
  d5.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t5) {
    for (var s4, i6 = 1, n6 = arguments.length; i6 < n6; i6++) {
      s4 = arguments[i6];
      for (var p5 in s4)
        if (Object.prototype.hasOwnProperty.call(s4, p5))
          t5[p5] = s4[p5];
    }
    return t5;
  };
  return __assign.apply(this, arguments);
};
function __rest(s4, e6) {
  var t5 = {};
  for (var p5 in s4)
    if (Object.prototype.hasOwnProperty.call(s4, p5) && e6.indexOf(p5) < 0)
      t5[p5] = s4[p5];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i6 = 0, p5 = Object.getOwnPropertySymbols(s4); i6 < p5.length; i6++) {
      if (e6.indexOf(p5[i6]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p5[i6]))
        t5[p5[i6]] = s4[p5[i6]];
    }
  return t5;
}
function __spreadArray(to, from4, pack) {
  if (pack || arguments.length === 2)
    for (var i6 = 0, l7 = from4.length, ar; i6 < l7; i6++) {
      if (ar || !(i6 in from4)) {
        if (!ar)
          ar = Array.prototype.slice.call(from4, 0, i6);
        ar[i6] = from4[i6];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from4));
}

// node_modules/@formatjs/icu-messageformat-parser/lib/error.js
var ErrorKind;
(function(ErrorKind2) {
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_CLOSING_BRACE"] = 1] = "EXPECT_ARGUMENT_CLOSING_BRACE";
  ErrorKind2[ErrorKind2["EMPTY_ARGUMENT"] = 2] = "EMPTY_ARGUMENT";
  ErrorKind2[ErrorKind2["MALFORMED_ARGUMENT"] = 3] = "MALFORMED_ARGUMENT";
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_TYPE"] = 4] = "EXPECT_ARGUMENT_TYPE";
  ErrorKind2[ErrorKind2["INVALID_ARGUMENT_TYPE"] = 5] = "INVALID_ARGUMENT_TYPE";
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_STYLE"] = 6] = "EXPECT_ARGUMENT_STYLE";
  ErrorKind2[ErrorKind2["INVALID_NUMBER_SKELETON"] = 7] = "INVALID_NUMBER_SKELETON";
  ErrorKind2[ErrorKind2["INVALID_DATE_TIME_SKELETON"] = 8] = "INVALID_DATE_TIME_SKELETON";
  ErrorKind2[ErrorKind2["EXPECT_NUMBER_SKELETON"] = 9] = "EXPECT_NUMBER_SKELETON";
  ErrorKind2[ErrorKind2["EXPECT_DATE_TIME_SKELETON"] = 10] = "EXPECT_DATE_TIME_SKELETON";
  ErrorKind2[ErrorKind2["UNCLOSED_QUOTE_IN_ARGUMENT_STYLE"] = 11] = "UNCLOSED_QUOTE_IN_ARGUMENT_STYLE";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_OPTIONS"] = 12] = "EXPECT_SELECT_ARGUMENT_OPTIONS";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE"] = 13] = "EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE";
  ErrorKind2[ErrorKind2["INVALID_PLURAL_ARGUMENT_OFFSET_VALUE"] = 14] = "INVALID_PLURAL_ARGUMENT_OFFSET_VALUE";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_SELECTOR"] = 15] = "EXPECT_SELECT_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_SELECTOR"] = 16] = "EXPECT_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT"] = 17] = "EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT"] = 18] = "EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT";
  ErrorKind2[ErrorKind2["INVALID_PLURAL_ARGUMENT_SELECTOR"] = 19] = "INVALID_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["DUPLICATE_PLURAL_ARGUMENT_SELECTOR"] = 20] = "DUPLICATE_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["DUPLICATE_SELECT_ARGUMENT_SELECTOR"] = 21] = "DUPLICATE_SELECT_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["MISSING_OTHER_CLAUSE"] = 22] = "MISSING_OTHER_CLAUSE";
  ErrorKind2[ErrorKind2["INVALID_TAG"] = 23] = "INVALID_TAG";
  ErrorKind2[ErrorKind2["INVALID_TAG_NAME"] = 25] = "INVALID_TAG_NAME";
  ErrorKind2[ErrorKind2["UNMATCHED_CLOSING_TAG"] = 26] = "UNMATCHED_CLOSING_TAG";
  ErrorKind2[ErrorKind2["UNCLOSED_TAG"] = 27] = "UNCLOSED_TAG";
})(ErrorKind || (ErrorKind = {}));

// node_modules/@formatjs/icu-messageformat-parser/lib/types.js
var TYPE;
(function(TYPE2) {
  TYPE2[TYPE2["literal"] = 0] = "literal";
  TYPE2[TYPE2["argument"] = 1] = "argument";
  TYPE2[TYPE2["number"] = 2] = "number";
  TYPE2[TYPE2["date"] = 3] = "date";
  TYPE2[TYPE2["time"] = 4] = "time";
  TYPE2[TYPE2["select"] = 5] = "select";
  TYPE2[TYPE2["plural"] = 6] = "plural";
  TYPE2[TYPE2["pound"] = 7] = "pound";
  TYPE2[TYPE2["tag"] = 8] = "tag";
})(TYPE || (TYPE = {}));
var SKELETON_TYPE;
(function(SKELETON_TYPE2) {
  SKELETON_TYPE2[SKELETON_TYPE2["number"] = 0] = "number";
  SKELETON_TYPE2[SKELETON_TYPE2["dateTime"] = 1] = "dateTime";
})(SKELETON_TYPE || (SKELETON_TYPE = {}));
function isLiteralElement(el) {
  return el.type === TYPE.literal;
}
function isArgumentElement(el) {
  return el.type === TYPE.argument;
}
function isNumberElement(el) {
  return el.type === TYPE.number;
}
function isDateElement(el) {
  return el.type === TYPE.date;
}
function isTimeElement(el) {
  return el.type === TYPE.time;
}
function isSelectElement(el) {
  return el.type === TYPE.select;
}
function isPluralElement(el) {
  return el.type === TYPE.plural;
}
function isPoundElement(el) {
  return el.type === TYPE.pound;
}
function isTagElement(el) {
  return el.type === TYPE.tag;
}
function isNumberSkeleton(el) {
  return !!(el && typeof el === "object" && el.type === SKELETON_TYPE.number);
}
function isDateTimeSkeleton(el) {
  return !!(el && typeof el === "object" && el.type === SKELETON_TYPE.dateTime);
}

// node_modules/@formatjs/icu-messageformat-parser/lib/regex.generated.js
var SPACE_SEPARATOR_REGEX = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;

// node_modules/@formatjs/icu-skeleton-parser/lib/date-time.js
var DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
function parseDateTimeSkeleton(skeleton) {
  var result = {};
  skeleton.replace(DATE_TIME_REGEX, function(match3) {
    var len = match3.length;
    switch (match3[0]) {
      case "G":
        result.era = len === 4 ? "long" : len === 5 ? "narrow" : "short";
        break;
      case "y":
        result.year = len === 2 ? "2-digit" : "numeric";
        break;
      case "Y":
      case "u":
      case "U":
      case "r":
        throw new RangeError("`Y/u/U/r` (year) patterns are not supported, use `y` instead");
      case "q":
      case "Q":
        throw new RangeError("`q/Q` (quarter) patterns are not supported");
      case "M":
      case "L":
        result.month = ["numeric", "2-digit", "short", "long", "narrow"][len - 1];
        break;
      case "w":
      case "W":
        throw new RangeError("`w/W` (week) patterns are not supported");
      case "d":
        result.day = ["numeric", "2-digit"][len - 1];
        break;
      case "D":
      case "F":
      case "g":
        throw new RangeError("`D/F/g` (day) patterns are not supported, use `d` instead");
      case "E":
        result.weekday = len === 4 ? "long" : len === 5 ? "narrow" : "short";
        break;
      case "e":
        if (len < 4) {
          throw new RangeError("`e..eee` (weekday) patterns are not supported");
        }
        result.weekday = ["short", "long", "narrow", "short"][len - 4];
        break;
      case "c":
        if (len < 4) {
          throw new RangeError("`c..ccc` (weekday) patterns are not supported");
        }
        result.weekday = ["short", "long", "narrow", "short"][len - 4];
        break;
      case "a":
        result.hour12 = true;
        break;
      case "b":
      case "B":
        throw new RangeError("`b/B` (period) patterns are not supported, use `a` instead");
      case "h":
        result.hourCycle = "h12";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "H":
        result.hourCycle = "h23";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "K":
        result.hourCycle = "h11";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "k":
        result.hourCycle = "h24";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "j":
      case "J":
      case "C":
        throw new RangeError("`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead");
      case "m":
        result.minute = ["numeric", "2-digit"][len - 1];
        break;
      case "s":
        result.second = ["numeric", "2-digit"][len - 1];
        break;
      case "S":
      case "A":
        throw new RangeError("`S/A` (second) patterns are not supported, use `s` instead");
      case "z":
        result.timeZoneName = len < 4 ? "short" : "long";
        break;
      case "Z":
      case "O":
      case "v":
      case "V":
      case "X":
      case "x":
        throw new RangeError("`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead");
    }
    return "";
  });
  return result;
}

// node_modules/@formatjs/icu-skeleton-parser/lib/regex.generated.js
var WHITE_SPACE_REGEX = /[\t-\r \x85\u200E\u200F\u2028\u2029]/i;

// node_modules/@formatjs/icu-skeleton-parser/lib/number.js
function parseNumberSkeletonFromString(skeleton) {
  if (skeleton.length === 0) {
    throw new Error("Number skeleton cannot be empty");
  }
  var stringTokens = skeleton.split(WHITE_SPACE_REGEX).filter(function(x4) {
    return x4.length > 0;
  });
  var tokens = [];
  for (var _i = 0, stringTokens_1 = stringTokens; _i < stringTokens_1.length; _i++) {
    var stringToken = stringTokens_1[_i];
    var stemAndOptions = stringToken.split("/");
    if (stemAndOptions.length === 0) {
      throw new Error("Invalid number skeleton");
    }
    var stem = stemAndOptions[0], options = stemAndOptions.slice(1);
    for (var _a3 = 0, options_1 = options; _a3 < options_1.length; _a3++) {
      var option = options_1[_a3];
      if (option.length === 0) {
        throw new Error("Invalid number skeleton");
      }
    }
    tokens.push({ stem, options });
  }
  return tokens;
}
function icuUnitToEcma(unit) {
  return unit.replace(/^(.*?)-/, "");
}
var FRACTION_PRECISION_REGEX = /^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g;
var SIGNIFICANT_PRECISION_REGEX = /^(@+)?(\+|#+)?[rs]?$/g;
var INTEGER_WIDTH_REGEX = /(\*)(0+)|(#+)(0+)|(0+)/g;
var CONCISE_INTEGER_WIDTH_REGEX = /^(0+)$/;
function parseSignificantPrecision(str) {
  var result = {};
  if (str[str.length - 1] === "r") {
    result.roundingPriority = "morePrecision";
  } else if (str[str.length - 1] === "s") {
    result.roundingPriority = "lessPrecision";
  }
  str.replace(SIGNIFICANT_PRECISION_REGEX, function(_2, g1, g22) {
    if (typeof g22 !== "string") {
      result.minimumSignificantDigits = g1.length;
      result.maximumSignificantDigits = g1.length;
    } else if (g22 === "+") {
      result.minimumSignificantDigits = g1.length;
    } else if (g1[0] === "#") {
      result.maximumSignificantDigits = g1.length;
    } else {
      result.minimumSignificantDigits = g1.length;
      result.maximumSignificantDigits = g1.length + (typeof g22 === "string" ? g22.length : 0);
    }
    return "";
  });
  return result;
}
function parseSign(str) {
  switch (str) {
    case "sign-auto":
      return {
        signDisplay: "auto"
      };
    case "sign-accounting":
    case "()":
      return {
        currencySign: "accounting"
      };
    case "sign-always":
    case "+!":
      return {
        signDisplay: "always"
      };
    case "sign-accounting-always":
    case "()!":
      return {
        signDisplay: "always",
        currencySign: "accounting"
      };
    case "sign-except-zero":
    case "+?":
      return {
        signDisplay: "exceptZero"
      };
    case "sign-accounting-except-zero":
    case "()?":
      return {
        signDisplay: "exceptZero",
        currencySign: "accounting"
      };
    case "sign-never":
    case "+_":
      return {
        signDisplay: "never"
      };
  }
}
function parseConciseScientificAndEngineeringStem(stem) {
  var result;
  if (stem[0] === "E" && stem[1] === "E") {
    result = {
      notation: "engineering"
    };
    stem = stem.slice(2);
  } else if (stem[0] === "E") {
    result = {
      notation: "scientific"
    };
    stem = stem.slice(1);
  }
  if (result) {
    var signDisplay = stem.slice(0, 2);
    if (signDisplay === "+!") {
      result.signDisplay = "always";
      stem = stem.slice(2);
    } else if (signDisplay === "+?") {
      result.signDisplay = "exceptZero";
      stem = stem.slice(2);
    }
    if (!CONCISE_INTEGER_WIDTH_REGEX.test(stem)) {
      throw new Error("Malformed concise eng/scientific notation");
    }
    result.minimumIntegerDigits = stem.length;
  }
  return result;
}
function parseNotationOptions(opt) {
  var result = {};
  var signOpts = parseSign(opt);
  if (signOpts) {
    return signOpts;
  }
  return result;
}
function parseNumberSkeleton(tokens) {
  var result = {};
  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
    var token2 = tokens_1[_i];
    switch (token2.stem) {
      case "percent":
      case "%":
        result.style = "percent";
        continue;
      case "%x100":
        result.style = "percent";
        result.scale = 100;
        continue;
      case "currency":
        result.style = "currency";
        result.currency = token2.options[0];
        continue;
      case "group-off":
      case ",_":
        result.useGrouping = false;
        continue;
      case "precision-integer":
      case ".":
        result.maximumFractionDigits = 0;
        continue;
      case "measure-unit":
      case "unit":
        result.style = "unit";
        result.unit = icuUnitToEcma(token2.options[0]);
        continue;
      case "compact-short":
      case "K":
        result.notation = "compact";
        result.compactDisplay = "short";
        continue;
      case "compact-long":
      case "KK":
        result.notation = "compact";
        result.compactDisplay = "long";
        continue;
      case "scientific":
        result = __assign(__assign(__assign({}, result), { notation: "scientific" }), token2.options.reduce(function(all3, opt2) {
          return __assign(__assign({}, all3), parseNotationOptions(opt2));
        }, {}));
        continue;
      case "engineering":
        result = __assign(__assign(__assign({}, result), { notation: "engineering" }), token2.options.reduce(function(all3, opt2) {
          return __assign(__assign({}, all3), parseNotationOptions(opt2));
        }, {}));
        continue;
      case "notation-simple":
        result.notation = "standard";
        continue;
      case "unit-width-narrow":
        result.currencyDisplay = "narrowSymbol";
        result.unitDisplay = "narrow";
        continue;
      case "unit-width-short":
        result.currencyDisplay = "code";
        result.unitDisplay = "short";
        continue;
      case "unit-width-full-name":
        result.currencyDisplay = "name";
        result.unitDisplay = "long";
        continue;
      case "unit-width-iso-code":
        result.currencyDisplay = "symbol";
        continue;
      case "scale":
        result.scale = parseFloat(token2.options[0]);
        continue;
      case "rounding-mode-floor":
        result.roundingMode = "floor";
        continue;
      case "rounding-mode-ceiling":
        result.roundingMode = "ceil";
        continue;
      case "rounding-mode-down":
        result.roundingMode = "trunc";
        continue;
      case "rounding-mode-up":
        result.roundingMode = "expand";
        continue;
      case "rounding-mode-half-even":
        result.roundingMode = "halfEven";
        continue;
      case "rounding-mode-half-down":
        result.roundingMode = "halfTrunc";
        continue;
      case "rounding-mode-half-up":
        result.roundingMode = "halfExpand";
        continue;
      case "integer-width":
        if (token2.options.length > 1) {
          throw new RangeError("integer-width stems only accept a single optional option");
        }
        token2.options[0].replace(INTEGER_WIDTH_REGEX, function(_2, g1, g22, g32, g4, g5) {
          if (g1) {
            result.minimumIntegerDigits = g22.length;
          } else if (g32 && g4) {
            throw new Error("We currently do not support maximum integer digits");
          } else if (g5) {
            throw new Error("We currently do not support exact integer digits");
          }
          return "";
        });
        continue;
    }
    if (CONCISE_INTEGER_WIDTH_REGEX.test(token2.stem)) {
      result.minimumIntegerDigits = token2.stem.length;
      continue;
    }
    if (FRACTION_PRECISION_REGEX.test(token2.stem)) {
      if (token2.options.length > 1) {
        throw new RangeError("Fraction-precision stems only accept a single optional option");
      }
      token2.stem.replace(FRACTION_PRECISION_REGEX, function(_2, g1, g22, g32, g4, g5) {
        if (g22 === "*") {
          result.minimumFractionDigits = g1.length;
        } else if (g32 && g32[0] === "#") {
          result.maximumFractionDigits = g32.length;
        } else if (g4 && g5) {
          result.minimumFractionDigits = g4.length;
          result.maximumFractionDigits = g4.length + g5.length;
        } else {
          result.minimumFractionDigits = g1.length;
          result.maximumFractionDigits = g1.length;
        }
        return "";
      });
      var opt = token2.options[0];
      if (opt === "w") {
        result = __assign(__assign({}, result), { trailingZeroDisplay: "stripIfInteger" });
      } else if (opt) {
        result = __assign(__assign({}, result), parseSignificantPrecision(opt));
      }
      continue;
    }
    if (SIGNIFICANT_PRECISION_REGEX.test(token2.stem)) {
      result = __assign(__assign({}, result), parseSignificantPrecision(token2.stem));
      continue;
    }
    var signOpts = parseSign(token2.stem);
    if (signOpts) {
      result = __assign(__assign({}, result), signOpts);
    }
    var conciseScientificAndEngineeringOpts = parseConciseScientificAndEngineeringStem(token2.stem);
    if (conciseScientificAndEngineeringOpts) {
      result = __assign(__assign({}, result), conciseScientificAndEngineeringOpts);
    }
  }
  return result;
}

// node_modules/@formatjs/icu-messageformat-parser/lib/time-data.generated.js
var timeData = {
  "001": [
    "H",
    "h"
  ],
  "AC": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "AD": [
    "H",
    "hB"
  ],
  "AE": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "AF": [
    "H",
    "hb",
    "hB",
    "h"
  ],
  "AG": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "AI": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "AL": [
    "h",
    "H",
    "hB"
  ],
  "AM": [
    "H",
    "hB"
  ],
  "AO": [
    "H",
    "hB"
  ],
  "AR": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "AS": [
    "h",
    "H"
  ],
  "AT": [
    "H",
    "hB"
  ],
  "AU": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "AW": [
    "H",
    "hB"
  ],
  "AX": [
    "H"
  ],
  "AZ": [
    "H",
    "hB",
    "h"
  ],
  "BA": [
    "H",
    "hB",
    "h"
  ],
  "BB": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "BD": [
    "h",
    "hB",
    "H"
  ],
  "BE": [
    "H",
    "hB"
  ],
  "BF": [
    "H",
    "hB"
  ],
  "BG": [
    "H",
    "hB",
    "h"
  ],
  "BH": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "BI": [
    "H",
    "h"
  ],
  "BJ": [
    "H",
    "hB"
  ],
  "BL": [
    "H",
    "hB"
  ],
  "BM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "BN": [
    "hb",
    "hB",
    "h",
    "H"
  ],
  "BO": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "BQ": [
    "H"
  ],
  "BR": [
    "H",
    "hB"
  ],
  "BS": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "BT": [
    "h",
    "H"
  ],
  "BW": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "BY": [
    "H",
    "h"
  ],
  "BZ": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CA": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "CC": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CD": [
    "hB",
    "H"
  ],
  "CF": [
    "H",
    "h",
    "hB"
  ],
  "CG": [
    "H",
    "hB"
  ],
  "CH": [
    "H",
    "hB",
    "h"
  ],
  "CI": [
    "H",
    "hB"
  ],
  "CK": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CL": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "CM": [
    "H",
    "h",
    "hB"
  ],
  "CN": [
    "H",
    "hB",
    "hb",
    "h"
  ],
  "CO": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "CP": [
    "H"
  ],
  "CR": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "CU": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "CV": [
    "H",
    "hB"
  ],
  "CW": [
    "H",
    "hB"
  ],
  "CX": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CY": [
    "h",
    "H",
    "hb",
    "hB"
  ],
  "CZ": [
    "H"
  ],
  "DE": [
    "H",
    "hB"
  ],
  "DG": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "DJ": [
    "h",
    "H"
  ],
  "DK": [
    "H"
  ],
  "DM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "DO": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "DZ": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "EA": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "EC": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "EE": [
    "H",
    "hB"
  ],
  "EG": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "EH": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "ER": [
    "h",
    "H"
  ],
  "ES": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "ET": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "FI": [
    "H"
  ],
  "FJ": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "FK": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "FM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "FO": [
    "H",
    "h"
  ],
  "FR": [
    "H",
    "hB"
  ],
  "GA": [
    "H",
    "hB"
  ],
  "GB": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "GD": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "GE": [
    "H",
    "hB",
    "h"
  ],
  "GF": [
    "H",
    "hB"
  ],
  "GG": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "GH": [
    "h",
    "H"
  ],
  "GI": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "GL": [
    "H",
    "h"
  ],
  "GM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "GN": [
    "H",
    "hB"
  ],
  "GP": [
    "H",
    "hB"
  ],
  "GQ": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "GR": [
    "h",
    "H",
    "hb",
    "hB"
  ],
  "GT": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "GU": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "GW": [
    "H",
    "hB"
  ],
  "GY": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "HK": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "HN": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "HR": [
    "H",
    "hB"
  ],
  "HU": [
    "H",
    "h"
  ],
  "IC": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "ID": [
    "H"
  ],
  "IE": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "IL": [
    "H",
    "hB"
  ],
  "IM": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "IN": [
    "h",
    "H"
  ],
  "IO": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "IQ": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "IR": [
    "hB",
    "H"
  ],
  "IS": [
    "H"
  ],
  "IT": [
    "H",
    "hB"
  ],
  "JE": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "JM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "JO": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "JP": [
    "H",
    "K",
    "h"
  ],
  "KE": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "KG": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "KH": [
    "hB",
    "h",
    "H",
    "hb"
  ],
  "KI": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "KM": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "KN": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "KP": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "KR": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "KW": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "KY": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "KZ": [
    "H",
    "hB"
  ],
  "LA": [
    "H",
    "hb",
    "hB",
    "h"
  ],
  "LB": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "LC": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "LI": [
    "H",
    "hB",
    "h"
  ],
  "LK": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "LR": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "LS": [
    "h",
    "H"
  ],
  "LT": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "LU": [
    "H",
    "h",
    "hB"
  ],
  "LV": [
    "H",
    "hB",
    "hb",
    "h"
  ],
  "LY": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "MA": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "MC": [
    "H",
    "hB"
  ],
  "MD": [
    "H",
    "hB"
  ],
  "ME": [
    "H",
    "hB",
    "h"
  ],
  "MF": [
    "H",
    "hB"
  ],
  "MG": [
    "H",
    "h"
  ],
  "MH": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "MK": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "ML": [
    "H"
  ],
  "MM": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "MN": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "MO": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "MP": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "MQ": [
    "H",
    "hB"
  ],
  "MR": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "MS": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "MT": [
    "H",
    "h"
  ],
  "MU": [
    "H",
    "h"
  ],
  "MV": [
    "H",
    "h"
  ],
  "MW": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "MX": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "MY": [
    "hb",
    "hB",
    "h",
    "H"
  ],
  "MZ": [
    "H",
    "hB"
  ],
  "NA": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "NC": [
    "H",
    "hB"
  ],
  "NE": [
    "H"
  ],
  "NF": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NG": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NI": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "NL": [
    "H",
    "hB"
  ],
  "NO": [
    "H",
    "h"
  ],
  "NP": [
    "H",
    "h",
    "hB"
  ],
  "NR": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NU": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NZ": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "OM": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "PA": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "PE": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "PF": [
    "H",
    "h",
    "hB"
  ],
  "PG": [
    "h",
    "H"
  ],
  "PH": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "PK": [
    "h",
    "hB",
    "H"
  ],
  "PL": [
    "H",
    "h"
  ],
  "PM": [
    "H",
    "hB"
  ],
  "PN": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "PR": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "PS": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "PT": [
    "H",
    "hB"
  ],
  "PW": [
    "h",
    "H"
  ],
  "PY": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "QA": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "RE": [
    "H",
    "hB"
  ],
  "RO": [
    "H",
    "hB"
  ],
  "RS": [
    "H",
    "hB",
    "h"
  ],
  "RU": [
    "H"
  ],
  "RW": [
    "H",
    "h"
  ],
  "SA": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "SB": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "SC": [
    "H",
    "h",
    "hB"
  ],
  "SD": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "SE": [
    "H"
  ],
  "SG": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "SH": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "SI": [
    "H",
    "hB"
  ],
  "SJ": [
    "H"
  ],
  "SK": [
    "H"
  ],
  "SL": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "SM": [
    "H",
    "h",
    "hB"
  ],
  "SN": [
    "H",
    "h",
    "hB"
  ],
  "SO": [
    "h",
    "H"
  ],
  "SR": [
    "H",
    "hB"
  ],
  "SS": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "ST": [
    "H",
    "hB"
  ],
  "SV": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "SX": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "SY": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "SZ": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "TA": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "TC": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "TD": [
    "h",
    "H",
    "hB"
  ],
  "TF": [
    "H",
    "h",
    "hB"
  ],
  "TG": [
    "H",
    "hB"
  ],
  "TH": [
    "H",
    "h"
  ],
  "TJ": [
    "H",
    "h"
  ],
  "TL": [
    "H",
    "hB",
    "hb",
    "h"
  ],
  "TM": [
    "H",
    "h"
  ],
  "TN": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "TO": [
    "h",
    "H"
  ],
  "TR": [
    "H",
    "hB"
  ],
  "TT": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "TW": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "TZ": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "UA": [
    "H",
    "hB",
    "h"
  ],
  "UG": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "UM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "US": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "UY": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "UZ": [
    "H",
    "hB",
    "h"
  ],
  "VA": [
    "H",
    "h",
    "hB"
  ],
  "VC": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "VE": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "VG": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "VI": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "VN": [
    "H",
    "h"
  ],
  "VU": [
    "h",
    "H"
  ],
  "WF": [
    "H",
    "hB"
  ],
  "WS": [
    "h",
    "H"
  ],
  "XK": [
    "H",
    "hB",
    "h"
  ],
  "YE": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "YT": [
    "H",
    "hB"
  ],
  "ZA": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "ZM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "ZW": [
    "H",
    "h"
  ],
  "af-ZA": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "ar-001": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "ca-ES": [
    "H",
    "h",
    "hB"
  ],
  "en-001": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "es-BO": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-BR": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-EC": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-ES": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-GQ": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-PE": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "fr-CA": [
    "H",
    "h",
    "hB"
  ],
  "gl-ES": [
    "H",
    "h",
    "hB"
  ],
  "gu-IN": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "hi-IN": [
    "hB",
    "h",
    "H"
  ],
  "it-CH": [
    "H",
    "h",
    "hB"
  ],
  "it-IT": [
    "H",
    "h",
    "hB"
  ],
  "kn-IN": [
    "hB",
    "h",
    "H"
  ],
  "ml-IN": [
    "hB",
    "h",
    "H"
  ],
  "mr-IN": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "pa-IN": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "ta-IN": [
    "hB",
    "h",
    "hb",
    "H"
  ],
  "te-IN": [
    "hB",
    "h",
    "H"
  ],
  "zu-ZA": [
    "H",
    "hB",
    "hb",
    "h"
  ]
};

// node_modules/@formatjs/icu-messageformat-parser/lib/date-time-pattern-generator.js
function getBestPattern(skeleton, locale) {
  var skeletonCopy = "";
  for (var patternPos = 0; patternPos < skeleton.length; patternPos++) {
    var patternChar = skeleton.charAt(patternPos);
    if (patternChar === "j") {
      var extraLength = 0;
      while (patternPos + 1 < skeleton.length && skeleton.charAt(patternPos + 1) === patternChar) {
        extraLength++;
        patternPos++;
      }
      var hourLen = 1 + (extraLength & 1);
      var dayPeriodLen = extraLength < 2 ? 1 : 3 + (extraLength >> 1);
      var dayPeriodChar = "a";
      var hourChar = getDefaultHourSymbolFromLocale(locale);
      if (hourChar == "H" || hourChar == "k") {
        dayPeriodLen = 0;
      }
      while (dayPeriodLen-- > 0) {
        skeletonCopy += dayPeriodChar;
      }
      while (hourLen-- > 0) {
        skeletonCopy = hourChar + skeletonCopy;
      }
    } else if (patternChar === "J") {
      skeletonCopy += "H";
    } else {
      skeletonCopy += patternChar;
    }
  }
  return skeletonCopy;
}
function getDefaultHourSymbolFromLocale(locale) {
  var hourCycle = locale.hourCycle;
  if (hourCycle === void 0 && // @ts-ignore hourCycle(s) is not identified yet
  locale.hourCycles && // @ts-ignore
  locale.hourCycles.length) {
    hourCycle = locale.hourCycles[0];
  }
  if (hourCycle) {
    switch (hourCycle) {
      case "h24":
        return "k";
      case "h23":
        return "H";
      case "h12":
        return "h";
      case "h11":
        return "K";
      default:
        throw new Error("Invalid hourCycle");
    }
  }
  var languageTag = locale.language;
  var regionTag;
  if (languageTag !== "root") {
    regionTag = locale.maximize().region;
  }
  var hourCycles = timeData[regionTag || ""] || timeData[languageTag || ""] || timeData["".concat(languageTag, "-001")] || timeData["001"];
  return hourCycles[0];
}

// node_modules/@formatjs/icu-messageformat-parser/lib/parser.js
var _a;
var SPACE_SEPARATOR_START_REGEX = new RegExp("^".concat(SPACE_SEPARATOR_REGEX.source, "*"));
var SPACE_SEPARATOR_END_REGEX = new RegExp("".concat(SPACE_SEPARATOR_REGEX.source, "*$"));
function createLocation(start2, end) {
  return { start: start2, end };
}
var hasNativeStartsWith = !!String.prototype.startsWith && "_a".startsWith("a", 1);
var hasNativeFromCodePoint = !!String.fromCodePoint;
var hasNativeFromEntries = !!Object.fromEntries;
var hasNativeCodePointAt = !!String.prototype.codePointAt;
var hasTrimStart = !!String.prototype.trimStart;
var hasTrimEnd = !!String.prototype.trimEnd;
var hasNativeIsSafeInteger = !!Number.isSafeInteger;
var isSafeInteger = hasNativeIsSafeInteger ? Number.isSafeInteger : function(n6) {
  return typeof n6 === "number" && isFinite(n6) && Math.floor(n6) === n6 && Math.abs(n6) <= 9007199254740991;
};
var REGEX_SUPPORTS_U_AND_Y = true;
try {
  re = RE("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  REGEX_SUPPORTS_U_AND_Y = ((_a = re.exec("a")) === null || _a === void 0 ? void 0 : _a[0]) === "a";
} catch (_2) {
  REGEX_SUPPORTS_U_AND_Y = false;
}
var re;
var startsWith = hasNativeStartsWith ? (
  // Native
  function startsWith2(s4, search2, position3) {
    return s4.startsWith(search2, position3);
  }
) : (
  // For IE11
  function startsWith3(s4, search2, position3) {
    return s4.slice(position3, position3 + search2.length) === search2;
  }
);
var fromCodePoint2 = hasNativeFromCodePoint ? String.fromCodePoint : (
  // IE11
  function fromCodePoint3() {
    var codePoints = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      codePoints[_i] = arguments[_i];
    }
    var elements = "";
    var length4 = codePoints.length;
    var i6 = 0;
    var code3;
    while (length4 > i6) {
      code3 = codePoints[i6++];
      if (code3 > 1114111)
        throw RangeError(code3 + " is not a valid code point");
      elements += code3 < 65536 ? String.fromCharCode(code3) : String.fromCharCode(((code3 -= 65536) >> 10) + 55296, code3 % 1024 + 56320);
    }
    return elements;
  }
);
var fromEntries = (
  // native
  hasNativeFromEntries ? Object.fromEntries : (
    // Ponyfill
    function fromEntries2(entries2) {
      var obj = {};
      for (var _i = 0, entries_1 = entries2; _i < entries_1.length; _i++) {
        var _a3 = entries_1[_i], k2 = _a3[0], v6 = _a3[1];
        obj[k2] = v6;
      }
      return obj;
    }
  )
);
var codePointAt = hasNativeCodePointAt ? (
  // Native
  function codePointAt2(s4, index3) {
    return s4.codePointAt(index3);
  }
) : (
  // IE 11
  function codePointAt3(s4, index3) {
    var size3 = s4.length;
    if (index3 < 0 || index3 >= size3) {
      return void 0;
    }
    var first = s4.charCodeAt(index3);
    var second;
    return first < 55296 || first > 56319 || index3 + 1 === size3 || (second = s4.charCodeAt(index3 + 1)) < 56320 || second > 57343 ? first : (first - 55296 << 10) + (second - 56320) + 65536;
  }
);
var trimStart2 = hasTrimStart ? (
  // Native
  function trimStart3(s4) {
    return s4.trimStart();
  }
) : (
  // Ponyfill
  function trimStart4(s4) {
    return s4.replace(SPACE_SEPARATOR_START_REGEX, "");
  }
);
var trimEnd = hasTrimEnd ? (
  // Native
  function trimEnd2(s4) {
    return s4.trimEnd();
  }
) : (
  // Ponyfill
  function trimEnd3(s4) {
    return s4.replace(SPACE_SEPARATOR_END_REGEX, "");
  }
);
function RE(s4, flag) {
  return new RegExp(s4, flag);
}
var matchIdentifierAtIndex;
if (REGEX_SUPPORTS_U_AND_Y) {
  IDENTIFIER_PREFIX_RE_1 = RE("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  matchIdentifierAtIndex = function matchIdentifierAtIndex2(s4, index3) {
    var _a3;
    IDENTIFIER_PREFIX_RE_1.lastIndex = index3;
    var match3 = IDENTIFIER_PREFIX_RE_1.exec(s4);
    return (_a3 = match3[1]) !== null && _a3 !== void 0 ? _a3 : "";
  };
} else {
  matchIdentifierAtIndex = function matchIdentifierAtIndex2(s4, index3) {
    var match3 = [];
    while (true) {
      var c5 = codePointAt(s4, index3);
      if (c5 === void 0 || _isWhiteSpace(c5) || _isPatternSyntax(c5)) {
        break;
      }
      match3.push(c5);
      index3 += c5 >= 65536 ? 2 : 1;
    }
    return fromCodePoint2.apply(void 0, match3);
  };
}
var IDENTIFIER_PREFIX_RE_1;
var Parser = (
  /** @class */
  function() {
    function Parser3(message, options) {
      if (options === void 0) {
        options = {};
      }
      this.message = message;
      this.position = { offset: 0, line: 1, column: 1 };
      this.ignoreTag = !!options.ignoreTag;
      this.locale = options.locale;
      this.requiresOtherClause = !!options.requiresOtherClause;
      this.shouldParseSkeletons = !!options.shouldParseSkeletons;
    }
    Parser3.prototype.parse = function() {
      if (this.offset() !== 0) {
        throw Error("parser can only be used once");
      }
      return this.parseMessage(0, "", false);
    };
    Parser3.prototype.parseMessage = function(nestingLevel, parentArgType, expectingCloseTag) {
      var elements = [];
      while (!this.isEOF()) {
        var char2 = this.char();
        if (char2 === 123) {
          var result = this.parseArgument(nestingLevel, expectingCloseTag);
          if (result.err) {
            return result;
          }
          elements.push(result.val);
        } else if (char2 === 125 && nestingLevel > 0) {
          break;
        } else if (char2 === 35 && (parentArgType === "plural" || parentArgType === "selectordinal")) {
          var position3 = this.clonePosition();
          this.bump();
          elements.push({
            type: TYPE.pound,
            location: createLocation(position3, this.clonePosition())
          });
        } else if (char2 === 60 && !this.ignoreTag && this.peek() === 47) {
          if (expectingCloseTag) {
            break;
          } else {
            return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));
          }
        } else if (char2 === 60 && !this.ignoreTag && _isAlpha(this.peek() || 0)) {
          var result = this.parseTag(nestingLevel, parentArgType);
          if (result.err) {
            return result;
          }
          elements.push(result.val);
        } else {
          var result = this.parseLiteral(nestingLevel, parentArgType);
          if (result.err) {
            return result;
          }
          elements.push(result.val);
        }
      }
      return { val: elements, err: null };
    };
    Parser3.prototype.parseTag = function(nestingLevel, parentArgType) {
      var startPosition = this.clonePosition();
      this.bump();
      var tagName3 = this.parseTagName();
      this.bumpSpace();
      if (this.bumpIf("/>")) {
        return {
          val: {
            type: TYPE.literal,
            value: "<".concat(tagName3, "/>"),
            location: createLocation(startPosition, this.clonePosition())
          },
          err: null
        };
      } else if (this.bumpIf(">")) {
        var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);
        if (childrenResult.err) {
          return childrenResult;
        }
        var children = childrenResult.val;
        var endTagStartPosition = this.clonePosition();
        if (this.bumpIf("</")) {
          if (this.isEOF() || !_isAlpha(this.char())) {
            return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
          }
          var closingTagNameStartPosition = this.clonePosition();
          var closingTagName = this.parseTagName();
          if (tagName3 !== closingTagName) {
            return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));
          }
          this.bumpSpace();
          if (!this.bumpIf(">")) {
            return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
          }
          return {
            val: {
              type: TYPE.tag,
              value: tagName3,
              children,
              location: createLocation(startPosition, this.clonePosition())
            },
            err: null
          };
        } else {
          return this.error(ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));
        }
      } else {
        return this.error(ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));
      }
    };
    Parser3.prototype.parseTagName = function() {
      var startOffset = this.offset();
      this.bump();
      while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {
        this.bump();
      }
      return this.message.slice(startOffset, this.offset());
    };
    Parser3.prototype.parseLiteral = function(nestingLevel, parentArgType) {
      var start2 = this.clonePosition();
      var value2 = "";
      while (true) {
        var parseQuoteResult = this.tryParseQuote(parentArgType);
        if (parseQuoteResult) {
          value2 += parseQuoteResult;
          continue;
        }
        var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);
        if (parseUnquotedResult) {
          value2 += parseUnquotedResult;
          continue;
        }
        var parseLeftAngleResult = this.tryParseLeftAngleBracket();
        if (parseLeftAngleResult) {
          value2 += parseLeftAngleResult;
          continue;
        }
        break;
      }
      var location2 = createLocation(start2, this.clonePosition());
      return {
        val: { type: TYPE.literal, value: value2, location: location2 },
        err: null
      };
    };
    Parser3.prototype.tryParseLeftAngleBracket = function() {
      if (!this.isEOF() && this.char() === 60 && (this.ignoreTag || // If at the opening tag or closing tag position, bail.
      !_isAlphaOrSlash(this.peek() || 0))) {
        this.bump();
        return "<";
      }
      return null;
    };
    Parser3.prototype.tryParseQuote = function(parentArgType) {
      if (this.isEOF() || this.char() !== 39) {
        return null;
      }
      switch (this.peek()) {
        case 39:
          this.bump();
          this.bump();
          return "'";
        case 123:
        case 60:
        case 62:
        case 125:
          break;
        case 35:
          if (parentArgType === "plural" || parentArgType === "selectordinal") {
            break;
          }
          return null;
        default:
          return null;
      }
      this.bump();
      var codePoints = [this.char()];
      this.bump();
      while (!this.isEOF()) {
        var ch = this.char();
        if (ch === 39) {
          if (this.peek() === 39) {
            codePoints.push(39);
            this.bump();
          } else {
            this.bump();
            break;
          }
        } else {
          codePoints.push(ch);
        }
        this.bump();
      }
      return fromCodePoint2.apply(void 0, codePoints);
    };
    Parser3.prototype.tryParseUnquoted = function(nestingLevel, parentArgType) {
      if (this.isEOF()) {
        return null;
      }
      var ch = this.char();
      if (ch === 60 || ch === 123 || ch === 35 && (parentArgType === "plural" || parentArgType === "selectordinal") || ch === 125 && nestingLevel > 0) {
        return null;
      } else {
        this.bump();
        return fromCodePoint2(ch);
      }
    };
    Parser3.prototype.parseArgument = function(nestingLevel, expectingCloseTag) {
      var openingBracePosition = this.clonePosition();
      this.bump();
      this.bumpSpace();
      if (this.isEOF()) {
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
      }
      if (this.char() === 125) {
        this.bump();
        return this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
      }
      var value2 = this.parseIdentifierIfPossible().value;
      if (!value2) {
        return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
      }
      this.bumpSpace();
      if (this.isEOF()) {
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
      }
      switch (this.char()) {
        case 125: {
          this.bump();
          return {
            val: {
              type: TYPE.argument,
              // value does not include the opening and closing braces.
              value: value2,
              location: createLocation(openingBracePosition, this.clonePosition())
            },
            err: null
          };
        }
        case 44: {
          this.bump();
          this.bumpSpace();
          if (this.isEOF()) {
            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
          }
          return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value2, openingBracePosition);
        }
        default:
          return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
      }
    };
    Parser3.prototype.parseIdentifierIfPossible = function() {
      var startingPosition = this.clonePosition();
      var startOffset = this.offset();
      var value2 = matchIdentifierAtIndex(this.message, startOffset);
      var endOffset = startOffset + value2.length;
      this.bumpTo(endOffset);
      var endPosition = this.clonePosition();
      var location2 = createLocation(startingPosition, endPosition);
      return { value: value2, location: location2 };
    };
    Parser3.prototype.parseArgumentOptions = function(nestingLevel, expectingCloseTag, value2, openingBracePosition) {
      var _a3;
      var typeStartPosition = this.clonePosition();
      var argType = this.parseIdentifierIfPossible().value;
      var typeEndPosition = this.clonePosition();
      switch (argType) {
        case "":
          return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
        case "number":
        case "date":
        case "time": {
          this.bumpSpace();
          var styleAndLocation = null;
          if (this.bumpIf(",")) {
            this.bumpSpace();
            var styleStartPosition = this.clonePosition();
            var result = this.parseSimpleArgStyleIfPossible();
            if (result.err) {
              return result;
            }
            var style = trimEnd(result.val);
            if (style.length === 0) {
              return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));
            }
            var styleLocation = createLocation(styleStartPosition, this.clonePosition());
            styleAndLocation = { style, styleLocation };
          }
          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
          if (argCloseResult.err) {
            return argCloseResult;
          }
          var location_1 = createLocation(openingBracePosition, this.clonePosition());
          if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, "::", 0)) {
            var skeleton = trimStart2(styleAndLocation.style.slice(2));
            if (argType === "number") {
              var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);
              if (result.err) {
                return result;
              }
              return {
                val: { type: TYPE.number, value: value2, location: location_1, style: result.val },
                err: null
              };
            } else {
              if (skeleton.length === 0) {
                return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);
              }
              var dateTimePattern = skeleton;
              if (this.locale) {
                dateTimePattern = getBestPattern(skeleton, this.locale);
              }
              var style = {
                type: SKELETON_TYPE.dateTime,
                pattern: dateTimePattern,
                location: styleAndLocation.styleLocation,
                parsedOptions: this.shouldParseSkeletons ? parseDateTimeSkeleton(dateTimePattern) : {}
              };
              var type2 = argType === "date" ? TYPE.date : TYPE.time;
              return {
                val: { type: type2, value: value2, location: location_1, style },
                err: null
              };
            }
          }
          return {
            val: {
              type: argType === "number" ? TYPE.number : argType === "date" ? TYPE.date : TYPE.time,
              value: value2,
              location: location_1,
              style: (_a3 = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a3 !== void 0 ? _a3 : null
            },
            err: null
          };
        }
        case "plural":
        case "selectordinal":
        case "select": {
          var typeEndPosition_1 = this.clonePosition();
          this.bumpSpace();
          if (!this.bumpIf(",")) {
            return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, __assign({}, typeEndPosition_1)));
          }
          this.bumpSpace();
          var identifierAndLocation = this.parseIdentifierIfPossible();
          var pluralOffset = 0;
          if (argType !== "select" && identifierAndLocation.value === "offset") {
            if (!this.bumpIf(":")) {
              return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));
            }
            this.bumpSpace();
            var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);
            if (result.err) {
              return result;
            }
            this.bumpSpace();
            identifierAndLocation = this.parseIdentifierIfPossible();
            pluralOffset = result.val;
          }
          var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);
          if (optionsResult.err) {
            return optionsResult;
          }
          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
          if (argCloseResult.err) {
            return argCloseResult;
          }
          var location_2 = createLocation(openingBracePosition, this.clonePosition());
          if (argType === "select") {
            return {
              val: {
                type: TYPE.select,
                value: value2,
                options: fromEntries(optionsResult.val),
                location: location_2
              },
              err: null
            };
          } else {
            return {
              val: {
                type: TYPE.plural,
                value: value2,
                options: fromEntries(optionsResult.val),
                offset: pluralOffset,
                pluralType: argType === "plural" ? "cardinal" : "ordinal",
                location: location_2
              },
              err: null
            };
          }
        }
        default:
          return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
      }
    };
    Parser3.prototype.tryParseArgumentClose = function(openingBracePosition) {
      if (this.isEOF() || this.char() !== 125) {
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
      }
      this.bump();
      return { val: true, err: null };
    };
    Parser3.prototype.parseSimpleArgStyleIfPossible = function() {
      var nestedBraces = 0;
      var startPosition = this.clonePosition();
      while (!this.isEOF()) {
        var ch = this.char();
        switch (ch) {
          case 39: {
            this.bump();
            var apostrophePosition = this.clonePosition();
            if (!this.bumpUntil("'")) {
              return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));
            }
            this.bump();
            break;
          }
          case 123: {
            nestedBraces += 1;
            this.bump();
            break;
          }
          case 125: {
            if (nestedBraces > 0) {
              nestedBraces -= 1;
            } else {
              return {
                val: this.message.slice(startPosition.offset, this.offset()),
                err: null
              };
            }
            break;
          }
          default:
            this.bump();
            break;
        }
      }
      return {
        val: this.message.slice(startPosition.offset, this.offset()),
        err: null
      };
    };
    Parser3.prototype.parseNumberSkeletonFromString = function(skeleton, location2) {
      var tokens = [];
      try {
        tokens = parseNumberSkeletonFromString(skeleton);
      } catch (e6) {
        return this.error(ErrorKind.INVALID_NUMBER_SKELETON, location2);
      }
      return {
        val: {
          type: SKELETON_TYPE.number,
          tokens,
          location: location2,
          parsedOptions: this.shouldParseSkeletons ? parseNumberSkeleton(tokens) : {}
        },
        err: null
      };
    };
    Parser3.prototype.tryParsePluralOrSelectOptions = function(nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {
      var _a3;
      var hasOtherClause = false;
      var options = [];
      var parsedSelectors = /* @__PURE__ */ new Set();
      var selector = parsedFirstIdentifier.value, selectorLocation = parsedFirstIdentifier.location;
      while (true) {
        if (selector.length === 0) {
          var startPosition = this.clonePosition();
          if (parentArgType !== "select" && this.bumpIf("=")) {
            var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);
            if (result.err) {
              return result;
            }
            selectorLocation = createLocation(startPosition, this.clonePosition());
            selector = this.message.slice(startPosition.offset, this.offset());
          } else {
            break;
          }
        }
        if (parsedSelectors.has(selector)) {
          return this.error(parentArgType === "select" ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);
        }
        if (selector === "other") {
          hasOtherClause = true;
        }
        this.bumpSpace();
        var openingBracePosition = this.clonePosition();
        if (!this.bumpIf("{")) {
          return this.error(parentArgType === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));
        }
        var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);
        if (fragmentResult.err) {
          return fragmentResult;
        }
        var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
        if (argCloseResult.err) {
          return argCloseResult;
        }
        options.push([
          selector,
          {
            value: fragmentResult.val,
            location: createLocation(openingBracePosition, this.clonePosition())
          }
        ]);
        parsedSelectors.add(selector);
        this.bumpSpace();
        _a3 = this.parseIdentifierIfPossible(), selector = _a3.value, selectorLocation = _a3.location;
      }
      if (options.length === 0) {
        return this.error(parentArgType === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));
      }
      if (this.requiresOtherClause && !hasOtherClause) {
        return this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));
      }
      return { val: options, err: null };
    };
    Parser3.prototype.tryParseDecimalInteger = function(expectNumberError, invalidNumberError) {
      var sign2 = 1;
      var startingPosition = this.clonePosition();
      if (this.bumpIf("+")) {
      } else if (this.bumpIf("-")) {
        sign2 = -1;
      }
      var hasDigits = false;
      var decimal = 0;
      while (!this.isEOF()) {
        var ch = this.char();
        if (ch >= 48 && ch <= 57) {
          hasDigits = true;
          decimal = decimal * 10 + (ch - 48);
          this.bump();
        } else {
          break;
        }
      }
      var location2 = createLocation(startingPosition, this.clonePosition());
      if (!hasDigits) {
        return this.error(expectNumberError, location2);
      }
      decimal *= sign2;
      if (!isSafeInteger(decimal)) {
        return this.error(invalidNumberError, location2);
      }
      return { val: decimal, err: null };
    };
    Parser3.prototype.offset = function() {
      return this.position.offset;
    };
    Parser3.prototype.isEOF = function() {
      return this.offset() === this.message.length;
    };
    Parser3.prototype.clonePosition = function() {
      return {
        offset: this.position.offset,
        line: this.position.line,
        column: this.position.column
      };
    };
    Parser3.prototype.char = function() {
      var offset = this.position.offset;
      if (offset >= this.message.length) {
        throw Error("out of bound");
      }
      var code3 = codePointAt(this.message, offset);
      if (code3 === void 0) {
        throw Error("Offset ".concat(offset, " is at invalid UTF-16 code unit boundary"));
      }
      return code3;
    };
    Parser3.prototype.error = function(kind, location2) {
      return {
        val: null,
        err: {
          kind,
          message: this.message,
          location: location2
        }
      };
    };
    Parser3.prototype.bump = function() {
      if (this.isEOF()) {
        return;
      }
      var code3 = this.char();
      if (code3 === 10) {
        this.position.line += 1;
        this.position.column = 1;
        this.position.offset += 1;
      } else {
        this.position.column += 1;
        this.position.offset += code3 < 65536 ? 1 : 2;
      }
    };
    Parser3.prototype.bumpIf = function(prefix4) {
      if (startsWith(this.message, prefix4, this.offset())) {
        for (var i6 = 0; i6 < prefix4.length; i6++) {
          this.bump();
        }
        return true;
      }
      return false;
    };
    Parser3.prototype.bumpUntil = function(pattern) {
      var currentOffset = this.offset();
      var index3 = this.message.indexOf(pattern, currentOffset);
      if (index3 >= 0) {
        this.bumpTo(index3);
        return true;
      } else {
        this.bumpTo(this.message.length);
        return false;
      }
    };
    Parser3.prototype.bumpTo = function(targetOffset) {
      if (this.offset() > targetOffset) {
        throw Error("targetOffset ".concat(targetOffset, " must be greater than or equal to the current offset ").concat(this.offset()));
      }
      targetOffset = Math.min(targetOffset, this.message.length);
      while (true) {
        var offset = this.offset();
        if (offset === targetOffset) {
          break;
        }
        if (offset > targetOffset) {
          throw Error("targetOffset ".concat(targetOffset, " is at invalid UTF-16 code unit boundary"));
        }
        this.bump();
        if (this.isEOF()) {
          break;
        }
      }
    };
    Parser3.prototype.bumpSpace = function() {
      while (!this.isEOF() && _isWhiteSpace(this.char())) {
        this.bump();
      }
    };
    Parser3.prototype.peek = function() {
      if (this.isEOF()) {
        return null;
      }
      var code3 = this.char();
      var offset = this.offset();
      var nextCode = this.message.charCodeAt(offset + (code3 >= 65536 ? 2 : 1));
      return nextCode !== null && nextCode !== void 0 ? nextCode : null;
    };
    return Parser3;
  }()
);
function _isAlpha(codepoint) {
  return codepoint >= 97 && codepoint <= 122 || codepoint >= 65 && codepoint <= 90;
}
function _isAlphaOrSlash(codepoint) {
  return _isAlpha(codepoint) || codepoint === 47;
}
function _isPotentialElementNameChar(c5) {
  return c5 === 45 || c5 === 46 || c5 >= 48 && c5 <= 57 || c5 === 95 || c5 >= 97 && c5 <= 122 || c5 >= 65 && c5 <= 90 || c5 == 183 || c5 >= 192 && c5 <= 214 || c5 >= 216 && c5 <= 246 || c5 >= 248 && c5 <= 893 || c5 >= 895 && c5 <= 8191 || c5 >= 8204 && c5 <= 8205 || c5 >= 8255 && c5 <= 8256 || c5 >= 8304 && c5 <= 8591 || c5 >= 11264 && c5 <= 12271 || c5 >= 12289 && c5 <= 55295 || c5 >= 63744 && c5 <= 64975 || c5 >= 65008 && c5 <= 65533 || c5 >= 65536 && c5 <= 983039;
}
function _isWhiteSpace(c5) {
  return c5 >= 9 && c5 <= 13 || c5 === 32 || c5 === 133 || c5 >= 8206 && c5 <= 8207 || c5 === 8232 || c5 === 8233;
}
function _isPatternSyntax(c5) {
  return c5 >= 33 && c5 <= 35 || c5 === 36 || c5 >= 37 && c5 <= 39 || c5 === 40 || c5 === 41 || c5 === 42 || c5 === 43 || c5 === 44 || c5 === 45 || c5 >= 46 && c5 <= 47 || c5 >= 58 && c5 <= 59 || c5 >= 60 && c5 <= 62 || c5 >= 63 && c5 <= 64 || c5 === 91 || c5 === 92 || c5 === 93 || c5 === 94 || c5 === 96 || c5 === 123 || c5 === 124 || c5 === 125 || c5 === 126 || c5 === 161 || c5 >= 162 && c5 <= 165 || c5 === 166 || c5 === 167 || c5 === 169 || c5 === 171 || c5 === 172 || c5 === 174 || c5 === 176 || c5 === 177 || c5 === 182 || c5 === 187 || c5 === 191 || c5 === 215 || c5 === 247 || c5 >= 8208 && c5 <= 8213 || c5 >= 8214 && c5 <= 8215 || c5 === 8216 || c5 === 8217 || c5 === 8218 || c5 >= 8219 && c5 <= 8220 || c5 === 8221 || c5 === 8222 || c5 === 8223 || c5 >= 8224 && c5 <= 8231 || c5 >= 8240 && c5 <= 8248 || c5 === 8249 || c5 === 8250 || c5 >= 8251 && c5 <= 8254 || c5 >= 8257 && c5 <= 8259 || c5 === 8260 || c5 === 8261 || c5 === 8262 || c5 >= 8263 && c5 <= 8273 || c5 === 8274 || c5 === 8275 || c5 >= 8277 && c5 <= 8286 || c5 >= 8592 && c5 <= 8596 || c5 >= 8597 && c5 <= 8601 || c5 >= 8602 && c5 <= 8603 || c5 >= 8604 && c5 <= 8607 || c5 === 8608 || c5 >= 8609 && c5 <= 8610 || c5 === 8611 || c5 >= 8612 && c5 <= 8613 || c5 === 8614 || c5 >= 8615 && c5 <= 8621 || c5 === 8622 || c5 >= 8623 && c5 <= 8653 || c5 >= 8654 && c5 <= 8655 || c5 >= 8656 && c5 <= 8657 || c5 === 8658 || c5 === 8659 || c5 === 8660 || c5 >= 8661 && c5 <= 8691 || c5 >= 8692 && c5 <= 8959 || c5 >= 8960 && c5 <= 8967 || c5 === 8968 || c5 === 8969 || c5 === 8970 || c5 === 8971 || c5 >= 8972 && c5 <= 8991 || c5 >= 8992 && c5 <= 8993 || c5 >= 8994 && c5 <= 9e3 || c5 === 9001 || c5 === 9002 || c5 >= 9003 && c5 <= 9083 || c5 === 9084 || c5 >= 9085 && c5 <= 9114 || c5 >= 9115 && c5 <= 9139 || c5 >= 9140 && c5 <= 9179 || c5 >= 9180 && c5 <= 9185 || c5 >= 9186 && c5 <= 9254 || c5 >= 9255 && c5 <= 9279 || c5 >= 9280 && c5 <= 9290 || c5 >= 9291 && c5 <= 9311 || c5 >= 9472 && c5 <= 9654 || c5 === 9655 || c5 >= 9656 && c5 <= 9664 || c5 === 9665 || c5 >= 9666 && c5 <= 9719 || c5 >= 9720 && c5 <= 9727 || c5 >= 9728 && c5 <= 9838 || c5 === 9839 || c5 >= 9840 && c5 <= 10087 || c5 === 10088 || c5 === 10089 || c5 === 10090 || c5 === 10091 || c5 === 10092 || c5 === 10093 || c5 === 10094 || c5 === 10095 || c5 === 10096 || c5 === 10097 || c5 === 10098 || c5 === 10099 || c5 === 10100 || c5 === 10101 || c5 >= 10132 && c5 <= 10175 || c5 >= 10176 && c5 <= 10180 || c5 === 10181 || c5 === 10182 || c5 >= 10183 && c5 <= 10213 || c5 === 10214 || c5 === 10215 || c5 === 10216 || c5 === 10217 || c5 === 10218 || c5 === 10219 || c5 === 10220 || c5 === 10221 || c5 === 10222 || c5 === 10223 || c5 >= 10224 && c5 <= 10239 || c5 >= 10240 && c5 <= 10495 || c5 >= 10496 && c5 <= 10626 || c5 === 10627 || c5 === 10628 || c5 === 10629 || c5 === 10630 || c5 === 10631 || c5 === 10632 || c5 === 10633 || c5 === 10634 || c5 === 10635 || c5 === 10636 || c5 === 10637 || c5 === 10638 || c5 === 10639 || c5 === 10640 || c5 === 10641 || c5 === 10642 || c5 === 10643 || c5 === 10644 || c5 === 10645 || c5 === 10646 || c5 === 10647 || c5 === 10648 || c5 >= 10649 && c5 <= 10711 || c5 === 10712 || c5 === 10713 || c5 === 10714 || c5 === 10715 || c5 >= 10716 && c5 <= 10747 || c5 === 10748 || c5 === 10749 || c5 >= 10750 && c5 <= 11007 || c5 >= 11008 && c5 <= 11055 || c5 >= 11056 && c5 <= 11076 || c5 >= 11077 && c5 <= 11078 || c5 >= 11079 && c5 <= 11084 || c5 >= 11085 && c5 <= 11123 || c5 >= 11124 && c5 <= 11125 || c5 >= 11126 && c5 <= 11157 || c5 === 11158 || c5 >= 11159 && c5 <= 11263 || c5 >= 11776 && c5 <= 11777 || c5 === 11778 || c5 === 11779 || c5 === 11780 || c5 === 11781 || c5 >= 11782 && c5 <= 11784 || c5 === 11785 || c5 === 11786 || c5 === 11787 || c5 === 11788 || c5 === 11789 || c5 >= 11790 && c5 <= 11798 || c5 === 11799 || c5 >= 11800 && c5 <= 11801 || c5 === 11802 || c5 === 11803 || c5 === 11804 || c5 === 11805 || c5 >= 11806 && c5 <= 11807 || c5 === 11808 || c5 === 11809 || c5 === 11810 || c5 === 11811 || c5 === 11812 || c5 === 11813 || c5 === 11814 || c5 === 11815 || c5 === 11816 || c5 === 11817 || c5 >= 11818 && c5 <= 11822 || c5 === 11823 || c5 >= 11824 && c5 <= 11833 || c5 >= 11834 && c5 <= 11835 || c5 >= 11836 && c5 <= 11839 || c5 === 11840 || c5 === 11841 || c5 === 11842 || c5 >= 11843 && c5 <= 11855 || c5 >= 11856 && c5 <= 11857 || c5 === 11858 || c5 >= 11859 && c5 <= 11903 || c5 >= 12289 && c5 <= 12291 || c5 === 12296 || c5 === 12297 || c5 === 12298 || c5 === 12299 || c5 === 12300 || c5 === 12301 || c5 === 12302 || c5 === 12303 || c5 === 12304 || c5 === 12305 || c5 >= 12306 && c5 <= 12307 || c5 === 12308 || c5 === 12309 || c5 === 12310 || c5 === 12311 || c5 === 12312 || c5 === 12313 || c5 === 12314 || c5 === 12315 || c5 === 12316 || c5 === 12317 || c5 >= 12318 && c5 <= 12319 || c5 === 12320 || c5 === 12336 || c5 === 64830 || c5 === 64831 || c5 >= 65093 && c5 <= 65094;
}

// node_modules/@formatjs/icu-messageformat-parser/lib/index.js
function pruneLocation(els) {
  els.forEach(function(el) {
    delete el.location;
    if (isSelectElement(el) || isPluralElement(el)) {
      for (var k2 in el.options) {
        delete el.options[k2].location;
        pruneLocation(el.options[k2].value);
      }
    } else if (isNumberElement(el) && isNumberSkeleton(el.style)) {
      delete el.style.location;
    } else if ((isDateElement(el) || isTimeElement(el)) && isDateTimeSkeleton(el.style)) {
      delete el.style.location;
    } else if (isTagElement(el)) {
      pruneLocation(el.children);
    }
  });
}
function parse2(message, opts) {
  if (opts === void 0) {
    opts = {};
  }
  opts = __assign({ shouldParseSkeletons: true, requiresOtherClause: true }, opts);
  var result = new Parser(message, opts).parse();
  if (result.err) {
    var error3 = SyntaxError(ErrorKind[result.err.kind]);
    error3.location = result.err.location;
    error3.originalMessage = result.err.message;
    throw error3;
  }
  if (!(opts === null || opts === void 0 ? void 0 : opts.captureLocation)) {
    pruneLocation(result.val);
  }
  return result.val;
}

// node_modules/@formatjs/fast-memoize/lib/index.js
function memoize2(fn2, options) {
  var cache3 = options && options.cache ? options.cache : cacheDefault;
  var serializer = options && options.serializer ? options.serializer : serializerDefault;
  var strategy = options && options.strategy ? options.strategy : strategyDefault;
  return strategy(fn2, {
    cache: cache3,
    serializer
  });
}
function isPrimitive(value2) {
  return value2 == null || typeof value2 === "number" || typeof value2 === "boolean";
}
function monadic(fn2, cache3, serializer, arg) {
  var cacheKey = isPrimitive(arg) ? arg : serializer(arg);
  var computedValue = cache3.get(cacheKey);
  if (typeof computedValue === "undefined") {
    computedValue = fn2.call(this, arg);
    cache3.set(cacheKey, computedValue);
  }
  return computedValue;
}
function variadic(fn2, cache3, serializer) {
  var args2 = Array.prototype.slice.call(arguments, 3);
  var cacheKey = serializer(args2);
  var computedValue = cache3.get(cacheKey);
  if (typeof computedValue === "undefined") {
    computedValue = fn2.apply(this, args2);
    cache3.set(cacheKey, computedValue);
  }
  return computedValue;
}
function assemble(fn2, context, strategy, cache3, serialize2) {
  return strategy.bind(context, fn2, cache3, serialize2);
}
function strategyDefault(fn2, options) {
  var strategy = fn2.length === 1 ? monadic : variadic;
  return assemble(fn2, this, strategy, options.cache.create(), options.serializer);
}
function strategyVariadic(fn2, options) {
  return assemble(fn2, this, variadic, options.cache.create(), options.serializer);
}
function strategyMonadic(fn2, options) {
  return assemble(fn2, this, monadic, options.cache.create(), options.serializer);
}
var serializerDefault = function() {
  return JSON.stringify(arguments);
};
function ObjectWithoutPrototypeCache() {
  this.cache = /* @__PURE__ */ Object.create(null);
}
ObjectWithoutPrototypeCache.prototype.get = function(key) {
  return this.cache[key];
};
ObjectWithoutPrototypeCache.prototype.set = function(key, value2) {
  this.cache[key] = value2;
};
var cacheDefault = {
  create: function create7() {
    return new ObjectWithoutPrototypeCache();
  }
};
var strategies = {
  variadic: strategyVariadic,
  monadic: strategyMonadic
};

// node_modules/intl-messageformat/lib/src/error.js
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["MISSING_VALUE"] = "MISSING_VALUE";
  ErrorCode2["INVALID_VALUE"] = "INVALID_VALUE";
  ErrorCode2["MISSING_INTL_API"] = "MISSING_INTL_API";
})(ErrorCode || (ErrorCode = {}));
var FormatError = (
  /** @class */
  function(_super) {
    __extends(FormatError2, _super);
    function FormatError2(msg2, code3, originalMessage) {
      var _this = _super.call(this, msg2) || this;
      _this.code = code3;
      _this.originalMessage = originalMessage;
      return _this;
    }
    FormatError2.prototype.toString = function() {
      return "[formatjs Error: ".concat(this.code, "] ").concat(this.message);
    };
    return FormatError2;
  }(Error)
);
var InvalidValueError = (
  /** @class */
  function(_super) {
    __extends(InvalidValueError2, _super);
    function InvalidValueError2(variableId, value2, options, originalMessage) {
      return _super.call(this, 'Invalid values for "'.concat(variableId, '": "').concat(value2, '". Options are "').concat(Object.keys(options).join('", "'), '"'), ErrorCode.INVALID_VALUE, originalMessage) || this;
    }
    return InvalidValueError2;
  }(FormatError)
);
var InvalidValueTypeError = (
  /** @class */
  function(_super) {
    __extends(InvalidValueTypeError2, _super);
    function InvalidValueTypeError2(value2, type2, originalMessage) {
      return _super.call(this, 'Value for "'.concat(value2, '" must be of type ').concat(type2), ErrorCode.INVALID_VALUE, originalMessage) || this;
    }
    return InvalidValueTypeError2;
  }(FormatError)
);
var MissingValueError = (
  /** @class */
  function(_super) {
    __extends(MissingValueError2, _super);
    function MissingValueError2(variableId, originalMessage) {
      return _super.call(this, 'The intl string context variable "'.concat(variableId, '" was not provided to the string "').concat(originalMessage, '"'), ErrorCode.MISSING_VALUE, originalMessage) || this;
    }
    return MissingValueError2;
  }(FormatError)
);

// node_modules/intl-messageformat/lib/src/formatters.js
var PART_TYPE;
(function(PART_TYPE2) {
  PART_TYPE2[PART_TYPE2["literal"] = 0] = "literal";
  PART_TYPE2[PART_TYPE2["object"] = 1] = "object";
})(PART_TYPE || (PART_TYPE = {}));
function mergeLiteral(parts) {
  if (parts.length < 2) {
    return parts;
  }
  return parts.reduce(function(all3, part) {
    var lastPart = all3[all3.length - 1];
    if (!lastPart || lastPart.type !== PART_TYPE.literal || part.type !== PART_TYPE.literal) {
      all3.push(part);
    } else {
      lastPart.value += part.value;
    }
    return all3;
  }, []);
}
function isFormatXMLElementFn(el) {
  return typeof el === "function";
}
function formatToParts(els, locales, formatters, formats, values3, currentPluralValue, originalMessage) {
  if (els.length === 1 && isLiteralElement(els[0])) {
    return [
      {
        type: PART_TYPE.literal,
        value: els[0].value
      }
    ];
  }
  var result = [];
  for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {
    var el = els_1[_i];
    if (isLiteralElement(el)) {
      result.push({
        type: PART_TYPE.literal,
        value: el.value
      });
      continue;
    }
    if (isPoundElement(el)) {
      if (typeof currentPluralValue === "number") {
        result.push({
          type: PART_TYPE.literal,
          value: formatters.getNumberFormat(locales).format(currentPluralValue)
        });
      }
      continue;
    }
    var varName = el.value;
    if (!(values3 && varName in values3)) {
      throw new MissingValueError(varName, originalMessage);
    }
    var value2 = values3[varName];
    if (isArgumentElement(el)) {
      if (!value2 || typeof value2 === "string" || typeof value2 === "number") {
        value2 = typeof value2 === "string" || typeof value2 === "number" ? String(value2) : "";
      }
      result.push({
        type: typeof value2 === "string" ? PART_TYPE.literal : PART_TYPE.object,
        value: value2
      });
      continue;
    }
    if (isDateElement(el)) {
      var style = typeof el.style === "string" ? formats.date[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : void 0;
      result.push({
        type: PART_TYPE.literal,
        value: formatters.getDateTimeFormat(locales, style).format(value2)
      });
      continue;
    }
    if (isTimeElement(el)) {
      var style = typeof el.style === "string" ? formats.time[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : formats.time.medium;
      result.push({
        type: PART_TYPE.literal,
        value: formatters.getDateTimeFormat(locales, style).format(value2)
      });
      continue;
    }
    if (isNumberElement(el)) {
      var style = typeof el.style === "string" ? formats.number[el.style] : isNumberSkeleton(el.style) ? el.style.parsedOptions : void 0;
      if (style && style.scale) {
        value2 = value2 * (style.scale || 1);
      }
      result.push({
        type: PART_TYPE.literal,
        value: formatters.getNumberFormat(locales, style).format(value2)
      });
      continue;
    }
    if (isTagElement(el)) {
      var children = el.children, value_1 = el.value;
      var formatFn = values3[value_1];
      if (!isFormatXMLElementFn(formatFn)) {
        throw new InvalidValueTypeError(value_1, "function", originalMessage);
      }
      var parts = formatToParts(children, locales, formatters, formats, values3, currentPluralValue);
      var chunks = formatFn(parts.map(function(p5) {
        return p5.value;
      }));
      if (!Array.isArray(chunks)) {
        chunks = [chunks];
      }
      result.push.apply(result, chunks.map(function(c5) {
        return {
          type: typeof c5 === "string" ? PART_TYPE.literal : PART_TYPE.object,
          value: c5
        };
      }));
    }
    if (isSelectElement(el)) {
      var opt = el.options[value2] || el.options.other;
      if (!opt) {
        throw new InvalidValueError(el.value, value2, Object.keys(el.options), originalMessage);
      }
      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values3));
      continue;
    }
    if (isPluralElement(el)) {
      var opt = el.options["=".concat(value2)];
      if (!opt) {
        if (!Intl.PluralRules) {
          throw new FormatError('Intl.PluralRules is not available in this environment.\nTry polyfilling it using "@formatjs/intl-pluralrules"\n', ErrorCode.MISSING_INTL_API, originalMessage);
        }
        var rule = formatters.getPluralRules(locales, { type: el.pluralType }).select(value2 - (el.offset || 0));
        opt = el.options[rule] || el.options.other;
      }
      if (!opt) {
        throw new InvalidValueError(el.value, value2, Object.keys(el.options), originalMessage);
      }
      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values3, value2 - (el.offset || 0)));
      continue;
    }
  }
  return mergeLiteral(result);
}

// node_modules/intl-messageformat/lib/src/core.js
function mergeConfig2(c1, c22) {
  if (!c22) {
    return c1;
  }
  return __assign(__assign(__assign({}, c1 || {}), c22 || {}), Object.keys(c1).reduce(function(all3, k2) {
    all3[k2] = __assign(__assign({}, c1[k2]), c22[k2] || {});
    return all3;
  }, {}));
}
function mergeConfigs(defaultConfig, configs) {
  if (!configs) {
    return defaultConfig;
  }
  return Object.keys(defaultConfig).reduce(function(all3, k2) {
    all3[k2] = mergeConfig2(defaultConfig[k2], configs[k2]);
    return all3;
  }, __assign({}, defaultConfig));
}
function createFastMemoizeCache(store2) {
  return {
    create: function() {
      return {
        get: function(key) {
          return store2[key];
        },
        set: function(key, value2) {
          store2[key] = value2;
        }
      };
    }
  };
}
function createDefaultFormatters(cache3) {
  if (cache3 === void 0) {
    cache3 = {
      number: {},
      dateTime: {},
      pluralRules: {}
    };
  }
  return {
    getNumberFormat: memoize2(function() {
      var _a3;
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      return new ((_a3 = Intl.NumberFormat).bind.apply(_a3, __spreadArray([void 0], args2, false)))();
    }, {
      cache: createFastMemoizeCache(cache3.number),
      strategy: strategies.variadic
    }),
    getDateTimeFormat: memoize2(function() {
      var _a3;
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      return new ((_a3 = Intl.DateTimeFormat).bind.apply(_a3, __spreadArray([void 0], args2, false)))();
    }, {
      cache: createFastMemoizeCache(cache3.dateTime),
      strategy: strategies.variadic
    }),
    getPluralRules: memoize2(function() {
      var _a3;
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      return new ((_a3 = Intl.PluralRules).bind.apply(_a3, __spreadArray([void 0], args2, false)))();
    }, {
      cache: createFastMemoizeCache(cache3.pluralRules),
      strategy: strategies.variadic
    })
  };
}
var IntlMessageFormat = (
  /** @class */
  function() {
    function IntlMessageFormat2(message, locales, overrideFormats, opts) {
      var _this = this;
      if (locales === void 0) {
        locales = IntlMessageFormat2.defaultLocale;
      }
      this.formatterCache = {
        number: {},
        dateTime: {},
        pluralRules: {}
      };
      this.format = function(values3) {
        var parts = _this.formatToParts(values3);
        if (parts.length === 1) {
          return parts[0].value;
        }
        var result = parts.reduce(function(all3, part) {
          if (!all3.length || part.type !== PART_TYPE.literal || typeof all3[all3.length - 1] !== "string") {
            all3.push(part.value);
          } else {
            all3[all3.length - 1] += part.value;
          }
          return all3;
        }, []);
        if (result.length <= 1) {
          return result[0] || "";
        }
        return result;
      };
      this.formatToParts = function(values3) {
        return formatToParts(_this.ast, _this.locales, _this.formatters, _this.formats, values3, void 0, _this.message);
      };
      this.resolvedOptions = function() {
        var _a4;
        return {
          locale: ((_a4 = _this.resolvedLocale) === null || _a4 === void 0 ? void 0 : _a4.toString()) || Intl.NumberFormat.supportedLocalesOf(_this.locales)[0]
        };
      };
      this.getAst = function() {
        return _this.ast;
      };
      this.locales = locales;
      this.resolvedLocale = IntlMessageFormat2.resolveLocale(locales);
      if (typeof message === "string") {
        this.message = message;
        if (!IntlMessageFormat2.__parse) {
          throw new TypeError("IntlMessageFormat.__parse must be set to process `message` of type `string`");
        }
        var _a3 = opts || {}, formatters = _a3.formatters, parseOpts = __rest(_a3, ["formatters"]);
        this.ast = IntlMessageFormat2.__parse(message, __assign(__assign({}, parseOpts), { locale: this.resolvedLocale }));
      } else {
        this.ast = message;
      }
      if (!Array.isArray(this.ast)) {
        throw new TypeError("A message must be provided as a String or AST.");
      }
      this.formats = mergeConfigs(IntlMessageFormat2.formats, overrideFormats);
      this.formatters = opts && opts.formatters || createDefaultFormatters(this.formatterCache);
    }
    Object.defineProperty(IntlMessageFormat2, "defaultLocale", {
      get: function() {
        if (!IntlMessageFormat2.memoizedDefaultLocale) {
          IntlMessageFormat2.memoizedDefaultLocale = new Intl.NumberFormat().resolvedOptions().locale;
        }
        return IntlMessageFormat2.memoizedDefaultLocale;
      },
      enumerable: false,
      configurable: true
    });
    IntlMessageFormat2.memoizedDefaultLocale = null;
    IntlMessageFormat2.resolveLocale = function(locales) {
      if (typeof Intl.Locale === "undefined") {
        return;
      }
      var supportedLocales = Intl.NumberFormat.supportedLocalesOf(locales);
      if (supportedLocales.length > 0) {
        return new Intl.Locale(supportedLocales[0]);
      }
      return new Intl.Locale(typeof locales === "string" ? locales : locales[0]);
    };
    IntlMessageFormat2.__parse = parse2;
    IntlMessageFormat2.formats = {
      number: {
        integer: {
          maximumFractionDigits: 0
        },
        currency: {
          style: "currency"
        },
        percent: {
          style: "percent"
        }
      },
      date: {
        short: {
          month: "numeric",
          day: "numeric",
          year: "2-digit"
        },
        medium: {
          month: "short",
          day: "numeric",
          year: "numeric"
        },
        long: {
          month: "long",
          day: "numeric",
          year: "numeric"
        },
        full: {
          weekday: "long",
          month: "long",
          day: "numeric",
          year: "numeric"
        }
      },
      time: {
        short: {
          hour: "numeric",
          minute: "numeric"
        },
        medium: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric"
        },
        long: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          timeZoneName: "short"
        },
        full: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          timeZoneName: "short"
        }
      }
    };
    return IntlMessageFormat2;
  }()
);

// node_modules/@react-aria/i18n/dist/useMessageFormatter.module.mjs
var import_react13 = __toESM(require_react(), 1);

// node_modules/@keystar/ui/dist/keystar-ui-typography.js
var import_react15 = __toESM(require_react());
var import_jsx_runtime4 = __toESM(require_jsx_runtime());

// node_modules/@react-aria/visually-hidden/dist/import.mjs
var import_react14 = __toESM(require_react(), 1);
var $5c3e21d68f1c4674$var$styles = {
  border: 0,
  clip: "rect(0 0 0 0)",
  clipPath: "inset(50%)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "absolute",
  width: "1px",
  whiteSpace: "nowrap"
};
function $5c3e21d68f1c4674$export$a966af930f325cab(props = {}) {
  let { style, isFocusable } = props;
  let [isFocused, setFocused] = (0, import_react14.useState)(false);
  let { focusWithinProps } = (0, $9ab94262bd0047c7$export$420e68273165f4ec)({
    isDisabled: !isFocusable,
    onFocusWithinChange: (val) => setFocused(val)
  });
  let combinedStyles = (0, import_react14.useMemo)(() => {
    if (isFocused)
      return style;
    else if (style)
      return {
        ...$5c3e21d68f1c4674$var$styles,
        ...style
      };
    else
      return $5c3e21d68f1c4674$var$styles;
  }, [
    isFocused
  ]);
  return {
    visuallyHiddenProps: {
      ...focusWithinProps,
      style: combinedStyles
    }
  };
}
function $5c3e21d68f1c4674$export$439d29a4e110a164(props) {
  let { children, elementType: Element4 = "div", isFocusable, style, ...otherProps } = props;
  let { visuallyHiddenProps } = $5c3e21d68f1c4674$export$a966af930f325cab(props);
  return (0, import_react14.default).createElement(Element4, (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(otherProps, visuallyHiddenProps), children);
}

// node_modules/@keystar/ui/dist/keystar-ui-typography.js
var HeadingContext = (0, import_react15.createContext)(void 0);
function useHeadingContext() {
  return (0, import_react15.useContext)(HeadingContext);
}
function getTrimStyles(fontDefinition) {
  const {
    capheightTrim: marginBottom,
    baselineTrim: marginTop
  } = fontDefinition;
  return {
    display: "block",
    lineHeight: fontDefinition.lineheight,
    "::before": {
      content: '" "',
      display: "table",
      marginBottom
    },
    "::after": {
      content: '" "',
      display: "table",
      marginTop
    }
  };
}
var TextContext = (0, import_react15.createContext)(void 0);
function useTextContext() {
  return (0, import_react15.useContext)(TextContext);
}
var textClassList = new ClassList("Text");
function useTextStyles(props) {
  const prevContext = useTextContext();
  const {
    align,
    casing,
    overflow = "breakword",
    size: size3,
    color: color2,
    trim: trim2 = !prevContext,
    variant,
    weight,
    UNSAFE_className,
    ...otherProps
  } = props;
  const fontDefinition = tokenSchema.typography.text[size3];
  const trimStyles = trim2 ? getTrimStyles(fontDefinition) : null;
  const styles2 = [{
    color: maybeTokenByKey("color.foreground", color2),
    fontFamily: tokenSchema.typography.fontFamily.base,
    fontSize: fontDefinition.size,
    fontVariantNumeric: variant,
    fontWeight: weight === "inherit" ? void 0 : tokenSchema.typography.fontWeight[weight],
    minWidth: 0,
    textAlign: align ? alignmentMap[align] : void 0,
    textTransform: casing
  }, textOptimizationStyles, overflow && overflowMap[overflow], trimStyles];
  return useStyleProps({
    ...otherProps,
    UNSAFE_className: [css(styles2), UNSAFE_className, textClassList.element("root")]
  });
}
var textOptimizationStyles = {
  MozOsxFontSmoothing: "auto",
  WebkitFontSmoothing: "auto"
};
var alignmentMap = {
  start: "start",
  center: "center",
  end: "end",
  FORCE_left: "left",
  FORCE_right: "right"
};
var overflowMap = {
  unset: {},
  nowrap: {
    whiteSpace: "nowrap"
  },
  breakword: {
    // hyphens: 'auto', // too eager
    overflowWrap: "break-word"
  }
};
var headingClassList = new ClassList("Heading");
function useHeadingStyles({
  align,
  size: size3,
  UNSAFE_className,
  ...otherProps
}) {
  const fontDefinition = tokenSchema.typography.heading[size3];
  const trimStyles = getTrimStyles(fontDefinition);
  const styles2 = [{
    color: tokenSchema.color.foreground.neutralEmphasis,
    fontSize: fontDefinition.size,
    fontFamily: tokenSchema.typography.fontFamily.base,
    fontWeight: sizeToWeight[size3],
    textAlign: align
  }, textOptimizationStyles, trimStyles];
  return useStyleProps({
    ...otherProps,
    UNSAFE_className: [css(styles2), UNSAFE_className, headingClassList.element("root")]
  });
}
var sizeToWeight = {
  small: tokenSchema.typography.fontWeight.semibold,
  regular: tokenSchema.typography.fontWeight.bold,
  medium: tokenSchema.typography.fontWeight.medium,
  large: tokenSchema.typography.fontWeight.bold
};
function Truncate({
  lines,
  title,
  ...props
}) {
  const className = useTruncateStyles(typeof lines === "boolean" ? 1 : lines);
  return (0, import_jsx_runtime4.jsx)("span", {
    className,
    title: title !== null && title !== void 0 ? title : isReactText(props.children) ? props.children.toString() : void 0,
    ...props
  });
}
function useTruncateStyles(lineClamp) {
  return css({
    display: "-webkit-box",
    WebkitLineClamp: lineClamp,
    textOverflow: "ellipsis",
    WebkitBoxOrient: "vertical",
    overflow: "hidden"
  });
}
function useVisuallyHiddenRange(range) {
  let matchedBreakpoints = useResponsiveRange();
  let {
    visuallyHiddenProps
  } = $5c3e21d68f1c4674$export$a966af930f325cab();
  if (range && matchedBreakpoints(range)) {
    return visuallyHiddenProps;
  }
}
var sizeToElement = {
  small: "h4",
  regular: "h3",
  medium: "h2",
  large: "h1"
};
var filterOptions$1 = {
  propNames: /* @__PURE__ */ new Set(["aria-hidden"])
};
var Heading = forwardRefWithAs((props, ref) => {
  props = useSlotProps(props, "heading");
  const {
    children,
    size: size3 = "regular",
    truncate: truncate2,
    elementType: ElementType = sizeToElement[size3],
    ...otherProps
  } = props;
  const styleProps = useHeadingStyles({
    size: size3,
    ...otherProps
  });
  const headingContext = (0, import_react15.useMemo)(() => ({
    size: size3
  }), [size3]);
  const visuallyHiddenProps = useVisuallyHiddenRange(props.visuallyHidden);
  const content3 = truncate2 ? (0, import_jsx_runtime4.jsx)(Truncate, {
    lines: truncate2,
    children
  }) : children;
  return (0, import_jsx_runtime4.jsx)(HeadingContext.Provider, {
    value: headingContext,
    children: (0, import_jsx_runtime4.jsx)(ElementType, {
      ref,
      ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps, filterOptions$1),
      ...styleProps,
      ...visuallyHiddenProps,
      children: content3
    })
  });
});
var filterOptions2 = {
  propNames: /* @__PURE__ */ new Set(["aria-hidden", "role"])
};
var Text2 = forwardRefWithAs((props, forwardedRef) => {
  var _prevContext$color, _prevContext$size, _prevContext$weight;
  props = useSlotProps(props, "text");
  const headingContext = useHeadingContext();
  const prevContext = useTextContext();
  validateProps$1(props, prevContext);
  warning(!headingContext, "The `Text` component is not supported within `Heading` components.");
  if (headingContext) {
    return (0, import_jsx_runtime4.jsx)("span", {
      children: props.children
    });
  }
  const {
    children,
    color: color2 = (_prevContext$color = prevContext === null || prevContext === void 0 ? void 0 : prevContext.color) !== null && _prevContext$color !== void 0 ? _prevContext$color : "neutral",
    elementType: ElementType = "span",
    size: size3 = (_prevContext$size = prevContext === null || prevContext === void 0 ? void 0 : prevContext.size) !== null && _prevContext$size !== void 0 ? _prevContext$size : "regular",
    trim: trim2 = !prevContext,
    truncate: truncate2,
    visuallyHidden,
    weight = (_prevContext$weight = prevContext === null || prevContext === void 0 ? void 0 : prevContext.weight) !== null && _prevContext$weight !== void 0 ? _prevContext$weight : "regular",
    ...otherProps
  } = props;
  const styleProps = useTextStyles({
    color: color2,
    size: size3,
    trim: trim2,
    weight,
    ...otherProps
  });
  const visuallyHiddenProps = useVisuallyHiddenRange(visuallyHidden);
  const content3 = truncate2 ? (0, import_jsx_runtime4.jsx)(Truncate, {
    lines: truncate2,
    children
  }) : children;
  const element4 = (0, import_jsx_runtime4.jsx)(ElementType, {
    ref: forwardedRef,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps, filterOptions2),
    ...styleProps,
    ...visuallyHiddenProps,
    children: content3
  });
  const nextContext = (0, import_react15.useMemo)(() => ({
    size: size3,
    color: color2,
    weight
  }), [size3, color2, weight]);
  if (prevContext || visuallyHidden) {
    return element4;
  }
  return (0, import_jsx_runtime4.jsx)(TextContext.Provider, {
    value: nextContext,
    children: element4
  });
});
function validateProps$1(props, context) {
  assert(!context || !props.align, 'The "align" prop is unsupported on nested Text.');
  assert(!context || !props.trim, 'The "trim" prop is unsupported on nested Text.');
}
var Emoji = (0, import_react15.forwardRef)(function Emoji2(props, forwardedRef) {
  const {
    label,
    symbol,
    ...otherProps
  } = props;
  const styleProps = useStyleProps(otherProps);
  return (0, import_jsx_runtime4.jsx)("span", {
    "aria-hidden": label ? void 0 : true,
    "aria-label": label,
    ref: forwardedRef,
    role: "img",
    ...styleProps,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
    children: symbol
  });
});
function noopSubscribe() {
  return () => {
  };
}
function useIsMac() {
  return (0, import_react15.useSyncExternalStore)(noopSubscribe, $c87311424ea30a05$export$9ac100e40613ea10, () => false);
}
var Kbd = (0, import_react15.forwardRef)(function Kbd2(props, forwardedRef) {
  props = useSlotProps(props, "kbd");
  let {
    alt,
    meta,
    shift,
    children,
    ...otherProps
  } = props;
  const styleProps = useTextStyles({
    casing: "full-width",
    color: "neutral",
    size: "regular",
    weight: "regular",
    ...otherProps
  });
  const isMac2 = useIsMac();
  const modifiers = (0, import_react15.useMemo)(() => {
    const SYSTEM_KEYS = isMac2 ? {
      alt: "⌥",
      meta: "⌘",
      shift: "⇧"
    } : {
      alt: "Alt",
      meta: "Ctrl",
      shift: "Shift"
      // shift: '⇧', // maybe?
    };
    let keys3 = [alt && SYSTEM_KEYS.alt, shift && SYSTEM_KEYS.shift, meta && SYSTEM_KEYS.meta].filter(Boolean);
    return joinModifierKeys(keys3, isMac2);
  }, [alt, meta, shift, isMac2]);
  return (0, import_jsx_runtime4.jsxs)("kbd", {
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
    ...styleProps,
    dir: "ltr",
    ref: forwardedRef,
    children: [modifiers, (0, import_jsx_runtime4.jsx)(Char, {
      children
    })]
  });
});
function Char(props) {
  return (0, import_jsx_runtime4.jsx)("span", {
    className: css({
      display: "inline-block",
      minWidth: "1em",
      textAlign: "center"
    }),
    ...props
  });
}
function joinModifierKeys(modifiers, isMac2) {
  if (modifiers.length === 0) {
    return "";
  }
  let delimiter2 = isMac2 ? "" : "+";
  return modifiers.join(delimiter2) + delimiter2;
}
var Numeral = (0, import_react15.forwardRef)(function Numeral2(props, forwardedRef) {
  props = useDerivedProps(props);
  validateProps(props);
  const formatter = $a916eb452884faea$export$b7a616150fdb9f44(optionsByFormat(props));
  const {
    abbreviate,
    format: format2,
    value: value2,
    ...textProps
  } = props;
  const headingContext = useHeadingContext();
  const formattedText = formatter.format(value2);
  if (headingContext) {
    return (0, import_jsx_runtime4.jsx)("span", {
      ref: forwardedRef,
      children: formattedText
    });
  }
  return (0, import_jsx_runtime4.jsx)(Text2, {
    ref: forwardedRef,
    ...textProps,
    children: formattedText
  });
});
function getFormat(props) {
  const {
    format: format2,
    currency,
    unit
  } = props;
  if (format2) {
    return format2;
  }
  if (currency) {
    return "currency";
  }
  if (unit) {
    return "unit";
  }
  return "decimal";
}
function useDerivedProps(props) {
  return {
    ...props,
    format: getFormat(props)
  };
}
function toFractionDigits(precision) {
  return Array.isArray(precision) ? precision : [precision, precision];
}
function optionsByFormat(props) {
  const {
    abbreviate,
    format: format2,
    precision,
    currency,
    unit
  } = props;
  const notation = abbreviate ? "compact" : void 0;
  const [minimumFractionDigits, maximumFractionDigits] = toFractionDigits(precision);
  const common = {
    maximumFractionDigits,
    minimumFractionDigits,
    notation,
    compactDisplay: abbreviate === "long" ? "long" : "short"
  };
  switch (format2) {
    case "currency":
      return {
        ...common,
        style: "currency",
        currency,
        currencyDisplay: "narrowSymbol"
      };
    case "percent":
      return {
        ...common,
        style: "percent"
      };
    case "unit":
      return {
        ...common,
        style: "unit",
        unit,
        unitDisplay: "narrow"
      };
    default:
      return common;
  }
}
function validateProps(props) {
  const {
    format: format2,
    currency,
    precision,
    unit
  } = props;
  assert(currency ? format2 === "currency" : true, 'When format is "currency", the currency property must be provided.');
  assert(unit ? format2 === "unit" : true, 'When format is "unit", the unit property must be provided.');
  assert(!(currency && unit), 'Formatting of "currency" and "unit" cannot be combined.');
  if (precision) {
    assert(Array.isArray(precision) ? precision.every(isInteger) : isInteger(precision), "Precision must be an integer, or an integer tuple for min/max.");
  }
}
var Prose = forwardRefWithAs((props, ref) => {
  const {
    children,
    elementType: ElementType = "div",
    ...otherProps
  } = props;
  const styleProps = useProseStyleProps(otherProps);
  return (0, import_jsx_runtime4.jsx)(ElementType, {
    ref,
    ...filterStyleProps(otherProps),
    ...styleProps,
    children
  });
});
function useProseStyleProps(props) {
  const {
    size: size3 = "medium",
    ...otherProps
  } = props;
  const styleProps = useStyleProps(otherProps);
  return {
    ...styleProps,
    ...toDataAttributes({
      size: size3
    }),
    className: classNames(css({
      color: tokenSchema.color.foreground.neutral,
      fontFamily: tokenSchema.typography.fontFamily.base,
      height: "100%",
      maxWidth: "100%",
      minHeight: 0,
      minWidth: 0,
      position: "relative",
      overflowWrap: "break-word",
      whiteSpace: "break-spaces",
      fontVariantLigatures: "none",
      fontFeatureSettings: '"liga" 0',
      // the above doesn't seem to work in Edge
      MozOsxFontSmoothing: "auto",
      WebkitFontSmoothing: "auto",
      '&[data-size="small"]': {
        fontSize: tokenSchema.typography.text.small.size,
        lineHeight: 1.6
      },
      '&[data-size="regular"]': {
        fontSize: tokenSchema.typography.text.regular.size,
        lineHeight: 1.5
      },
      '&[data-size="medium"]': {
        fontSize: tokenSchema.typography.text.medium.size,
        lineHeight: 1.5
      },
      '&[data-size="large"]': {
        fontSize: tokenSchema.typography.text.large.size,
        lineHeight: 1.4
      },
      // Elements
      // ---------------------------------------------------------------------
      "& :is(blockquote, p, pre, ol, ul, table)": {
        marginBlock: "0.75em",
        ":first-child": {
          marginTop: 0
        },
        ":last-child": {
          marginBottom: 0
        }
      },
      "ol, ul": {
        paddingInlineStart: "1em"
      },
      "ol ol, ul ul, ol ul, ul ol": {
        marginBlock: 0
      },
      "li :is(blockquote, p, pre, ol, ul, table)": {
        marginBottom: 0
      },
      blockquote: {
        borderInlineStart: `${tokenSchema.size.border.large} solid ${tokenSchema.color.foreground.neutral}`,
        marginInline: 0,
        paddingInlineStart: "1em"
      },
      hr: {
        backgroundColor: tokenSchema.color.alias.borderIdle,
        border: 0,
        borderRadius: tokenSchema.size.border.medium,
        height: tokenSchema.size.border.medium,
        marginBlock: "1.5em"
      },
      // inline elements
      img: {
        height: "auto",
        maxWidth: "100%"
      },
      strong: {
        fontWeight: tokenSchema.typography.fontWeight.semibold
      },
      a: {
        color: tokenSchema.color.foreground.accent
      },
      // code block
      pre: {
        backgroundColor: tokenSchema.color.background.surface,
        borderRadius: tokenSchema.size.radius.medium,
        color: tokenSchema.color.foreground.neutralEmphasis,
        fontFamily: tokenSchema.typography.fontFamily.code,
        fontSize: "0.85em",
        lineHeight: tokenSchema.typography.lineheight.medium,
        minWidth: 0,
        maxWidth: "100%",
        overflow: "auto",
        padding: tokenSchema.size.space.medium,
        whiteSpace: "pre-wrap"
      },
      "pre > code": {
        fontFamily: "inherit"
      },
      // inline code
      "& :not(pre) > code": {
        backgroundColor: tokenSchema.color.background.accent,
        borderRadius: tokenSchema.size.radius.small,
        color: tokenSchema.color.foreground.neutralEmphasis,
        display: "inline-block",
        fontSize: "0.85em",
        fontFamily: tokenSchema.typography.fontFamily.code,
        paddingInline: tokenSchema.size.space.small
      },
      // Headings
      // ---------------------------------------------------------------------
      "& :is(h1, h2, h3, h4, h5, h6)": {
        color: tokenSchema.color.foreground.neutralEmphasis,
        lineHeight: 1.25,
        marginTop: "1.5em",
        marginBottom: "0.67em",
        ":first-child": {
          marginTop: 0
        },
        ":last-child": {
          marginBottom: 0
        }
      },
      h1: {
        fontSize: "2em",
        fontWeight: tokenSchema.typography.fontWeight.bold
      },
      h2: {
        fontSize: "1.5em",
        fontWeight: tokenSchema.typography.fontWeight.bold
      },
      h3: {
        fontSize: "1.25em",
        fontWeight: tokenSchema.typography.fontWeight.bold
      },
      h4: {
        fontSize: "1.1em",
        fontWeight: tokenSchema.typography.fontWeight.semibold
      },
      h5: {
        fontSize: "1em",
        fontWeight: tokenSchema.typography.fontWeight.semibold
      },
      h6: {
        fontSize: "0.9em",
        fontWeight: tokenSchema.typography.fontWeight.semibold,
        letterSpacing: "0.0125em"
      },
      ...getListStyles()
    }), styleProps.className)
  };
}
function getListStyles() {
  let styles2 = {};
  let listDepth = 10;
  const orderedListStyles = ["lower-roman", "decimal", "lower-alpha"];
  const unorderedListStyles = ["square", "disc", "circle"];
  while (listDepth--) {
    let arr = Array.from({
      length: listDepth
    });
    if (arr.length) {
      styles2[arr.map(() => `ol`).join(" ")] = {
        listStyle: orderedListStyles[listDepth % 3]
      };
      styles2[arr.map(() => `ul`).join(" ")] = {
        listStyle: unorderedListStyles[listDepth % 3]
      };
    }
  }
  return styles2;
}

// node_modules/@keystar/ui/dist/keystar-ui-icon.js
var import_react16 = __toESM(require_react());
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var STROKE_VAR = `--${TOKEN_PREFIX}-icon-stroke`;
var Icon = (props) => {
  var _maybeTokenByKey;
  props = useSlotProps(props, "icon");
  const {
    strokeScaling,
    size: size3,
    color: color2,
    ...otherProps
  } = props;
  const stroke = (_maybeTokenByKey = maybeTokenByKey("color.foreground", color2)) !== null && _maybeTokenByKey !== void 0 ? _maybeTokenByKey : "currentColor";
  const iconClassName2 = css({
    fill: "none",
    stroke: `var(${STROKE_VAR})`,
    flexShrink: 0,
    height: tokenSchema.size.icon.regular,
    width: tokenSchema.size.icon.regular,
    "&[data-size=small]": {
      height: tokenSchema.size.icon.small,
      width: tokenSchema.size.icon.small
    },
    "&[data-size=medium]": {
      height: tokenSchema.size.icon.medium,
      width: tokenSchema.size.icon.medium
    },
    "&[data-size=large]": {
      height: tokenSchema.size.icon.large,
      width: tokenSchema.size.icon.large
    },
    // Maintain stroke width, no matter the size.
    // @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/vector-effect#non-scaling-stroke
    "&[data-stroke-scaling=false] > *": {
      vectorEffect: "non-scaling-stroke"
    }
  });
  const styleProps = useStyleProps(otherProps);
  const hasAriaLabel = "aria-label" in props && !!props["aria-label"];
  return (0, import_jsx_runtime5.jsx)("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...toDataAttributes({
      strokeScaling,
      size: size3
    }),
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps, {
      labelable: true
    }),
    "aria-hidden": !hasAriaLabel,
    focusable: "false",
    role: "img",
    className: classNames(iconClassName2, styleProps.className),
    style: {
      [STROKE_VAR]: stroke,
      ...styleProps.style
    },
    height: "1em",
    children: props.src
  });
};

// node_modules/@react-aria/label/dist/import.mjs
function $d191a55c9702f145$export$8467354a121f1b9f(props) {
  let { id: id2, label, "aria-labelledby": ariaLabelledby, "aria-label": ariaLabel, labelElementType = "label" } = props;
  id2 = (0, $bdb11010cef70236$export$f680877a34711e37)(id2);
  let labelId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  let labelProps = {};
  if (label) {
    ariaLabelledby = ariaLabelledby ? `${labelId} ${ariaLabelledby}` : labelId;
    labelProps = {
      id: labelId,
      htmlFor: labelElementType === "label" ? id2 : void 0
    };
  } else if (!ariaLabelledby && !ariaLabel)
    console.warn("If you do not provide a visible label, you must specify an aria-label or aria-labelledby attribute for accessibility");
  let fieldProps = (0, $313b98861ee5dd6c$export$d6875122194c7b44)({
    id: id2,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledby
  });
  return {
    labelProps,
    fieldProps
  };
}
function $2baaea4c71418dea$export$294aa081a6c6f55d(props) {
  let { description, errorMessage, isInvalid, validationState } = props;
  let { labelProps, fieldProps } = (0, $d191a55c9702f145$export$8467354a121f1b9f)(props);
  let descriptionId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)([
    Boolean(description),
    Boolean(errorMessage),
    isInvalid,
    validationState
  ]);
  let errorMessageId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)([
    Boolean(description),
    Boolean(errorMessage),
    isInvalid,
    validationState
  ]);
  fieldProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(fieldProps, {
    "aria-describedby": [
      descriptionId,
      // Use aria-describedby for error message because aria-errormessage is unsupported using VoiceOver or NVDA. See https://github.com/adobe/react-spectrum/issues/1346#issuecomment-740136268
      errorMessageId,
      props["aria-describedby"]
    ].filter(Boolean).join(" ") || void 0
  });
  return {
    labelProps,
    fieldProps,
    descriptionProps: {
      id: descriptionId
    },
    errorMessageProps: {
      id: errorMessageId
    }
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-field.js
var import_react17 = __toESM(require_react());
var import_jsx_runtime7 = __toESM(require_jsx_runtime());

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-alertTriangleIcon.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var alertTriangleIcon = (0, import_jsx_runtime6.jsx)("path", {
  d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3ZM12 9v4M12 17h.01"
});

// node_modules/@keystar/ui/dist/keystar-ui-field.js
var localizedMessages = {
  "ar-AE": {
    "(optional)": "(اختياري)",
    "(required)": "(مطلوب)"
  },
  "bg-BG": {
    "(optional)": "(незадължително)",
    "(required)": "(задължително)"
  },
  "cs-CZ": {
    "(optional)": "(volitelně)",
    "(required)": "(požadováno)"
  },
  "da-DK": {
    "(optional)": "(valgfrit)",
    "(required)": "(obligatorisk)"
  },
  "de-DE": {
    "(optional)": "(optional)",
    "(required)": "(erforderlich)"
  },
  "el-GR": {
    "(optional)": "(προαιρετικό)",
    "(required)": "(απαιτείται)"
  },
  "en-US": {
    "(optional)": "(optional)",
    "(required)": "(required)"
  },
  "es-ES": {
    "(optional)": "(opcional)",
    "(required)": "(necesario)"
  },
  "et-EE": {
    "(optional)": "(valikuline)",
    "(required)": "(nõutav)"
  },
  "fi-FI": {
    "(optional)": "(valinnainen)",
    "(required)": "(pakollinen)"
  },
  "fr-FR": {
    "(optional)": "(facultatif)",
    "(required)": "(requis)"
  },
  "he-IL": {
    "(optional)": "(אופציונלי)",
    "(required)": "(נדרש)"
  },
  "hr-HR": {
    "(optional)": "(opcionalno)",
    "(required)": "(obvezno)"
  },
  "hu-HU": {
    "(optional)": "(opcionális)",
    "(required)": "(kötelező)"
  },
  "it-IT": {
    "(optional)": "(facoltativo)",
    "(required)": "(obbligatorio)"
  },
  "ja-JP": {
    "(optional)": "（オプション）",
    "(required)": "（必須）"
  },
  "ko-KR": {
    "(optional)": "(선택 사항)",
    "(required)": "(필수 사항)"
  },
  "lt-LT": {
    "(optional)": "(pasirenkama)",
    "(required)": "(privaloma)"
  },
  "lv-LV": {
    "(optional)": "(neobligāti)",
    "(required)": "(obligāti)"
  },
  "nb-NO": {
    "(optional)": "(valgfritt)",
    "(required)": "(obligatorisk)"
  },
  "nl-NL": {
    "(optional)": "(optioneel)",
    "(required)": "(vereist)"
  },
  "pl-PL": {
    "(optional)": "(opcjonalne)",
    "(required)": "(wymagane)"
  },
  "pt-BR": {
    "(optional)": "(opcional)",
    "(required)": "(obrigatório)"
  },
  "pt-PT": {
    "(optional)": "(opcional)",
    "(required)": "(obrigatório)"
  },
  "ro-RO": {
    "(optional)": "(opţional)",
    "(required)": "(obligatoriu)"
  },
  "ru-RU": {
    "(optional)": "(дополнительно)",
    "(required)": "(обязательно)"
  },
  "sk-SK": {
    "(optional)": "(nepovinné)",
    "(required)": "(povinné)"
  },
  "sl-SI": {
    "(optional)": "(opcijsko)",
    "(required)": "(obvezno)"
  },
  "sr-SP": {
    "(optional)": "(opciono)",
    "(required)": "(obavezno)"
  },
  "sv-SE": {
    "(optional)": "(valfritt)",
    "(required)": "(krävs)"
  },
  "tr-TR": {
    "(optional)": "(isteğe bağlı)",
    "(required)": "(gerekli)"
  },
  "uk-UA": {
    "(optional)": "(необов’язково)",
    "(required)": "(обов’язково)"
  },
  "zh-CN": {
    "(optional)": "（可选）",
    "(required)": "（必填）"
  },
  "zh-TW": {
    "(optional)": "(選填)",
    "(required)": "(必填)"
  }
};
var FieldLabel = forwardRefWithAs(function FieldLabel2({
  children,
  elementType: ElementType = "label",
  isRequired,
  supplementRequiredState,
  ...labelProps
}, forwardedRef) {
  const styleProps = useTextStyles({
    color: "neutral",
    size: "regular",
    trim: true,
    weight: "medium",
    UNSAFE_className: css({
      cursor: "default"
    })
  });
  return (0, import_jsx_runtime7.jsxs)(ElementType, {
    ref: forwardedRef,
    ...labelProps,
    ...styleProps,
    children: [children, isRequired && (0, import_jsx_runtime7.jsx)(Asterisk, {
      supplementRequiredState
    })]
  });
});
function Asterisk({
  supplementRequiredState
}) {
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages);
  return (0, import_jsx_runtime7.jsx)("span", {
    "aria-label": supplementRequiredState ? stringFormatter.format("(required)") : void 0,
    children: (0, import_jsx_runtime7.jsx)("span", {
      "aria-hidden": true,
      className: css({
        color: tokenSchema.color.foreground.critical,
        fontSize: tokenSchema.typography.text.large.size,
        lineHeight: 1,
        paddingInlineStart: "0.125em"
      }),
      children: "*"
    })
  });
}
var FieldMessage = (props) => {
  return (0, import_jsx_runtime7.jsxs)(Flex, {
    gap: "regular",
    UNSAFE_className: css({
      marginTop: "calc(var(--icon-offset) * -1)"
    }),
    UNSAFE_style: {
      // @ts-ignore
      "--icon-offset": `calc(${tokenSchema.size.icon.regular} - ${tokenSchema.typography.text.small.size})`
    },
    children: [(0, import_jsx_runtime7.jsx)(Icon, {
      src: alertTriangleIcon,
      color: "critical"
    }), (0, import_jsx_runtime7.jsx)(Text2, {
      color: "critical",
      size: "small",
      UNSAFE_className: css({
        paddingTop: "var(--icon-offset)"
      }),
      ...props
    })]
  });
};
var FieldPrimitive = (0, import_react17.forwardRef)(function FieldPrimitive2(props, forwardedRef) {
  const {
    children,
    contextualHelp,
    isRequired,
    label,
    labelElementType,
    labelProps,
    description,
    descriptionProps,
    errorMessage,
    errorMessageProps,
    supplementRequiredState
  } = props;
  const styleProps = useStyleProps(props);
  const contextualHelpId = (0, import_react17.useId)();
  const contextualHelpSlots = (0, import_react17.useMemo)(() => {
    return {
      // match capsize styles from the label text. stops the contextual help button
      // from pushing elements above/below it
      button: {
        UNSAFE_className: css({
          marginBottom: tokenSchema.typography.text.regular.capheightTrim,
          marginTop: tokenSchema.typography.text.regular.baselineTrim
        }),
        id: contextualHelpId,
        "aria-labelledby": labelProps !== null && labelProps !== void 0 && labelProps.id ? `${labelProps.id} ${contextualHelpId}` : void 0
      }
    };
  }, [contextualHelpId, labelProps === null || labelProps === void 0 ? void 0 : labelProps.id]);
  return (0, import_jsx_runtime7.jsxs)(Flex, {
    ref: forwardedRef,
    direction: "column",
    gap: "medium",
    minWidth: 0,
    UNSAFE_className: styleProps.className,
    UNSAFE_style: styleProps.style,
    children: [(() => {
      if (!label) {
        return null;
      }
      const labelUI = (0, import_jsx_runtime7.jsx)(FieldLabel, {
        elementType: labelElementType,
        isRequired,
        supplementRequiredState,
        ...labelProps,
        children: label
      });
      if (contextualHelp) {
        return (0, import_jsx_runtime7.jsxs)(Flex, {
          gap: "small",
          alignItems: "center",
          children: [labelUI, (0, import_jsx_runtime7.jsx)(SlotProvider, {
            slots: contextualHelpSlots,
            children: contextualHelp
          })]
        });
      }
      return labelUI;
    })(), description && (0, import_jsx_runtime7.jsx)(Text2, {
      ...descriptionProps,
      size: "small",
      color: "neutralSecondary",
      children: description
    }), children, errorMessage && (0, import_jsx_runtime7.jsx)(FieldMessage, {
      ...errorMessageProps,
      children: errorMessage
    })]
  });
});
var Field = (props) => {
  const {
    children,
    description,
    errorMessage,
    isDisabled,
    isReadOnly,
    isRequired,
    label,
    ...otherProps
  } = props;
  let {
    labelProps,
    fieldProps,
    descriptionProps,
    errorMessageProps
  } = $2baaea4c71418dea$export$294aa081a6c6f55d(props);
  const renderProps = {
    ...fieldProps,
    disabled: isDisabled,
    readOnly: isReadOnly,
    "aria-required": isRequired || void 0,
    "aria-invalid": errorMessage ? true : void 0
  };
  return (0, import_jsx_runtime7.jsx)(FieldPrimitive, {
    isRequired,
    label,
    labelProps,
    description,
    descriptionProps,
    errorMessage,
    errorMessageProps,
    ...otherProps,
    children: children(renderProps)
  });
};
function validateFieldProps(props) {
  if (props.errorMessage) {
    return Object.assign({}, {
      validationState: "invalid"
    }, props);
  }
  return props;
}

// node_modules/@keystar/ui/dist/keystar-ui-text-field.js
var import_react21 = __toESM(require_react());
var import_jsx_runtime8 = __toESM(require_jsx_runtime());

// node_modules/@react-aria/textfield/dist/import.mjs
var import_react20 = __toESM(require_react(), 1);

// node_modules/@react-aria/form/dist/import.mjs
var import_react18 = __toESM(require_react(), 1);
function $e93e671b31057976$export$b8473d3665f3a75a(props, state, ref) {
  let { validationBehavior, focus } = props;
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (validationBehavior === "native" && (ref === null || ref === void 0 ? void 0 : ref.current)) {
      let errorMessage = state.realtimeValidation.isInvalid ? state.realtimeValidation.validationErrors.join(" ") || "Invalid value." : "";
      ref.current.setCustomValidity(errorMessage);
      if (!ref.current.hasAttribute("title"))
        ref.current.title = "";
      if (!state.realtimeValidation.isInvalid)
        state.updateValidation($e93e671b31057976$var$getNativeValidity(ref.current));
    }
  });
  let onReset = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(() => {
    state.resetValidation();
  });
  let onInvalid = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    var _ref_current;
    if (!state.displayValidation.isInvalid)
      state.commitValidation();
    let form = ref === null || ref === void 0 ? void 0 : (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.form;
    if (!e6.defaultPrevented && ref && form && $e93e671b31057976$var$getFirstInvalidInput(form) === ref.current) {
      var _ref_current1;
      if (focus)
        focus();
      else
        (_ref_current1 = ref.current) === null || _ref_current1 === void 0 ? void 0 : _ref_current1.focus();
      (0, $507fabe10e71c6fb$export$8397ddfc504fdb9a)("keyboard");
    }
    e6.preventDefault();
  });
  let onChange2 = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(() => {
    state.commitValidation();
  });
  (0, import_react18.useEffect)(() => {
    let input = ref === null || ref === void 0 ? void 0 : ref.current;
    if (!input)
      return;
    let form = input.form;
    input.addEventListener("invalid", onInvalid);
    input.addEventListener("change", onChange2);
    form === null || form === void 0 ? void 0 : form.addEventListener("reset", onReset);
    return () => {
      input.removeEventListener("invalid", onInvalid);
      input.removeEventListener("change", onChange2);
      form === null || form === void 0 ? void 0 : form.removeEventListener("reset", onReset);
    };
  }, [
    ref,
    onInvalid,
    onChange2,
    onReset,
    validationBehavior
  ]);
}
function $e93e671b31057976$var$getValidity(input) {
  let validity = input.validity;
  return {
    badInput: validity.badInput,
    customError: validity.customError,
    patternMismatch: validity.patternMismatch,
    rangeOverflow: validity.rangeOverflow,
    rangeUnderflow: validity.rangeUnderflow,
    stepMismatch: validity.stepMismatch,
    tooLong: validity.tooLong,
    tooShort: validity.tooShort,
    typeMismatch: validity.typeMismatch,
    valueMissing: validity.valueMissing,
    valid: validity.valid
  };
}
function $e93e671b31057976$var$getNativeValidity(input) {
  return {
    isInvalid: !input.validity.valid,
    validationDetails: $e93e671b31057976$var$getValidity(input),
    validationErrors: input.validationMessage ? [
      input.validationMessage
    ] : []
  };
}
function $e93e671b31057976$var$getFirstInvalidInput(form) {
  for (let i6 = 0; i6 < form.elements.length; i6++) {
    let element4 = form.elements[i6];
    if (!element4.validity.valid)
      return element4;
  }
  return null;
}

// node_modules/@react-stately/form/dist/import.mjs
var import_react19 = __toESM(require_react(), 1);
var $e5be200c675c3b3a$export$aca958c65c314e6c = {
  badInput: false,
  customError: false,
  patternMismatch: false,
  rangeOverflow: false,
  rangeUnderflow: false,
  stepMismatch: false,
  tooLong: false,
  tooShort: false,
  typeMismatch: false,
  valueMissing: false,
  valid: true
};
var $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE = {
  ...$e5be200c675c3b3a$export$aca958c65c314e6c,
  customError: true,
  valid: false
};
var $e5be200c675c3b3a$export$dad6ae84456c676a = {
  isInvalid: false,
  validationDetails: $e5be200c675c3b3a$export$aca958c65c314e6c,
  validationErrors: []
};
var $e5be200c675c3b3a$export$571b5131b7e65c11 = (0, import_react19.createContext)({});
var $e5be200c675c3b3a$export$a763b9476acd3eb = "__formValidationState" + Date.now();
function $e5be200c675c3b3a$export$fc1a364ae1f3ff10(props) {
  if (props[$e5be200c675c3b3a$export$a763b9476acd3eb]) {
    let { realtimeValidation, displayValidation, updateValidation, resetValidation, commitValidation } = props[$e5be200c675c3b3a$export$a763b9476acd3eb];
    return {
      realtimeValidation,
      displayValidation,
      updateValidation,
      resetValidation,
      commitValidation
    };
  }
  return $e5be200c675c3b3a$var$useFormValidationStateImpl(props);
}
function $e5be200c675c3b3a$var$useFormValidationStateImpl(props) {
  let { isInvalid, validationState, name: name2, value: value2, builtinValidation, validate: validate3, validationBehavior = "aria" } = props;
  if (validationState)
    isInvalid || (isInvalid = validationState === "invalid");
  let controlledError = isInvalid ? {
    isInvalid: true,
    validationErrors: [],
    validationDetails: $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE
  } : null;
  let clientError = (0, import_react19.useMemo)(() => $e5be200c675c3b3a$var$getValidationResult($e5be200c675c3b3a$var$runValidate(validate3, value2)), [
    validate3,
    value2
  ]);
  if (builtinValidation === null || builtinValidation === void 0 ? void 0 : builtinValidation.validationDetails.valid)
    builtinValidation = null;
  let serverErrors = (0, import_react19.useContext)($e5be200c675c3b3a$export$571b5131b7e65c11);
  let serverErrorMessages = (0, import_react19.useMemo)(() => {
    if (name2)
      return Array.isArray(name2) ? name2.flatMap((name3) => $e5be200c675c3b3a$var$asArray(serverErrors[name3])) : $e5be200c675c3b3a$var$asArray(serverErrors[name2]);
    return [];
  }, [
    serverErrors,
    name2
  ]);
  let [lastServerErrors, setLastServerErrors] = (0, import_react19.useState)(serverErrors);
  let [isServerErrorCleared, setServerErrorCleared] = (0, import_react19.useState)(false);
  if (serverErrors !== lastServerErrors) {
    setLastServerErrors(serverErrors);
    setServerErrorCleared(false);
  }
  let serverError = (0, import_react19.useMemo)(() => $e5be200c675c3b3a$var$getValidationResult(isServerErrorCleared ? [] : serverErrorMessages), [
    isServerErrorCleared,
    serverErrorMessages
  ]);
  let nextValidation = (0, import_react19.useRef)($e5be200c675c3b3a$export$dad6ae84456c676a);
  let [currentValidity, setCurrentValidity] = (0, import_react19.useState)($e5be200c675c3b3a$export$dad6ae84456c676a);
  let lastError = (0, import_react19.useRef)($e5be200c675c3b3a$export$dad6ae84456c676a);
  let commitValidation = () => {
    if (!commitQueued)
      return;
    setCommitQueued(false);
    let error3 = clientError || builtinValidation || nextValidation.current;
    if (!$e5be200c675c3b3a$var$isEqualValidation(error3, lastError.current)) {
      lastError.current = error3;
      setCurrentValidity(error3);
    }
  };
  let [commitQueued, setCommitQueued] = (0, import_react19.useState)(false);
  (0, import_react19.useEffect)(commitValidation);
  let realtimeValidation = controlledError || serverError || clientError || builtinValidation || $e5be200c675c3b3a$export$dad6ae84456c676a;
  let displayValidation = validationBehavior === "native" ? controlledError || serverError || currentValidity : controlledError || serverError || clientError || builtinValidation || currentValidity;
  return {
    realtimeValidation,
    displayValidation,
    updateValidation(value3) {
      if (validationBehavior === "aria" && !$e5be200c675c3b3a$var$isEqualValidation(currentValidity, value3))
        setCurrentValidity(value3);
      else
        nextValidation.current = value3;
    },
    resetValidation() {
      let error3 = $e5be200c675c3b3a$export$dad6ae84456c676a;
      if (!$e5be200c675c3b3a$var$isEqualValidation(error3, lastError.current)) {
        lastError.current = error3;
        setCurrentValidity(error3);
      }
      if (validationBehavior === "native")
        setCommitQueued(false);
      setServerErrorCleared(true);
    },
    commitValidation() {
      if (validationBehavior === "native")
        setCommitQueued(true);
      setServerErrorCleared(true);
    }
  };
}
function $e5be200c675c3b3a$var$asArray(v6) {
  if (!v6)
    return [];
  return Array.isArray(v6) ? v6 : [
    v6
  ];
}
function $e5be200c675c3b3a$var$runValidate(validate3, value2) {
  if (typeof validate3 === "function") {
    let e6 = validate3(value2);
    if (e6 && typeof e6 !== "boolean")
      return $e5be200c675c3b3a$var$asArray(e6);
  }
  return [];
}
function $e5be200c675c3b3a$var$getValidationResult(errors) {
  return errors.length ? {
    isInvalid: true,
    validationErrors: errors,
    validationDetails: $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE
  } : null;
}
function $e5be200c675c3b3a$var$isEqualValidation(a3, b2) {
  if (a3 === b2)
    return true;
  return a3 && b2 && a3.isInvalid === b2.isInvalid && a3.validationErrors.length === b2.validationErrors.length && a3.validationErrors.every((a4, i6) => a4 === b2.validationErrors[i6]) && Object.entries(a3.validationDetails).every(([k2, v6]) => b2.validationDetails[k2] === v6);
}
function $e5be200c675c3b3a$export$75ee7c75d68f5b0e(...results) {
  let errors = /* @__PURE__ */ new Set();
  let isInvalid = false;
  let validationDetails = {
    ...$e5be200c675c3b3a$export$aca958c65c314e6c
  };
  for (let v6 of results) {
    var _validationDetails, _key;
    for (let e6 of v6.validationErrors)
      errors.add(e6);
    isInvalid || (isInvalid = v6.isInvalid);
    for (let key in validationDetails)
      (_validationDetails = validationDetails)[_key = key] || (_validationDetails[_key] = v6.validationDetails[key]);
  }
  validationDetails.valid = !isInvalid;
  return {
    isInvalid,
    validationErrors: [
      ...errors
    ],
    validationDetails
  };
}

// node_modules/@react-aria/textfield/dist/import.mjs
function $2d73ec29415bd339$export$712718f7aec83d5(props, ref) {
  let { inputElementType = "input", isDisabled = false, isRequired = false, isReadOnly = false, type: type2 = "text", validationBehavior = "aria" } = props;
  let [value2, setValue] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(props.value, props.defaultValue || "", props.onChange);
  let { focusableProps } = (0, $e6afbd83fe6ebbd2$export$4c014de7c8940b4c)(props, ref);
  let validationState = (0, $e5be200c675c3b3a$export$fc1a364ae1f3ff10)({
    ...props,
    value: value2
  });
  let { isInvalid, validationErrors, validationDetails } = validationState.displayValidation;
  let { labelProps, fieldProps, descriptionProps, errorMessageProps } = (0, $2baaea4c71418dea$export$294aa081a6c6f55d)({
    ...props,
    isInvalid,
    errorMessage: props.errorMessage || validationErrors
  });
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  const inputOnlyProps = {
    type: type2,
    pattern: props.pattern
  };
  (0, $99facab73266f662$export$5add1d006293d136)(ref, value2, setValue);
  (0, $e93e671b31057976$export$b8473d3665f3a75a)(props, validationState, ref);
  (0, import_react20.useEffect)(() => {
    if (ref.current instanceof (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(ref.current).HTMLTextAreaElement) {
      let input = ref.current;
      Object.defineProperty(input, "defaultValue", {
        get: () => input.value,
        set: () => {
        },
        configurable: true
      });
    }
  }, [
    ref
  ]);
  return {
    labelProps,
    inputProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, inputElementType === "input" && inputOnlyProps, {
      disabled: isDisabled,
      readOnly: isReadOnly,
      required: isRequired && validationBehavior === "native",
      "aria-required": isRequired && validationBehavior === "aria" || void 0,
      "aria-invalid": isInvalid || void 0,
      "aria-errormessage": props["aria-errormessage"],
      "aria-activedescendant": props["aria-activedescendant"],
      "aria-autocomplete": props["aria-autocomplete"],
      "aria-haspopup": props["aria-haspopup"],
      value: value2,
      onChange: (e6) => setValue(e6.target.value),
      autoComplete: props.autoComplete,
      autoCapitalize: props.autoCapitalize,
      maxLength: props.maxLength,
      minLength: props.minLength,
      name: props.name,
      placeholder: props.placeholder,
      inputMode: props.inputMode,
      // Clipboard events
      onCopy: props.onCopy,
      onCut: props.onCut,
      onPaste: props.onPaste,
      // Composition events
      onCompositionEnd: props.onCompositionEnd,
      onCompositionStart: props.onCompositionStart,
      onCompositionUpdate: props.onCompositionUpdate,
      // Selection events
      onSelect: props.onSelect,
      // Input events
      onBeforeInput: props.onBeforeInput,
      onInput: props.onInput,
      ...focusableProps,
      ...fieldProps
    }),
    descriptionProps,
    errorMessageProps,
    isInvalid,
    validationErrors,
    validationDetails
  };
}
function $d841c8010a73d545$var$supportsNativeBeforeInputEvent() {
  return typeof window !== "undefined" && window.InputEvent && // @ts-ignore
  typeof InputEvent.prototype.getTargetRanges === "function";
}
function $d841c8010a73d545$export$4f384c9210e583c3(props, state, inputRef) {
  let onBeforeInputFallback = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    let input = inputRef.current;
    let nextValue;
    switch (e6.inputType) {
      case "historyUndo":
      case "historyRedo":
        return;
      case "deleteContent":
      case "deleteByCut":
      case "deleteByDrag":
        nextValue = input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);
        break;
      case "deleteContentForward":
        nextValue = input.selectionEnd === input.selectionStart ? input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd + 1) : input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);
        break;
      case "deleteContentBackward":
        nextValue = input.selectionEnd === input.selectionStart ? input.value.slice(0, input.selectionStart - 1) + input.value.slice(input.selectionStart) : input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);
        break;
      case "deleteSoftLineBackward":
      case "deleteHardLineBackward":
        nextValue = input.value.slice(input.selectionStart);
        break;
      default:
        if (e6.data != null)
          nextValue = input.value.slice(0, input.selectionStart) + e6.data + input.value.slice(input.selectionEnd);
        break;
    }
    if (nextValue == null || !state.validate(nextValue))
      e6.preventDefault();
  });
  (0, import_react20.useEffect)(() => {
    if (!$d841c8010a73d545$var$supportsNativeBeforeInputEvent())
      return;
    let input = inputRef.current;
    input.addEventListener("beforeinput", onBeforeInputFallback, false);
    return () => {
      input.removeEventListener("beforeinput", onBeforeInputFallback, false);
    };
  }, [
    inputRef,
    onBeforeInputFallback
  ]);
  let onBeforeInput = !$d841c8010a73d545$var$supportsNativeBeforeInputEvent() ? (e6) => {
    let nextValue = e6.target.value.slice(0, e6.target.selectionStart) + e6.data + e6.target.value.slice(e6.target.selectionEnd);
    if (!state.validate(nextValue))
      e6.preventDefault();
  } : null;
  let { labelProps, inputProps: textFieldProps, descriptionProps, errorMessageProps, ...validation } = (0, $2d73ec29415bd339$export$712718f7aec83d5)(props, inputRef);
  let compositionStartState = (0, import_react20.useRef)(null);
  return {
    inputProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(textFieldProps, {
      onBeforeInput,
      onCompositionStart() {
        let { value: value2, selectionStart, selectionEnd } = inputRef.current;
        compositionStartState.current = {
          value: value2,
          selectionStart,
          selectionEnd
        };
      },
      onCompositionEnd() {
        if (!state.validate(inputRef.current.value)) {
          let { value: value2, selectionStart, selectionEnd } = compositionStartState.current;
          inputRef.current.value = value2;
          inputRef.current.setSelectionRange(selectionStart, selectionEnd);
          state.setInputValue(value2);
        }
      }
    }),
    labelProps,
    descriptionProps,
    errorMessageProps,
    ...validation
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-text-field.js
var TextFieldPrimitive = (0, import_react21.forwardRef)(function TextFieldPrimitive2(props, forwardedRef) {
  const {
    autoFocus,
    description,
    descriptionProps,
    endElement,
    errorMessage,
    errorMessageProps,
    id: id2,
    inputProps,
    inputWrapperProps,
    isDisabled,
    isMultiline = false,
    isRequired,
    label,
    labelProps,
    startElement,
    ...otherProps
  } = props;
  const InputElement = isMultiline ? "textarea" : "input";
  let {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    isDisabled
  });
  let inputClassName = useTextFieldStyles();
  let inputRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let onIndicatorPressStart = () => {
    if (document.activeElement === inputRef.current) {
      return;
    }
    inputRef.current.focus();
  };
  let {
    pressProps
  } = $f6c31cce2adf654f$export$45712eceda6fad21({
    isDisabled,
    onPressStart: onIndicatorPressStart,
    preventFocusOnPress: true
  });
  return (0, import_jsx_runtime8.jsx)(FieldPrimitive, {
    isRequired,
    description,
    descriptionProps,
    errorMessage,
    errorMessageProps,
    label,
    labelProps,
    ...otherProps,
    children: (0, import_jsx_runtime8.jsxs)("div", {
      ...inputWrapperProps,
      ...hoverProps,
      className: classNames(css({
        display: "flex",
        flex: "1 1 auto",
        position: "relative",
        zIndex: 0
      }), inputWrapperProps === null || inputWrapperProps === void 0 ? void 0 : inputWrapperProps.className),
      children: [startElement, (0, import_jsx_runtime8.jsx)(FocusRing, {
        autoFocus,
        isTextInput: true,
        children: (0, import_jsx_runtime8.jsx)(InputElement, {
          ...inputProps,
          ...toDataAttributes({
            adornment: getAdornmentType(props),
            hovered: isHovered || void 0,
            multiline: isMultiline || void 0
          }),
          className: classNames(inputClassName, inputProps === null || inputProps === void 0 ? void 0 : inputProps.className),
          "data-adornment": getAdornmentType(props),
          ref: inputRef,
          rows: isMultiline ? 1 : void 0
        })
      }), (0, import_jsx_runtime8.jsx)(InputStateIndicator, {
        inputClassName,
        ...pressProps
      }), endElement]
    })
  });
});
function makeSiblingSelector(base) {
  return function siblingSelector(...selectors) {
    return selectors.map((s4) => `.${base}${s4} + &`).join(", ");
  };
}
var InputStateIndicator = ({
  inputClassName,
  ...props
}) => {
  const s4 = makeSiblingSelector(inputClassName);
  return (0, import_jsx_runtime8.jsx)("div", {
    role: "presentation",
    ...props,
    className: css({
      backgroundColor: tokenSchema.color.background.canvas,
      border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.alias.borderIdle}`,
      borderRadius: tokenSchema.size.radius.regular,
      cursor: "text",
      inset: 0,
      position: "absolute",
      transition: transition(["border-color", "box-shadow"]),
      zIndex: -1,
      [s4("[data-hovered]")]: {
        borderColor: tokenSchema.color.alias.borderHovered
      },
      [s4(":invalid", "[aria-invalid]")]: {
        borderColor: tokenSchema.color.alias.borderInvalid
      },
      [s4(":focus")]: {
        borderColor: tokenSchema.color.alias.borderFocused
      },
      [s4(":focus:not([readonly])")]: {
        boxShadow: `0 0 0 1px ${tokenSchema.color.alias.borderFocused}`
      },
      [s4(":disabled", "[aria-disabled]")]: {
        backgroundColor: tokenSchema.color.background.surfaceSecondary,
        borderColor: "transparent",
        cursor: "auto"
      }
    })
  });
};
function useTextFieldStyles() {
  return css({
    color: tokenSchema.color.foreground.neutral,
    flex: 1,
    fontFamily: tokenSchema.typography.fontFamily.base,
    fontSize: tokenSchema.typography.text.regular.size,
    fontWeight: tokenSchema.typography.fontWeight.regular,
    height: tokenSchema.size.element.regular,
    lineHeight: tokenSchema.typography.lineheight.small,
    outline: 0,
    overflow: "visible",
    paddingBlock: tokenSchema.size.space.small,
    paddingInline: tokenSchema.size.space.medium,
    position: "relative",
    textIndent: 0,
    textOverflow: "ellipsis",
    verticalAlign: "top",
    width: "100%",
    MozOsxFontSmoothing: "auto",
    WebkitFontSmoothing: "auto",
    "::placeholder": {
      color: tokenSchema.color.foreground.neutralTertiary
    },
    "&:disabled, &[aria-disabled]": {
      color: tokenSchema.color.alias.foregroundDisabled,
      "::placeholder": {
        color: tokenSchema.color.alias.foregroundDisabled
      }
    },
    /* Remove the inner padding and cancel buttons for input[type="search"] in Chrome and Safari on macOS. */
    "&::-webkit-search-cancel-button, &::-webkit-search-decoration": {
      WebkitAppearance: "none"
    },
    // TEXTAREA
    // ------------------------------
    "&[data-multiline]": {
      height: "auto",
      lineHeight: tokenSchema.typography.lineheight.medium,
      minHeight: tokenSchema.size.scale["700"],
      overflow: "auto",
      paddingBlock: tokenSchema.size.space.regular,
      resize: "none"
    }
  });
}
function getAdornmentType(props) {
  if (props.startElement && props.endElement) {
    return "both";
  } else if (props.startElement) {
    return "start";
  } else if (props.endElement) {
    return "end";
  }
  return "none";
}
function validateTextFieldProps(props) {
  warning(!props.placeholder || !!props.description, "Placeholder text is not accessible. Use the `description` prop to provide information that will aid user input.");
  return validateFieldProps(props);
}
var TextField = (0, import_react21.forwardRef)(function TextField2(props, forwardedRef) {
  props = validateTextFieldProps(props);
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let {
    labelProps,
    inputProps,
    descriptionProps,
    errorMessageProps
  } = $2d73ec29415bd339$export$712718f7aec83d5(props, domRef);
  return (0, import_jsx_runtime8.jsx)(TextFieldPrimitive, {
    ref: domRef,
    ...props,
    labelProps,
    inputProps,
    descriptionProps,
    errorMessageProps
  });
});
var TextArea = (0, import_react21.forwardRef)(function TextArea2({
  onChange: onChange2,
  ...props
}, forwardedRef) {
  props = validateTextFieldProps(props);
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let [inputValue, setInputValue] = $458b0a5536c1a7cf$export$40bfa8c7b0832715(props.value, props.defaultValue, () => {
  });
  let onHeightChange = (0, import_react21.useCallback)(() => {
    let input = domRef.current;
    if (!props.height && input) {
      let prevOverflow = input.style.overflow;
      let isFirefox = "MozAppearance" in input.style;
      if (!isFirefox) {
        input.style.overflow = "hidden";
      }
      input.style.height = "auto";
      input.style.height = `${input.scrollHeight + (input.offsetHeight - input.clientHeight)}px`;
      input.style.overflow = prevOverflow;
    }
  }, [domRef, props.height]);
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    if (domRef.current) {
      onHeightChange();
    }
  }, [onHeightChange, inputValue, domRef]);
  let {
    labelProps,
    inputProps,
    descriptionProps,
    errorMessageProps
  } = $2d73ec29415bd339$export$712718f7aec83d5({
    ...props,
    onChange: $ff5963eb1fccf552$export$e08e3b67e392101e(onChange2, setInputValue),
    inputElementType: "textarea"
  }, domRef);
  return (0, import_jsx_runtime8.jsx)(TextFieldPrimitive, {
    ...props,
    ref: domRef,
    labelProps,
    inputProps,
    descriptionProps,
    errorMessageProps,
    isMultiline: true
  });
});

// node_modules/@keystar/ui/dist/keystar-ui-split-view.js
var import_react22 = __toESM(require_react());
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
var SplitViewContext = (0, import_react22.createContext)({
  activity: void 0,
  id: "",
  isCollapsed: void 0
});
var SplitViewProvider = SplitViewContext.Provider;
function useSplitView() {
  return (0, import_react22.useContext)(SplitViewContext);
}
var currentState = null;
var element2 = null;
function getCursorStyle(state, isReversed) {
  switch (state) {
    case "horizontal":
      return "ew-resize";
    case "horizontal-max":
      return isReversed ? "e-resize" : "w-resize";
    case "horizontal-min":
      return isReversed ? "w-resize" : "e-resize";
  }
}
function resetGlobalCursorStyle() {
  if (element2 !== null) {
    document.head.removeChild(element2);
    currentState = null;
    element2 = null;
  }
}
function setGlobalCursorStyle(state, isReversed) {
  if (currentState === state) {
    return;
  }
  currentState = state;
  const style = getCursorStyle(state, isReversed);
  if (element2 === null) {
    element2 = document.createElement("style");
    document.head.appendChild(element2);
  }
  element2.innerHTML = `*{cursor: ${style}!important;}`;
}
function initializeDefaultStorage(storageObject) {
  try {
    if (typeof localStorage !== "undefined") {
      storageObject.getItem = (name2) => {
        return localStorage.getItem(name2);
      };
      storageObject.setItem = (name2, value2) => {
        localStorage.setItem(name2, value2);
      };
    } else {
      throw new Error("localStorage not supported in this environment");
    }
  } catch (error3) {
    console.error(error3);
    storageObject.getItem = () => null;
    storageObject.setItem = () => {
    };
  }
}
var defaultStorage = {
  getItem: (name2) => {
    initializeDefaultStorage(defaultStorage);
    return defaultStorage.getItem(name2);
  },
  setItem: (name2, value2) => {
    initializeDefaultStorage(defaultStorage);
    defaultStorage.setItem(name2, value2);
  }
};
function getPosition(e6) {
  if (isMouseEvent(e6)) {
    return e6.clientX;
  } else if (isTouchEvent(e6)) {
    return e6.touches[0].clientX;
  }
  return 0;
}
function getPercentage(value2, min3, max4) {
  return Math.round((value2 - min3) / (max4 - min3) * 100);
}
function getPrimaryPaneId(id2) {
  return `primary-pane-${id2}`;
}
function getSecondaryPaneId(id2) {
  return `secondary-pane-${id2}`;
}
function getResizeHandleId(id2) {
  return `resize-handle-${id2}`;
}
function getPrimaryPane(id2) {
  return document.getElementById(getPrimaryPaneId(id2));
}
function getSecondaryPane(id2) {
  return document.getElementById(getSecondaryPaneId(id2));
}
function getResizeHandle(id2) {
  return document.getElementById(getResizeHandleId(id2));
}
function px(value2) {
  return `${value2}px`;
}
function isMouseEvent(event) {
  return event.type.startsWith("mouse");
}
function isTouchEvent(event) {
  return event.type.startsWith("touch");
}
var MAX_WIDTH_PROP = "--primary-pane-max-width";
var MAX_WIDTH_VAR = `var(${MAX_WIDTH_PROP})`;
var MIN_WIDTH_PROP = "--primary-pane-min-width";
var MIN_WIDTH_VAR = `var(${MIN_WIDTH_PROP})`;
var WIDTH_PROP = "--primary-pane-width";
var WIDTH_VAR = `var(${WIDTH_PROP})`;
var SNAP_REGION_PX = 32;
var KEYBOARD_ARROW_STEPS = 10;
function SplitView(props) {
  let {
    autoSaveId,
    children,
    defaultSize,
    isCollapsed,
    minSize,
    maxSize,
    onCollapseChange,
    onResize,
    storage = defaultStorage
  } = props;
  const [startPane, endPane] = children;
  const getIsMounted = useIsMounted();
  const id2 = useId(props.id);
  const {
    direction
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  const styleProps = useStyleProps(props);
  const [isReversed, setReversed] = (0, import_react22.useState)(false);
  const [isDragging, setDragging] = (0, import_react22.useState)(false);
  const [handleIsFocused, setHandleFocus] = (0, import_react22.useState)(false);
  const [size3, setSize] = (0, import_react22.useState)(() => {
    let size4 = defaultSize;
    if (autoSaveId) {
      let savedSize = storage.getItem(autoSaveId);
      if (savedSize) {
        size4 = Number.parseInt(savedSize);
      }
    }
    return size4;
  });
  const wrapperRef = (0, import_react22.useRef)(null);
  const offsetRef = (0, import_react22.useRef)(0);
  const moveRef = (0, import_react22.useRef)(0);
  (0, import_react22.useEffect)(() => {
    const resizeHandle = getResizeHandle(id2);
    const primaryPane = getPrimaryPane(id2);
    const secondaryPane = getSecondaryPane(id2);
    setReversed(direction === "rtl" ? (resizeHandle === null || resizeHandle === void 0 ? void 0 : resizeHandle.previousElementSibling) === primaryPane : (resizeHandle === null || resizeHandle === void 0 ? void 0 : resizeHandle.previousElementSibling) === secondaryPane);
  }, [direction, id2]);
  $4f58c5f72bcf79f7$export$496315a1608d9602(() => onResize === null || onResize === void 0 ? void 0 : onResize(size3), [size3]);
  (0, import_react22.useEffect)(() => {
    var _wrapperRef$current;
    (_wrapperRef$current = wrapperRef.current) === null || _wrapperRef$current === void 0 || _wrapperRef$current.style.setProperty(WIDTH_PROP, px(size3));
    moveRef.current = size3;
    if (autoSaveId) {
      storage.setItem(autoSaveId, px(size3));
    }
  }, [autoSaveId, onResize, size3, storage]);
  (0, import_react22.useEffect)(() => {
    const wrapper = wrapperRef.current;
    const resizeHandle = getResizeHandle(id2);
    const primaryPane = getPrimaryPane(id2);
    if (!wrapper || !resizeHandle || !primaryPane) {
      return;
    }
    let collapseRequested = false;
    let collapseAllowed = typeof isCollapsed === "boolean";
    const onMove = (e6) => {
      e6.preventDefault();
      let delta = getPosition(e6) - offsetRef.current;
      if (isReversed)
        delta = delta * -1;
      let nextWidth = size3 + delta;
      if (Math.abs(nextWidth - defaultSize) < SNAP_REGION_PX / 2) {
        nextWidth = defaultSize;
      }
      if (collapseAllowed) {
        collapseRequested = nextWidth <= minSize / 2;
      }
      if (collapseRequested) {
        primaryPane.style.setProperty("width", "0px");
        moveRef.current = size3;
      } else {
        moveRef.current = nextWidth;
        primaryPane.style.removeProperty("width");
      }
      wrapper.style.setProperty(WIDTH_PROP, px(moveRef.current));
      let cursorStyle = "horizontal";
      if (moveRef.current < minSize) {
        cursorStyle = "horizontal-min";
      }
      if (moveRef.current > maxSize) {
        cursorStyle = "horizontal-max";
      }
      setGlobalCursorStyle(cursorStyle, isReversed);
    };
    const stopDragging = () => {
      resizeHandle.blur();
      setDragging(false);
      resetGlobalCursorStyle();
      if (collapseRequested) {
        onCollapseChange === null || onCollapseChange === void 0 || onCollapseChange(!isCollapsed);
        primaryPane.style.removeProperty("width");
      } else {
        setSize($9446cca9a3875146$export$7d15b64cf5a3a4c4(moveRef.current, minSize, maxSize));
      }
      collapseRequested = false;
      document.body.removeEventListener("mousemove", onMove);
      document.body.removeEventListener("touchmove", onMove);
      window.removeEventListener("mouseup", stopDragging);
      window.removeEventListener("touchend", stopDragging);
    };
    const startDragging = (e6) => {
      if ("button" in e6 && e6.button !== 0) {
        return;
      }
      if ("touches" in e6 && e6.touches.length !== 1) {
        return;
      }
      setDragging(true);
      offsetRef.current = getPosition(e6);
      document.body.addEventListener("mousemove", onMove);
      document.body.addEventListener("touchmove", onMove);
      window.addEventListener("mouseup", stopDragging);
      window.addEventListener("touchend", stopDragging);
    };
    const onKeyDown = (e6) => {
      if (e6.defaultPrevented) {
        return;
      }
      let step = Math.round((maxSize - minSize) / KEYBOARD_ARROW_STEPS);
      let increment2 = () => setSize((size4) => Math.min(size4 + step, maxSize));
      let decrement = () => setSize((size4) => Math.max(size4 - step, minSize));
      switch (e6.key) {
        case "Enter":
          if (collapseAllowed) {
            e6.preventDefault();
            onCollapseChange === null || onCollapseChange === void 0 || onCollapseChange(!isCollapsed);
          }
          break;
        case "Home":
          e6.preventDefault();
          setSize(minSize);
          break;
        case "End":
          e6.preventDefault();
          setSize(maxSize);
          break;
        case "ArrowLeft":
          e6.preventDefault();
          if (isReversed) {
            increment2();
          } else {
            decrement();
          }
          break;
        case "ArrowRight":
          e6.preventDefault();
          if (isReversed) {
            decrement();
          } else {
            increment2();
          }
      }
    };
    let options = {
      passive: true
    };
    let onDoubleClick = (e6) => {
      if (e6.clientX === offsetRef.current) {
        setSize(defaultSize);
      }
    };
    resizeHandle.addEventListener("contextmenu", stopDragging);
    resizeHandle.addEventListener("dblclick", onDoubleClick);
    resizeHandle.addEventListener("keydown", onKeyDown);
    resizeHandle.addEventListener("mousedown", startDragging, options);
    resizeHandle.addEventListener("touchstart", startDragging, options);
    return () => {
      resizeHandle.removeEventListener("contextmenu", stopDragging);
      resizeHandle.removeEventListener("dblclick", onDoubleClick);
      resizeHandle.removeEventListener("keydown", onKeyDown);
      resizeHandle.removeEventListener("mousedown", startDragging);
      resizeHandle.removeEventListener("touchstart", startDragging);
    };
  }, [maxSize, minSize, defaultSize, id2, isReversed, size3, onCollapseChange, isCollapsed]);
  return (0, import_jsx_runtime9.jsx)(SplitViewProvider, {
    value: {
      id: id2,
      isCollapsed,
      activity: !getIsMounted() ? "initializing" : isDragging ? "pointer" : handleIsFocused ? "keyboard" : void 0
    },
    children: (0, import_jsx_runtime9.jsxs)("div", {
      ...styleProps,
      ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(props),
      ref: wrapperRef,
      className: classNames(css({
        display: "flex",
        height: "100%",
        width: "100%",
        overflow: "hidden",
        [MIN_WIDTH_PROP]: px(minSize),
        [MAX_WIDTH_PROP]: px(maxSize),
        [WIDTH_PROP]: px(defaultSize)
      }), styleProps.className),
      children: [startPane, (0, import_jsx_runtime9.jsx)(SplitViewResizeHandle, {
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-valuenow": getPercentage(size3, minSize, maxSize),
        onBlur: () => setHandleFocus(false),
        onFocus: () => setHandleFocus(true)
      }), endPane]
    })
  });
}
var SplitPanePrimary = (0, import_react22.forwardRef)(function SplitPanePrimary2(props, forwardedRef) {
  let {
    activity,
    id: id2,
    isCollapsed
  } = useSplitView();
  let styleProps = useStyleProps(props);
  return (0, import_jsx_runtime9.jsx)("div", {
    ...styleProps,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(props),
    ref: forwardedRef,
    id: getPrimaryPaneId(id2),
    "data-split-pane": "primary",
    "data-split-view-activity": activity,
    "data-split-view-collapsed": isCollapsed || void 0,
    className: classNames(css({
      containerType: "inline-size",
      overflow: "hidden",
      width: `clamp(${MIN_WIDTH_VAR},${WIDTH_VAR},${MAX_WIDTH_VAR})`,
      // prevent the secondary pane from collapsing completely, regardless of
      // consumer preference. losing the drag handle is a bad experience.
      maxWidth: `calc(100% - 100px)`,
      // hide when collapsed
      "&[data-split-view-collapsed]": {
        visibility: "hidden",
        width: 0
      },
      // support transition when not dragging
      "&:not([data-split-view-activity])": {
        transition: transition("width")
      },
      // disable interactive elements during drag
      "&[data-split-view-activity=pointer]": {
        pointerEvents: "none"
      }
    }), styleProps.className),
    children: props.children
  });
});
var SplitPaneSecondary = (0, import_react22.forwardRef)(function SplitPaneSecondary2(props, forwardedRef) {
  let {
    id: id2,
    activity
  } = useSplitView();
  let styleProps = useStyleProps(props);
  return (0, import_jsx_runtime9.jsx)("div", {
    ...styleProps,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(props),
    ref: forwardedRef,
    id: getSecondaryPaneId(id2),
    "data-split-pane": "secondary",
    "data-split-view-activity": activity,
    className: classNames(css({
      containerType: "inline-size",
      flex: `1 1 0`,
      // prevent the secondary pane from collapsing completely, regardless of
      // consumer preference. losing the drag handle is a bad experience.
      minWidth: `100px`,
      overflow: "hidden",
      // disable interactive elements during drag
      "&[data-split-view-activity=pointer]": {
        pointerEvents: "none"
      }
    }), styleProps.className),
    children: props.children
  });
});
var SplitViewResizeHandle = (0, import_react22.forwardRef)(function SplitViewResizeHandle2(props, forwardedRef) {
  let {
    activity,
    id: id2,
    isCollapsed
  } = useSplitView();
  return (0, import_jsx_runtime9.jsx)("div", {
    ...props,
    ref: forwardedRef,
    "aria-controls": getPrimaryPaneId(id2),
    "aria-label": "Resize",
    "aria-orientation": "vertical",
    id: getResizeHandleId(id2),
    role: "separator",
    tabIndex: 0,
    "data-split-view-resize-handle": true,
    "data-split-view-activity": activity,
    "data-split-view-collapsed": isCollapsed || void 0,
    className: css({
      backgroundColor: tokenSchema.color.border.muted,
      boxSizing: "border-box",
      cursor: "ew-resize",
      flexShrink: 0,
      outline: 0,
      position: "relative",
      touchAction: "none",
      transition: transition("background-color"),
      userSelect: "none",
      width: tokenSchema.size.border.regular,
      zIndex: 1,
      // hide visually when collapsed. still allow keyboard focus
      "&[data-split-view-collapsed]:not([data-split-view-activity])": visuallyHiddenStyles,
      // increase hit area
      "&::before": {
        content: '""',
        position: "absolute",
        inset: `calc(${tokenSchema.size.space.small} * -1)`
      },
      // drag indicator
      "&::after": {
        backgroundColor: tokenSchema.color.alias.backgroundHovered,
        content: '""',
        insetBlock: 0,
        insetInline: `calc(${tokenSchema.size.border.medium} * -1)`,
        opacity: 0,
        position: "absolute",
        transition: transition("opacity")
      },
      // delay transition to avoid unexpected flicker, the user may just be
      // mousing between panes; this way we ensure intent
      "&:hover": {
        backgroundColor: tokenSchema.color.border.neutral,
        transitionDelay: tokenSchema.animation.duration.regular,
        "&::after": {
          opacity: 1,
          transitionDelay: tokenSchema.animation.duration.regular
        }
      },
      "&[data-split-view-activity=pointer]::after, &[data-split-view-activity=keyboard]::after": {
        backgroundColor: tokenSchema.color.background.accentEmphasis,
        insetInline: `calc(${tokenSchema.size.border.regular} * -1)`,
        opacity: 1
      }
    })
  });
});
var visuallyHiddenStyles = {
  border: 0,
  clip: "rect(0 0 0 0)",
  clipPath: "inset(50%)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "absolute",
  width: "1px",
  whiteSpace: "nowrap"
};

// node_modules/@react-aria/overlays/dist/ar-AE.mjs
var $773d5888b972f1cf$exports = {};
$773d5888b972f1cf$exports = {
  "dismiss": `تجاهل`
};

// node_modules/@react-aria/overlays/dist/bg-BG.mjs
var $d11f19852b941573$exports = {};
$d11f19852b941573$exports = {
  "dismiss": `Отхвърляне`
};

// node_modules/@react-aria/overlays/dist/cs-CZ.mjs
var $b983974c2ee1efb3$exports = {};
$b983974c2ee1efb3$exports = {
  "dismiss": `Odstranit`
};

// node_modules/@react-aria/overlays/dist/da-DK.mjs
var $5809cc9d4e92de73$exports = {};
$5809cc9d4e92de73$exports = {
  "dismiss": `Luk`
};

// node_modules/@react-aria/overlays/dist/de-DE.mjs
var $c68c2e4fc74398d1$exports = {};
$c68c2e4fc74398d1$exports = {
  "dismiss": `Schließen`
};

// node_modules/@react-aria/overlays/dist/el-GR.mjs
var $0898b4c153db2b77$exports = {};
$0898b4c153db2b77$exports = {
  "dismiss": `Απόρριψη`
};

// node_modules/@react-aria/overlays/dist/en-US.mjs
var $6d74810286a15183$exports = {};
$6d74810286a15183$exports = {
  "dismiss": `Dismiss`
};

// node_modules/@react-aria/overlays/dist/es-ES.mjs
var $309d73dc65f78055$exports = {};
$309d73dc65f78055$exports = {
  "dismiss": `Descartar`
};

// node_modules/@react-aria/overlays/dist/et-EE.mjs
var $44ad94f7205cf593$exports = {};
$44ad94f7205cf593$exports = {
  "dismiss": `Lõpeta`
};

// node_modules/@react-aria/overlays/dist/fi-FI.mjs
var $7c28f5687f0779a9$exports = {};
$7c28f5687f0779a9$exports = {
  "dismiss": `Hylkää`
};

// node_modules/@react-aria/overlays/dist/fr-FR.mjs
var $e6d75df4b68bd73a$exports = {};
$e6d75df4b68bd73a$exports = {
  "dismiss": `Rejeter`
};

// node_modules/@react-aria/overlays/dist/he-IL.mjs
var $87505c9dab186d0f$exports = {};
$87505c9dab186d0f$exports = {
  "dismiss": `התעלם`
};

// node_modules/@react-aria/overlays/dist/hr-HR.mjs
var $553439c3ffb3e492$exports = {};
$553439c3ffb3e492$exports = {
  "dismiss": `Odbaci`
};

// node_modules/@react-aria/overlays/dist/hu-HU.mjs
var $74cf411061b983a2$exports = {};
$74cf411061b983a2$exports = {
  "dismiss": `Elutasítás`
};

// node_modules/@react-aria/overlays/dist/it-IT.mjs
var $e933f298574dc435$exports = {};
$e933f298574dc435$exports = {
  "dismiss": `Ignora`
};

// node_modules/@react-aria/overlays/dist/ja-JP.mjs
var $ac91fc9fe02f71f6$exports = {};
$ac91fc9fe02f71f6$exports = {
  "dismiss": `閉じる`
};

// node_modules/@react-aria/overlays/dist/ko-KR.mjs
var $52b96f86422025af$exports = {};
$52b96f86422025af$exports = {
  "dismiss": `무시`
};

// node_modules/@react-aria/overlays/dist/lt-LT.mjs
var $c0d724c3e51dafa6$exports = {};
$c0d724c3e51dafa6$exports = {
  "dismiss": `Atmesti`
};

// node_modules/@react-aria/overlays/dist/lv-LV.mjs
var $c92899672a3fe72e$exports = {};
$c92899672a3fe72e$exports = {
  "dismiss": `Nerādīt`
};

// node_modules/@react-aria/overlays/dist/nb-NO.mjs
var $9f576b39d8e7a9d6$exports = {};
$9f576b39d8e7a9d6$exports = {
  "dismiss": `Lukk`
};

// node_modules/@react-aria/overlays/dist/nl-NL.mjs
var $9d025808aeec81a7$exports = {};
$9d025808aeec81a7$exports = {
  "dismiss": `Negeren`
};

// node_modules/@react-aria/overlays/dist/pl-PL.mjs
var $fce709921e2c0fa6$exports = {};
$fce709921e2c0fa6$exports = {
  "dismiss": `Zignoruj`
};

// node_modules/@react-aria/overlays/dist/pt-BR.mjs
var $2599cf0c4ab37f59$exports = {};
$2599cf0c4ab37f59$exports = {
  "dismiss": `Descartar`
};

// node_modules/@react-aria/overlays/dist/pt-PT.mjs
var $3c220ae7ef8a35fd$exports = {};
$3c220ae7ef8a35fd$exports = {
  "dismiss": `Dispensar`
};

// node_modules/@react-aria/overlays/dist/ro-RO.mjs
var $93562b5094072f54$exports = {};
$93562b5094072f54$exports = {
  "dismiss": `Revocare`
};

// node_modules/@react-aria/overlays/dist/ru-RU.mjs
var $cd9e2abd0d06c7b4$exports = {};
$cd9e2abd0d06c7b4$exports = {
  "dismiss": `Пропустить`
};

// node_modules/@react-aria/overlays/dist/sk-SK.mjs
var $45375701f409adf1$exports = {};
$45375701f409adf1$exports = {
  "dismiss": `Zrušiť`
};

// node_modules/@react-aria/overlays/dist/sl-SI.mjs
var $27fab53a576de9dd$exports = {};
$27fab53a576de9dd$exports = {
  "dismiss": `Opusti`
};

// node_modules/@react-aria/overlays/dist/sr-SP.mjs
var $4438748d9952e7c7$exports = {};
$4438748d9952e7c7$exports = {
  "dismiss": `Odbaci`
};

// node_modules/@react-aria/overlays/dist/sv-SE.mjs
var $0936d7347ef4da4c$exports = {};
$0936d7347ef4da4c$exports = {
  "dismiss": `Avvisa`
};

// node_modules/@react-aria/overlays/dist/tr-TR.mjs
var $29700c92185d38f8$exports = {};
$29700c92185d38f8$exports = {
  "dismiss": `Kapat`
};

// node_modules/@react-aria/overlays/dist/uk-UA.mjs
var $662ccaf2be4c25b3$exports = {};
$662ccaf2be4c25b3$exports = {
  "dismiss": `Скасувати`
};

// node_modules/@react-aria/overlays/dist/zh-CN.mjs
var $d80a27deda7cdb3c$exports = {};
$d80a27deda7cdb3c$exports = {
  "dismiss": `取消`
};

// node_modules/@react-aria/overlays/dist/zh-TW.mjs
var $2b2734393847c884$exports = {};
$2b2734393847c884$exports = {
  "dismiss": `關閉`
};

// node_modules/@react-aria/overlays/dist/import.mjs
var import_react23 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
function $parcel$interopDefault(a3) {
  return a3 && a3.__esModule ? a3.default : a3;
}
var $edcf132a9284368a$var$AXIS = {
  top: "top",
  bottom: "top",
  left: "left",
  right: "left"
};
var $edcf132a9284368a$var$FLIPPED_DIRECTION = {
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left"
};
var $edcf132a9284368a$var$CROSS_AXIS = {
  top: "left",
  left: "top"
};
var $edcf132a9284368a$var$AXIS_SIZE = {
  top: "height",
  left: "width"
};
var $edcf132a9284368a$var$TOTAL_SIZE = {
  width: "totalWidth",
  height: "totalHeight"
};
var $edcf132a9284368a$var$PARSED_PLACEMENT_CACHE = {};
var $edcf132a9284368a$var$visualViewport = typeof document !== "undefined" && window.visualViewport;
function $edcf132a9284368a$var$getContainerDimensions(containerNode) {
  let width = 0, height = 0, totalWidth = 0, totalHeight = 0, top = 0, left = 0;
  let scroll = {};
  let isPinchZoomedIn = ($edcf132a9284368a$var$visualViewport === null || $edcf132a9284368a$var$visualViewport === void 0 ? void 0 : $edcf132a9284368a$var$visualViewport.scale) > 1;
  if (containerNode.tagName === "BODY") {
    let documentElement = document.documentElement;
    totalWidth = documentElement.clientWidth;
    totalHeight = documentElement.clientHeight;
    var _visualViewport_width;
    width = (_visualViewport_width = $edcf132a9284368a$var$visualViewport === null || $edcf132a9284368a$var$visualViewport === void 0 ? void 0 : $edcf132a9284368a$var$visualViewport.width) !== null && _visualViewport_width !== void 0 ? _visualViewport_width : totalWidth;
    var _visualViewport_height;
    height = (_visualViewport_height = $edcf132a9284368a$var$visualViewport === null || $edcf132a9284368a$var$visualViewport === void 0 ? void 0 : $edcf132a9284368a$var$visualViewport.height) !== null && _visualViewport_height !== void 0 ? _visualViewport_height : totalHeight;
    scroll.top = documentElement.scrollTop || containerNode.scrollTop;
    scroll.left = documentElement.scrollLeft || containerNode.scrollLeft;
    if ($edcf132a9284368a$var$visualViewport) {
      top = $edcf132a9284368a$var$visualViewport.offsetTop;
      left = $edcf132a9284368a$var$visualViewport.offsetLeft;
    }
  } else {
    ({ width, height, top, left } = $edcf132a9284368a$var$getOffset(containerNode));
    scroll.top = containerNode.scrollTop;
    scroll.left = containerNode.scrollLeft;
    totalWidth = width;
    totalHeight = height;
  }
  if ((0, $c87311424ea30a05$export$78551043582a6a98)() && (containerNode.tagName === "BODY" || containerNode.tagName === "HTML") && isPinchZoomedIn) {
    scroll.top = 0;
    scroll.left = 0;
    top = $edcf132a9284368a$var$visualViewport.pageTop;
    left = $edcf132a9284368a$var$visualViewport.pageLeft;
  }
  return {
    width,
    height,
    totalWidth,
    totalHeight,
    scroll,
    top,
    left
  };
}
function $edcf132a9284368a$var$getScroll(node4) {
  return {
    top: node4.scrollTop,
    left: node4.scrollLeft,
    width: node4.scrollWidth,
    height: node4.scrollHeight
  };
}
function $edcf132a9284368a$var$getDelta(axis, offset, size3, boundaryDimensions, containerDimensions, padding, containerOffsetWithBoundary) {
  let containerScroll = containerDimensions.scroll[axis];
  let boundarySize = boundaryDimensions[$edcf132a9284368a$var$AXIS_SIZE[axis]];
  let boundaryStartEdge = boundaryDimensions.scroll[$edcf132a9284368a$var$AXIS[axis]] + padding;
  let boundaryEndEdge = boundarySize + boundaryDimensions.scroll[$edcf132a9284368a$var$AXIS[axis]] - padding;
  let startEdgeOffset = offset - containerScroll + containerOffsetWithBoundary[axis] - boundaryDimensions[$edcf132a9284368a$var$AXIS[axis]];
  let endEdgeOffset = offset - containerScroll + size3 + containerOffsetWithBoundary[axis] - boundaryDimensions[$edcf132a9284368a$var$AXIS[axis]];
  if (startEdgeOffset < boundaryStartEdge)
    return boundaryStartEdge - startEdgeOffset;
  else if (endEdgeOffset > boundaryEndEdge)
    return Math.max(boundaryEndEdge - endEdgeOffset, boundaryStartEdge - startEdgeOffset);
  else
    return 0;
}
function $edcf132a9284368a$var$getMargins(node4) {
  let style = window.getComputedStyle(node4);
  return {
    top: parseInt(style.marginTop, 10) || 0,
    bottom: parseInt(style.marginBottom, 10) || 0,
    left: parseInt(style.marginLeft, 10) || 0,
    right: parseInt(style.marginRight, 10) || 0
  };
}
function $edcf132a9284368a$var$parsePlacement(input) {
  if ($edcf132a9284368a$var$PARSED_PLACEMENT_CACHE[input])
    return $edcf132a9284368a$var$PARSED_PLACEMENT_CACHE[input];
  let [placement, crossPlacement] = input.split(" ");
  let axis = $edcf132a9284368a$var$AXIS[placement] || "right";
  let crossAxis = $edcf132a9284368a$var$CROSS_AXIS[axis];
  if (!$edcf132a9284368a$var$AXIS[crossPlacement])
    crossPlacement = "center";
  let size3 = $edcf132a9284368a$var$AXIS_SIZE[axis];
  let crossSize = $edcf132a9284368a$var$AXIS_SIZE[crossAxis];
  $edcf132a9284368a$var$PARSED_PLACEMENT_CACHE[input] = {
    placement,
    crossPlacement,
    axis,
    crossAxis,
    size: size3,
    crossSize
  };
  return $edcf132a9284368a$var$PARSED_PLACEMENT_CACHE[input];
}
function $edcf132a9284368a$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned, arrowSize, arrowBoundaryOffset) {
  let { placement, crossPlacement, axis, crossAxis, size: size3, crossSize } = placementInfo;
  let position3 = {};
  position3[crossAxis] = childOffset[crossAxis];
  if (crossPlacement === "center")
    position3[crossAxis] += (childOffset[crossSize] - overlaySize[crossSize]) / 2;
  else if (crossPlacement !== crossAxis)
    position3[crossAxis] += childOffset[crossSize] - overlaySize[crossSize];
  position3[crossAxis] += crossOffset;
  const minPosition = childOffset[crossAxis] - overlaySize[crossSize] + arrowSize + arrowBoundaryOffset;
  const maxPosition = childOffset[crossAxis] + childOffset[crossSize] - arrowSize - arrowBoundaryOffset;
  position3[crossAxis] = (0, $9446cca9a3875146$export$7d15b64cf5a3a4c4)(position3[crossAxis], minPosition, maxPosition);
  if (placement === axis) {
    const containerHeight = isContainerPositioned ? containerOffsetWithBoundary[size3] : boundaryDimensions[$edcf132a9284368a$var$TOTAL_SIZE[size3]];
    position3[$edcf132a9284368a$var$FLIPPED_DIRECTION[axis]] = Math.floor(containerHeight - childOffset[axis] + offset);
  } else
    position3[axis] = Math.floor(childOffset[axis] + childOffset[size3] + offset);
  return position3;
}
function $edcf132a9284368a$var$getMaxHeight(position3, boundaryDimensions, containerOffsetWithBoundary, isContainerPositioned, margins, padding, overlayHeight, heightGrowthDirection) {
  const containerHeight = isContainerPositioned ? containerOffsetWithBoundary.height : boundaryDimensions[$edcf132a9284368a$var$TOTAL_SIZE.height];
  let overlayTop = position3.top != null ? containerOffsetWithBoundary.top + position3.top : containerOffsetWithBoundary.top + (containerHeight - position3.bottom - overlayHeight);
  let maxHeight = heightGrowthDirection !== "top" ? (
    // We want the distance between the top of the overlay to the bottom of the boundary
    Math.max(0, boundaryDimensions.height + boundaryDimensions.top + boundaryDimensions.scroll.top - overlayTop - (margins.top + margins.bottom + padding))
  ) : Math.max(0, overlayTop + overlayHeight - (boundaryDimensions.top + boundaryDimensions.scroll.top) - (margins.top + margins.bottom + padding));
  return Math.min(boundaryDimensions.height - padding * 2, maxHeight);
}
function $edcf132a9284368a$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding, placementInfo) {
  let { placement, axis, size: size3 } = placementInfo;
  if (placement === axis)
    return Math.max(0, childOffset[axis] - boundaryDimensions[axis] - boundaryDimensions.scroll[axis] + containerOffsetWithBoundary[axis] - margins[axis] - margins[$edcf132a9284368a$var$FLIPPED_DIRECTION[axis]] - padding);
  return Math.max(0, boundaryDimensions[size3] + boundaryDimensions[axis] + boundaryDimensions.scroll[axis] - containerOffsetWithBoundary[axis] - childOffset[axis] - childOffset[size3] - margins[axis] - margins[$edcf132a9284368a$var$FLIPPED_DIRECTION[axis]] - padding);
}
function $edcf132a9284368a$export$6839422d1f33cee9(placementInput, childOffset, overlaySize, scrollSize, margins, padding, flip, boundaryDimensions, containerDimensions, containerOffsetWithBoundary, offset, crossOffset, isContainerPositioned, userSetMaxHeight, arrowSize, arrowBoundaryOffset) {
  let placementInfo = $edcf132a9284368a$var$parsePlacement(placementInput);
  let { size: size3, crossAxis, crossSize, placement, crossPlacement } = placementInfo;
  let position3 = $edcf132a9284368a$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned, arrowSize, arrowBoundaryOffset);
  let normalizedOffset = offset;
  let space3 = $edcf132a9284368a$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, placementInfo);
  if (flip && scrollSize[size3] > space3) {
    let flippedPlacementInfo = $edcf132a9284368a$var$parsePlacement(`${$edcf132a9284368a$var$FLIPPED_DIRECTION[placement]} ${crossPlacement}`);
    let flippedPosition = $edcf132a9284368a$var$computePosition(childOffset, boundaryDimensions, overlaySize, flippedPlacementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned, arrowSize, arrowBoundaryOffset);
    let flippedSpace = $edcf132a9284368a$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, flippedPlacementInfo);
    if (flippedSpace > space3) {
      placementInfo = flippedPlacementInfo;
      position3 = flippedPosition;
      normalizedOffset = offset;
    }
  }
  let heightGrowthDirection = "bottom";
  if (placementInfo.axis === "top") {
    if (placementInfo.placement === "top")
      heightGrowthDirection = "top";
    else if (placementInfo.placement === "bottom")
      heightGrowthDirection = "bottom";
  } else if (placementInfo.crossAxis === "top") {
    if (placementInfo.crossPlacement === "top")
      heightGrowthDirection = "bottom";
    else if (placementInfo.crossPlacement === "bottom")
      heightGrowthDirection = "top";
  }
  let delta = $edcf132a9284368a$var$getDelta(crossAxis, position3[crossAxis], overlaySize[crossSize], boundaryDimensions, containerDimensions, padding, containerOffsetWithBoundary);
  position3[crossAxis] += delta;
  let maxHeight = $edcf132a9284368a$var$getMaxHeight(position3, boundaryDimensions, containerOffsetWithBoundary, isContainerPositioned, margins, padding, overlaySize.height, heightGrowthDirection);
  if (userSetMaxHeight && userSetMaxHeight < maxHeight)
    maxHeight = userSetMaxHeight;
  overlaySize.height = Math.min(overlaySize.height, maxHeight);
  position3 = $edcf132a9284368a$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, normalizedOffset, crossOffset, containerOffsetWithBoundary, isContainerPositioned, arrowSize, arrowBoundaryOffset);
  delta = $edcf132a9284368a$var$getDelta(crossAxis, position3[crossAxis], overlaySize[crossSize], boundaryDimensions, containerDimensions, padding, containerOffsetWithBoundary);
  position3[crossAxis] += delta;
  let arrowPosition = {};
  let preferredArrowPosition = childOffset[crossAxis] + 0.5 * childOffset[crossSize] - overlaySize[crossAxis];
  const arrowMinPosition = arrowSize / 2 + arrowBoundaryOffset;
  const arrowMaxPosition = overlaySize[crossSize] - arrowSize / 2 - arrowBoundaryOffset;
  const arrowOverlappingChildMinEdge = childOffset[crossAxis] - overlaySize[crossAxis] + arrowSize / 2;
  const arrowOverlappingChildMaxEdge = childOffset[crossAxis] + childOffset[crossSize] - overlaySize[crossAxis] - arrowSize / 2;
  const arrowPositionOverlappingChild = (0, $9446cca9a3875146$export$7d15b64cf5a3a4c4)(preferredArrowPosition, arrowOverlappingChildMinEdge, arrowOverlappingChildMaxEdge);
  arrowPosition[crossAxis] = (0, $9446cca9a3875146$export$7d15b64cf5a3a4c4)(arrowPositionOverlappingChild, arrowMinPosition, arrowMaxPosition);
  return {
    position: position3,
    maxHeight,
    arrowOffsetLeft: arrowPosition.left,
    arrowOffsetTop: arrowPosition.top,
    placement: placementInfo.placement
  };
}
function $edcf132a9284368a$export$b3ceb0cbf1056d98(opts) {
  let { placement, targetNode, overlayNode, scrollNode, padding, shouldFlip, boundaryElement, offset, crossOffset, maxHeight, arrowSize = 0, arrowBoundaryOffset = 0 } = opts;
  let container = overlayNode instanceof HTMLElement ? $edcf132a9284368a$var$getContainingBlock(overlayNode) : document.documentElement;
  let isViewportContainer = container === document.documentElement;
  const containerPositionStyle = window.getComputedStyle(container).position;
  let isContainerPositioned = !!containerPositionStyle && containerPositionStyle !== "static";
  let childOffset = isViewportContainer ? $edcf132a9284368a$var$getOffset(targetNode) : $edcf132a9284368a$var$getPosition(targetNode, container);
  if (!isViewportContainer) {
    let { marginTop, marginLeft } = window.getComputedStyle(targetNode);
    childOffset.top += parseInt(marginTop, 10) || 0;
    childOffset.left += parseInt(marginLeft, 10) || 0;
  }
  let overlaySize = $edcf132a9284368a$var$getOffset(overlayNode);
  let margins = $edcf132a9284368a$var$getMargins(overlayNode);
  overlaySize.width += margins.left + margins.right;
  overlaySize.height += margins.top + margins.bottom;
  let scrollSize = $edcf132a9284368a$var$getScroll(scrollNode);
  let boundaryDimensions = $edcf132a9284368a$var$getContainerDimensions(boundaryElement);
  let containerDimensions = $edcf132a9284368a$var$getContainerDimensions(container);
  let containerOffsetWithBoundary = boundaryElement.tagName === "BODY" ? $edcf132a9284368a$var$getOffset(container) : $edcf132a9284368a$var$getPosition(container, boundaryElement);
  if (container.tagName === "HTML" && boundaryElement.tagName === "BODY") {
    containerDimensions.scroll.top = 0;
    containerDimensions.scroll.left = 0;
  }
  return $edcf132a9284368a$export$6839422d1f33cee9(placement, childOffset, overlaySize, scrollSize, margins, padding, shouldFlip, boundaryDimensions, containerDimensions, containerOffsetWithBoundary, offset, crossOffset, isContainerPositioned, maxHeight, arrowSize, arrowBoundaryOffset);
}
function $edcf132a9284368a$var$getOffset(node4) {
  let { top, left, width, height } = node4.getBoundingClientRect();
  let { scrollTop, scrollLeft, clientTop, clientLeft } = document.documentElement;
  return {
    top: top + scrollTop - clientTop,
    left: left + scrollLeft - clientLeft,
    width,
    height
  };
}
function $edcf132a9284368a$var$getPosition(node4, parent) {
  let style = window.getComputedStyle(node4);
  let offset;
  if (style.position === "fixed") {
    let { top, left, width, height } = node4.getBoundingClientRect();
    offset = {
      top,
      left,
      width,
      height
    };
  } else {
    offset = $edcf132a9284368a$var$getOffset(node4);
    let parentOffset = $edcf132a9284368a$var$getOffset(parent);
    let parentStyle = window.getComputedStyle(parent);
    parentOffset.top += (parseInt(parentStyle.borderTopWidth, 10) || 0) - parent.scrollTop;
    parentOffset.left += (parseInt(parentStyle.borderLeftWidth, 10) || 0) - parent.scrollLeft;
    offset.top -= parentOffset.top;
    offset.left -= parentOffset.left;
  }
  offset.top -= parseInt(style.marginTop, 10) || 0;
  offset.left -= parseInt(style.marginLeft, 10) || 0;
  return offset;
}
function $edcf132a9284368a$var$getContainingBlock(node4) {
  let offsetParent = node4.offsetParent;
  if (offsetParent && offsetParent === document.body && window.getComputedStyle(offsetParent).position === "static" && !$edcf132a9284368a$var$isContainingBlock(offsetParent))
    offsetParent = document.documentElement;
  if (offsetParent == null) {
    offsetParent = node4.parentElement;
    while (offsetParent && !$edcf132a9284368a$var$isContainingBlock(offsetParent))
      offsetParent = offsetParent.parentElement;
  }
  return offsetParent || document.documentElement;
}
function $edcf132a9284368a$var$isContainingBlock(node4) {
  let style = window.getComputedStyle(node4);
  return style.transform !== "none" || /transform|perspective/.test(style.willChange) || style.filter !== "none" || style.contain === "paint" || // @ts-ignore
  "backdropFilter" in style && style.backdropFilter !== "none" || // @ts-ignore
  "WebkitBackdropFilter" in style && style.WebkitBackdropFilter !== "none";
}
var $dd149f63282afbbf$export$f6211563215e3b37 = /* @__PURE__ */ new WeakMap();
function $dd149f63282afbbf$export$18fc8428861184da(opts) {
  let { triggerRef, isOpen, onClose } = opts;
  (0, import_react23.useEffect)(() => {
    if (!isOpen || onClose === null)
      return;
    let onScroll = (e6) => {
      let target = e6.target;
      if (!triggerRef.current || target instanceof Node && !target.contains(triggerRef.current))
        return;
      let onCloseHandler = onClose || $dd149f63282afbbf$export$f6211563215e3b37.get(triggerRef.current);
      if (onCloseHandler)
        onCloseHandler();
    };
    window.addEventListener("scroll", onScroll, true);
    return () => {
      window.removeEventListener("scroll", onScroll, true);
    };
  }, [
    isOpen,
    onClose,
    triggerRef
  ]);
}
var $2a41e45df1593e64$var$visualViewport = typeof document !== "undefined" && window.visualViewport;
function $2a41e45df1593e64$export$d39e1813b3bdd0e1(props) {
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let { arrowSize = 0, targetRef, overlayRef, scrollRef = overlayRef, placement = "bottom", containerPadding = 12, shouldFlip = true, boundaryElement = typeof document !== "undefined" ? document.body : null, offset = 0, crossOffset = 0, shouldUpdatePosition = true, isOpen = true, onClose, maxHeight, arrowBoundaryOffset = 0 } = props;
  let [position3, setPosition] = (0, import_react23.useState)({
    position: {},
    arrowOffsetLeft: void 0,
    arrowOffsetTop: void 0,
    maxHeight: void 0,
    placement: void 0
  });
  let deps = [
    shouldUpdatePosition,
    placement,
    overlayRef.current,
    targetRef.current,
    scrollRef.current,
    containerPadding,
    shouldFlip,
    boundaryElement,
    offset,
    crossOffset,
    isOpen,
    direction,
    maxHeight,
    arrowBoundaryOffset,
    arrowSize
  ];
  let lastScale = (0, import_react23.useRef)($2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.scale);
  (0, import_react23.useEffect)(() => {
    if (isOpen)
      lastScale.current = $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.scale;
  }, [
    isOpen
  ]);
  let updatePosition = (0, import_react23.useCallback)(() => {
    if (shouldUpdatePosition === false || !isOpen || !overlayRef.current || !targetRef.current || !scrollRef.current || !boundaryElement)
      return;
    if (($2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.scale) !== lastScale.current)
      return;
    if (!maxHeight && overlayRef.current)
      overlayRef.current.style.maxHeight = "none";
    let position4 = (0, $edcf132a9284368a$export$b3ceb0cbf1056d98)({
      placement: $2a41e45df1593e64$var$translateRTL(placement, direction),
      overlayNode: overlayRef.current,
      targetNode: targetRef.current,
      scrollNode: scrollRef.current,
      padding: containerPadding,
      shouldFlip,
      boundaryElement,
      offset,
      crossOffset,
      maxHeight,
      arrowSize,
      arrowBoundaryOffset
    });
    Object.keys(position4.position).forEach((key) => overlayRef.current.style[key] = position4.position[key] + "px");
    overlayRef.current.style.maxHeight = position4.maxHeight != null ? position4.maxHeight + "px" : void 0;
    setPosition(position4);
  }, deps);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(updatePosition, deps);
  $2a41e45df1593e64$var$useResize(updatePosition);
  (0, $9daab02d461809db$export$683480f191c0e3ea)({
    ref: overlayRef,
    onResize: updatePosition
  });
  let isResizing = (0, import_react23.useRef)(false);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    let timeout;
    let onResize = () => {
      isResizing.current = true;
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        isResizing.current = false;
      }, 500);
      updatePosition();
    };
    let onScroll = () => {
      if (isResizing.current)
        onResize();
    };
    $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.addEventListener("resize", onResize);
    $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.addEventListener("scroll", onScroll);
    return () => {
      $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.removeEventListener("resize", onResize);
      $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.removeEventListener("scroll", onScroll);
    };
  }, [
    updatePosition
  ]);
  let close = (0, import_react23.useCallback)(() => {
    if (!isResizing.current)
      onClose();
  }, [
    onClose,
    isResizing
  ]);
  (0, $dd149f63282afbbf$export$18fc8428861184da)({
    triggerRef: targetRef,
    isOpen,
    onClose: onClose && close
  });
  return {
    overlayProps: {
      style: {
        position: "absolute",
        zIndex: 1e5,
        ...position3.position,
        maxHeight: position3.maxHeight
      }
    },
    placement: position3.placement,
    arrowProps: {
      "aria-hidden": "true",
      role: "presentation",
      style: {
        left: position3.arrowOffsetLeft,
        top: position3.arrowOffsetTop
      }
    },
    updatePosition
  };
}
function $2a41e45df1593e64$var$useResize(onResize) {
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    window.addEventListener("resize", onResize, false);
    return () => {
      window.removeEventListener("resize", onResize, false);
    };
  }, [
    onResize
  ]);
}
function $2a41e45df1593e64$var$translateRTL(position3, direction) {
  if (direction === "rtl")
    return position3.replace("start", "right").replace("end", "left");
  return position3.replace("start", "left").replace("end", "right");
}
var $a11501f3d1d39e6c$var$visibleOverlays = [];
function $a11501f3d1d39e6c$export$ea8f71083e90600f(props, ref) {
  let { onClose, shouldCloseOnBlur, isOpen, isDismissable = false, isKeyboardDismissDisabled = false, shouldCloseOnInteractOutside } = props;
  (0, import_react23.useEffect)(() => {
    if (isOpen)
      $a11501f3d1d39e6c$var$visibleOverlays.push(ref);
    return () => {
      let index3 = $a11501f3d1d39e6c$var$visibleOverlays.indexOf(ref);
      if (index3 >= 0)
        $a11501f3d1d39e6c$var$visibleOverlays.splice(index3, 1);
    };
  }, [
    isOpen,
    ref
  ]);
  let onHide = () => {
    if ($a11501f3d1d39e6c$var$visibleOverlays[$a11501f3d1d39e6c$var$visibleOverlays.length - 1] === ref && onClose)
      onClose();
  };
  let onInteractOutsideStart = (e6) => {
    if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e6.target)) {
      if ($a11501f3d1d39e6c$var$visibleOverlays[$a11501f3d1d39e6c$var$visibleOverlays.length - 1] === ref) {
        e6.stopPropagation();
        e6.preventDefault();
      }
    }
  };
  let onInteractOutside = (e6) => {
    if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e6.target)) {
      if ($a11501f3d1d39e6c$var$visibleOverlays[$a11501f3d1d39e6c$var$visibleOverlays.length - 1] === ref) {
        e6.stopPropagation();
        e6.preventDefault();
      }
      onHide();
    }
  };
  let onKeyDown = (e6) => {
    if (e6.key === "Escape" && !isKeyboardDismissDisabled) {
      e6.stopPropagation();
      e6.preventDefault();
      onHide();
    }
  };
  (0, $e0b6e0b68ec7f50f$export$872b660ac5a1ff98)({
    ref,
    onInteractOutside: isDismissable && isOpen ? onInteractOutside : null,
    onInteractOutsideStart
  });
  let { focusWithinProps } = (0, $9ab94262bd0047c7$export$420e68273165f4ec)({
    isDisabled: !shouldCloseOnBlur,
    onBlurWithin: (e6) => {
      if (!e6.relatedTarget || (0, $9bf71ea28793e738$export$1258395f99bf9cbf)(e6.relatedTarget))
        return;
      if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e6.relatedTarget))
        onClose();
    }
  });
  let onPointerDownUnderlay = (e6) => {
    if (e6.target === e6.currentTarget)
      e6.preventDefault();
  };
  return {
    overlayProps: {
      onKeyDown,
      ...focusWithinProps
    },
    underlayProps: {
      onPointerDown: onPointerDownUnderlay
    }
  };
}
function $628037886ba31236$export$f9d5c8beee7d008d(props, state, ref) {
  let { type: type2 } = props;
  let { isOpen } = state;
  (0, import_react23.useEffect)(() => {
    if (ref && ref.current)
      (0, $dd149f63282afbbf$export$f6211563215e3b37).set(ref.current, state.close);
  });
  let ariaHasPopup = void 0;
  if (type2 === "menu")
    ariaHasPopup = true;
  else if (type2 === "listbox")
    ariaHasPopup = "listbox";
  let overlayId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  return {
    triggerProps: {
      "aria-haspopup": ariaHasPopup,
      "aria-expanded": isOpen,
      "aria-controls": isOpen ? overlayId : null,
      onPress: state.toggle
    },
    overlayProps: {
      id: overlayId
    }
  };
}
var $49c51c25361d4cd2$var$visualViewport = typeof document !== "undefined" && window.visualViewport;
var $49c51c25361d4cd2$var$nonTextInputTypes = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
var $49c51c25361d4cd2$var$preventScrollCount = 0;
var $49c51c25361d4cd2$var$restore;
function $49c51c25361d4cd2$export$ee0f7cc6afcd1c18(options = {}) {
  let { isDisabled } = options;
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (isDisabled)
      return;
    $49c51c25361d4cd2$var$preventScrollCount++;
    if ($49c51c25361d4cd2$var$preventScrollCount === 1) {
      if ((0, $c87311424ea30a05$export$fedb369cb70207f1)())
        $49c51c25361d4cd2$var$restore = $49c51c25361d4cd2$var$preventScrollMobileSafari();
      else
        $49c51c25361d4cd2$var$restore = $49c51c25361d4cd2$var$preventScrollStandard();
    }
    return () => {
      $49c51c25361d4cd2$var$preventScrollCount--;
      if ($49c51c25361d4cd2$var$preventScrollCount === 0)
        $49c51c25361d4cd2$var$restore();
    };
  }, [
    isDisabled
  ]);
}
function $49c51c25361d4cd2$var$preventScrollStandard() {
  return (0, $ff5963eb1fccf552$export$e08e3b67e392101e)($49c51c25361d4cd2$var$setStyle(document.documentElement, "paddingRight", `${window.innerWidth - document.documentElement.clientWidth}px`), $49c51c25361d4cd2$var$setStyle(document.documentElement, "overflow", "hidden"));
}
function $49c51c25361d4cd2$var$preventScrollMobileSafari() {
  let scrollable;
  let restoreScrollableStyles;
  let onTouchStart = (e6) => {
    scrollable = (0, $62d8ded9296f3872$export$cfa2225e87938781)(e6.target, true);
    if (scrollable === document.documentElement && scrollable === document.body)
      return;
    if (scrollable instanceof HTMLElement && window.getComputedStyle(scrollable).overscrollBehavior === "auto")
      restoreScrollableStyles = $49c51c25361d4cd2$var$setStyle(scrollable, "overscrollBehavior", "contain");
  };
  let onTouchMove = (e6) => {
    if (!scrollable || scrollable === document.documentElement || scrollable === document.body) {
      e6.preventDefault();
      return;
    }
    if (scrollable.scrollHeight === scrollable.clientHeight && scrollable.scrollWidth === scrollable.clientWidth)
      e6.preventDefault();
  };
  let onTouchEnd = (e6) => {
    let target = e6.target;
    if ($49c51c25361d4cd2$var$willOpenKeyboard(target) && target !== document.activeElement) {
      e6.preventDefault();
      setupStyles();
      target.style.transform = "translateY(-2000px)";
      target.focus();
      requestAnimationFrame(() => {
        target.style.transform = "";
      });
    }
    if (restoreScrollableStyles)
      restoreScrollableStyles();
  };
  let onFocus = (e6) => {
    let target = e6.target;
    if ($49c51c25361d4cd2$var$willOpenKeyboard(target)) {
      setupStyles();
      target.style.transform = "translateY(-2000px)";
      requestAnimationFrame(() => {
        target.style.transform = "";
        if ($49c51c25361d4cd2$var$visualViewport) {
          if ($49c51c25361d4cd2$var$visualViewport.height < window.innerHeight)
            requestAnimationFrame(() => {
              $49c51c25361d4cd2$var$scrollIntoView(target);
            });
          else
            $49c51c25361d4cd2$var$visualViewport.addEventListener("resize", () => $49c51c25361d4cd2$var$scrollIntoView(target), {
              once: true
            });
        }
      });
    }
  };
  let restoreStyles = null;
  let setupStyles = () => {
    if (restoreStyles)
      return;
    let onWindowScroll = () => {
      window.scrollTo(0, 0);
    };
    let scrollX = window.pageXOffset;
    let scrollY = window.pageYOffset;
    restoreStyles = (0, $ff5963eb1fccf552$export$e08e3b67e392101e)($49c51c25361d4cd2$var$addEvent(window, "scroll", onWindowScroll), $49c51c25361d4cd2$var$setStyle(document.documentElement, "paddingRight", `${window.innerWidth - document.documentElement.clientWidth}px`), $49c51c25361d4cd2$var$setStyle(document.documentElement, "overflow", "hidden"), $49c51c25361d4cd2$var$setStyle(document.body, "marginTop", `-${scrollY}px`), () => {
      window.scrollTo(scrollX, scrollY);
    });
    window.scrollTo(0, 0);
  };
  let removeEvents = (0, $ff5963eb1fccf552$export$e08e3b67e392101e)($49c51c25361d4cd2$var$addEvent(document, "touchstart", onTouchStart, {
    passive: false,
    capture: true
  }), $49c51c25361d4cd2$var$addEvent(document, "touchmove", onTouchMove, {
    passive: false,
    capture: true
  }), $49c51c25361d4cd2$var$addEvent(document, "touchend", onTouchEnd, {
    passive: false,
    capture: true
  }), $49c51c25361d4cd2$var$addEvent(document, "focus", onFocus, true));
  return () => {
    restoreScrollableStyles === null || restoreScrollableStyles === void 0 ? void 0 : restoreScrollableStyles();
    restoreStyles === null || restoreStyles === void 0 ? void 0 : restoreStyles();
    removeEvents();
  };
}
function $49c51c25361d4cd2$var$setStyle(element4, style, value2) {
  let cur = element4.style[style];
  element4.style[style] = value2;
  return () => {
    element4.style[style] = cur;
  };
}
function $49c51c25361d4cd2$var$addEvent(target, event, handler, options) {
  target.addEventListener(event, handler, options);
  return () => {
    target.removeEventListener(event, handler, options);
  };
}
function $49c51c25361d4cd2$var$scrollIntoView(target) {
  let root = document.scrollingElement || document.documentElement;
  while (target && target !== root) {
    let scrollable = (0, $62d8ded9296f3872$export$cfa2225e87938781)(target);
    if (scrollable !== document.documentElement && scrollable !== document.body && scrollable !== target) {
      let scrollableTop = scrollable.getBoundingClientRect().top;
      let targetTop = target.getBoundingClientRect().top;
      if (targetTop > scrollableTop + target.clientHeight)
        scrollable.scrollTop += targetTop - scrollableTop;
    }
    target = scrollable.parentElement;
  }
}
function $49c51c25361d4cd2$var$willOpenKeyboard(target) {
  return target instanceof HTMLInputElement && !$49c51c25361d4cd2$var$nonTextInputTypes.has(target.type) || target instanceof HTMLTextAreaElement || target instanceof HTMLElement && target.isContentEditable;
}
var $f57aed4a881a3485$var$Context = (0, import_react23.default).createContext(null);
function $f57aed4a881a3485$export$178405afcd8c5eb(props) {
  let { children } = props;
  let parent = (0, import_react23.useContext)($f57aed4a881a3485$var$Context);
  let [modalCount, setModalCount] = (0, import_react23.useState)(0);
  let context = (0, import_react23.useMemo)(() => ({
    parent,
    modalCount,
    addModal() {
      setModalCount((count) => count + 1);
      if (parent)
        parent.addModal();
    },
    removeModal() {
      setModalCount((count) => count - 1);
      if (parent)
        parent.removeModal();
    }
  }), [
    parent,
    modalCount
  ]);
  return (0, import_react23.default).createElement($f57aed4a881a3485$var$Context.Provider, {
    value: context
  }, children);
}
function $f57aed4a881a3485$export$d9aaed4c3ece1bc0() {
  let context = (0, import_react23.useContext)($f57aed4a881a3485$var$Context);
  return {
    modalProviderProps: {
      "aria-hidden": context && context.modalCount > 0 ? true : null
    }
  };
}
var $a2f21f5f14f60553$exports = {};
$a2f21f5f14f60553$exports = {
  "ar-AE": $773d5888b972f1cf$exports,
  "bg-BG": $d11f19852b941573$exports,
  "cs-CZ": $b983974c2ee1efb3$exports,
  "da-DK": $5809cc9d4e92de73$exports,
  "de-DE": $c68c2e4fc74398d1$exports,
  "el-GR": $0898b4c153db2b77$exports,
  "en-US": $6d74810286a15183$exports,
  "es-ES": $309d73dc65f78055$exports,
  "et-EE": $44ad94f7205cf593$exports,
  "fi-FI": $7c28f5687f0779a9$exports,
  "fr-FR": $e6d75df4b68bd73a$exports,
  "he-IL": $87505c9dab186d0f$exports,
  "hr-HR": $553439c3ffb3e492$exports,
  "hu-HU": $74cf411061b983a2$exports,
  "it-IT": $e933f298574dc435$exports,
  "ja-JP": $ac91fc9fe02f71f6$exports,
  "ko-KR": $52b96f86422025af$exports,
  "lt-LT": $c0d724c3e51dafa6$exports,
  "lv-LV": $c92899672a3fe72e$exports,
  "nb-NO": $9f576b39d8e7a9d6$exports,
  "nl-NL": $9d025808aeec81a7$exports,
  "pl-PL": $fce709921e2c0fa6$exports,
  "pt-BR": $2599cf0c4ab37f59$exports,
  "pt-PT": $3c220ae7ef8a35fd$exports,
  "ro-RO": $93562b5094072f54$exports,
  "ru-RU": $cd9e2abd0d06c7b4$exports,
  "sk-SK": $45375701f409adf1$exports,
  "sl-SI": $27fab53a576de9dd$exports,
  "sr-SP": $4438748d9952e7c7$exports,
  "sv-SE": $0936d7347ef4da4c$exports,
  "tr-TR": $29700c92185d38f8$exports,
  "uk-UA": $662ccaf2be4c25b3$exports,
  "zh-CN": $d80a27deda7cdb3c$exports,
  "zh-TW": $2b2734393847c884$exports
};
function $86ea4cb521eb2e37$export$2317d149ed6f78c4(props) {
  let { onDismiss, ...otherProps } = props;
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault($a2f21f5f14f60553$exports)), "@react-aria/overlays");
  let labels = (0, $313b98861ee5dd6c$export$d6875122194c7b44)(otherProps, stringFormatter.format("dismiss"));
  let onClick = () => {
    if (onDismiss)
      onDismiss();
  };
  return (0, import_react23.default).createElement((0, $5c3e21d68f1c4674$export$439d29a4e110a164), null, (0, import_react23.default).createElement("button", {
    ...labels,
    tabIndex: -1,
    onClick,
    style: {
      width: 1,
      height: 1
    }
  }));
}
var $5e3802645cc19319$var$refCountMap = /* @__PURE__ */ new WeakMap();
var $5e3802645cc19319$var$observerStack = [];
function $5e3802645cc19319$export$1c3ebcada18427bf(targets, root = document.body) {
  let visibleNodes = new Set(targets);
  let hiddenNodes = /* @__PURE__ */ new Set();
  let walk = (root2) => {
    for (let element4 of root2.querySelectorAll("[data-live-announcer], [data-react-aria-top-layer]"))
      visibleNodes.add(element4);
    let acceptNode = (node4) => {
      if (visibleNodes.has(node4) || hiddenNodes.has(node4.parentElement) && node4.parentElement.getAttribute("role") !== "row")
        return NodeFilter.FILTER_REJECT;
      for (let target of visibleNodes) {
        if (node4.contains(target))
          return NodeFilter.FILTER_SKIP;
      }
      return NodeFilter.FILTER_ACCEPT;
    };
    let walker = document.createTreeWalker(root2, NodeFilter.SHOW_ELEMENT, {
      acceptNode
    });
    let acceptRoot = acceptNode(root2);
    if (acceptRoot === NodeFilter.FILTER_ACCEPT)
      hide(root2);
    if (acceptRoot !== NodeFilter.FILTER_REJECT) {
      let node4 = walker.nextNode();
      while (node4 != null) {
        hide(node4);
        node4 = walker.nextNode();
      }
    }
  };
  let hide = (node4) => {
    var _refCountMap_get;
    let refCount = (_refCountMap_get = $5e3802645cc19319$var$refCountMap.get(node4)) !== null && _refCountMap_get !== void 0 ? _refCountMap_get : 0;
    if (node4.getAttribute("aria-hidden") === "true" && refCount === 0)
      return;
    if (refCount === 0)
      node4.setAttribute("aria-hidden", "true");
    hiddenNodes.add(node4);
    $5e3802645cc19319$var$refCountMap.set(node4, refCount + 1);
  };
  if ($5e3802645cc19319$var$observerStack.length)
    $5e3802645cc19319$var$observerStack[$5e3802645cc19319$var$observerStack.length - 1].disconnect();
  walk(root);
  let observer = new MutationObserver((changes) => {
    for (let change of changes) {
      if (change.type !== "childList" || change.addedNodes.length === 0)
        continue;
      if (![
        ...visibleNodes,
        ...hiddenNodes
      ].some((node4) => node4.contains(change.target))) {
        for (let node4 of change.removedNodes)
          if (node4 instanceof Element) {
            visibleNodes.delete(node4);
            hiddenNodes.delete(node4);
          }
        for (let node4 of change.addedNodes) {
          if ((node4 instanceof HTMLElement || node4 instanceof SVGElement) && (node4.dataset.liveAnnouncer === "true" || node4.dataset.reactAriaTopLayer === "true"))
            visibleNodes.add(node4);
          else if (node4 instanceof Element)
            walk(node4);
        }
      }
    }
  });
  observer.observe(root, {
    childList: true,
    subtree: true
  });
  let observerWrapper = {
    observe() {
      observer.observe(root, {
        childList: true,
        subtree: true
      });
    },
    disconnect() {
      observer.disconnect();
    }
  };
  $5e3802645cc19319$var$observerStack.push(observerWrapper);
  return () => {
    observer.disconnect();
    for (let node4 of hiddenNodes) {
      let count = $5e3802645cc19319$var$refCountMap.get(node4);
      if (count === 1) {
        node4.removeAttribute("aria-hidden");
        $5e3802645cc19319$var$refCountMap.delete(node4);
      } else
        $5e3802645cc19319$var$refCountMap.set(node4, count - 1);
    }
    if (observerWrapper === $5e3802645cc19319$var$observerStack[$5e3802645cc19319$var$observerStack.length - 1]) {
      $5e3802645cc19319$var$observerStack.pop();
      if ($5e3802645cc19319$var$observerStack.length)
        $5e3802645cc19319$var$observerStack[$5e3802645cc19319$var$observerStack.length - 1].observe();
    } else
      $5e3802645cc19319$var$observerStack.splice($5e3802645cc19319$var$observerStack.indexOf(observerWrapper), 1);
  };
}
function $f2f8a6077418541e$export$542a6fd13ac93354(props, state) {
  let { triggerRef, popoverRef, isNonModal, isKeyboardDismissDisabled, shouldCloseOnInteractOutside, ...otherProps } = props;
  let { overlayProps, underlayProps } = (0, $a11501f3d1d39e6c$export$ea8f71083e90600f)({
    isOpen: state.isOpen,
    onClose: state.close,
    shouldCloseOnBlur: true,
    isDismissable: !isNonModal,
    isKeyboardDismissDisabled,
    shouldCloseOnInteractOutside
  }, popoverRef);
  let { overlayProps: positionProps, arrowProps, placement } = (0, $2a41e45df1593e64$export$d39e1813b3bdd0e1)({
    ...otherProps,
    targetRef: triggerRef,
    overlayRef: popoverRef,
    isOpen: state.isOpen,
    onClose: isNonModal ? state.close : null
  });
  (0, $49c51c25361d4cd2$export$ee0f7cc6afcd1c18)({
    isDisabled: isNonModal || !state.isOpen
  });
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (state.isOpen && !isNonModal && popoverRef.current)
      return (0, $5e3802645cc19319$export$1c3ebcada18427bf)([
        popoverRef.current
      ]);
  }, [
    isNonModal,
    state.isOpen,
    popoverRef
  ]);
  return {
    popoverProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(overlayProps, positionProps),
    arrowProps,
    underlayProps,
    placement
  };
}
var $337b884510726a0d$export$a2200b96afd16271 = (0, import_react23.default).createContext(null);
function $337b884510726a0d$export$c6fdb837b070b4ff(props) {
  let isSSR = (0, $b5e257d569688ac6$export$535bd6ca7f90a273)();
  let { portalContainer = isSSR ? null : document.body, isExiting } = props;
  let [contain, setContain] = (0, import_react23.useState)(false);
  let contextValue = (0, import_react23.useMemo)(() => ({
    contain,
    setContain
  }), [
    contain,
    setContain
  ]);
  if (!portalContainer)
    return null;
  let contents = props.children;
  if (!props.disableFocusManagement)
    contents = (0, import_react23.default).createElement((0, $9bf71ea28793e738$export$20e40289641fbbb6), {
      restoreFocus: true,
      contain: contain && !isExiting
    }, contents);
  contents = (0, import_react23.default).createElement($337b884510726a0d$export$a2200b96afd16271.Provider, {
    value: contextValue
  }, (0, import_react23.default).createElement((0, $f1ab8c75478c6f73$export$cf75428e0b9ed1ea), null, contents));
  return (0, import_react_dom.default).createPortal(contents, portalContainer);
}
function $337b884510726a0d$export$14c98a7594375490() {
  let ctx = (0, import_react23.useContext)($337b884510726a0d$export$a2200b96afd16271);
  let setContain = ctx === null || ctx === void 0 ? void 0 : ctx.setContain;
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    setContain === null || setContain === void 0 ? void 0 : setContain(true);
  }, [
    setContain
  ]);
}
function $8ac8429251c45e4b$export$dbc0f175b25fb0fb(props, state, ref) {
  let { overlayProps, underlayProps } = (0, $a11501f3d1d39e6c$export$ea8f71083e90600f)({
    ...props,
    isOpen: state.isOpen,
    onClose: state.close
  }, ref);
  (0, $49c51c25361d4cd2$export$ee0f7cc6afcd1c18)({
    isDisabled: !state.isOpen
  });
  (0, $337b884510726a0d$export$14c98a7594375490)();
  (0, import_react23.useEffect)(() => {
    if (state.isOpen)
      return (0, $5e3802645cc19319$export$1c3ebcada18427bf)([
        ref.current
      ]);
  }, [
    state.isOpen,
    ref
  ]);
  return {
    modalProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(overlayProps),
    underlayProps
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-core.js
var import_react24 = __toESM(require_react());
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
var Context2 = (0, import_react24.createContext)(null);
Context2.displayName = "KeystarProviderContext";
function useProvider() {
  let context = (0, import_react24.useContext)(Context2);
  if (!context) {
    throw new Error("Attempt to access context outside of KeystarProvider.");
  }
  return context;
}
function useProviderProps(props) {
  let context = useProvider();
  if (!context) {
    return props;
  }
  return Object.assign({}, {
    // prominence: context.prominence,
    isDisabled: context.isDisabled,
    isRequired: context.isRequired,
    isReadOnly: context.isReadOnly
  }, props);
}
var cssCustomProperties = `
/**
 * Do not edit directly
 * Generated on Fri, 03 Nov 2023 05:52:12 GMT
 */

.kui-scheme--auto,
.kui-scheme--light {
  color-scheme: light;

  --kui-color-scale-slate11: #2c2c2c;
  --kui-color-scale-slate10: #4b4b4b;
  --kui-color-scale-slate9: #6e6e6e;
  --kui-color-scale-slate8: #8e8e8e;
  --kui-color-scale-slate7: #b3b3b3;
  --kui-color-scale-slate6: #cacaca;
  --kui-color-scale-slate5: #e1e1e1;
  --kui-color-scale-slate4: #eaeaea;
  --kui-color-scale-slate3: #f5f5f5;
  --kui-color-scale-slate2: #fafafa;
  --kui-color-scale-slate1: #ffffff;
  --kui-color-scale-red11: #cd2b31;
  --kui-color-scale-red10: #dc3d43;
  --kui-color-scale-red9: #e5484d;
  --kui-color-scale-red8: #eb9091;
  --kui-color-scale-red7: #f3aeaf;
  --kui-color-scale-red6: #f9c6c6;
  --kui-color-scale-red5: #fdd8d8;
  --kui-color-scale-red4: #ffe5e5;
  --kui-color-scale-red3: #ffefef;
  --kui-color-scale-red2: #fff8f8;
  --kui-color-scale-red1: #fffcfc;
  --kui-color-scale-purple11: #793aaf;
  --kui-color-scale-purple10: #8445bc;
  --kui-color-scale-purple9: #8e4ec6;
  --kui-color-scale-purple8: #be93e4;
  --kui-color-scale-purple7: #d3b4ed;
  --kui-color-scale-purple6: #e3ccf4;
  --kui-color-scale-purple5: #eddbf9;
  --kui-color-scale-purple4: #f3e7fc;
  --kui-color-scale-purple3: #f9f1fe;
  --kui-color-scale-purple2: #fdfaff;
  --kui-color-scale-purple1: #fefcfe;
  --kui-color-scale-pink11: #cd1d8d;
  --kui-color-scale-pink10: #d23197;
  --kui-color-scale-pink9: #d6409f;
  --kui-color-scale-pink8: #e38ec3;
  --kui-color-scale-pink7: #ecadd4;
  --kui-color-scale-pink6: #f3c6e2;
  --kui-color-scale-pink5: #f9d8ec;
  --kui-color-scale-pink4: #fce5f3;
  --kui-color-scale-pink3: #feeef8;
  --kui-color-scale-pink2: #fff7fc;
  --kui-color-scale-pink1: #fffcfe;
  --kui-color-scale-indigo11: #3451b2;
  --kui-color-scale-indigo10: #3a5ccc;
  --kui-color-scale-indigo9: #3e63dd;
  --kui-color-scale-indigo8: #8da4ef;
  --kui-color-scale-indigo7: #aec0f5;
  --kui-color-scale-indigo6: #c6d4f9;
  --kui-color-scale-indigo5: #d9e2fc;
  --kui-color-scale-indigo4: #e6edfe;
  --kui-color-scale-indigo3: #f0f4ff;
  --kui-color-scale-indigo2: #f8faff;
  --kui-color-scale-indigo1: #fdfdfe;
  --kui-color-scale-green11: #18794e;
  --kui-color-scale-green10: #299764;
  --kui-color-scale-green9: #30a46c;
  --kui-color-scale-green8: #5bb98c;
  --kui-color-scale-green7: #92ceac;
  --kui-color-scale-green6: #b4dfc4;
  --kui-color-scale-green5: #ccebd7;
  --kui-color-scale-green4: #ddf3e4;
  --kui-color-scale-green3: #e9f9ee;
  --kui-color-scale-green2: #f2fcf5;
  --kui-color-scale-green1: #fbfefc;
  --kui-color-scale-amber11: #ad5700;
  --kui-color-scale-amber10: #ffa01c;
  --kui-color-scale-amber9: #ffb224;
  --kui-color-scale-amber8: #ee9d2b;
  --kui-color-scale-amber7: #f3ba63;
  --kui-color-scale-amber6: #ffd386;
  --kui-color-scale-amber5: #ffe3a2;
  --kui-color-scale-amber4: #ffecbc;
  --kui-color-scale-amber3: #fff4d5;
  --kui-color-scale-amber2: #fff9ed;
  --kui-color-scale-amber1: #fefdfb;
  --kui-color-scale-white: #ffffff;
  --kui-color-scale-black: #000000;
  --kui-color-alias-foreground-selected: var(--kui-color-scale-indigo11);
  --kui-color-alias-foreground-disabled: var(--kui-color-scale-slate7);
  --kui-color-alias-foreground-focused: var(--kui-color-scale-indigo11);
  --kui-color-alias-foreground-pressed: var(--kui-color-scale-slate11);
  --kui-color-alias-foreground-hovered: var(--kui-color-scale-slate11);
  --kui-color-alias-foreground-idle: var(--kui-color-scale-slate10);
  --kui-color-alias-border-invalid: var(--kui-color-scale-red9);
  --kui-color-alias-border-selected: var(--kui-color-scale-indigo9);
  --kui-color-alias-border-disabled: var(--kui-color-scale-slate4);
  --kui-color-alias-border-focused: var(--kui-color-scale-indigo9);
  --kui-color-alias-border-pressed: var(--kui-color-scale-slate8);
  --kui-color-alias-border-hovered: var(--kui-color-scale-slate7);
  --kui-color-alias-border-idle: var(--kui-color-scale-slate6);
  --kui-color-alias-focus-ring: var(--kui-color-scale-indigo9);
  --kui-color-alias-background-selected-hovered: color-mix(in srgb, transparent, var(--kui-color-scale-indigo9) 20%);
  --kui-color-alias-background-selected: color-mix(in srgb, transparent, var(--kui-color-scale-indigo9) 10%);
  --kui-color-alias-background-pressed: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 10%);
  --kui-color-alias-background-focused: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 6%);
  --kui-color-alias-background-hovered: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 6%);
  --kui-color-alias-background-disabled: var(--kui-color-scale-slate3);
  --kui-color-alias-background-idle: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 3%);
  --kui-color-alias-blanket: color-mix(in srgb, transparent, var(--kui-color-scale-black) 60%);
  --kui-color-shadow-emphasis: color-mix(in srgb, transparent, var(--kui-color-scale-black) 20%);
  --kui-color-shadow-regular: color-mix(in srgb, transparent, var(--kui-color-scale-black) 15%);
  --kui-color-shadow-muted: color-mix(in srgb, transparent, var(--kui-color-scale-black) 5%);
  --kui-color-foreground-highlight: var(--kui-color-scale-pink11);
  --kui-color-foreground-pending: var(--kui-color-scale-purple11);
  --kui-color-foreground-critical: var(--kui-color-scale-red11);
  --kui-color-foreground-caution: var(--kui-color-scale-amber11);
  --kui-color-foreground-positive: var(--kui-color-scale-green11);
  --kui-color-foreground-accent: var(--kui-color-scale-indigo11);
  --kui-color-foreground-inverse-secondary: var(--kui-color-scale-slate6);
  --kui-color-foreground-inverse: var(--kui-color-scale-slate2);
  --kui-color-foreground-on-emphasis: var(--kui-color-scale-white);
  --kui-color-foreground-neutral-tertiary: var(--kui-color-scale-slate8);
  --kui-color-foreground-neutral-secondary: var(--kui-color-scale-slate9);
  --kui-color-foreground-neutral-emphasis: var(--kui-color-scale-slate11);
  --kui-color-foreground-neutral: var(--kui-color-scale-slate10);
  --kui-color-border-highlight: var(--kui-color-scale-pink6);
  --kui-color-border-pending: var(--kui-color-scale-purple6);
  --kui-color-border-critical: var(--kui-color-scale-red6);
  --kui-color-border-caution: var(--kui-color-scale-amber6);
  --kui-color-border-positive: var(--kui-color-scale-green6);
  --kui-color-border-accent: var(--kui-color-scale-indigo6);
  --kui-color-border-emphasis: var(--kui-color-scale-slate6);
  --kui-color-border-neutral: var(--kui-color-scale-slate5);
  --kui-color-border-muted: var(--kui-color-scale-slate4);
  --kui-color-background-highlight-emphasis: var(--kui-color-scale-pink9);
  --kui-color-background-highlight: var(--kui-color-scale-pink3);
  --kui-color-background-pending-emphasis: var(--kui-color-scale-purple9);
  --kui-color-background-pending: var(--kui-color-scale-purple3);
  --kui-color-background-critical-emphasis: var(--kui-color-scale-red9);
  --kui-color-background-critical: var(--kui-color-scale-red3);
  --kui-color-background-caution-emphasis: var(--kui-color-scale-amber9);
  --kui-color-background-caution: var(--kui-color-scale-amber3);
  --kui-color-background-positive-emphasis: var(--kui-color-scale-green9);
  --kui-color-background-positive: var(--kui-color-scale-green3);
  --kui-color-background-accent-emphasis: var(--kui-color-scale-indigo9);
  --kui-color-background-accent: var(--kui-color-scale-indigo3);
  --kui-color-background-inverse: var(--kui-color-scale-slate10);
  --kui-color-background-surface-tertiary: var(--kui-color-scale-slate4);
  --kui-color-background-surface-secondary: var(--kui-color-scale-slate3);
  --kui-color-background-surface: var(--kui-color-scale-slate2);
  --kui-color-background-canvas: var(--kui-color-scale-slate1);
}
.kui-scheme--dark {
  color-scheme: dark;

  --kui-color-scale-slate11: #e3e3e3;
  --kui-color-scale-slate10: #b9b9b9;
  --kui-color-scale-slate9: #909090;
  --kui-color-scale-slate8: #6e6e6e;
  --kui-color-scale-slate7: #5a5a5a;
  --kui-color-scale-slate6: #4a4a4a;
  --kui-color-scale-slate5: #3e3e3e;
  --kui-color-scale-slate4: #323232;
  --kui-color-scale-slate3: #2f2f2f;
  --kui-color-scale-slate2: #252525;
  --kui-color-scale-slate1: #1f1f1f;
  --kui-color-scale-red11: #ff6369;
  --kui-color-scale-red10: #f2555a;
  --kui-color-scale-red9: #e5484d;
  --kui-color-scale-red8: #aa2429;
  --kui-color-scale-red7: #822025;
  --kui-color-scale-red6: #671e22;
  --kui-color-scale-red5: #541b1f;
  --kui-color-scale-red4: #481a1d;
  --kui-color-scale-red3: #3c181a;
  --kui-color-scale-red2: #291415;
  --kui-color-scale-red1: #1f1315;
  --kui-color-scale-purple11: #bf7af0;
  --kui-color-scale-purple10: #9d5bd2;
  --kui-color-scale-purple9: #8e4ec6;
  --kui-color-scale-purple8: #7938b2;
  --kui-color-scale-purple7: #5f2d84;
  --kui-color-scale-purple6: #4e2667;
  --kui-color-scale-purple5: #432155;
  --kui-color-scale-purple4: #3a1e48;
  --kui-color-scale-purple3: #301a3a;
  --kui-color-scale-purple2: #221527;
  --kui-color-scale-purple1: #1b141d;
  --kui-color-scale-pink11: #f65cb6;
  --kui-color-scale-pink10: #e34ba9;
  --kui-color-scale-pink9: #d6409f;
  --kui-color-scale-pink8: #a71873;
  --kui-color-scale-pink7: #7a1d5a;
  --kui-color-scale-pink6: #601d48;
  --kui-color-scale-pink5: #501b3f;
  --kui-color-scale-pink4: #451a37;
  --kui-color-scale-pink3: #3a182f;
  --kui-color-scale-pink2: #271421;
  --kui-color-scale-pink1: #1f121b;
  --kui-color-scale-indigo11: #849dff;
  --kui-color-scale-indigo10: #5373e7;
  --kui-color-scale-indigo9: #3e63dd;
  --kui-color-scale-indigo8: #2f4eb2;
  --kui-color-scale-indigo7: #273e89;
  --kui-color-scale-indigo6: #22346e;
  --kui-color-scale-indigo5: #1f2c5c;
  --kui-color-scale-indigo4: #1c274f;
  --kui-color-scale-indigo3: #192140;
  --kui-color-scale-indigo2: #15192d;
  --kui-color-scale-indigo1: #131620;
  --kui-color-scale-green11: #4cc38a;
  --kui-color-scale-green10: #3cb179;
  --kui-color-scale-green9: #30a46c;
  --kui-color-scale-green8: #236e4a;
  --kui-color-scale-green7: #1b543a;
  --kui-color-scale-green6: #164430;
  --kui-color-scale-green5: #133929;
  --kui-color-scale-green4: #113123;
  --kui-color-scale-green3: #0f291e;
  --kui-color-scale-green2: #0c1f17;
  --kui-color-scale-green1: #0d1912;
  --kui-color-scale-amber11: #f1a10d;
  --kui-color-scale-amber10: #ffcb47;
  --kui-color-scale-amber9: #ffb224;
  --kui-color-scale-amber8: #824e00;
  --kui-color-scale-amber7: #693f05;
  --kui-color-scale-amber6: #573300;
  --kui-color-scale-amber5: #4a2900;
  --kui-color-scale-amber4: #3f2200;
  --kui-color-scale-amber3: #341c00;
  --kui-color-scale-amber2: #271700;
  --kui-color-scale-amber1: #1f1300;
  --kui-color-scale-white: #ffffff;
  --kui-color-scale-black: #000000;
  --kui-color-alias-foreground-selected: var(--kui-color-scale-indigo11);
  --kui-color-alias-foreground-disabled: var(--kui-color-scale-slate7);
  --kui-color-alias-foreground-focused: var(--kui-color-scale-indigo11);
  --kui-color-alias-foreground-pressed: var(--kui-color-scale-slate11);
  --kui-color-alias-foreground-hovered: var(--kui-color-scale-slate11);
  --kui-color-alias-foreground-idle: var(--kui-color-scale-slate10);
  --kui-color-alias-border-invalid: var(--kui-color-scale-red9);
  --kui-color-alias-border-selected: var(--kui-color-scale-indigo9);
  --kui-color-alias-border-disabled: var(--kui-color-scale-slate4);
  --kui-color-alias-border-focused: var(--kui-color-scale-indigo9);
  --kui-color-alias-border-pressed: var(--kui-color-scale-slate8);
  --kui-color-alias-border-hovered: var(--kui-color-scale-slate7);
  --kui-color-alias-border-idle: var(--kui-color-scale-slate6);
  --kui-color-alias-focus-ring: var(--kui-color-scale-indigo9);
  --kui-color-alias-background-selected-hovered: color-mix(in srgb, transparent, var(--kui-color-scale-indigo9) 20%);
  --kui-color-alias-background-selected: color-mix(in srgb, transparent, var(--kui-color-scale-indigo9) 10%);
  --kui-color-alias-background-pressed: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 10%);
  --kui-color-alias-background-focused: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 6%);
  --kui-color-alias-background-hovered: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 6%);
  --kui-color-alias-background-disabled: var(--kui-color-scale-slate3);
  --kui-color-alias-background-idle: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 4%);
  --kui-color-alias-blanket: color-mix(in srgb, transparent, var(--kui-color-scale-black) 60%);
  --kui-color-shadow-emphasis: color-mix(in srgb, transparent, var(--kui-color-scale-black) 60%);
  --kui-color-shadow-regular: color-mix(in srgb, transparent, var(--kui-color-scale-black) 40%);
  --kui-color-shadow-muted: color-mix(in srgb, transparent, var(--kui-color-scale-black) 20%);
  --kui-color-foreground-highlight: var(--kui-color-scale-pink11);
  --kui-color-foreground-pending: var(--kui-color-scale-purple11);
  --kui-color-foreground-critical: var(--kui-color-scale-red11);
  --kui-color-foreground-caution: var(--kui-color-scale-amber11);
  --kui-color-foreground-positive: var(--kui-color-scale-green11);
  --kui-color-foreground-accent: var(--kui-color-scale-indigo11);
  --kui-color-foreground-inverse-secondary: var(--kui-color-scale-slate6);
  --kui-color-foreground-inverse: var(--kui-color-scale-slate2);
  --kui-color-foreground-on-emphasis: var(--kui-color-scale-white);
  --kui-color-foreground-neutral-tertiary: var(--kui-color-scale-slate8);
  --kui-color-foreground-neutral-secondary: var(--kui-color-scale-slate9);
  --kui-color-foreground-neutral-emphasis: var(--kui-color-scale-slate11);
  --kui-color-foreground-neutral: var(--kui-color-scale-slate10);
  --kui-color-border-highlight: var(--kui-color-scale-pink6);
  --kui-color-border-pending: var(--kui-color-scale-purple6);
  --kui-color-border-critical: var(--kui-color-scale-red6);
  --kui-color-border-caution: var(--kui-color-scale-amber6);
  --kui-color-border-positive: var(--kui-color-scale-green6);
  --kui-color-border-accent: var(--kui-color-scale-indigo6);
  --kui-color-border-emphasis: var(--kui-color-scale-slate6);
  --kui-color-border-neutral: var(--kui-color-scale-slate5);
  --kui-color-border-muted: var(--kui-color-scale-slate4);
  --kui-color-background-highlight-emphasis: var(--kui-color-scale-pink9);
  --kui-color-background-highlight: var(--kui-color-scale-pink3);
  --kui-color-background-pending-emphasis: var(--kui-color-scale-purple9);
  --kui-color-background-pending: var(--kui-color-scale-purple3);
  --kui-color-background-critical-emphasis: var(--kui-color-scale-red9);
  --kui-color-background-critical: var(--kui-color-scale-red3);
  --kui-color-background-caution-emphasis: var(--kui-color-scale-amber9);
  --kui-color-background-caution: var(--kui-color-scale-amber3);
  --kui-color-background-positive-emphasis: var(--kui-color-scale-green9);
  --kui-color-background-positive: var(--kui-color-scale-green3);
  --kui-color-background-accent-emphasis: var(--kui-color-scale-indigo9);
  --kui-color-background-accent: var(--kui-color-scale-indigo3);
  --kui-color-background-inverse: var(--kui-color-scale-slate10);
  --kui-color-background-surface-tertiary: var(--kui-color-scale-slate4);
  --kui-color-background-surface-secondary: var(--kui-color-scale-slate3);
  --kui-color-background-surface: var(--kui-color-scale-slate2);
  --kui-color-background-canvas: var(--kui-color-scale-slate1);
}
@media (prefers-color-scheme: dark) {
  .kui-scheme--auto {
    color-scheme: dark;

    --kui-color-scale-slate11: #e3e3e3;
    --kui-color-scale-slate10: #b9b9b9;
    --kui-color-scale-slate9: #909090;
    --kui-color-scale-slate8: #6e6e6e;
    --kui-color-scale-slate7: #5a5a5a;
    --kui-color-scale-slate6: #4a4a4a;
    --kui-color-scale-slate5: #3e3e3e;
    --kui-color-scale-slate4: #323232;
    --kui-color-scale-slate3: #2f2f2f;
    --kui-color-scale-slate2: #252525;
    --kui-color-scale-slate1: #1f1f1f;
    --kui-color-scale-red11: #ff6369;
    --kui-color-scale-red10: #f2555a;
    --kui-color-scale-red9: #e5484d;
    --kui-color-scale-red8: #aa2429;
    --kui-color-scale-red7: #822025;
    --kui-color-scale-red6: #671e22;
    --kui-color-scale-red5: #541b1f;
    --kui-color-scale-red4: #481a1d;
    --kui-color-scale-red3: #3c181a;
    --kui-color-scale-red2: #291415;
    --kui-color-scale-red1: #1f1315;
    --kui-color-scale-purple11: #bf7af0;
    --kui-color-scale-purple10: #9d5bd2;
    --kui-color-scale-purple9: #8e4ec6;
    --kui-color-scale-purple8: #7938b2;
    --kui-color-scale-purple7: #5f2d84;
    --kui-color-scale-purple6: #4e2667;
    --kui-color-scale-purple5: #432155;
    --kui-color-scale-purple4: #3a1e48;
    --kui-color-scale-purple3: #301a3a;
    --kui-color-scale-purple2: #221527;
    --kui-color-scale-purple1: #1b141d;
    --kui-color-scale-pink11: #f65cb6;
    --kui-color-scale-pink10: #e34ba9;
    --kui-color-scale-pink9: #d6409f;
    --kui-color-scale-pink8: #a71873;
    --kui-color-scale-pink7: #7a1d5a;
    --kui-color-scale-pink6: #601d48;
    --kui-color-scale-pink5: #501b3f;
    --kui-color-scale-pink4: #451a37;
    --kui-color-scale-pink3: #3a182f;
    --kui-color-scale-pink2: #271421;
    --kui-color-scale-pink1: #1f121b;
    --kui-color-scale-indigo11: #849dff;
    --kui-color-scale-indigo10: #5373e7;
    --kui-color-scale-indigo9: #3e63dd;
    --kui-color-scale-indigo8: #2f4eb2;
    --kui-color-scale-indigo7: #273e89;
    --kui-color-scale-indigo6: #22346e;
    --kui-color-scale-indigo5: #1f2c5c;
    --kui-color-scale-indigo4: #1c274f;
    --kui-color-scale-indigo3: #192140;
    --kui-color-scale-indigo2: #15192d;
    --kui-color-scale-indigo1: #131620;
    --kui-color-scale-green11: #4cc38a;
    --kui-color-scale-green10: #3cb179;
    --kui-color-scale-green9: #30a46c;
    --kui-color-scale-green8: #236e4a;
    --kui-color-scale-green7: #1b543a;
    --kui-color-scale-green6: #164430;
    --kui-color-scale-green5: #133929;
    --kui-color-scale-green4: #113123;
    --kui-color-scale-green3: #0f291e;
    --kui-color-scale-green2: #0c1f17;
    --kui-color-scale-green1: #0d1912;
    --kui-color-scale-amber11: #f1a10d;
    --kui-color-scale-amber10: #ffcb47;
    --kui-color-scale-amber9: #ffb224;
    --kui-color-scale-amber8: #824e00;
    --kui-color-scale-amber7: #693f05;
    --kui-color-scale-amber6: #573300;
    --kui-color-scale-amber5: #4a2900;
    --kui-color-scale-amber4: #3f2200;
    --kui-color-scale-amber3: #341c00;
    --kui-color-scale-amber2: #271700;
    --kui-color-scale-amber1: #1f1300;
    --kui-color-scale-white: #ffffff;
    --kui-color-scale-black: #000000;
    --kui-color-alias-foreground-selected: var(--kui-color-scale-indigo11);
    --kui-color-alias-foreground-disabled: var(--kui-color-scale-slate7);
    --kui-color-alias-foreground-focused: var(--kui-color-scale-indigo11);
    --kui-color-alias-foreground-pressed: var(--kui-color-scale-slate11);
    --kui-color-alias-foreground-hovered: var(--kui-color-scale-slate11);
    --kui-color-alias-foreground-idle: var(--kui-color-scale-slate10);
    --kui-color-alias-border-invalid: var(--kui-color-scale-red9);
    --kui-color-alias-border-selected: var(--kui-color-scale-indigo9);
    --kui-color-alias-border-disabled: var(--kui-color-scale-slate4);
    --kui-color-alias-border-focused: var(--kui-color-scale-indigo9);
    --kui-color-alias-border-pressed: var(--kui-color-scale-slate8);
    --kui-color-alias-border-hovered: var(--kui-color-scale-slate7);
    --kui-color-alias-border-idle: var(--kui-color-scale-slate6);
    --kui-color-alias-focus-ring: var(--kui-color-scale-indigo9);
    --kui-color-alias-background-selected-hovered: color-mix(in srgb, transparent, var(--kui-color-scale-indigo9) 20%);
    --kui-color-alias-background-selected: color-mix(in srgb, transparent, var(--kui-color-scale-indigo9) 10%);
    --kui-color-alias-background-pressed: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 10%);
    --kui-color-alias-background-focused: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 6%);
    --kui-color-alias-background-hovered: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 6%);
    --kui-color-alias-background-disabled: var(--kui-color-scale-slate3);
    --kui-color-alias-background-idle: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 4%);
    --kui-color-alias-blanket: color-mix(in srgb, transparent, var(--kui-color-scale-black) 60%);
    --kui-color-shadow-emphasis: color-mix(in srgb, transparent, var(--kui-color-scale-black) 60%);
    --kui-color-shadow-regular: color-mix(in srgb, transparent, var(--kui-color-scale-black) 40%);
    --kui-color-shadow-muted: color-mix(in srgb, transparent, var(--kui-color-scale-black) 20%);
    --kui-color-foreground-highlight: var(--kui-color-scale-pink11);
    --kui-color-foreground-pending: var(--kui-color-scale-purple11);
    --kui-color-foreground-critical: var(--kui-color-scale-red11);
    --kui-color-foreground-caution: var(--kui-color-scale-amber11);
    --kui-color-foreground-positive: var(--kui-color-scale-green11);
    --kui-color-foreground-accent: var(--kui-color-scale-indigo11);
    --kui-color-foreground-inverse-secondary: var(--kui-color-scale-slate6);
    --kui-color-foreground-inverse: var(--kui-color-scale-slate2);
    --kui-color-foreground-on-emphasis: var(--kui-color-scale-white);
    --kui-color-foreground-neutral-tertiary: var(--kui-color-scale-slate8);
    --kui-color-foreground-neutral-secondary: var(--kui-color-scale-slate9);
    --kui-color-foreground-neutral-emphasis: var(--kui-color-scale-slate11);
    --kui-color-foreground-neutral: var(--kui-color-scale-slate10);
    --kui-color-border-highlight: var(--kui-color-scale-pink6);
    --kui-color-border-pending: var(--kui-color-scale-purple6);
    --kui-color-border-critical: var(--kui-color-scale-red6);
    --kui-color-border-caution: var(--kui-color-scale-amber6);
    --kui-color-border-positive: var(--kui-color-scale-green6);
    --kui-color-border-accent: var(--kui-color-scale-indigo6);
    --kui-color-border-emphasis: var(--kui-color-scale-slate6);
    --kui-color-border-neutral: var(--kui-color-scale-slate5);
    --kui-color-border-muted: var(--kui-color-scale-slate4);
    --kui-color-background-highlight-emphasis: var(--kui-color-scale-pink9);
    --kui-color-background-highlight: var(--kui-color-scale-pink3);
    --kui-color-background-pending-emphasis: var(--kui-color-scale-purple9);
    --kui-color-background-pending: var(--kui-color-scale-purple3);
    --kui-color-background-critical-emphasis: var(--kui-color-scale-red9);
    --kui-color-background-critical: var(--kui-color-scale-red3);
    --kui-color-background-caution-emphasis: var(--kui-color-scale-amber9);
    --kui-color-background-caution: var(--kui-color-scale-amber3);
    --kui-color-background-positive-emphasis: var(--kui-color-scale-green9);
    --kui-color-background-positive: var(--kui-color-scale-green3);
    --kui-color-background-accent-emphasis: var(--kui-color-scale-indigo9);
    --kui-color-background-accent: var(--kui-color-scale-indigo3);
    --kui-color-background-inverse: var(--kui-color-scale-slate10);
    --kui-color-background-surface-tertiary: var(--kui-color-scale-slate4);
    --kui-color-background-surface-secondary: var(--kui-color-scale-slate3);
    --kui-color-background-surface: var(--kui-color-scale-slate2);
    --kui-color-background-canvas: var(--kui-color-scale-slate1);
  }
}
.kui-theme {
  --kui-animation-easing-ease-out: cubic-bezier(0, 0, 0.4, 1);
  --kui-animation-easing-ease-in: cubic-bezier(0.5, 0, 1, 1);
  --kui-animation-easing-ease-in-out: cubic-bezier(0.45, 0, 0.4, 1);
  --kui-animation-duration-xlong: 1920ms;
  --kui-animation-duration-long: 960ms;
  --kui-animation-duration-regular: 320ms;
  --kui-animation-duration-short: 160ms;
}
.kui-theme {
  --kui-size-dialog-large: 860px;
  --kui-size-dialog-medium: 640px;
  --kui-size-dialog-small: 420px;
  --kui-size-dialog-xsmall: 320px;
  --kui-size-container-xlarge: 1400px;
  --kui-size-container-large: 1280px;
  --kui-size-container-medium: 940px;
  --kui-size-container-small: 660px;
  --kui-size-container-xsmall: 400px;
  --kui-size-alias-focus-ring-gap: 2px;
  --kui-size-alias-focus-ring: 2px;
  --kui-size-icon-large: var(--kui-size-scale-400);
  --kui-size-icon-medium: var(--kui-size-scale-300);
  --kui-size-icon-regular: var(--kui-size-scale-200);
  --kui-size-icon-small: var(--kui-size-scale-150);
  --kui-size-element-xlarge: var(--kui-size-scale-800);
  --kui-size-element-large: var(--kui-size-scale-600);
  --kui-size-element-medium: var(--kui-size-scale-450);
  --kui-size-element-regular: var(--kui-size-scale-400);
  --kui-size-element-small: var(--kui-size-scale-300);
  --kui-size-element-xsmall: var(--kui-size-scale-200);
  --kui-size-alias-single-line-width: var(--kui-size-scale-2400);
  --kui-size-alias-single-line-height: var(--kui-size-scale-400);
}
.kui-theme {
  --kui-size-radius-xlarge: 16px;
  --kui-size-radius-large: 12px;
  --kui-size-radius-medium: 8px;
  --kui-size-radius-regular: 6px;
  --kui-size-radius-small: 4px;
  --kui-size-radius-xsmall: 2px;
  --kui-size-radius-full: 9999px;
  --kui-size-border-large: 4px;
  --kui-size-border-medium: 2px;
  --kui-size-border-regular: 1px;
  --kui-size-space-xxlarge: var(--kui-size-scale-400);
  --kui-size-space-xlarge: var(--kui-size-scale-300);
  --kui-size-space-large: var(--kui-size-scale-200);
  --kui-size-space-medium: var(--kui-size-scale-150);
  --kui-size-space-regular: var(--kui-size-scale-100);
  --kui-size-space-small: var(--kui-size-scale-50);
  --kui-size-space-xsmall: var(--kui-size-scale-25);
  --kui-size-shadow-large: 0px var(--kui-size-scale-100) var(--kui-size-scale-300) 0px;
  --kui-size-shadow-medium: 0px var(--kui-size-scale-40) var(--kui-size-scale-75) 0px;
  --kui-size-shadow-small: 0px var(--kui-size-scale-10) var(--kui-size-scale-25) 0px;
}
.kui-theme {
  --kui-size-scale-6000: 480px;
  --kui-size-scale-5000: 400px;
  --kui-size-scale-4600: 368px;
  --kui-size-scale-3600: 288px;
  --kui-size-scale-3400: 272px;
  --kui-size-scale-3000: 240px;
  --kui-size-scale-2400: 192px;
  --kui-size-scale-2000: 160px;
  --kui-size-scale-1700: 136px;
  --kui-size-scale-1600: 128px;
  --kui-size-scale-1250: 100px;
  --kui-size-scale-1200: 96px;
  --kui-size-scale-1000: 80px;
  --kui-size-scale-900: 72px;
  --kui-size-scale-800: 64px;
  --kui-size-scale-700: 56px;
  --kui-size-scale-675: 54px;
  --kui-size-scale-600: 48px;
  --kui-size-scale-550: 44px;
  --kui-size-scale-500: 40px;
  --kui-size-scale-450: 36px;
  --kui-size-scale-400: 32px;
  --kui-size-scale-350: 28px;
  --kui-size-scale-325: 26px;
  --kui-size-scale-300: 24px;
  --kui-size-scale-275: 22px;
  --kui-size-scale-250: 20px;
  --kui-size-scale-225: 18px;
  --kui-size-scale-200: 16px;
  --kui-size-scale-175: 14px;
  --kui-size-scale-160: 13px;
  --kui-size-scale-150: 12px;
  --kui-size-scale-130: 11px;
  --kui-size-scale-125: 10px;
  --kui-size-scale-115: 9px;
  --kui-size-scale-100: 8px;
  --kui-size-scale-85: 7px;
  --kui-size-scale-75: 6px;
  --kui-size-scale-65: 5px;
  --kui-size-scale-50: 4px;
  --kui-size-scale-40: 3px;
  --kui-size-scale-25: 2px;
  --kui-size-scale-10: 1px;
  --kui-size-scale-0: 0px;
}
.kui-theme {
  --kui-typography-heading-large-lineheight: 1.2;
  --kui-typography-heading-large-size: 32px;
  --kui-typography-heading-medium-lineheight: 1.2;
  --kui-typography-heading-medium-size: 24px;
  --kui-typography-heading-regular-lineheight: 1.2;
  --kui-typography-heading-regular-size: 20px;
  --kui-typography-heading-small-lineheight: 1.2;
  --kui-typography-heading-small-size: 16px;
  --kui-typography-text-large-lineheight: 1.2;
  --kui-typography-text-large-size: 18px;
  --kui-typography-text-medium-lineheight: 1.4;
  --kui-typography-text-medium-size: 16px;
  --kui-typography-text-regular-lineheight: 1.4;
  --kui-typography-text-regular-size: 14px;
  --kui-typography-text-small-lineheight: 1.4;
  --kui-typography-text-small-size: 12px;
  --kui-typography-lineheight-small: 1.2;
  --kui-typography-lineheight-medium: 1.4;
  --kui-typography-lineheight-large: 1.6;
  --kui-typography-font-weight-bold: 700;
  --kui-typography-font-weight-semibold: 600;
  --kui-typography-font-weight-medium: 500;
  --kui-typography-font-weight-regular: 400;
  --kui-typography-font-family-code: ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace;
  --kui-typography-font-family-base: var(--font-inter, Inter);
  --kui-typography-heading-large-capheight: 23.2727px;
  --kui-typography-heading-large-capheight-trim: -0.2364em;
  --kui-typography-heading-large-baseline-trim: -0.2364em;
  --kui-typography-heading-medium-capheight: 17.4545px;
  --kui-typography-heading-medium-capheight-trim: -0.2364em;
  --kui-typography-heading-medium-baseline-trim: -0.2364em;
  --kui-typography-heading-regular-capheight: 14.5455px;
  --kui-typography-heading-regular-capheight-trim: -0.2364em;
  --kui-typography-heading-regular-baseline-trim: -0.2364em;
  --kui-typography-heading-small-capheight: 11.6364px;
  --kui-typography-heading-small-capheight-trim: -0.2364em;
  --kui-typography-heading-small-baseline-trim: -0.2364em;
  --kui-typography-text-large-capheight: 13.0909px;
  --kui-typography-text-large-capheight-trim: -0.2364em;
  --kui-typography-text-large-baseline-trim: -0.2364em;
  --kui-typography-text-medium-capheight: 11.6364px;
  --kui-typography-text-medium-capheight-trim: -0.3364em;
  --kui-typography-text-medium-baseline-trim: -0.3364em;
  --kui-typography-text-regular-capheight: 10.1818px;
  --kui-typography-text-regular-capheight-trim: -0.3364em;
  --kui-typography-text-regular-baseline-trim: -0.3364em;
  --kui-typography-text-small-capheight: 8.7273px;
  --kui-typography-text-small-capheight-trim: -0.3364em;
  --kui-typography-text-small-baseline-trim: -0.3364em;
}`;
var schemes = {
  auto: SCHEME_AUTO,
  light: SCHEME_LIGHT,
  dark: SCHEME_DARK
};
var documentElementClasses = (args2) => {
  const scheme = schemes[args2.colorScheme || "auto"];
  return `${documentReset(args2.bodyBackground)} ${THEME_DEFAULT} ${scheme}`;
};
var documentReset = (background = "canvas") => css`
  html& {
    scroll-behavior: smooth;
    text-size-adjust: none;
    -webkit-tap-highlight-color: #0000;
  }
  @media (prefers-reduced-motion: reduce) {
    html& {
      scroll-behavior: auto;
    }
  }

  html& body {
    background-color: ${tokenSchema.color.background[background]};
    margin: 0;
  }
`;
function flatString(str) {
  return str.replace(/\n|\s{2,}/g, "");
}
var reset = resetClassName.replace(":", "\\:");
var elementReset = flatString(`
  :where(.${reset}) {
    border: 0;
    box-sizing: border-box;
    font: inherit;
    font-size: 100%;
    margin: 0;
    padding: 0;
    vertical-align: baseline;
  }
  :where(ol.${reset}, ul.${reset}) { list-style: none; }
  :where(canvas.${reset}, img.${reset}, picture.${reset}, svg.${reset}, video.${reset}) { display: block; }
  :where(input.${reset}, button.${reset}, textarea.${reset}, select.${reset}) { appearance: none; background-color: transparent; }
  :where(a.${reset}, abbr.${reset}) { color: inherit; text-decoration: none; }
  :where(table.${reset}) = { border-collapse: collapse; border-spacing: 0; }
`);
injectGlobal(cssCustomProperties);
injectGlobal(elementReset);
function useScale() {
  let matchesFine = useMediaQuery("(any-pointer: fine)");
  return !matchesFine ? "large" : "medium";
}
var KeystarProvider = forwardRefWithAs(function KeystarProvider2(props, forwardedRef) {
  let prevContext = (0, import_react24.useContext)(Context2);
  let prevColorScheme = prevContext && prevContext.colorScheme;
  let autoScale = useScale();
  let {
    locale: prevLocale
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let matchedBreakpoints = useMatchedBreakpoints();
  let {
    children,
    colorScheme = prevColorScheme || "auto",
    isDisabled,
    isRequired,
    isReadOnly,
    locale = prevContext ? prevLocale : void 0,
    router,
    scale = prevContext ? prevContext.scale : autoScale,
    ...otherProps
  } = props;
  let currentProps = {
    colorScheme,
    isDisabled,
    isRequired,
    isReadOnly,
    scale
  };
  let filteredProps = Object.fromEntries(Object.entries(currentProps).filter(([_2, value2]) => value2 !== void 0));
  let context = Object.assign({}, prevContext, filteredProps);
  let contents = children;
  let domProps = $65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps);
  let styleProps = useStyleProps(otherProps);
  if (!prevContext || props.elementType || props.locale || colorScheme !== prevContext.colorScheme || scale !== prevContext.scale || Object.keys(domProps).length > 0 || otherProps.UNSAFE_className || styleProps.style && Object.keys(styleProps.style).length > 0) {
    var _props$elementType;
    contents = (0, import_jsx_runtime10.jsx)(ProviderWrapper, {
      ref: forwardedRef,
      ...props,
      style: {
        isolation: !prevContext ? "isolate" : void 0
      },
      elementType: (_props$elementType = props.elementType) !== null && _props$elementType !== void 0 ? _props$elementType : "div",
      children: contents
    });
  }
  if (router) {
    contents = (0, import_jsx_runtime10.jsx)($ea8dcbcb9ea1b556$export$323e4fc2fa4753fb, {
      ...router,
      children: contents
    });
  }
  return (0, import_jsx_runtime10.jsx)(Context2.Provider, {
    value: context,
    children: (0, import_jsx_runtime10.jsx)(BreakpointProvider, {
      value: matchedBreakpoints,
      children: (0, import_jsx_runtime10.jsx)($18f2051aff69b9bf$export$a54013f0d02a8f82, {
        locale,
        children: (0, import_jsx_runtime10.jsx)($f57aed4a881a3485$export$178405afcd8c5eb, {
          children: contents
        })
      })
    })
  });
});
var ProviderWrapper = forwardRefWithAs(function ProviderWrapper2(props, forwardedRef) {
  var _props$elementType2;
  let {
    children,
    style
  } = props;
  let {
    locale,
    direction
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let {
    modalProviderProps
  } = $f57aed4a881a3485$export$d9aaed4c3ece1bc0();
  let {
    colorScheme
  } = useProvider();
  const ElementType = (_props$elementType2 = props.elementType) !== null && _props$elementType2 !== void 0 ? _props$elementType2 : "div";
  return (0, import_jsx_runtime10.jsx)(ElementType, {
    ...modalProviderProps,
    className: `${props.UNSAFE_className ? `${props.UNSAFE_className} ` : ""}${documentElementClasses({
      bodyBackground: props.bodyBackground,
      colorScheme
    })}`,
    lang: locale,
    dir: direction,
    ref: forwardedRef,
    style: {
      ...style,
      ...props.UNSAFE_style
    },
    children
  });
});
function ClientSideOnlyDocumentElement(props) {
  const context = useProvider();
  const classes = documentElementClasses({
    bodyBackground: props.bodyBackground,
    colorScheme: context.colorScheme
  });
  (0, import_react24.useLayoutEffect)(() => {
    const split2 = classes.split(" ");
    const root = document.documentElement;
    root.classList.add(...split2);
    return () => {
      root.classList.remove(...split2);
    };
  }, [classes]);
  return null;
}

// node_modules/@react-aria/link/dist/import.mjs
function $298d61e98472621b$export$dcf14c9974fe2767(props, ref) {
  let {
    elementType = "a",
    onPress,
    onPressStart,
    onPressEnd,
    // @ts-ignore
    onClick: deprecatedOnClick,
    isDisabled,
    ...otherProps
  } = props;
  let linkProps = {};
  if (elementType !== "a")
    linkProps = {
      role: "link",
      tabIndex: !isDisabled ? 0 : void 0
    };
  let { focusableProps } = (0, $e6afbd83fe6ebbd2$export$4c014de7c8940b4c)(props, ref);
  let { pressProps, isPressed } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    onPress,
    onPressStart,
    onPressEnd,
    isDisabled,
    ref
  });
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(otherProps, {
    labelable: true,
    isLink: elementType === "a"
  });
  let interactionHandlers = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(focusableProps, pressProps);
  let router = (0, $ea8dcbcb9ea1b556$export$9a302a45f65d0572)();
  return {
    isPressed,
    linkProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, {
      ...interactionHandlers,
      ...linkProps,
      "aria-disabled": isDisabled || void 0,
      "aria-current": props["aria-current"],
      onClick: (e6) => {
        var _pressProps_onClick;
        (_pressProps_onClick = pressProps.onClick) === null || _pressProps_onClick === void 0 ? void 0 : _pressProps_onClick.call(pressProps, e6);
        if (deprecatedOnClick) {
          deprecatedOnClick(e6);
          console.warn("onClick is deprecated, please use onPress");
        }
        if (!router.isNative && e6.currentTarget instanceof HTMLAnchorElement && e6.currentTarget.href && // If props are applied to a router Link component, it may have already prevented default.
        !e6.isDefaultPrevented() && (0, $ea8dcbcb9ea1b556$export$efa8c9099e530235)(e6.currentTarget, e6)) {
          e6.preventDefault();
          router.open(e6.currentTarget, e6);
        }
      }
    })
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-button.js
var import_react25 = __toESM(require_react());
var import_jsx_runtime12 = __toESM(require_jsx_runtime());

// node_modules/@react-aria/button/dist/import.mjs
function $701a24aa0da5b062$export$ea18c227d4417cc3(props, ref) {
  let {
    elementType = "button",
    isDisabled,
    onPress,
    onPressStart,
    onPressEnd,
    onPressUp,
    onPressChange,
    preventFocusOnPress,
    allowFocusWhenDisabled,
    // @ts-ignore
    onClick: deprecatedOnClick,
    href,
    target,
    rel,
    type: type2 = "button"
  } = props;
  let additionalProps;
  if (elementType === "button")
    additionalProps = {
      type: type2,
      disabled: isDisabled
    };
  else
    additionalProps = {
      role: "button",
      tabIndex: isDisabled ? void 0 : 0,
      href: elementType === "a" && isDisabled ? void 0 : href,
      target: elementType === "a" ? target : void 0,
      type: elementType === "input" ? type2 : void 0,
      disabled: elementType === "input" ? isDisabled : void 0,
      "aria-disabled": !isDisabled || elementType === "input" ? void 0 : isDisabled,
      rel: elementType === "a" ? rel : void 0
    };
  let { pressProps, isPressed } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    onPressStart,
    onPressEnd,
    onPressChange,
    onPress,
    onPressUp,
    isDisabled,
    preventFocusOnPress,
    ref
  });
  let { focusableProps } = (0, $e6afbd83fe6ebbd2$export$4c014de7c8940b4c)(props, ref);
  if (allowFocusWhenDisabled)
    focusableProps.tabIndex = isDisabled ? -1 : focusableProps.tabIndex;
  let buttonProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(focusableProps, pressProps, (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  }));
  return {
    isPressed,
    buttonProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(additionalProps, buttonProps, {
      "aria-haspopup": props["aria-haspopup"],
      "aria-expanded": props["aria-expanded"],
      "aria-controls": props["aria-controls"],
      "aria-pressed": props["aria-pressed"],
      onClick: (e6) => {
        if (deprecatedOnClick) {
          deprecatedOnClick(e6);
          console.warn("onClick is deprecated, please use onPress");
        }
      }
    })
  };
}
function $55f54f7887471b58$export$51e84d46ca0bc451(props, state, ref) {
  const { isSelected } = state;
  const { isPressed, buttonProps } = (0, $701a24aa0da5b062$export$ea18c227d4417cc3)({
    ...props,
    onPress: (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(state.toggle, props.onPress)
  }, ref);
  return {
    isPressed,
    buttonProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(buttonProps, {
      "aria-pressed": isSelected
    })
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-xIcon.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
var xIcon = (0, import_jsx_runtime11.jsx)("path", {
  d: "M18 6 6 18M6 6l12 12"
});

// node_modules/@react-stately/toggle/dist/import.mjs
function $3017fa7ffdddec74$export$8042c6c013fd5226(props = {}) {
  let { isReadOnly } = props;
  let [isSelected, setSelected] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(props.isSelected, props.defaultSelected || false, props.onChange);
  function updateSelected(value2) {
    if (!isReadOnly)
      setSelected(value2);
  }
  function toggleState() {
    if (!isReadOnly)
      setSelected(!isSelected);
  }
  return {
    isSelected,
    setSelected: updateSelected,
    toggle: toggleState
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-button.js
var ButtonGroup = (0, import_react25.forwardRef)(function ButtonGroup2(props, forwardedRef) {
  let {
    scale
  } = useProvider();
  props = useProviderProps(props);
  props = useSlotProps(props, "buttonGroup");
  let {
    align = "start",
    children,
    isDisabled,
    orientation = "horizontal",
    ...otherProps
  } = props;
  let styleProps = useStyleProps(otherProps);
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let [hasOverflow, setHasOverflow] = $1dbecbe27a04f9af$export$14d238f342723f25(false);
  let checkForOverflow = (0, import_react25.useCallback)(() => {
    let computeHasOverflow = () => {
      if (domRef.current && orientation === "horizontal") {
        let buttonGroupChildren = Array.from(domRef.current.children);
        let maxX = domRef.current.offsetWidth + 1;
        if (buttonGroupChildren.some((child) => child.offsetLeft < 0 || child.offsetLeft + child.offsetWidth > maxX)) {
          return true;
        }
        return false;
      }
    };
    if (orientation === "horizontal") {
      setHasOverflow(function* () {
        yield false;
        yield computeHasOverflow();
      });
    }
  }, [domRef, orientation, scale, setHasOverflow, children]);
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    checkForOverflow();
  }, [checkForOverflow]);
  let parent = (0, import_react25.useRef)();
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    if (domRef.current) {
      parent.current = domRef.current.parentElement;
    }
  });
  $9daab02d461809db$export$683480f191c0e3ea({
    ref: parent,
    onResize: checkForOverflow
  });
  return (0, import_jsx_runtime12.jsx)("div", {
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
    ...toDataAttributes({
      align,
      orientation: hasOverflow ? "vertical" : orientation
    }),
    ...styleProps,
    ref: domRef,
    className: classNames(styleProps.className, css({
      alignItems: "flex-start",
      display: "inline-flex",
      gap: tokenSchema.size.space.regular,
      position: "relative",
      '&[data-orientation="horizontal"]': {
        '&[data-align="center"]': {
          justifyContent: "center"
        },
        '&[data-align="end"]': {
          justifyContent: "flex-end"
        }
      },
      '&[data-orientation="vertical"]': {
        flexDirection: "column",
        '&[data-align="center"]': {
          alignItems: "center"
        },
        '&[data-align="end"]': {
          alignItems: "flex-end"
        }
      }
    })),
    children: (0, import_jsx_runtime12.jsx)(KeystarProvider, {
      isDisabled,
      children
    })
  });
});
var buttonClassList = new ClassList("Button", ["icon", "text"]);
function useButtonStyles(props, state) {
  const {
    prominence = "default",
    tone = prominence === "high" ? "accent" : "neutral"
  } = props;
  const {
    isHovered,
    isPressed
  } = state;
  const styleProps = useStyleProps(props);
  return {
    ...toDataAttributes({
      hovered: isHovered || void 0,
      pressed: isPressed || void 0,
      prominence: prominence === "default" ? void 0 : prominence,
      tone: tone === "neutral" ? void 0 : tone,
      static: props.static
    }),
    style: styleProps.style,
    className: classNames(buttonClassList.element("root"), css({
      alignItems: "center",
      borderRadius: tokenSchema.size.radius.regular,
      cursor: "default",
      display: "inline-flex",
      flexShrink: 0,
      fontSize: tokenSchema.typography.text.regular.size,
      fontWeight: tokenSchema.typography.fontWeight.semibold,
      height: tokenSchema.size.element.regular,
      justifyContent: "center",
      minWidth: tokenSchema.size.element.regular,
      outline: 0,
      gap: tokenSchema.size.space.regular,
      paddingInline: tokenSchema.size.space.large,
      position: "relative",
      transitionDuration: "130ms",
      transitionProperty: "background, border-color, box-shadow, color, ",
      transitionTimingFunction: "ease-out",
      userSelect: "none",
      // indicate when external link? e.g. `&[href^=http]`
      "a&": {
        cursor: "pointer"
      },
      "&:disabled, &[aria-disabled]": {
        cursor: "default"
      },
      // inherit text styles from parent
      [buttonClassList.selector("text", "descendant")]: {
        fontSize: "inherit",
        fontWeight: "inherit"
      },
      // special size for button icons. otherwise they appear too "thin"
      // beside the bold text
      [buttonClassList.selector("icon", "descendant")]: {
        height: tokenSchema.size.scale[225],
        width: tokenSchema.size.scale[225]
      },
      // focus ring
      "--focus-ring-color": tokenSchema.color.alias.focusRing,
      "&[data-static=light]": {
        "--focus-ring-color": "#fff"
      },
      "&[data-static=dark]": {
        "--focus-ring-color": "#000"
      },
      "&::after": {
        borderRadius: `calc(${tokenSchema.size.radius.regular} + ${tokenSchema.size.alias.focusRingGap})`,
        content: '""',
        inset: 0,
        pointerEvents: "none",
        position: "absolute",
        transition: transition(["box-shadow", "margin"], {
          easing: "easeOut"
        })
      },
      "&[data-focus=visible]::after": {
        boxShadow: `0 0 0 ${tokenSchema.size.alias.focusRing} var(--focus-ring-color)`,
        margin: `calc(-1 * ${tokenSchema.size.alias.focusRingGap})`
      },
      // PROMINENCE: default
      "&:not([data-prominence])": {
        backgroundColor: tokenSchema.color.scale.slate4,
        color: tokenSchema.color.foreground.neutralEmphasis,
        '&[data-hovered], &[data-focus="visible"]': {
          backgroundColor: tokenSchema.color.scale.slate5
        },
        "&[data-pressed]": {
          backgroundColor: tokenSchema.color.scale.slate6
        },
        // tones
        "&[data-tone=accent]": {
          color: tokenSchema.color.foreground.accent
        },
        "&[data-tone=critical]": {
          color: tokenSchema.color.foreground.critical
        },
        // states
        "&:disabled, &[aria-disabled]": {
          backgroundColor: tokenSchema.color.alias.backgroundHovered,
          color: tokenSchema.color.alias.foregroundDisabled
        },
        // static
        "&[data-static=light]": {
          backgroundColor: "#ffffff12",
          color: "#fff",
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: "#ffffff1a"
          },
          "&[data-pressed]": {
            backgroundColor: "#ffffff26"
          },
          "&:disabled, &[aria-disabled]": {
            backgroundColor: "#ffffff1a",
            color: "#ffffff8c"
          }
        },
        "&[data-static=dark]": {
          backgroundColor: "#00000012",
          color: "#000",
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: "#0000001a"
          },
          "&[data-pressed]": {
            backgroundColor: "#00000026"
          },
          "&:disabled, &[aria-disabled]": {
            backgroundColor: "#0000001a",
            color: "#0000008c"
          }
        }
      },
      // PROMINENCE: high
      "&[data-prominence=high]": {
        backgroundColor: tokenSchema.color.scale.slate10,
        color: tokenSchema.color.foreground.inverse,
        '&[data-hovered], &[data-focus="visible"]': {
          backgroundColor: tokenSchema.color.scale.slate11
        },
        "&[data-pressed]": {
          backgroundColor: tokenSchema.color.scale.slate11
        },
        // NOTE: "neutral" tone invalid for "high" prominence
        "&[data-tone=accent]": {
          backgroundColor: tokenSchema.color.scale.indigo9,
          color: tokenSchema.color.foreground.onEmphasis,
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: tokenSchema.color.scale.indigo10
          },
          "&[data-pressed]": {
            backgroundColor: tokenSchema.color.scale.indigo11
          }
        },
        "&[data-tone=critical]": {
          backgroundColor: tokenSchema.color.scale.red9,
          color: tokenSchema.color.foreground.onEmphasis,
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: tokenSchema.color.scale.red10
          },
          "&[data-pressed]": {
            backgroundColor: tokenSchema.color.scale.red11
          }
        },
        "&:disabled, &[aria-disabled]": {
          backgroundColor: tokenSchema.color.background.surfaceTertiary,
          color: tokenSchema.color.alias.foregroundDisabled
        },
        // static
        "&[data-static=light]": {
          backgroundColor: "#ffffffe6",
          color: "#000",
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: "#fff"
          },
          "&[data-pressed]": {
            backgroundColor: "#fff"
          },
          "&:disabled, &[aria-disabled]": {
            backgroundColor: "#ffffff1a",
            color: "#ffffff8c"
          }
        },
        "&[data-static=dark]": {
          backgroundColor: "#000000e6",
          color: "#fff",
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: "#000"
          },
          "&[data-pressed]": {
            backgroundColor: "#000"
          },
          "&:disabled, &[aria-disabled]": {
            backgroundColor: "#0000001a",
            color: "#0000008c"
          }
        }
      },
      // PROMINENCE: low
      "&[data-prominence=low]": {
        color: tokenSchema.color.foreground.neutral,
        // neutral interactions
        '&[data-hovered], &[data-focus="visible"]': {
          backgroundColor: tokenSchema.color.alias.backgroundHovered,
          color: tokenSchema.color.foreground.neutralEmphasis
        },
        "&[data-pressed]": {
          backgroundColor: tokenSchema.color.alias.backgroundPressed
        },
        // tones
        "&[data-tone=accent]": {
          color: tokenSchema.color.foreground.accent,
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: tokenSchema.color.scale.indigo3
          },
          "&[data-pressed]": {
            backgroundColor: tokenSchema.color.scale.indigo4
          }
        },
        "&[data-tone=critical]": {
          color: tokenSchema.color.foreground.critical,
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: tokenSchema.color.scale.red3
          },
          "&[data-pressed]": {
            backgroundColor: tokenSchema.color.scale.red4
          }
        },
        "&:disabled, &[aria-disabled]": {
          color: tokenSchema.color.alias.foregroundDisabled
        },
        // static
        "&[data-static=light]": {
          color: "#fff",
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: "#ffffff1a"
          },
          "&[data-pressed]": {
            backgroundColor: "#ffffff26"
          },
          "&:disabled, &[aria-disabled]": {
            color: "#ffffff8c"
          }
        },
        "&[data-static=dark]": {
          color: "#000",
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: "#0000001a"
          },
          "&[data-pressed]": {
            backgroundColor: "#00000026"
          },
          "&:disabled, &[aria-disabled]": {
            color: "#0000008c"
          }
        }
      }
    }), styleProps.className)
  };
}
var Button = (0, import_react25.forwardRef)(function Button2(props, forwardedRef) {
  props = useProviderProps(props);
  props = useSlotProps(props, "button");
  const children = useButtonChildren(props);
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  if ("href" in props && props.href) {
    return (0, import_jsx_runtime12.jsx)(FocusRing, {
      autoFocus: props.autoFocus,
      children: (0, import_jsx_runtime12.jsx)(LinkButton$1, {
        ref: domRef,
        ...props,
        children
      })
    });
  }
  return (0, import_jsx_runtime12.jsx)(FocusRing, {
    autoFocus: props.autoFocus,
    children: (0, import_jsx_runtime12.jsx)(BaseButton$1, {
      ref: domRef,
      ...props,
      children
    })
  });
});
var LinkButton$1 = (0, import_react25.forwardRef)(function Button3(props, forwardedRef) {
  const {
    children,
    isDisabled,
    // link specific
    download,
    href,
    hrefLang,
    ping,
    referrerPolicy,
    rel,
    target,
    ...otherProps
  } = props;
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const {
    buttonProps,
    isPressed
  } = $701a24aa0da5b062$export$ea18c227d4417cc3({
    elementType: "a",
    ...props
  }, domRef);
  const {
    linkProps
  } = $298d61e98472621b$export$dcf14c9974fe2767(otherProps, domRef);
  const {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    isDisabled
  });
  const styleProps = useButtonStyles(props, {
    isHovered,
    isPressed
  });
  return (0, import_jsx_runtime12.jsx)("a", {
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, linkProps, hoverProps, styleProps),
    ref: domRef,
    download,
    href,
    hrefLang,
    ping,
    referrerPolicy,
    rel,
    target,
    children
  });
});
var BaseButton$1 = (0, import_react25.forwardRef)(function Button4(props, forwardedRef) {
  const {
    children,
    isDisabled,
    ...otherProps
  } = props;
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const {
    buttonProps,
    isPressed
  } = $701a24aa0da5b062$export$ea18c227d4417cc3(props, domRef);
  const {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    isDisabled
  });
  const styleProps = useButtonStyles(props, {
    isHovered,
    isPressed
  });
  return (0, import_jsx_runtime12.jsx)("button", {
    ref: domRef,
    ...styleProps,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps, {
      propNames: /* @__PURE__ */ new Set(["form"])
    }),
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, hoverProps),
    children
  });
});
var useButtonChildren = (props) => {
  const {
    children
  } = props;
  const slots = (0, import_react25.useMemo)(() => {
    return {
      icon: {
        UNSAFE_className: buttonClassList.element("icon")
      },
      text: {
        color: "inherit",
        overflow: "unset",
        trim: false,
        UNSAFE_className: buttonClassList.element("text")
      }
    };
  }, []);
  return (0, import_jsx_runtime12.jsx)(SlotProvider, {
    slots,
    children: isReactText(children) ? (0, import_jsx_runtime12.jsx)(Text2, {
      children
    }) : children
  });
};
var actionButtonClassList = new ClassList("ActionButton", ["icon", "text"]);
function useActionButtonStyles(props, state) {
  const {
    prominence = "default"
  } = props;
  const {
    isHovered,
    isPressed
  } = state;
  const isSelected = "isSelected" in props && props.isSelected || state.isSelected;
  const styleProps = useStyleProps(props);
  return {
    ...toDataAttributes({
      interaction: isPressed ? "press" : isHovered ? "hover" : void 0,
      prominence: prominence === "default" ? void 0 : prominence,
      selected: isSelected || void 0,
      static: props.static
    }),
    style: styleProps.style,
    className: classNames(actionButtonClassList.element("root"), css({
      alignItems: "center",
      borderColor: "transparent",
      borderRadius: tokenSchema.size.radius.regular,
      borderStyle: "solid",
      borderWidth: tokenSchema.size.border.regular,
      cursor: "default",
      display: "inline-flex",
      flexShrink: 0,
      fontWeight: tokenSchema.typography.fontWeight.medium,
      height: tokenSchema.size.element.regular,
      justifyContent: "center",
      minWidth: tokenSchema.size.element.regular,
      outline: 0,
      paddingInline: tokenSchema.size.space.regular,
      position: "relative",
      transitionDuration: "130ms",
      transitionProperty: "background, border-color, box-shadow, color",
      transitionTimingFunction: "ease-out",
      userSelect: "none",
      // indicate when external link? e.g. `&[href^=http]`
      "a&": {
        cursor: "pointer"
      },
      // CONTENTS
      [actionButtonClassList.selector("text", "descendant")]: {
        fontWeight: "inherit",
        marginInline: tokenSchema.size.space.small,
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
      },
      // FOCUS RING
      "--focus-ring-color": tokenSchema.color.alias.focusRing,
      "&[data-static]": {
        "--focus-ring-color": "currentColor"
      },
      "&::after": {
        borderRadius: `inherit`,
        content: '""',
        inset: 0,
        margin: 0,
        pointerEvents: "none",
        position: "absolute",
        transition: transition(["box-shadow", "margin"], {
          easing: "easeOut"
        })
      },
      "&[data-focus=visible]::after": {
        boxShadow: `0 0 0 ${tokenSchema.size.alias.focusRing} var(--focus-ring-color)`
      },
      // PROMINENCE
      // prominence: default
      "&:not([data-prominence])": {
        backgroundColor: tokenSchema.color.alias.backgroundIdle,
        borderColor: tokenSchema.color.alias.borderIdle,
        color: tokenSchema.color.alias.foregroundIdle,
        // interactions
        "&[data-interaction=hover]": {
          backgroundColor: tokenSchema.color.alias.backgroundHovered,
          borderColor: tokenSchema.color.alias.borderHovered,
          color: tokenSchema.color.alias.foregroundHovered
        },
        "&[data-interaction=press]": {
          backgroundColor: tokenSchema.color.alias.backgroundPressed,
          borderColor: tokenSchema.color.alias.borderPressed,
          color: tokenSchema.color.alias.foregroundPressed
        },
        // states
        "&[data-selected]": {
          backgroundColor: tokenSchema.color.alias.backgroundSelected,
          color: tokenSchema.color.foreground.neutralEmphasis,
          "&[data-interaction=hover]": {
            backgroundColor: tokenSchema.color.alias.backgroundSelectedHovered
          }
        },
        "&:disabled, &[aria-disabled=true], &[data-disabled=true]": {
          backgroundColor: tokenSchema.color.alias.backgroundDisabled,
          borderColor: "transparent",
          color: tokenSchema.color.alias.foregroundDisabled
        },
        // static
        "&[data-static]": {
          backgroundColor: "transparent"
        },
        "&[data-static=light]": {
          borderColor: "#fff6",
          color: "#fff",
          '&[data-interaction=hover], &[data-focus="visible"]': {
            backgroundColor: "#ffffff1a",
            borderColor: "#ffffff8c"
          },
          "&[data-interaction=press]": {
            backgroundColor: "#ffffff26",
            borderColor: "#ffffffb3"
          },
          "&:disabled, &[aria-disabled]": {
            borderColor: "#ffffff40",
            color: "#ffffff8c"
          }
        },
        "&[data-static=dark]": {
          borderColor: "#0006",
          color: "#000",
          '&[data-interaction=hover], &[data-focus="visible"]': {
            backgroundColor: "#0000001a",
            borderColor: "#0000008c"
          },
          "&[data-interaction=press]": {
            backgroundColor: "#00000026",
            borderColor: "#000000b3"
          },
          "&:disabled, &[aria-disabled]": {
            borderColor: "#00000040",
            color: "#0000008c"
          }
        }
      },
      // prominence: low
      "&[data-prominence=low]": {
        color: tokenSchema.color.foreground.neutral,
        // interactions
        "&[data-interaction=hover]": {
          backgroundColor: tokenSchema.color.alias.backgroundHovered,
          color: tokenSchema.color.foreground.neutralEmphasis
        },
        "&[data-interaction=press]": {
          backgroundColor: tokenSchema.color.alias.backgroundPressed
        },
        // states
        "&[data-selected]": {
          backgroundColor: tokenSchema.color.alias.backgroundSelected,
          color: tokenSchema.color.alias.foregroundSelected,
          "&[data-interaction=hover]": {
            backgroundColor: tokenSchema.color.alias.backgroundSelectedHovered
          }
        },
        "&:disabled, &[aria-disabled=true], &[data-disabled=true]": {
          borderColor: "transparent",
          color: tokenSchema.color.alias.foregroundDisabled
        },
        // static
        "&[data-static=light]": {
          color: "#fff",
          '&[data-interaction=hover], &[data-focus="visible"]': {
            backgroundColor: "#ffffff1a"
          },
          "&[data-interaction=press]": {
            backgroundColor: "#ffffff26"
          },
          "&:disabled, &[aria-disabled]": {
            color: "#ffffff8c"
          }
        },
        "&[data-static=dark]": {
          color: "#000",
          '&[data-interaction=hover], &[data-focus="visible"]': {
            backgroundColor: "#0000001a"
          },
          "&[data-interaction=press]": {
            backgroundColor: "#00000026"
          },
          "&:disabled, &[aria-disabled]": {
            color: "#0000008c"
          }
        }
      }
    }), styleProps.className)
  };
}
var ActionButton = (0, import_react25.forwardRef)(function ActionButton2(props, forwardedRef) {
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const children = useActionButtonChildren(props);
  if ("href" in props && props.href) {
    return (0, import_jsx_runtime12.jsx)(FocusRing, {
      autoFocus: props.autoFocus,
      children: (0, import_jsx_runtime12.jsx)(LinkButton, {
        ref: domRef,
        ...props,
        children
      })
    });
  }
  return (0, import_jsx_runtime12.jsx)(FocusRing, {
    autoFocus: props.autoFocus,
    children: (0, import_jsx_runtime12.jsx)(BaseButton, {
      ref: domRef,
      ...props,
      children
    })
  });
});
var LinkButton = (0, import_react25.forwardRef)(function LinkActionButton(props, forwardedRef) {
  const {
    children,
    isDisabled,
    // link specific
    download,
    href,
    hrefLang,
    ping,
    referrerPolicy,
    rel,
    target,
    ...otherProps
  } = props;
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const {
    buttonProps,
    isPressed
  } = $701a24aa0da5b062$export$ea18c227d4417cc3({
    elementType: "a",
    ...props
  }, domRef);
  const {
    linkProps
  } = $298d61e98472621b$export$dcf14c9974fe2767(otherProps, domRef);
  const {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    isDisabled
  });
  const styleProps = useActionButtonStyles(props, {
    isHovered,
    isPressed
  });
  return (0, import_jsx_runtime12.jsx)("a", {
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, linkProps, hoverProps, styleProps),
    ref: domRef,
    download,
    href,
    hrefLang,
    ping,
    referrerPolicy,
    rel,
    target,
    children
  });
});
var BaseButton = (0, import_react25.forwardRef)(function BaseActionButton(props, forwardedRef) {
  props = useProviderProps(props);
  props = useSlotProps(props, "button");
  const {
    children,
    isDisabled,
    ...otherProps
  } = props;
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const {
    buttonProps,
    isPressed
  } = $701a24aa0da5b062$export$ea18c227d4417cc3(props, domRef);
  const {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    isDisabled
  });
  const styleProps = useActionButtonStyles(props, {
    isHovered,
    isPressed
  });
  return (0, import_jsx_runtime12.jsx)("button", {
    ref: domRef,
    ...styleProps,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps, {
      propNames: /* @__PURE__ */ new Set(["form"])
    }),
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, hoverProps),
    children
  });
});
var iconClassName = actionButtonClassList.element("icon");
var textClassName = actionButtonClassList.element("text");
var useActionButtonChildren = (props, alternateSlots) => {
  const {
    children
  } = props;
  const slots = (0, import_react25.useMemo)(() => {
    return {
      ...alternateSlots,
      icon: {
        UNSAFE_className: iconClassName,
        ...alternateSlots === null || alternateSlots === void 0 ? void 0 : alternateSlots.icon
      },
      text: {
        color: "inherit",
        overflow: "unset",
        trim: false,
        UNSAFE_className: textClassName,
        ...alternateSlots === null || alternateSlots === void 0 ? void 0 : alternateSlots.text
      }
    };
  }, [alternateSlots]);
  return (0, import_jsx_runtime12.jsx)(SlotProvider, {
    slots,
    children: isReactText(children) ? (0, import_jsx_runtime12.jsx)(Text2, {
      children
    }) : children
  });
};
var ClearButton = (0, import_react25.forwardRef)(function ClearButton2(props, forwardedRef) {
  let {
    autoFocus,
    isDisabled,
    preventFocus,
    elementType = preventFocus ? "div" : "button",
    ...otherProps
  } = props;
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let {
    buttonProps,
    isPressed
  } = $701a24aa0da5b062$export$ea18c227d4417cc3({
    ...props,
    elementType
  }, domRef);
  let {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    isDisabled
  });
  let styleProps = useClearButtonStyles(otherProps, {
    isHovered,
    isPressed
  });
  if (preventFocus) {
    delete buttonProps.tabIndex;
  }
  let ElementType = elementType;
  return (0, import_jsx_runtime12.jsx)(FocusRing, {
    autoFocus,
    children: (0, import_jsx_runtime12.jsx)(ElementType, {
      ...styleProps,
      ...$3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, hoverProps),
      ref: domRef,
      children: (0, import_jsx_runtime12.jsx)(Icon, {
        src: xIcon
      })
    })
  });
});
function useClearButtonStyles(props, state) {
  let {
    isPressed,
    isHovered
  } = state;
  let styleProps = useStyleProps(props);
  const clearButtonStyles = css({
    alignItems: "center",
    borderRadius: "100%",
    color: tokenSchema.color.foreground.neutralSecondary,
    display: "flex",
    height: tokenSchema.size.element.regular,
    justifyContent: "center",
    outline: 0,
    position: "relative",
    transition: transition(["box-shadow", "margin"], {
      easing: "easeOut"
    }),
    width: tokenSchema.size.element.regular,
    "--focus-ring-color": tokenSchema.color.alias.focusRing,
    "&[data-static]": {
      "--focus-ring-color": "currentColor"
    },
    "&::after": {
      borderRadius: `inherit`,
      content: '""',
      inset: 0,
      pointerEvents: "none",
      position: "absolute",
      transition: transition(["box-shadow", "margin"], {
        easing: "easeOut"
      })
    },
    "&[data-focus=visible]::after": {
      boxShadow: `0 0 0 ${tokenSchema.size.alias.focusRing} var(--focus-ring-color)`,
      margin: `calc(-1 * ${tokenSchema.size.alias.focusRingGap})`
    },
    "&[data-interaction=hover]": {
      color: tokenSchema.color.foreground.neutral
    },
    "&[data-interaction=press]": {
      color: tokenSchema.color.foreground.neutralEmphasis
    },
    "&:disabled, &[aria-disabled]": {
      color: tokenSchema.color.alias.foregroundDisabled
    },
    // static
    "&[data-static=light]": {
      color: "#fff",
      '&[data-interaction=hover], &[data-focus="visible"]': {
        backgroundColor: "#ffffff1a"
      },
      "&[data-interaction=press]": {
        backgroundColor: "#ffffff26"
      },
      "&:disabled, &[aria-disabled]": {
        backgroundColor: "#ffffff1a",
        color: "#ffffff8c"
      }
    },
    "&[data-static=dark]": {
      color: "#000",
      '&[data-interaction=hover], &[data-focus="visible"]': {
        backgroundColor: "#0000001a"
      },
      "&[data-interaction=press]": {
        backgroundColor: "#00000026"
      },
      "&:disabled, &[aria-disabled]": {
        backgroundColor: "#0000001a",
        color: "#0000008c"
      }
    }
  });
  return {
    ...styleProps,
    ...toDataAttributes({
      static: props.static,
      interaction: isPressed ? "press" : isHovered ? "hover" : void 0
    }),
    className: classNames(clearButtonStyles, styleProps.className)
  };
}
var FieldButton = (0, import_react25.forwardRef)(function FieldButton2(props, forwardedRef) {
  props = useSlotProps(props, "button");
  let {
    elementType: ElementType = "button",
    isDisabled,
    autoFocus,
    isActive
  } = props;
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let {
    buttonProps,
    isPressed
  } = $701a24aa0da5b062$export$ea18c227d4417cc3(props, domRef);
  let {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    isDisabled
  });
  let {
    children,
    styleProps
  } = useFieldButton(props, {
    isHovered,
    isPressed: isActive !== null && isActive !== void 0 ? isActive : isPressed
  });
  return (0, import_jsx_runtime12.jsx)(FocusRing, {
    autoFocus,
    children: (0, import_jsx_runtime12.jsx)(ElementType, {
      ...styleProps,
      ...$3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, hoverProps),
      ref: domRef,
      className: classNames(css({
        justifyContent: "space-between",
        textAlign: "start"
      }), styleProps.className),
      style: {
        ...styleProps.style,
        boxShadow: "none"
      },
      children
    })
  });
});
function useFieldButton(props, state) {
  let {
    isHovered,
    isPressed
  } = state;
  const styleProps = useActionButtonStyles(props, {
    isHovered,
    isPressed
  });
  let slots = (0, import_react25.useMemo)(() => ({
    text: {
      flex: true,
      truncate: true
    }
  }), []);
  let children = useActionButtonChildren(props, slots);
  return {
    children,
    styleProps
  };
}
var ToggleButton = (0, import_react25.forwardRef)(function ToggleButton2(props, forwardedRef) {
  const {
    isDisabled,
    ...otherProps
  } = props;
  props = useProviderProps(props);
  props = useSlotProps(props, "button");
  const children = useActionButtonChildren(props);
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const state = $3017fa7ffdddec74$export$8042c6c013fd5226(props);
  const {
    buttonProps,
    isPressed
  } = $55f54f7887471b58$export$51e84d46ca0bc451(props, state, domRef);
  const {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    isDisabled
  });
  const styleProps = useActionButtonStyles(props, {
    isHovered,
    isPressed,
    isSelected: state.isSelected
  });
  return (0, import_jsx_runtime12.jsx)(FocusRing, {
    autoFocus: props.autoFocus,
    children: (0, import_jsx_runtime12.jsx)("button", {
      ref: domRef,
      ...styleProps,
      ...$3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, hoverProps),
      ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
      children
    })
  });
});

// node_modules/@react-stately/overlays/dist/import.mjs
var import_react26 = __toESM(require_react(), 1);
function $fc909762b330b746$export$61c6a8c84e605fb6(props) {
  let [isOpen, setOpen] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(props.isOpen, props.defaultOpen || false, props.onOpenChange);
  const open = (0, import_react26.useCallback)(() => {
    setOpen(true);
  }, [
    setOpen
  ]);
  const close = (0, import_react26.useCallback)(() => {
    setOpen(false);
  }, [
    setOpen
  ]);
  const toggle = (0, import_react26.useCallback)(() => {
    setOpen(!isOpen);
  }, [
    setOpen,
    isOpen
  ]);
  return {
    isOpen,
    setOpen,
    open,
    close,
    toggle
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-overlays.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime());
var import_react27 = __toESM(require_react());
function Blanket(props) {
  const {
    isOpen,
    isTransparent,
    ...otherProps
  } = props;
  const styleProps = useStyleProps(otherProps);
  return (0, import_jsx_runtime13.jsx)("div", {
    ...filterStyleProps(otherProps),
    ...toDataAttributes({
      fill: isTransparent ? "transparent" : "translucent",
      open: isOpen || void 0
    }),
    ...styleProps,
    className: classNames(css({
      inset: 0,
      opacity: 0,
      overflow: "hidden",
      pointerEvents: "none",
      position: "fixed",
      visibility: "hidden",
      zIndex: 1,
      // exit animation
      '&[data-fill="translucent"]': {
        backgroundColor: "#0006",
        // TODO: add token
        transition: [transition("opacity", {
          easing: "easeOut",
          duration: "regular",
          delay: "short"
        }), transition("visibility", {
          delay: "regular",
          duration: 0,
          easing: "linear"
        })].join(", ")
      },
      '&[data-open="true"]': {
        opacity: 1,
        pointerEvents: "auto",
        visibility: "visible",
        // enter animation
        transition: transition("opacity", {
          easing: "easeIn"
        })
      }
    }), styleProps.className)
  });
}
function DirectionIndicator({
  fill,
  placement,
  size: size3,
  stroke,
  ...props
}) {
  return (0, import_jsx_runtime13.jsx)("span", {
    ...props,
    ...toDataAttributes({
      fill,
      placement,
      size: size3
    }),
    "data-placement": placement,
    className: classNames(css({
      height: "var(--size)",
      position: "absolute",
      width: "var(--size)",
      // fill
      '&[data-fill="surface"]': {
        fill: tokenSchema.color.background.surface
      },
      '&[data-fill="inverse"]': {
        fill: tokenSchema.color.background.inverse
      },
      '&[data-fill="accent"]': {
        fill: tokenSchema.color.background.accentEmphasis
      },
      '&[data-fill="critical"]': {
        fill: tokenSchema.color.background.criticalEmphasis
      },
      '&[data-fill="positive"]': {
        fill: tokenSchema.color.background.positiveEmphasis
      },
      // size
      '&[data-size="xsmall"]': {
        "--size": tokenSchema.size.element.xsmall
      },
      '&[data-size="small"]': {
        "--size": tokenSchema.size.element.small
      },
      '&[data-size="regular"]': {
        "--size": tokenSchema.size.element.regular
      },
      // align block
      '&[data-placement="top"], &[data-placement="bottom"]': {
        left: "50%",
        transform: "translateX(-50%)"
      },
      '&[data-placement="top"]': {
        top: "100%"
      },
      '&[data-placement="bottom"]': {
        bottom: "100%"
      },
      // align inline
      '&[data-placement="left"], &[data-placement="right"], &[data-placement="start"], &[data-placement="end"]': {
        top: "50%",
        transform: "translateY(-50%)"
      },
      '&[data-placement="left"]': {
        left: "100%"
      },
      '&[data-placement="right"]': {
        right: "100%"
      },
      '&[data-placement="start"]': {
        insetInlineStart: "100%"
      },
      '&[data-placement="end"]': {
        insetInlineEnd: "100%"
      }
    }), props.className),
    children: (0, import_jsx_runtime13.jsxs)("svg", {
      "data-placement": placement,
      viewBox: "0 0 30 30",
      className: css({
        // bottom is default; no rotation
        '&[data-placement="top"]': {
          transform: "rotate(180deg)"
        },
        '&[data-placement="left"], [dir=ltr] &[data-placement="start"], [dir=rtl] &[data-placement="end"]': {
          transform: "rotate(90deg)"
        },
        '&[data-placement="right"], [dir=ltr] &[data-placement="end"], [dir=rtl] &[data-placement="start"]': {
          transform: "rotate(270deg)"
        }
      }),
      children: [stroke && (0, import_jsx_runtime13.jsx)("path", {
        fill: stroke,
        d: "M23.7,27.1L17,19.9C16.5,19.3,15.8,19,15,19s-1.6,0.3-2.1,0.9l-6.6,7.2C5.3,28.1,3.4,29,2,29h26 C26.7,29,24.6,28.1,23.7,27.1z"
      }), (0, import_jsx_runtime13.jsx)("path", {
        d: "M23,27.8c1.1,1.2,3.4,2.2,5,2.2h2H0h2c1.7,0,3.9-1,5-2.2l6.6-7.2c0.7-0.8,2-0.8,2.7,0L23,27.8L23,27.8z"
      })]
    })
  });
}
var forceReflow = (node4) => node4.scrollTop;
var Overlay = (0, import_react27.forwardRef)(function Overlay2(props, forwardedRef) {
  var _cloneValidElement;
  let {
    isOpen,
    container,
    children,
    nodeRef
  } = props;
  const [isOpenState, setIsOpenState] = (0, import_react27.useState)(props.isOpen ? "mounting" : false);
  if (isOpen && !isOpenState) {
    setIsOpenState("mounting");
  }
  const hasCalledCompletedCallback = (0, import_react27.useRef)(false);
  (0, import_react27.useLayoutEffect)(() => {
    if (!hasCalledCompletedCallback.current && isOpen === isOpenState) {
      hasCalledCompletedCallback.current = true;
      if (isOpen) {
        var _props$onEntered;
        (_props$onEntered = props.onEntered) === null || _props$onEntered === void 0 || _props$onEntered.call(props);
      } else {
        var _props$onExited;
        (_props$onExited = props.onExited) === null || _props$onExited === void 0 || _props$onExited.call(props);
      }
    }
    if (isOpen === isOpenState)
      return;
    hasCalledCompletedCallback.current = false;
    if (isOpen) {
      var _props$onEnter, _props$onEntering;
      (_props$onEnter = props.onEnter) === null || _props$onEnter === void 0 || _props$onEnter.call(props);
      if (nodeRef.current) {
        forceReflow(nodeRef.current);
      }
      setIsOpenState(true);
      (_props$onEntering = props.onEntering) === null || _props$onEntering === void 0 || _props$onEntering.call(props);
    } else {
      var _props$onExit, _props$onExiting;
      (_props$onExit = props.onExit) === null || _props$onExit === void 0 || _props$onExit.call(props);
      (_props$onExiting = props.onExiting) === null || _props$onExiting === void 0 || _props$onExiting.call(props);
      const id2 = setTimeout(() => {
        setIsOpenState(false);
      }, 320);
      return () => clearTimeout(id2);
    }
  }, [isOpen, isOpenState, nodeRef, props]);
  if (!isOpenState) {
    return null;
  }
  return (0, import_jsx_runtime13.jsx)($337b884510726a0d$export$c6fdb837b070b4ff, {
    portalContainer: container,
    children: (0, import_jsx_runtime13.jsx)(KeystarProvider, {
      ref: forwardedRef,
      UNSAFE_style: {
        background: "transparent",
        isolation: "isolate"
      },
      isDisabled: false,
      children: (_cloneValidElement = cloneValidElement(children, {
        isOpen: isOpenState === "mounting" ? false : isOpen
      })) !== null && _cloneValidElement !== void 0 ? _cloneValidElement : children
    })
  });
});
var Modal = (0, import_react27.forwardRef)(function Modal2(props, forwardedRef) {
  let {
    children,
    state,
    ...otherProps
  } = props;
  let wrapperRef = (0, import_react27.useRef)(null);
  return (
    /* @ts-expect-error FIXME: resolve ref inconsistencies */
    (0, import_jsx_runtime13.jsx)(Overlay, {
      ...otherProps,
      isOpen: state.isOpen,
      nodeRef: wrapperRef,
      children: (0, import_jsx_runtime13.jsx)(ModalWrapper, {
        ref: forwardedRef,
        ...props,
        wrapperRef,
        children
      })
    })
  );
});
var MAX_HEIGHT_VAR = `--${TOKEN_PREFIX}-visual-viewport-height`;
var ModalWrapper = (0, import_react27.forwardRef)(function ModalWrapper2(props, forwardedRef) {
  let {
    type: type2,
    children,
    state,
    isOpen,
    wrapperRef
  } = props;
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let {
    modalProps,
    underlayProps
  } = $8ac8429251c45e4b$export$dbc0f175b25fb0fb(props, state, domRef);
  let styleProps = useStyleProps(props);
  let viewport = $5df64b3807dc15ee$export$d699905dd57c73ca();
  return (0, import_jsx_runtime13.jsxs)("div", {
    ref: wrapperRef,
    children: [(0, import_jsx_runtime13.jsx)(Blanket, {
      ...underlayProps,
      isOpen
    }), (0, import_jsx_runtime13.jsx)("div", {
      className: css({
        alignItems: "center",
        boxSizing: "border-box",
        display: "flex",
        insetBlockStart: 0,
        insetInlineStart: 0,
        justifyContent: "center",
        pointerEvents: "none",
        position: "fixed",
        width: "100vw",
        zIndex: 2
        // above blanket
      }),
      style: {
        // @ts-ignore
        [MAX_HEIGHT_VAR]: `${viewport.height}px`,
        height: `var(${MAX_HEIGHT_VAR})`
      },
      children: (0, import_jsx_runtime13.jsx)("div", {
        ...modalProps,
        ...toDataAttributes({
          open: isOpen,
          type: type2
        }),
        ...styleProps,
        ref: domRef,
        className: classNames(styleProps.className, css({
          backgroundColor: tokenSchema.color.background.surface,
          // TODO: component token?
          borderRadius: tokenSchema.size.radius.large,
          // TODO: component token?
          boxShadow: `${tokenSchema.size.shadow.large} ${tokenSchema.color.shadow.emphasis}`,
          maxHeight: `calc(var(${MAX_HEIGHT_VAR}) * 0.9)`,
          maxWidth: "90vw",
          opacity: 0,
          outline: 0,
          pointerEvents: "auto",
          transform: `translateY(${tokenSchema.size.space.large})`,
          // initialise with offset
          zIndex: 2,
          // above blanket
          // exit animation
          transition: [transition("opacity", {
            easing: "easeIn"
          }), transition("transform", {
            delay: "short",
            duration: 0,
            easing: "linear"
          })].join(", "),
          '&[data-type="fullscreen"]': {
            position: "fixed",
            inset: tokenSchema.size.space.xxlarge,
            maxWidth: "none",
            maxHeight: "none",
            width: `calc(100% - calc(2 * ${tokenSchema.size.space.xxlarge}))`,
            height: `calc(100% - calc(2 * ${tokenSchema.size.space.xxlarge}))`
          },
          '&[data-open="true"]': {
            opacity: 1,
            transform: `translateY(0)`,
            // enter animation
            transition: transition(["opacity", "transform"], {
              easing: "easeOut"
            })
          }
        })),
        children
      })
    })]
  });
});
var Popover = (0, import_react27.forwardRef)(function Popover2(props, forwardedRef) {
  let {
    children,
    state,
    ...otherProps
  } = props;
  let wrapperRef = (0, import_react27.useRef)(null);
  return (
    /* @ts-expect-error FIXME: resolve ref inconsistencies */
    (0, import_jsx_runtime13.jsx)(Overlay, {
      ...otherProps,
      isOpen: state.isOpen,
      nodeRef: wrapperRef,
      children: (0, import_jsx_runtime13.jsx)(PopoverWrapper, {
        ref: forwardedRef,
        ...props,
        wrapperRef,
        children
      })
    })
  );
});
var PopoverWrapper = (0, import_react27.forwardRef)(function PopoverWrapper2(props, forwardedRef) {
  let {
    children,
    isOpen,
    hideArrow,
    isNonModal,
    state,
    wrapperRef
  } = props;
  let popoverRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let {
    popoverProps,
    arrowProps,
    underlayProps,
    placement
  } = $f2f8a6077418541e$export$542a6fd13ac93354({
    ...props,
    containerPadding: 8,
    popoverRef,
    // @ts-expect-error we need to override the default value, but `undefined` doesn't work.
    maxHeight: null
  }, state);
  let styleProps = usePopoverStyles({
    ...props,
    placement
  });
  return (0, import_jsx_runtime13.jsxs)("div", {
    ref: wrapperRef,
    children: [!isNonModal && (0, import_jsx_runtime13.jsx)(Blanket, {
      isTransparent: true,
      ...underlayProps,
      isOpen
    }), (0, import_jsx_runtime13.jsxs)("div", {
      ...styleProps,
      ...popoverProps,
      style: {
        ...styleProps.style,
        ...popoverProps.style
      },
      ref: popoverRef,
      role: "presentation",
      children: [!isNonModal && (0, import_jsx_runtime13.jsx)($86ea4cb521eb2e37$export$2317d149ed6f78c4, {
        onDismiss: state.close
      }), hideArrow ? null : (0, import_jsx_runtime13.jsx)(DirectionIndicator, {
        ...arrowProps,
        fill: "surface",
        stroke: tokenSchema.color.border.emphasis,
        placement,
        size: "regular"
      }), children, (0, import_jsx_runtime13.jsx)($86ea4cb521eb2e37$export$2317d149ed6f78c4, {
        onDismiss: state.close
      })]
    })]
  });
});
function usePopoverStyles(props) {
  let {
    hideArrow,
    isOpen,
    placement
  } = props;
  let consumerStyleProps = useStyleProps(props);
  let offset = "var(--popover-offset)";
  let popoverStyles = css({
    backgroundColor: tokenSchema.color.background.surface,
    // TODO: component token?
    borderRadius: tokenSchema.size.radius.medium,
    // TODO: component token?
    border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.emphasis}`,
    boxSizing: "content-box",
    // resolves measurement/scroll issues related to border
    opacity: 0,
    outline: 0,
    pointerEvents: "auto",
    position: "absolute",
    // drop shadow
    filter: `drop-shadow(0 1px 4px ${tokenSchema.color.shadow.regular})`,
    // use filter:drop-shadow instead of box-shadow so the arrow is included
    willChange: "filter, transform",
    // filter bug in safari: https://stackoverflow.com/questions/56478925/safari-drop-shadow-filter-remains-visible-even-with-hidden-element
    // exit animation
    transition: [transition("opacity", {
      easing: "easeIn"
    }), transition("transform", {
      delay: "short",
      duration: 0,
      easing: "linear"
    })].join(", "),
    // gutter between popover and viewport
    "&[data-placement=top]": {
      marginTop: tokenSchema.size.space.regular
    },
    "&[data-placement=bottom]": {
      marginBottom: tokenSchema.size.space.regular
    },
    "&[data-placement=left]": {
      marginLeft: tokenSchema.size.space.regular
    },
    "&[data-placement=right]": {
      marginRight: tokenSchema.size.space.regular
    },
    "&[data-open]": {
      opacity: 1,
      // enter animation
      transition: transition(["opacity", "transform"], {
        easing: "easeOut"
      })
    },
    // animate towards placement; re-enforce the illusion that the popover
    // originates from, and is bound to, the trigger.
    "&[data-placement=top][data-open]": {
      transform: `translateY(calc(${offset} * -1))`
    },
    "&[data-placement=bottom][data-open]": {
      transform: `translateY(${offset})`
    },
    "&[data-placement=left][data-open]": {
      transform: `translateX(calc(${offset} * -1))`
    },
    "&[data-placement=right][data-open]": {
      transform: `translateX(${offset})`
    }
  });
  return {
    ...toDataAttributes({
      arrow: !hideArrow || void 0,
      placement,
      open: isOpen || void 0
    }),
    className: classNames(popoverStyles, consumerStyleProps.className),
    style: {
      "--popover-offset": hideArrow ? tokenSchema.size.space.regular : tokenSchema.size.space.large,
      ...consumerStyleProps.style
    }
  };
}
var Tray = (0, import_react27.forwardRef)(function Tray2(props, forwardedRef) {
  let {
    children,
    state,
    ...otherProps
  } = props;
  let wrapperRef = (0, import_react27.useRef)(null);
  return (
    /* @ts-expect-error FIXME: resolve ref inconsistencies */
    (0, import_jsx_runtime13.jsx)(Overlay, {
      ...otherProps,
      isOpen: state.isOpen,
      nodeRef: wrapperRef,
      children: (0, import_jsx_runtime13.jsx)(TrayWrapper, {
        ref: forwardedRef,
        ...props,
        wrapperRef,
        children
      })
    })
  );
});
var TrayWrapper = (0, import_react27.forwardRef)(function TrayWrapper2(props, forwardedRef) {
  let {
    children,
    state,
    isFixedHeight,
    isOpen,
    wrapperRef
  } = props;
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let {
    modalProps,
    underlayProps
  } = $8ac8429251c45e4b$export$dbc0f175b25fb0fb({
    ...props,
    isDismissable: true
  }, state, domRef);
  let styleProps = useStyleProps(props);
  let viewport = $5df64b3807dc15ee$export$d699905dd57c73ca();
  return (0, import_jsx_runtime13.jsxs)("div", {
    ref: wrapperRef,
    children: [(0, import_jsx_runtime13.jsx)(Blanket, {
      ...underlayProps,
      isOpen
    }), (0, import_jsx_runtime13.jsx)("div", {
      className: css({
        boxSizing: "border-box",
        display: "flex",
        insetBlockStart: 0,
        insetInlineStart: 0,
        justifyContent: "center",
        pointerEvents: "none",
        position: "fixed",
        height: "100vh",
        width: "100%",
        zIndex: 2
        // above blanket
      }),
      style: {
        height: viewport.height
      },
      children: (0, import_jsx_runtime13.jsx)("div", {
        ...modalProps,
        ...toDataAttributes({
          open: isOpen,
          fillScreen: isFixedHeight || void 0
        }),
        ref: domRef,
        style: Object.assign({}, isFixedHeight ? {
          height: `calc(${viewport.height}px - ${tokenSchema.size.space.xxlarge})`,
          top: tokenSchema.size.space.xxlarge
        } : {}, {
          maxHeight: `calc(${viewport.height}px - ${tokenSchema.size.space.xxlarge})`,
          paddingBottom: `max(calc(100vh - ${viewport.height}px), env(safe-area-inset-bottom))`
        }, styleProps.style),
        className: classNames(styleProps.className, css({
          backgroundColor: tokenSchema.color.background.surface,
          // TODO: component token?
          bottom: 0,
          maxWidth: "100vw",
          opacity: 0,
          outline: 0,
          pointerEvents: "auto",
          position: "absolute",
          transform: "translateY(100%)",
          // initialise with offset
          width: "100%",
          zIndex: 2,
          // above blanket
          // NOTE: trays shouldn't be used for larger screens, but in case
          // they are we need to tweak the appearance.
          [breakpointQueries$1.above.mobile]: {
            borderStartStartRadius: tokenSchema.size.radius.medium,
            // TODO: component token?
            borderStartEndRadius: tokenSchema.size.radius.medium,
            // TODO: component token?
            maxWidth: breakpoints.tablet
          },
          // exit animation
          transition: transition(["opacity", "transform"], {
            easing: "easeIn"
          }),
          '&[data-open="true"]': {
            opacity: 1,
            transform: `translateY(0)`,
            // enter animation
            transition: transition(["opacity", "transform"], {
              easing: "easeOut",
              delay: "short"
            })
          }
        })),
        children
      })
    })]
  });
});

// node_modules/@keystar/ui/dist/keystar-ui-dialog.js
var import_react29 = __toESM(require_react());

// node_modules/@react-aria/dialog/dist/import.mjs
var import_react28 = __toESM(require_react(), 1);
function $40df3f8667284809$export$d55e7ee900f34e93(props, ref) {
  let { role = "dialog" } = props;
  let titleId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)();
  titleId = props["aria-label"] ? void 0 : titleId;
  let isRefocusing = (0, import_react28.useRef)(false);
  (0, import_react28.useEffect)(() => {
    if (ref.current && !ref.current.contains(document.activeElement)) {
      (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
      let timeout = setTimeout(() => {
        if (document.activeElement === ref.current) {
          isRefocusing.current = true;
          if (ref.current) {
            ref.current.blur();
            (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
          }
          isRefocusing.current = false;
        }
      }, 500);
      return () => {
        clearTimeout(timeout);
      };
    }
  }, [
    ref
  ]);
  (0, $337b884510726a0d$export$14c98a7594375490)();
  return {
    dialogProps: {
      ...(0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
        labelable: true
      }),
      role,
      tabIndex: -1,
      "aria-labelledby": props["aria-labelledby"] || titleId,
      // Prevent blur events from reaching useOverlay, which may cause
      // popovers to close. Since focus is contained within the dialog,
      // we don't want this to occur due to the above useEffect.
      onBlur: (e6) => {
        if (isRefocusing.current)
          e6.stopPropagation();
      }
    },
    titleProps: {
      id: titleId
    }
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-dialog.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime());
var DialogContext = import_react29.default.createContext(null);
var localizedMessages2 = {
  "ar-AE": {
    alert: "تنبيه",
    dismiss: "تجاهل"
  },
  "bg-BG": {
    alert: "Сигнал",
    dismiss: "Отхвърляне"
  },
  "cs-CZ": {
    alert: "Výstraha",
    dismiss: "Odstranit"
  },
  "da-DK": {
    alert: "Advarsel",
    dismiss: "Luk"
  },
  "de-DE": {
    alert: "Warnhinweis",
    dismiss: "Schließen"
  },
  "el-GR": {
    alert: "Ειδοποίηση",
    dismiss: "Απόρριψη"
  },
  "en-US": {
    alert: "Alert",
    dismiss: "Dismiss"
  },
  "es-ES": {
    alert: "Alerta",
    dismiss: "Descartar"
  },
  "et-EE": {
    alert: "Teade",
    dismiss: "Lõpeta"
  },
  "fi-FI": {
    alert: "Hälytys",
    dismiss: "Hylkää"
  },
  "fr-FR": {
    alert: "Alerte",
    dismiss: "Rejeter"
  },
  "he-IL": {
    alert: "התראה",
    dismiss: "התעלם"
  },
  "hr-HR": {
    alert: "Upozorenje",
    dismiss: "Odbaci"
  },
  "hu-HU": {
    alert: "Figyelmeztetés",
    dismiss: "Elutasítás"
  },
  "it-IT": {
    alert: "Avviso",
    dismiss: "Ignora"
  },
  "ja-JP": {
    alert: "アラート",
    dismiss: "閉じる"
  },
  "ko-KR": {
    alert: "경고",
    dismiss: "무시"
  },
  "lt-LT": {
    alert: "Įspėjimas",
    dismiss: "Atmesti"
  },
  "lv-LV": {
    alert: "Brīdinājums",
    dismiss: "Nerādīt"
  },
  "nb-NO": {
    alert: "Varsel",
    dismiss: "Lukk"
  },
  "nl-NL": {
    alert: "Melding",
    dismiss: "Negeren"
  },
  "pl-PL": {
    alert: "Ostrzeżenie",
    dismiss: "Zignoruj"
  },
  "pt-BR": {
    alert: "Alerta",
    dismiss: "Descartar"
  },
  "pt-PT": {
    alert: "Alerta",
    dismiss: "Dispensar"
  },
  "ro-RO": {
    alert: "Alertă",
    dismiss: "Revocare"
  },
  "ru-RU": {
    alert: "Предупреждение",
    dismiss: "Пропустить"
  },
  "sk-SK": {
    alert: "Upozornenie",
    dismiss: "Zrušiť"
  },
  "sl-SI": {
    alert: "Opozorilo",
    dismiss: "Opusti"
  },
  "sr-SP": {
    alert: "Upozorenje",
    dismiss: "Odbaci"
  },
  "sv-SE": {
    alert: "Varning",
    dismiss: "Avvisa"
  },
  "tr-TR": {
    alert: "Uyarı",
    dismiss: "Kapat"
  },
  "uk-UA": {
    alert: "Сигнал тривоги",
    dismiss: "Скасувати"
  },
  "zh-CN": {
    alert: "警报",
    dismiss: "取消"
  },
  "zh-T": {
    alert: "警示",
    dismiss: "關閉"
  }
};
var dialogClassList = new ClassList("Dialog", ["root", "grid", "heading", "header", "footer", "button-group"]);
var Dialog = (0, import_react29.forwardRef)(function Dialog2(props, forwardedRef) {
  let {
    type: type2 = "modal",
    ...contextProps
  } = (0, import_react29.useContext)(DialogContext) || {};
  let {
    children,
    isDismissable = contextProps.isDismissable,
    onDismiss = contextProps.onClose,
    size: size3
  } = props;
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages2);
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let gridRef = (0, import_react29.useRef)(null);
  let {
    dialogProps,
    titleProps
  } = $40df3f8667284809$export$d55e7ee900f34e93($3ef42575df84b30b$export$9d1611c77c2fe928(contextProps, props), domRef);
  const headingSize = "regular";
  let hasHeading = useHasChild(dialogClassList.selector("heading"), gridRef);
  let hasHeader = useHasChild(dialogClassList.selector("header"), gridRef);
  let hasFooter = useHasChild(dialogClassList.selector("footer"), gridRef);
  let hasButtonGroup = useHasChild(dialogClassList.selector("button-group"), gridRef);
  let slots = (0, import_react29.useMemo)(() => ({
    heading: {
      ...toDataAttributes({
        hasHeader
      }),
      UNSAFE_className: classNames(dialogClassList.element("heading"), getHeadingStyles()),
      elementType: "h2",
      size: headingSize,
      // FIXME: declared as const—shouldn't need this weirdness.
      ...titleProps
    },
    header: {
      // ...toDataAttributes({ hasHeading }),
      UNSAFE_className: classNames(dialogClassList.element("header"), getHeaderStyles())
    },
    content: {
      ...toDataAttributes({
        hasHeader: hasHeader || hasHeading || void 0,
        hasFooter: hasFooter || hasButtonGroup && type2 !== "fullscreen" || void 0
      }),
      UNSAFE_className: getContentStyles()
    },
    footer: {
      UNSAFE_className: classNames(dialogClassList.element("footer"), getFooterStyles())
    },
    buttonGroup: {
      ...toDataAttributes({
        hasFooter
      }),
      UNSAFE_className: classNames(dialogClassList.element("button-group"), getButtonGroupStyles()),
      align: "end"
    }
  }), [hasButtonGroup, hasFooter, hasHeader, hasHeading, headingSize, titleProps, type2]);
  const sizeVariant = getSizeVariant(type2, size3);
  const dialogStyleProps = useDialogStyleProps(props, sizeVariant);
  const gridStyleProps2 = useGridStyleProps2({
    isDismissable,
    size: sizeVariant
  });
  return (0, import_jsx_runtime14.jsx)("section", {
    ...dialogStyleProps,
    ...dialogProps,
    ref: domRef,
    children: (0, import_jsx_runtime14.jsxs)(Grid, {
      ref: gridRef,
      ...gridStyleProps2,
      children: [(0, import_jsx_runtime14.jsx)(SlotProvider, {
        slots,
        children
      }), isDismissable && (0, import_jsx_runtime14.jsx)(ActionButton, {
        prominence: "low",
        "aria-label": stringFormatter.format("dismiss"),
        onPress: onDismiss,
        gridArea: "closeButton",
        UNSAFE_className: css({
          placeSelf: "flex-start end",
          paddingInline: 0,
          marginBlock: `calc((${tokenSchema.size.element.regular} - ${tokenSchema.typography.heading[headingSize].capheight}) / 2 * -1)`,
          marginInlineEnd: `calc(${tokenSchema.size.space.medium} * -1)`,
          marginInlineStart: tokenSchema.size.space.regular
        }),
        children: (0, import_jsx_runtime14.jsx)(Icon, {
          src: xIcon,
          size: "medium"
        })
      })]
    })
  });
});
function getSizeVariant(type2, size3) {
  if (type2 === "fullscreen") {
    return "fullscreen";
  }
  if (type2 === "popover") {
    return size3 || "xsmall";
  }
  return size3 || "medium";
}
function useDialogStyleProps(props, sizeVariant) {
  let styleProps = useStyleProps(props);
  return {
    ...toDataAttributes({
      size: sizeVariant
    }),
    ...styleProps,
    className: classNames(dialogClassList.element("root"), css({
      display: "flex",
      maxHeight: "inherit",
      maxWidth: "100%",
      outline: 0,
      width: "var(--dialog-width)",
      "--dialog-width": "fit-content",
      '&[data-size="xsmall"]': {
        "--dialog-width": tokenSchema.size.dialog.xsmall
      },
      '&[data-size="small"]': {
        "--dialog-width": tokenSchema.size.dialog.small
      },
      '&[data-size="medium"]': {
        "--dialog-width": tokenSchema.size.dialog.medium
      },
      '&[data-size="large"]': {
        "--dialog-width": tokenSchema.size.dialog.large
      },
      '&[data-size="fullscreen"]': {
        maxHeight: "none",
        maxWidth: "none",
        height: "100%",
        "--dialog-width": "100%"
      }
    }), styleProps.className)
  };
}
function useGridStyleProps2({
  isDismissable,
  size: size3
}) {
  let gridStyles = css({
    display: "grid",
    padding: tokenSchema.size.space.xxlarge,
    gridTemplateColumns: "auto 1fr auto",
    gridTemplateRows: "auto 1fr auto",
    gridTemplateAreas: `"heading header header"
      "content content content"
      "footer footer buttonGroup"`,
    width: "100%",
    "&[data-dismissable]": {
      gridTemplateColumns: "auto 1fr auto minmax(0, auto)",
      gridTemplateAreas: `"heading header header closeButton"
        "content content content content"
        "footer footer footer footer"`,
      // slot styles
      [dialogClassList.selector("button-group")]: {
        display: "none"
      }
    },
    // MOBILE SPECIFIC
    [breakpointQueries$1.below.tablet]: {
      padding: tokenSchema.size.space.xlarge,
      gridTemplateRows: "auto auto 1fr auto",
      gridTemplateAreas: `"heading heading heading"
      "header header header"
        "content content content"
        "footer footer buttonGroup"`,
      "&[data-dismissable]": {
        gridTemplateAreas: `"heading heading closeButton"
          "header header header"
            "content content content"
            "footer footer buttonGroup"`
      }
    },
    // TABLET & ABOVE
    [breakpointQueries$1.above.mobile]: {
      '&[data-size="fullscreen"]': {
        gridTemplateAreas: `"heading header buttonGroup"
          "content content content"
          "footer footer footer"`
      }
    }
  });
  return {
    ...toDataAttributes({
      dismissable: isDismissable || void 0,
      size: size3
    }),
    UNSAFE_className: classNames(dialogClassList.element("grid"), gridStyles)
  };
}
function getHeadingStyles() {
  return css({
    alignSelf: "center",
    gridArea: "heading",
    paddingBottom: tokenSchema.size.space.large,
    [breakpointQueries$1.above.mobile]: {
      paddingBottom: tokenSchema.size.space.xlarge
    },
    "&[data-has-header=false]": {
      gridArea: "heading-start / heading-start / header-end / header-end"
    }
  });
}
function getHeaderStyles() {
  return css({
    alignItems: "center",
    boxSizing: "border-box",
    display: "flex",
    gridArea: "header",
    minWidth: "fit-content",
    outline: 0,
    paddingBottom: tokenSchema.size.space.large,
    [breakpointQueries$1.above.mobile]: {
      justifyContent: "flex-end",
      paddingBottom: tokenSchema.size.space.xlarge
    }
  });
}
function getContentStyles() {
  return css({
    gridArea: "content",
    overflowX: "hidden",
    overflowY: "auto",
    WebkitOverflowScrolling: "touch",
    // fixes two issues:
    // - focus rings get clipped by overflow: auto
    // - trimmed text (capsize) creates unwanted scrollbars
    padding: tokenSchema.size.space.regular,
    margin: `calc(${tokenSchema.size.space.regular} * -1)`
  });
}
function getButtonGroupStyles() {
  return css({
    gridArea: "buttonGroup",
    minWidth: 0,
    marginInlineStart: tokenSchema.size.space.regular,
    paddingTop: tokenSchema.size.space.large,
    [breakpointQueries$1.above.mobile]: {
      paddingTop: tokenSchema.size.space.xlarge
    },
    [`${dialogClassList.selector("root")}:not([data-size=fullscreen]) &[data-has-footer=false]`]: {
      gridArea: "footer-start / footer-start / buttonGroup-end / buttonGroup-end"
    },
    // correct consumer error; hide the button group when the dialog is dismissable
    [`${dialogClassList.selector("root")}[data-dismissable] &`]: {
      display: "none"
    }
  });
}
function getFooterStyles() {
  return css({
    alignItems: "center",
    display: "flex",
    flexWrap: "wrap",
    gridArea: "footer",
    minWidth: 0,
    paddingTop: tokenSchema.size.space.large,
    [breakpointQueries$1.above.mobile]: {
      paddingTop: tokenSchema.size.space.xlarge
    }
  });
}
var AlertDialog = (0, import_react29.forwardRef)(function AlertDialog2(props, forwardedRef) {
  let {
    onClose = () => {
    }
  } = (0, import_react29.useContext)(DialogContext) || {};
  let {
    autoFocusButton,
    cancelLabel,
    children,
    isPrimaryActionDisabled,
    isSecondaryActionDisabled,
    onCancel = () => {
    },
    onPrimaryAction = () => {
    },
    onSecondaryAction = () => {
    },
    primaryActionLabel,
    secondaryActionLabel,
    title,
    tone,
    ...otherProps
  } = props;
  let styleProps = useStyleProps(otherProps);
  return (0, import_jsx_runtime14.jsxs)(Dialog, {
    role: "alertdialog",
    ref: forwardedRef,
    size: "small",
    UNSAFE_className: styleProps.className,
    UNSAFE_style: styleProps.style,
    children: [(0, import_jsx_runtime14.jsx)(Heading, {
      children: title
    }), (0, import_jsx_runtime14.jsx)(Content, {
      children: isReactText(children) ? (0, import_jsx_runtime14.jsx)(Text2, {
        children
      }) : children
    }), (0, import_jsx_runtime14.jsxs)(ButtonGroup, {
      align: "end",
      children: [cancelLabel && (0, import_jsx_runtime14.jsx)(Button, {
        onPress: () => $ff5963eb1fccf552$export$e08e3b67e392101e(onClose(), onCancel()),
        autoFocus: autoFocusButton === "cancel",
        prominence: secondaryActionLabel ? "low" : void 0,
        children: cancelLabel
      }), secondaryActionLabel && (0, import_jsx_runtime14.jsx)(Button, {
        onPress: () => $ff5963eb1fccf552$export$e08e3b67e392101e(onClose(), onSecondaryAction()),
        autoFocus: autoFocusButton === "secondary",
        isDisabled: isSecondaryActionDisabled,
        children: secondaryActionLabel
      }), (0, import_jsx_runtime14.jsx)(Button, {
        prominence: "high",
        tone,
        onPress: () => $ff5963eb1fccf552$export$e08e3b67e392101e(onClose(), onPrimaryAction()),
        isDisabled: isPrimaryActionDisabled,
        autoFocus: autoFocusButton === "primary",
        children: primaryActionLabel
      })]
    })]
  });
});
function DialogContainer(props) {
  let {
    children,
    type: type2 = "modal",
    onDismiss,
    isDismissable,
    isKeyboardDismissDisabled
  } = props;
  let childArray = import_react29.default.Children.toArray(children);
  if (childArray.length > 1) {
    throw new Error("Only a single child can be passed to DialogContainer.");
  }
  let lastChild = (0, import_react29.useRef)(null);
  let child = import_react29.default.isValidElement(childArray[0]) ? childArray[0] : null;
  if (child) {
    lastChild.current = child;
  }
  let context = {
    type: type2,
    onClose: onDismiss,
    isDismissable
  };
  let state = $fc909762b330b746$export$61c6a8c84e605fb6({
    isOpen: !!child,
    onOpenChange: (isOpen) => {
      if (!isOpen) {
        onDismiss();
      }
    }
  });
  return (0, import_jsx_runtime14.jsx)(Modal, {
    state,
    type: type2,
    isDismissable,
    isKeyboardDismissDisabled,
    children: (0, import_jsx_runtime14.jsx)(DialogContext.Provider, {
      value: context,
      children: lastChild.current
    })
  });
}
function useDialogContainer() {
  const context = (0, import_react29.useContext)(DialogContext);
  assert(!!context, "Cannot call `useDialogContext` outside of `<DialogTrigger>` or `<DialogContainer>`.");
  return {
    type: context.type,
    dismiss() {
      context.onClose();
    }
  };
}
function DialogTrigger(props) {
  let {
    children,
    type: type2 = "modal",
    mobileType = type2 === "popover" ? "modal" : type2,
    hideArrow,
    targetRef,
    isDismissable,
    isKeyboardDismissDisabled,
    ...positionProps
  } = props;
  if (!Array.isArray(children) || children.length > 2) {
    throw new Error("DialogTrigger must have exactly 2 children");
  }
  let [trigger2, content3] = children;
  let isMobile = useMediaQuery(breakpointQueries$1.below.tablet);
  if (isMobile) {
    if (type2 !== "modal" && mobileType === "modal") {
      isDismissable = true;
    }
    type2 = mobileType;
  }
  let state = $fc909762b330b746$export$61c6a8c84e605fb6(props);
  let wasOpen = (0, import_react29.useRef)(false);
  wasOpen.current = state.isOpen;
  let isExiting = (0, import_react29.useRef)(false);
  let onExiting = () => isExiting.current = true;
  let onExited = () => isExiting.current = false;
  (0, import_react29.useEffect)(() => {
    return () => {
      if ((wasOpen.current || isExiting.current) && type2 !== "popover" && type2 !== "tray") {
        console.warn("A DialogTrigger unmounted while open. This is likely due to being placed within a trigger that unmounts or inside a conditional. Consider using a DialogContainer instead.");
      }
    };
  }, []);
  if (type2 === "popover") {
    return (0, import_jsx_runtime14.jsx)(PopoverTrigger, {
      ...positionProps,
      state,
      targetRef,
      trigger: trigger2,
      content: content3,
      isKeyboardDismissDisabled,
      hideArrow
    });
  }
  let renderOverlay = () => {
    switch (type2) {
      case "fullscreen":
      case "modal":
        return (0, import_jsx_runtime14.jsx)(Modal, {
          state,
          isDismissable: type2 === "modal" ? isDismissable : false,
          type: type2,
          isKeyboardDismissDisabled,
          onExiting,
          onExited,
          children: typeof content3 === "function" ? content3(state.close) : content3
        });
      case "tray":
        return (0, import_jsx_runtime14.jsx)(Tray, {
          state,
          isKeyboardDismissDisabled,
          children: typeof content3 === "function" ? content3(state.close) : content3
        });
    }
    assertNever(type2);
  };
  return (0, import_jsx_runtime14.jsx)(DialogTriggerBase, {
    type: type2,
    state,
    isDismissable,
    trigger: trigger2,
    overlay: renderOverlay()
  });
}
DialogTrigger.getCollectionNode = function* (props) {
  let [trigger2] = import_react29.Children.toArray(props.children);
  let [, content3] = props.children;
  yield {
    element: trigger2,
    wrapper: (element4) => (0, import_jsx_runtime14.jsxs)(DialogTrigger, {
      ...props,
      children: [element4, content3]
    }, element4.key)
  };
};
var _DialogTrigger = DialogTrigger;
function PopoverTrigger({
  state,
  targetRef,
  trigger: trigger2,
  content: content3,
  hideArrow,
  ...props
}) {
  let triggerRef = (0, import_react29.useRef)(null);
  let {
    triggerProps,
    overlayProps
  } = $628037886ba31236$export$f9d5c8beee7d008d({
    type: "dialog"
  }, state, triggerRef);
  let triggerPropsWithRef = {
    ...triggerProps,
    ref: targetRef ? void 0 : triggerRef
  };
  let overlay = (0, import_jsx_runtime14.jsx)(Popover, {
    ...props,
    hideArrow,
    triggerRef: targetRef || triggerRef,
    state,
    children: typeof content3 === "function" ? content3(state.close) : content3
  });
  return (0, import_jsx_runtime14.jsx)(DialogTriggerBase, {
    type: "popover",
    state,
    triggerProps: triggerPropsWithRef,
    dialogProps: overlayProps,
    trigger: trigger2,
    overlay
  });
}
function DialogTriggerBase({
  type: type2,
  state,
  isDismissable,
  dialogProps = {},
  triggerProps = {},
  overlay,
  trigger: trigger2
}) {
  let context = {
    type: type2,
    onClose: state.close,
    isDismissable,
    ...dialogProps
  };
  return (0, import_jsx_runtime14.jsxs)(import_react29.Fragment, {
    children: [(0, import_jsx_runtime14.jsx)($f1ab8c75478c6f73$export$3351871ee4b288b8, {
      ...$3ef42575df84b30b$export$9d1611c77c2fe928(triggerProps, {
        onPress: state.open
      }),
      isPressed: state.isOpen && type2 !== "modal" && type2 !== "fullscreen",
      children: trigger2
    }), (0, import_jsx_runtime14.jsx)(DialogContext.Provider, {
      value: context,
      children: overlay
    })]
  });
}

// node_modules/@react-aria/dnd/dist/ar-AE.mjs
var $7dfcac1a0c98c789$exports = {};
$7dfcac1a0c98c789$exports = {
  "dragDescriptionKeyboard": `اضغط Enter لبدء السحب.`,
  "dragDescriptionKeyboardAlt": `اضغط على Alt + Enter لبدء السحب.`,
  "dragDescriptionLongPress": `اضغط باستمرار لبدء السحب.`,
  "dragDescriptionTouch": `اضغط مرتين لبدء السحب.`,
  "dragDescriptionVirtual": `انقر لبدء السحب.`,
  "dragItem": (args2) => `اسحب ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `اسحب ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} عنصر محدد`,
    other: () => `${formatter.number(args2.count)} عناصر محددة`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `اضغط على Enter للسحب ${formatter.plural(args2.count, {
    one: `عدد العناصر المختارة`,
    other: `عدد العناصر المختارة`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `اضغط على مفتاحي Alt + Enter للسحب ${formatter.plural(args2.count, {
    one: `عدد العناصر المختارة`,
    other: `عدد العناصر المختارة`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `اضغط باستمرار للسحب ${formatter.plural(args2.count, {
    one: `عدد العناصر المختارة`,
    other: `عدد العناصر المختارة`
  })}.`,
  "dragStartedKeyboard": `بدأ السحب. اضغط Tab للانتقال إلى موضع الإفلات، ثم اضغط Enter للإفلات، أو اضغط Escape للإلغاء.`,
  "dragStartedTouch": `بدأ السحب. انتقل إلى موضع الإفلات، ثم اضغط مرتين للإفلات.`,
  "dragStartedVirtual": `بدأ السحب. انتقل إلى مكان الإفلات، ثم انقر أو اضغط Enter للإفلات.`,
  "dropCanceled": `تم إلغاء الإفلات.`,
  "dropComplete": `اكتمل الإفلات.`,
  "dropDescriptionKeyboard": `اضغط Enter للإفلات. اضغط Escape لإلغاء السحب.`,
  "dropDescriptionTouch": `اضغط مرتين للإفلات.`,
  "dropDescriptionVirtual": `انقر للإفلات.`,
  "dropIndicator": `مؤشر الإفلات`,
  "dropOnItem": (args2) => `إفلات ${args2.itemText}`,
  "dropOnRoot": `الإفلات`,
  "endDragKeyboard": `السحب. اضغط Enter لإلغاء السحب.`,
  "endDragTouch": `السحب. اضغط مرتين لإلغاء السحب.`,
  "endDragVirtual": `السحب. انقر لإلغاء السحب.`,
  "insertAfter": (args2) => `أدخل بعد ${args2.itemText}`,
  "insertBefore": (args2) => `أدخل قبل ${args2.itemText}`,
  "insertBetween": (args2) => `أدخل بين ${args2.beforeItemText} و ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/bg-BG.mjs
var $f311c26671219eca$exports = {};
$f311c26671219eca$exports = {
  "dragDescriptionKeyboard": `Натиснете „Enter“, за да започнете да плъзгате.`,
  "dragDescriptionKeyboardAlt": `Натиснете Alt + Enter, за да започнете да плъзгате.`,
  "dragDescriptionLongPress": `Натиснете продължително, за да започнете да плъзгате.`,
  "dragDescriptionTouch": `Натиснете двукратно, за да започнете да плъзгате.`,
  "dragDescriptionVirtual": `Щракнете, за да започнете да плъзгате.`,
  "dragItem": (args2) => `Плъзни ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Плъзни ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} избран елемент`,
    other: () => `${formatter.number(args2.count)} избрани елемента`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Натиснете Enter, за да плъзнете ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} избран елемент`,
    other: () => `${formatter.number(args2.count)} избрани елементи`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Натиснете Alt и Enter, за да плъзнете ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} избран елемент`,
    other: () => `${formatter.number(args2.count)} избрани елементи`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Натиснете продължително, за да плъзнете ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} избран елемент`,
    other: () => `${formatter.number(args2.count)} избрани елементи`
  })}.`,
  "dragStartedKeyboard": `Започна плъзгане. Натиснете „Tab“, за да се придвижите до целта, след което натиснете „Enter“ за пускане или натиснете „Escape“ за отмяна.`,
  "dragStartedTouch": `Започна плъзгане. Придвижете се до целта, след което натиснете двукратно, за да пуснете.`,
  "dragStartedVirtual": `Започна плъзгане. Придвижете се до целта, след което щракнете или натиснете „Enter“ за пускане.`,
  "dropCanceled": `Пускането е отменено.`,
  "dropComplete": `Пускането е завършено.`,
  "dropDescriptionKeyboard": `Натиснете „Enter“ за пускане. Натиснете „Escape“ за отмяна на плъзгането.`,
  "dropDescriptionTouch": `Натиснете двукратно за пускане.`,
  "dropDescriptionVirtual": `Щракнете за пускане.`,
  "dropIndicator": `индикатор за пускане`,
  "dropOnItem": (args2) => `Пусни върху ${args2.itemText}`,
  "dropOnRoot": `Пусни върху`,
  "endDragKeyboard": `Плъзгане. Натиснете „Enter“ за отмяна на плъзгането.`,
  "endDragTouch": `Плъзгане. Натиснете двукратно за отмяна на плъзгането.`,
  "endDragVirtual": `Плъзгане. Щракнете за отмяна.`,
  "insertAfter": (args2) => `Вмъкни след ${args2.itemText}`,
  "insertBefore": (args2) => `Вмъкни преди ${args2.itemText}`,
  "insertBetween": (args2) => `Вмъкни между ${args2.beforeItemText} и ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/cs-CZ.mjs
var $1aa4ade186550f72$exports = {};
$1aa4ade186550f72$exports = {
  "dragDescriptionKeyboard": `Stisknutím klávesy Enter začnete s přetahováním.`,
  "dragDescriptionKeyboardAlt": `Stisknutím Alt + Enter zahájíte přetahování.`,
  "dragDescriptionLongPress": `Dlouhým stisknutím zahájíte přetahování.`,
  "dragDescriptionTouch": `Poklepáním začnete s přetahováním.`,
  "dragDescriptionVirtual": `Kliknutím začnete s přetahováním.`,
  "dragItem": (args2) => `Přetáhnout ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Přetáhnout ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} vybranou položku`,
    few: () => `${formatter.number(args2.count)} vybrané položky`,
    other: () => `${formatter.number(args2.count)} vybraných položek`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Stisknutím klávesy Enter přetáhněte ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} vybranou položku`,
    other: () => `${formatter.number(args2.count)} vybrané položky`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Stisknutím Alt + Enter přetáhněte ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} vybranou položku`,
    other: () => `${formatter.number(args2.count)} vybrané položky`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Dlouhým stisknutím přetáhnete ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} vybranou položku`,
    other: () => `${formatter.number(args2.count)} vybrané položky`
  })}.`,
  "dragStartedKeyboard": `Začněte s přetahováním. Po stisknutí klávesy Tab najděte požadovaný cíl a stisknutím klávesy Enter přetažení dokončete nebo stisknutím klávesy Esc akci zrušte.`,
  "dragStartedTouch": `Začněte s přetahováním. Najděte požadovaný cíl a poklepáním přetažení dokončete.`,
  "dragStartedVirtual": `Začněte s přetahováním. Najděte požadovaný cíl a kliknutím nebo stisknutím klávesy Enter přetažení dokončete.`,
  "dropCanceled": `Přetažení bylo zrušeno.`,
  "dropComplete": `Přetažení bylo dokončeno.`,
  "dropDescriptionKeyboard": `Stisknutím klávesy Enter přetažení dokončete nebo stisknutím klávesy Esc akci zrušte.`,
  "dropDescriptionTouch": `Poklepáním přetažení dokončete.`,
  "dropDescriptionVirtual": `Kliknutím objekt přetáhněte.`,
  "dropIndicator": `indikátor přetažení`,
  "dropOnItem": (args2) => `Přetáhnout na ${args2.itemText}`,
  "dropOnRoot": `Přetáhnout na`,
  "endDragKeyboard": `Probíhá přetahování. Stisknutím klávesy Enter přetažení zrušíte.`,
  "endDragTouch": `Probíhá přetahování. Poklepáním přetažení zrušíte.`,
  "endDragVirtual": `Probíhá přetahování. Kliknutím přetažení zrušíte.`,
  "insertAfter": (args2) => `Vložit za ${args2.itemText}`,
  "insertBefore": (args2) => `Vložit před ${args2.itemText}`,
  "insertBetween": (args2) => `Vložit mezi ${args2.beforeItemText} a ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/da-DK.mjs
var $b6b0ea1b94a7633c$exports = {};
$b6b0ea1b94a7633c$exports = {
  "dragDescriptionKeyboard": `Tryk på Enter for at starte med at trække.`,
  "dragDescriptionKeyboardAlt": `Tryk på Alt + Enter for at starte med at trække.`,
  "dragDescriptionLongPress": `Tryk længe for at starte med at trække.`,
  "dragDescriptionTouch": `Dobbelttryk for at starte med at trække.`,
  "dragDescriptionVirtual": `Klik for at starte med at trække.`,
  "dragItem": (args2) => `Træk ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Træk ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valgt element`,
    other: () => `${formatter.number(args2.count)} valgte elementer`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Tryk på Enter for at trække ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valgte element`,
    other: () => `${formatter.number(args2.count)} valgte elementer`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Tryk på Alt + Enter for at trække ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valgte element`,
    other: () => `${formatter.number(args2.count)} valgte elementer`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Tryk længe for at trække ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valgte element`,
    other: () => `${formatter.number(args2.count)} valgte elementer`
  })}.`,
  "dragStartedKeyboard": `Startet med at trække. Tryk på Tab for at gå til et slip-mål, tryk derefter på Enter for at slippe, eller tryk på Escape for at annullere.`,
  "dragStartedTouch": `Startet med at trække. Gå til et slip-mål, og dobbelttryk derefter for at slippe.`,
  "dragStartedVirtual": `Startet med at trække. Gå til et slip-mål, og klik eller tryk derefter på enter for at slippe.`,
  "dropCanceled": `Slip annulleret.`,
  "dropComplete": `Slip fuldført.`,
  "dropDescriptionKeyboard": `Tryk på Enter for at slippe. Tryk på Escape for at annullere trækning.`,
  "dropDescriptionTouch": `Dobbelttryk for at slippe.`,
  "dropDescriptionVirtual": `Klik for at slippe.`,
  "dropIndicator": `slip-indikator`,
  "dropOnItem": (args2) => `Slip på ${args2.itemText}`,
  "dropOnRoot": `Slip på`,
  "endDragKeyboard": `Trækning. Tryk på enter for at annullere træk.`,
  "endDragTouch": `Trækning. Dobbelttryk for at annullere træk.`,
  "endDragVirtual": `Trækning. Klik for at annullere trækning.`,
  "insertAfter": (args2) => `Indsæt efter ${args2.itemText}`,
  "insertBefore": (args2) => `Indsæt før ${args2.itemText}`,
  "insertBetween": (args2) => `Indsæt mellem ${args2.beforeItemText} og ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/de-DE.mjs
var $d10e4f47c744ad52$exports = {};
$d10e4f47c744ad52$exports = {
  "dragDescriptionKeyboard": `Drücken Sie die Eingabetaste, um den Ziehvorgang zu starten.`,
  "dragDescriptionKeyboardAlt": `Alt + Eingabe drücken, um den Ziehvorgang zu starten.`,
  "dragDescriptionLongPress": `Lang drücken, um mit dem Ziehen zu beginnen.`,
  "dragDescriptionTouch": `Tippen Sie doppelt, um den Ziehvorgang zu starten.`,
  "dragDescriptionVirtual": `Zum Starten des Ziehvorgangs klicken.`,
  "dragItem": (args2) => `${args2.itemText} ziehen`,
  "dragSelectedItems": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} ausgewähltes Objekt`,
    other: () => `${formatter.number(args2.count)} ausgewählte Objekte`
  })} ziehen`,
  "dragSelectedKeyboard": (args2, formatter) => `Eingabetaste drücken, um ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} ausgewähltes Element`,
    other: () => `${formatter.number(args2.count)} ausgewählte Elemente`
  })} zu ziehen.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Alt + Eingabetaste drücken, um ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} ausgewähltes Element`,
    other: () => `${formatter.number(args2.count)} ausgewählte Elemente`
  })} zu ziehen.`,
  "dragSelectedLongPress": (args2, formatter) => `Lang drücken, um ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} ausgewähltes Element`,
    other: () => `${formatter.number(args2.count)} ausgewählte Elemente`
  })} zu ziehen.`,
  "dragStartedKeyboard": `Ziehvorgang gestartet. Drücken Sie die Tabulatortaste, um zu einem Ablegeziel zu navigieren und drücken Sie dann die Eingabetaste, um das Objekt abzulegen, oder Escape, um den Vorgang abzubrechen.`,
  "dragStartedTouch": `Ziehvorgang gestartet. Navigieren Sie zu einem Ablegeziel und tippen Sie doppelt, um das Objekt abzulegen.`,
  "dragStartedVirtual": `Ziehvorgang gestartet. Navigieren Sie zu einem Ablegeziel und klicken Sie oder drücken Sie die Eingabetaste, um das Objekt abzulegen.`,
  "dropCanceled": `Ablegen abgebrochen.`,
  "dropComplete": `Ablegen abgeschlossen.`,
  "dropDescriptionKeyboard": `Drücken Sie die Eingabetaste, um das Objekt abzulegen. Drücken Sie Escape, um den Vorgang abzubrechen.`,
  "dropDescriptionTouch": `Tippen Sie doppelt, um das Objekt abzulegen.`,
  "dropDescriptionVirtual": `Zum Ablegen klicken.`,
  "dropIndicator": `Ablegeanzeiger`,
  "dropOnItem": (args2) => `Auf ${args2.itemText} ablegen`,
  "dropOnRoot": `Ablegen auf`,
  "endDragKeyboard": `Ziehvorgang läuft. Drücken Sie die Eingabetaste, um den Vorgang abzubrechen.`,
  "endDragTouch": `Ziehvorgang läuft. Tippen Sie doppelt, um den Vorgang abzubrechen.`,
  "endDragVirtual": `Ziehvorgang läuft. Klicken Sie, um den Vorgang abzubrechen.`,
  "insertAfter": (args2) => `Nach ${args2.itemText} einfügen`,
  "insertBefore": (args2) => `Vor ${args2.itemText} einfügen`,
  "insertBetween": (args2) => `Zwischen ${args2.beforeItemText} und ${args2.afterItemText} einfügen`
};

// node_modules/@react-aria/dnd/dist/el-GR.mjs
var $b3d2bb9abce688ab$exports = {};
$b3d2bb9abce688ab$exports = {
  "dragDescriptionKeyboard": `Πατήστε Enter για έναρξη της μεταφοράς.`,
  "dragDescriptionKeyboardAlt": `Πατήστε Alt + Enter για έναρξη της μεταφοράς.`,
  "dragDescriptionLongPress": `Πατήστε παρατεταμένα για να ξεκινήσετε τη μεταφορά.`,
  "dragDescriptionTouch": `Πατήστε δύο φορές για έναρξη της μεταφοράς.`,
  "dragDescriptionVirtual": `Κάντε κλικ για να ξεκινήσετε τη μεταφορά.`,
  "dragItem": (args2) => `Μεταφορά ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Μεταφορά σε ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} επιλεγμένο στοιχείο`,
    other: () => `${formatter.number(args2.count)} επιλεγμένα στοιχεία`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Πατήστε Enter για να σύρετε ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} επιλεγμένο στοιχείο`,
    other: () => `${formatter.number(args2.count)} επιλεγμένα στοιχεία`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Πατήστε Alt + Enter για να σύρετε ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} επιλεγμένο στοιχείο`,
    other: () => `${formatter.number(args2.count)} επιλεγμένα στοιχεία`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Πατήστε παρατεταμένα για να σύρετε ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} επιλεγμένο στοιχείο`,
    other: () => `${formatter.number(args2.count)} επιλεγμένα στοιχεία`
  })}.`,
  "dragStartedKeyboard": `Η μεταφορά ξεκίνησε. Πατήστε το πλήκτρο Tab για να μεταβείτε σε έναν προορισμό απόθεσης και, στη συνέχεια, πατήστε Enter για απόθεση ή πατήστε Escape για ακύρωση.`,
  "dragStartedTouch": `Η μεταφορά ξεκίνησε. Μεταβείτε σε έναν προορισμό απόθεσης και, στη συνέχεια, πατήστε δύο φορές για απόθεση.`,
  "dragStartedVirtual": `Η μεταφορά ξεκίνησε. Μεταβείτε σε έναν προορισμό απόθεσης και, στη συνέχεια, κάντε κλικ ή πατήστε Enter για απόθεση.`,
  "dropCanceled": `Η απόθεση ακυρώθηκε.`,
  "dropComplete": `Η απόθεση ολοκληρώθηκε.`,
  "dropDescriptionKeyboard": `Πατήστε Enter για απόθεση. Πατήστε Escape για ακύρωση της μεταφοράς.`,
  "dropDescriptionTouch": `Πατήστε δύο φορές για απόθεση.`,
  "dropDescriptionVirtual": `Κάντε κλικ για απόθεση.`,
  "dropIndicator": `δείκτης απόθεσης`,
  "dropOnItem": (args2) => `Απόθεση σε ${args2.itemText}`,
  "dropOnRoot": `Απόθεση σε`,
  "endDragKeyboard": `Μεταφορά σε εξέλιξη. Πατήστε Enter για ακύρωση της μεταφοράς.`,
  "endDragTouch": `Μεταφορά σε εξέλιξη. Πατήστε δύο φορές για ακύρωση της μεταφοράς.`,
  "endDragVirtual": `Μεταφορά σε εξέλιξη. Κάντε κλικ για ακύρωση της μεταφοράς.`,
  "insertAfter": (args2) => `Εισαγωγή μετά από ${args2.itemText}`,
  "insertBefore": (args2) => `Εισαγωγή πριν από ${args2.itemText}`,
  "insertBetween": (args2) => `Εισαγωγή μεταξύ ${args2.beforeItemText} και ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/en-US.mjs
var $f9b46437e610cca1$exports = {};
$f9b46437e610cca1$exports = {
  "dragItem": (args2) => `Drag ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Drag ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} selected item`,
    other: () => `${formatter.number(args2.count)} selected items`
  })}`,
  "dragDescriptionKeyboard": `Press Enter to start dragging.`,
  "dragDescriptionKeyboardAlt": `Press Alt + Enter to start dragging.`,
  "dragDescriptionTouch": `Double tap to start dragging.`,
  "dragDescriptionVirtual": `Click to start dragging.`,
  "dragDescriptionLongPress": `Long press to start dragging.`,
  "dragSelectedKeyboard": (args2, formatter) => `Press Enter to drag ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} selected item`,
    other: () => `${formatter.number(args2.count)} selected items`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Press Alt + Enter to drag ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} selected item`,
    other: () => `${formatter.number(args2.count)} selected items`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Long press to drag ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} selected item`,
    other: () => `${formatter.number(args2.count)} selected items`
  })}.`,
  "dragStartedKeyboard": `Started dragging. Press Tab to navigate to a drop target, then press Enter to drop, or press Escape to cancel.`,
  "dragStartedTouch": `Started dragging. Navigate to a drop target, then double tap to drop.`,
  "dragStartedVirtual": `Started dragging. Navigate to a drop target, then click or press Enter to drop.`,
  "endDragKeyboard": `Dragging. Press Enter to cancel drag.`,
  "endDragTouch": `Dragging. Double tap to cancel drag.`,
  "endDragVirtual": `Dragging. Click to cancel drag.`,
  "dropDescriptionKeyboard": `Press Enter to drop. Press Escape to cancel drag.`,
  "dropDescriptionTouch": `Double tap to drop.`,
  "dropDescriptionVirtual": `Click to drop.`,
  "dropCanceled": `Drop canceled.`,
  "dropComplete": `Drop complete.`,
  "dropIndicator": `drop indicator`,
  "dropOnRoot": `Drop on`,
  "dropOnItem": (args2) => `Drop on ${args2.itemText}`,
  "insertBefore": (args2) => `Insert before ${args2.itemText}`,
  "insertBetween": (args2) => `Insert between ${args2.beforeItemText} and ${args2.afterItemText}`,
  "insertAfter": (args2) => `Insert after ${args2.itemText}`
};

// node_modules/@react-aria/dnd/dist/es-ES.mjs
var $204b5c01bd3acf26$exports = {};
$204b5c01bd3acf26$exports = {
  "dragDescriptionKeyboard": `Pulse Intro para empezar a arrastrar.`,
  "dragDescriptionKeyboardAlt": `Pulse Intro para empezar a arrastrar.`,
  "dragDescriptionLongPress": `Mantenga pulsado para comenzar a arrastrar.`,
  "dragDescriptionTouch": `Pulse dos veces para iniciar el arrastre.`,
  "dragDescriptionVirtual": `Haga clic para iniciar el arrastre.`,
  "dragItem": (args2) => `Arrastrar ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Arrastrar ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} elemento seleccionado`,
    other: () => `${formatter.number(args2.count)} elementos seleccionados`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Pulse Intro para arrastrar ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} elemento seleccionado`,
    other: () => `${formatter.number(args2.count)} elementos seleccionados`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Pulse Alt + Intro para arrastrar ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} elemento seleccionado`,
    other: () => `${formatter.number(args2.count)} elementos seleccionados`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Mantenga pulsado para arrastrar ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} elemento seleccionado`,
    other: () => `${formatter.number(args2.count)} elementos seleccionados`
  })}.`,
  "dragStartedKeyboard": `Se ha empezado a arrastrar. Pulse el tabulador para ir al público destinatario donde se vaya a colocar y, a continuación, pulse Intro para soltar, o pulse Escape para cancelar.`,
  "dragStartedTouch": `Se ha empezado a arrastrar. Vaya al público destinatario donde se vaya a colocar y, a continuación, pulse dos veces para soltar.`,
  "dragStartedVirtual": `Se ha empezado a arrastrar. Vaya al público destinatario donde se vaya a colocar y, a continuación, haga clic o pulse Intro para soltar.`,
  "dropCanceled": `Se ha cancelado la colocación.`,
  "dropComplete": `Colocación finalizada.`,
  "dropDescriptionKeyboard": `Pulse Intro para soltar. Pulse Escape para cancelar el arrastre.`,
  "dropDescriptionTouch": `Pulse dos veces para soltar.`,
  "dropDescriptionVirtual": `Haga clic para soltar.`,
  "dropIndicator": `indicador de colocación`,
  "dropOnItem": (args2) => `Soltar en ${args2.itemText}`,
  "dropOnRoot": `Soltar en`,
  "endDragKeyboard": `Arrastrando. Pulse Intro para cancelar el arrastre.`,
  "endDragTouch": `Arrastrando. Pulse dos veces para cancelar el arrastre.`,
  "endDragVirtual": `Arrastrando. Haga clic para cancelar el arrastre.`,
  "insertAfter": (args2) => `Insertar después de ${args2.itemText}`,
  "insertBefore": (args2) => `Insertar antes de ${args2.itemText}`,
  "insertBetween": (args2) => `Insertar entre ${args2.beforeItemText} y ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/et-EE.mjs
var $110bdd83348ecbc0$exports = {};
$110bdd83348ecbc0$exports = {
  "dragDescriptionKeyboard": `Lohistamise alustamiseks vajutage klahvi Enter.`,
  "dragDescriptionKeyboardAlt": `Lohistamise alustamiseks vajutage klahvikombinatsiooni Alt + Enter.`,
  "dragDescriptionLongPress": `Vajutage pikalt lohistamise alustamiseks.`,
  "dragDescriptionTouch": `Topeltpuudutage lohistamise alustamiseks.`,
  "dragDescriptionVirtual": `Klõpsake lohistamise alustamiseks.`,
  "dragItem": (args2) => `Lohista ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Lohista ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valitud üksust`,
    other: () => `${formatter.number(args2.count)} valitud üksust`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valitud üksuse`,
    other: () => `${formatter.number(args2.count)} valitud üksuse`
  })} lohistamiseks vajutage sisestusklahvi Enter.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Lohistamiseks vajutage klahvikombinatsiooni Alt + Enter ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valitud üksuse`,
    other: () => `${formatter.number(args2.count)} valitud üksuse`
  })} jaoks.`,
  "dragSelectedLongPress": (args2, formatter) => `Pikk vajutus ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valitud üksuse`,
    other: () => `${formatter.number(args2.count)} valitud üksuse`
  })} lohistamiseks.`,
  "dragStartedKeyboard": `Alustati lohistamist. Kukutamise sihtmärgi juurde navigeerimiseks vajutage klahvi Tab, seejärel vajutage kukutamiseks klahvi Enter või loobumiseks klahvi Escape.`,
  "dragStartedTouch": `Alustati lohistamist. Navigeerige kukutamise sihtmärgi juurde ja topeltpuudutage kukutamiseks.`,
  "dragStartedVirtual": `Alustati lohistamist. Navigeerige kukutamise sihtmärgi juurde ja kukutamiseks klõpsake või vajutage klahvi Enter.`,
  "dropCanceled": `Lohistamisest loobuti.`,
  "dropComplete": `Lohistamine on tehtud.`,
  "dropDescriptionKeyboard": `Kukutamiseks vajutage klahvi Enter. Lohistamisest loobumiseks vajutage klahvi Escape.`,
  "dropDescriptionTouch": `Kukutamiseks topeltpuudutage.`,
  "dropDescriptionVirtual": `Kukutamiseks klõpsake.`,
  "dropIndicator": `lohistamise indikaator`,
  "dropOnItem": (args2) => `Kukuta asukohta ${args2.itemText}`,
  "dropOnRoot": `Kukuta asukohta`,
  "endDragKeyboard": `Lohistamine. Lohistamisest loobumiseks vajutage klahvi Enter.`,
  "endDragTouch": `Lohistamine. Lohistamisest loobumiseks topeltpuudutage.`,
  "endDragVirtual": `Lohistamine. Lohistamisest loobumiseks klõpsake.`,
  "insertAfter": (args2) => `Sisesta ${args2.itemText} järele`,
  "insertBefore": (args2) => `Sisesta ${args2.itemText} ette`,
  "insertBetween": (args2) => `Sisesta ${args2.beforeItemText} ja ${args2.afterItemText} vahele`
};

// node_modules/@react-aria/dnd/dist/fi-FI.mjs
var $87d3ccd5e347c7cc$exports = {};
$87d3ccd5e347c7cc$exports = {
  "dragDescriptionKeyboard": `Aloita vetäminen painamalla Enter-näppäintä.`,
  "dragDescriptionKeyboardAlt": `Aloita vetäminen painamalla Alt + Enter -näppäinyhdistelmää.`,
  "dragDescriptionLongPress": `Aloita vetäminen pitämällä painettuna.`,
  "dragDescriptionTouch": `Aloita vetäminen kaksoisnapauttamalla.`,
  "dragDescriptionVirtual": `Aloita vetäminen napsauttamalla.`,
  "dragItem": (args2) => `Vedä kohdetta ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Vedä ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valittua kohdetta`,
    other: () => `${formatter.number(args2.count)} valittua kohdetta`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Vedä painamalla Enter ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valittu kohde`,
    other: () => `${formatter.number(args2.count)} valittua kohdetta`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Vedä painamalla Alt + Enter ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valittu kohde`,
    other: () => `${formatter.number(args2.count)} valittua kohdetta`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Vedä pitämällä painettuna ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valittu kohde`,
    other: () => `${formatter.number(args2.count)} valittua kohdetta`
  })}.`,
  "dragStartedKeyboard": `Vetäminen aloitettu. Siirry pudotuskohteeseen painamalla sarkainnäppäintä ja sitten pudota painamalla Enter-näppäintä tai peruuta painamalla Escape-näppäintä.`,
  "dragStartedTouch": `Vetäminen aloitettu. Siirry pudotuskohteeseen ja pudota kaksoisnapauttamalla.`,
  "dragStartedVirtual": `Vetäminen aloitettu. Siirry pudotuskohteeseen ja pudota napsauttamalla tai painamalla Enter-näppäintä.`,
  "dropCanceled": `Pudotus peruutettu.`,
  "dropComplete": `Pudotus suoritettu.`,
  "dropDescriptionKeyboard": `Pudota painamalla Enter-näppäintä. Peruuta vetäminen painamalla Escape-näppäintä.`,
  "dropDescriptionTouch": `Pudota kaksoisnapauttamalla.`,
  "dropDescriptionVirtual": `Pudota napsauttamalla.`,
  "dropIndicator": `pudotuksen ilmaisin`,
  "dropOnItem": (args2) => `Pudota kohteeseen ${args2.itemText}`,
  "dropOnRoot": `Pudota kohteeseen`,
  "endDragKeyboard": `Vedetään. Peruuta vetäminen painamalla Enter-näppäintä.`,
  "endDragTouch": `Vedetään. Peruuta vetäminen kaksoisnapauttamalla.`,
  "endDragVirtual": `Vedetään. Peruuta vetäminen napsauttamalla.`,
  "insertAfter": (args2) => `Lisää kohteen ${args2.itemText} jälkeen`,
  "insertBefore": (args2) => `Lisää ennen kohdetta ${args2.itemText}`,
  "insertBetween": (args2) => `Lisää kohteiden ${args2.beforeItemText} ja ${args2.afterItemText} väliin`
};

// node_modules/@react-aria/dnd/dist/fr-FR.mjs
var $a5de891427686596$exports = {};
$a5de891427686596$exports = {
  "dragDescriptionKeyboard": `Appuyez sur Entrée pour commencer le déplacement.`,
  "dragDescriptionKeyboardAlt": `Appuyez sur Alt + Entrée pour commencer à faire glisser.`,
  "dragDescriptionLongPress": `Appuyez de manière prolongée pour commencer à faire glisser.`,
  "dragDescriptionTouch": `Touchez deux fois pour commencer le déplacement.`,
  "dragDescriptionVirtual": `Cliquez pour commencer le déplacement.`,
  "dragItem": (args2) => `Déplacer ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Déplacer ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} élément sélectionné`,
    other: () => `${formatter.number(args2.count)} éléments sélectionnés`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Appuyez sur Entrée pour faire glisser ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} élément sélectionné`,
    other: () => `${formatter.number(args2.count)} éléments sélectionnés`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Appuyez sur Alt + Entrée pour faire glisser ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} élément sélectionné`,
    other: () => `${formatter.number(args2.count)} éléments sélectionnés`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Appuyez de manière prolongée pour faire glisser ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} élément sélectionné`,
    other: () => `${formatter.number(args2.count)} éléments sélectionnés`
  })}.`,
  "dragStartedKeyboard": `Déplacement commencé. Appuyez sur Tabulation pour accéder à une cible de dépôt, puis appuyez sur Entrée pour déposer, ou appuyez sur Échap pour annuler.`,
  "dragStartedTouch": `Déplacement commencé. Accédez à une cible de dépôt, puis touchez deux fois pour déposer.`,
  "dragStartedVirtual": `Déplacement commencé. Accédez à une cible de dépôt, puis cliquez ou appuyez sur Entrée pour déposer.`,
  "dropCanceled": `Dépôt annulé.`,
  "dropComplete": `Dépôt terminé.`,
  "dropDescriptionKeyboard": `Appuyez sur Entrée pour déposer. Appuyez sur Échap pour annuler le déplacement.`,
  "dropDescriptionTouch": `Touchez deux fois pour déposer.`,
  "dropDescriptionVirtual": `Cliquez pour déposer.`,
  "dropIndicator": `indicateur de dépôt`,
  "dropOnItem": (args2) => `Déposer sur ${args2.itemText}`,
  "dropOnRoot": `Déposer sur`,
  "endDragKeyboard": `Déplacement. Appuyez sur Entrée pour annuler le déplacement.`,
  "endDragTouch": `Déplacement. Touchez deux fois pour annuler le déplacement.`,
  "endDragVirtual": `Déplacement. Cliquez pour annuler le déplacement.`,
  "insertAfter": (args2) => `Insérer après ${args2.itemText}`,
  "insertBefore": (args2) => `Insérer avant ${args2.itemText}`,
  "insertBetween": (args2) => `Insérer entre ${args2.beforeItemText} et ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/he-IL.mjs
var $ad7f4c66d85b4494$exports = {};
$ad7f4c66d85b4494$exports = {
  "dragDescriptionKeyboard": `הקש על Enter כדי להתחיל לגרור.`,
  "dragDescriptionKeyboardAlt": `הקש Alt + Enter כדי להתחיל לגרור.`,
  "dragDescriptionLongPress": `לחץ לחיצה ארוכה כדי להתחיל לגרור.`,
  "dragDescriptionTouch": `הקש פעמיים כדי להתחיל בגרירה.`,
  "dragDescriptionVirtual": `לחץ כדי להתחיל לגרור.`,
  "dragItem": (args2) => `גרור את ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `גרור ${formatter.plural(args2.count, {
    one: () => `פריט נבחר ${formatter.number(args2.count)}`,
    other: () => `${formatter.number(args2.count)} פריטים שנבחרו`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `הקש על Enter כדי לגרור ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} פריט שנבחר`,
    other: () => `${formatter.number(args2.count)} פריטים שנבחרו`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `הקש Alt + Enter כדי לגרור ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} פריט שנבחר`,
    other: () => `${formatter.number(args2.count)} פריטים שנבחרו`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `לחץ לחיצה ארוכה כדי לגרור ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} פריט שנבחר`,
    other: () => `${formatter.number(args2.count)} פריטים שנבחרו`
  })}.`,
  "dragStartedKeyboard": `התחלת לגרור. הקש על Tab כדי לנווט לנקודת הגרירה ולאחר מכן הקש על Enter כדי לשחרר או על Escape כדי לבטל.`,
  "dragStartedTouch": `התחלת לגרור. נווט לנקודת השחרור ולאחר מכן הקש פעמיים כדי לשחרר.`,
  "dragStartedVirtual": `התחלת לגרור. נווט לנקודת השחרור ולאחר מכן לחץ או הקש על Enter כדי לשחרר.`,
  "dropCanceled": `השחרור בוטל.`,
  "dropComplete": `השחרור הושלם.`,
  "dropDescriptionKeyboard": `הקש על Enter כדי לשחרר. הקש על Escape כדי לבטל את הגרירה.`,
  "dropDescriptionTouch": `הקש פעמיים כדי לשחרר.`,
  "dropDescriptionVirtual": `לחץ כדי לשחרר.`,
  "dropIndicator": `מחוון שחרור`,
  "dropOnItem": (args2) => `שחרר על ${args2.itemText}`,
  "dropOnRoot": `שחרר על`,
  "endDragKeyboard": `גורר. הקש על Enter כדי לבטל את הגרירה.`,
  "endDragTouch": `גורר. הקש פעמיים כדי לבטל את הגרירה.`,
  "endDragVirtual": `גורר. לחץ כדי לבטל את הגרירה.`,
  "insertAfter": (args2) => `הוסף אחרי ${args2.itemText}`,
  "insertBefore": (args2) => `הוסף לפני ${args2.itemText}`,
  "insertBetween": (args2) => `הוסף בין ${args2.beforeItemText} לבין ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/hr-HR.mjs
var $4aa59f3c6a796cae$exports = {};
$4aa59f3c6a796cae$exports = {
  "dragDescriptionKeyboard": `Pritisnite Enter da biste počeli povlačiti.`,
  "dragDescriptionKeyboardAlt": `Pritisnite Alt + Enter za početak povlačenja.`,
  "dragDescriptionLongPress": `Dugo pritisnite za početak povlačenja.`,
  "dragDescriptionTouch": `Dvaput dodirnite da biste počeli povlačiti.`,
  "dragDescriptionVirtual": `Kliknite da biste počeli povlačiti.`,
  "dragItem": (args2) => `Povucite stavku ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Povucite ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} odabranu stavku`,
    other: () => `ovoliko odabranih stavki: ${formatter.number(args2.count)}`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Pritisnite Enter za povlačenje ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} odabrana stavka`,
    other: () => `${formatter.number(args2.count)} odabrane stavke`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Pritisnite Alt + Enter za povlačenje ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} odabrana stavka`,
    other: () => `${formatter.number(args2.count)} odabrane stavke`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Dugo pritisnite za povlačenje ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} odabrana stavka`,
    other: () => `${formatter.number(args2.count)} odabrane stavke`
  })}.`,
  "dragStartedKeyboard": `Počeli ste povlačiti. Pritisnite tipku tabulatora da biste došli do cilja ispuštanja, a zatim Enter da biste ispustili stavku ili Escape da biste prekinuli povlačenje.`,
  "dragStartedTouch": `Počeli ste povlačiti. Dođite do cilja ispuštanja, a zatim dvaput dodirnite da biste ispustili stavku.`,
  "dragStartedVirtual": `Počeli ste povlačiti. Dođite do cilja ispuštanja, a zatim kliknite ili pritisnite Enter da biste ispustili stavku.`,
  "dropCanceled": `Povlačenje je prekinuto.`,
  "dropComplete": `Ispuštanje je dovršeno.`,
  "dropDescriptionKeyboard": `Pritisnite Enter da biste ispustili stavku. Pritisnite Escape da biste prekinuli povlačenje.`,
  "dropDescriptionTouch": `Dvaput dodirnite da biste ispustili stavku.`,
  "dropDescriptionVirtual": `Kliknite da biste ispustili stavku.`,
  "dropIndicator": `pokazatelj ispuštanja`,
  "dropOnItem": (args2) => `Ispustite na stavku ${args2.itemText}`,
  "dropOnRoot": `Ispustite na`,
  "endDragKeyboard": `Povlačenje. Pritisnite Enter da biste prekinuli povlačenje.`,
  "endDragTouch": `Povlačenje. Dvaput dodirnite da biste prekinuli povlačenje.`,
  "endDragVirtual": `Povlačenje. Kliknite da biste prekinuli povlačenje.`,
  "insertAfter": (args2) => `Umetnite iza stavke ${args2.itemText}`,
  "insertBefore": (args2) => `Ispustite ispred stavke ${args2.itemText}`,
  "insertBetween": (args2) => `Umetnite između stavki ${args2.beforeItemText} i ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/hu-HU.mjs
var $d8d3646556c40586$exports = {};
$d8d3646556c40586$exports = {
  "dragDescriptionKeyboard": `Nyomja le az Enter billentyűt a húzás megkezdéséhez.`,
  "dragDescriptionKeyboardAlt": `Nyomja le az Alt + Enter billentyűket a húzás megkezdéséhez.`,
  "dragDescriptionLongPress": `Hosszan nyomja meg a húzás elindításához.`,
  "dragDescriptionTouch": `Koppintson duplán a húzás megkezdéséhez.`,
  "dragDescriptionVirtual": `Kattintson a húzás megkezdéséhez.`,
  "dragItem": (args2) => `${args2.itemText} húzása`,
  "dragSelectedItems": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} kijelölt elem`,
    other: () => `${formatter.number(args2.count)} kijelölt elem`
  })} húzása`,
  "dragSelectedKeyboard": (args2, formatter) => `Nyomja meg az Entert ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} kijelölt elem`,
    other: () => `${formatter.number(args2.count)} kijelölt elem`
  })} húzásához.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Nyomja meg az Alt + Enter billentyűket ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} kijelölt elem`,
    other: () => `${formatter.number(args2.count)} kijelölt elem`
  })} húzásához.`,
  "dragSelectedLongPress": (args2, formatter) => `Tartsa lenyomva hosszan ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} kijelölt elem`,
    other: () => `${formatter.number(args2.count)} kijelölt elem`
  })} húzásához.`,
  "dragStartedKeyboard": `Húzás megkezdve. Nyomja le a Tab billentyűt az elengedési célhoz navigálásához, majd nyomja le az Enter billentyűt az elengedéshez, vagy nyomja le az Escape billentyűt a megszakításhoz.`,
  "dragStartedTouch": `Húzás megkezdve. Navigáljon egy elengedési célhoz, majd koppintson duplán az elengedéshez.`,
  "dragStartedVirtual": `Húzás megkezdve. Navigáljon egy elengedési célhoz, majd kattintson vagy nyomja le az Enter billentyűt az elengedéshez.`,
  "dropCanceled": `Elengedés megszakítva.`,
  "dropComplete": `Elengedés teljesítve.`,
  "dropDescriptionKeyboard": `Nyomja le az Enter billentyűt az elengedéshez. Nyomja le az Escape billentyűt a húzás megszakításához.`,
  "dropDescriptionTouch": `Koppintson duplán az elengedéshez.`,
  "dropDescriptionVirtual": `Kattintson az elengedéshez.`,
  "dropIndicator": `elengedésjelző`,
  "dropOnItem": (args2) => `Elengedés erre: ${args2.itemText}`,
  "dropOnRoot": `Elengedés erre:`,
  "endDragKeyboard": `Húzás folyamatban. Nyomja le az Enter billentyűt a húzás megszakításához.`,
  "endDragTouch": `Húzás folyamatban. Koppintson duplán a húzás megszakításához.`,
  "endDragVirtual": `Húzás folyamatban. Kattintson a húzás megszakításához.`,
  "insertAfter": (args2) => `Beszúrás ${args2.itemText} után`,
  "insertBefore": (args2) => `Beszúrás ${args2.itemText} elé`,
  "insertBetween": (args2) => `Beszúrás ${args2.beforeItemText} és ${args2.afterItemText} közé`
};

// node_modules/@react-aria/dnd/dist/it-IT.mjs
var $982d558b45395246$exports = {};
$982d558b45395246$exports = {
  "dragDescriptionKeyboard": `Premi Invio per iniziare a trascinare.`,
  "dragDescriptionKeyboardAlt": `Premi Alt + Invio per iniziare a trascinare.`,
  "dragDescriptionLongPress": `Premi a lungo per iniziare a trascinare.`,
  "dragDescriptionTouch": `Tocca due volte per iniziare a trascinare.`,
  "dragDescriptionVirtual": `Fai clic per iniziare a trascinare.`,
  "dragItem": (args2) => `Trascina ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Trascina ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} altro elemento selezionato`,
    other: () => `${formatter.number(args2.count)} altri elementi selezionati`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Premi Invio per trascinare ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} elemento selezionato`,
    other: () => `${formatter.number(args2.count)} elementi selezionati`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Premi Alt + Invio per trascinare ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} elemento selezionato`,
    other: () => `${formatter.number(args2.count)} elementi selezionati`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Premi a lungo per trascinare ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} elemento selezionato`,
    other: () => `${formatter.number(args2.count)} elementi selezionati`
  })}.`,
  "dragStartedKeyboard": `Hai iniziato a trascinare. Premi Tab per arrivare sull’area di destinazione, quindi premi Invio per rilasciare o Esc per annullare.`,
  "dragStartedTouch": `Hai iniziato a trascinare. Arriva sull’area di destinazione, quindi tocca due volte per rilasciare.`,
  "dragStartedVirtual": `Hai iniziato a trascinare. Arriva sull’area di destinazione, quindi fai clic o premi Invio per rilasciare.`,
  "dropCanceled": `Rilascio annullato.`,
  "dropComplete": `Rilascio completato.`,
  "dropDescriptionKeyboard": `Premi Invio per rilasciare. Premi Esc per annullare.`,
  "dropDescriptionTouch": `Tocca due volte per rilasciare.`,
  "dropDescriptionVirtual": `Fai clic per rilasciare.`,
  "dropIndicator": `indicatore di rilascio`,
  "dropOnItem": (args2) => `Rilascia su ${args2.itemText}`,
  "dropOnRoot": `Rilascia su`,
  "endDragKeyboard": `Trascinamento. Premi Invio per annullare.`,
  "endDragTouch": `Trascinamento. Tocca due volte per annullare.`,
  "endDragVirtual": `Trascinamento. Fai clic per annullare.`,
  "insertAfter": (args2) => `Inserisci dopo ${args2.itemText}`,
  "insertBefore": (args2) => `Inserisci prima di ${args2.itemText}`,
  "insertBetween": (args2) => `Inserisci tra ${args2.beforeItemText} e ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/ja-JP.mjs
var $6a0cf387b9de036c$exports = {};
$6a0cf387b9de036c$exports = {
  "dragDescriptionKeyboard": `Enter キーを押してドラッグを開始してください。`,
  "dragDescriptionKeyboardAlt": `Alt+Enter キーを押してドラッグを開始します。`,
  "dragDescriptionLongPress": `長押ししてドラッグを開始します。`,
  "dragDescriptionTouch": `ダブルタップしてドラッグを開始します。`,
  "dragDescriptionVirtual": `クリックしてドラッグを開始します。`,
  "dragItem": (args2) => `${args2.itemText} をドラッグ`,
  "dragSelectedItems": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} 個の選択項目`,
    other: () => `${formatter.number(args2.count)} 個の選択項目`
  })} をドラッグ`,
  "dragSelectedKeyboard": (args2, formatter) => `Enter キーを押して、${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} 選択した項目`,
    other: () => `${formatter.number(args2.count)} 選択した項目`
  })}をドラッグします。`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Alt+Enter キーを押して、${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} 選択した項目`,
    other: () => `${formatter.number(args2.count)} 選択した項目`
  })}をドラッグします。`,
  "dragSelectedLongPress": (args2, formatter) => `長押しして、${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} 選択した項目`,
    other: () => `${formatter.number(args2.count)} 選択した項目`
  })}をドラッグします。`,
  "dragStartedKeyboard": `ドラッグを開始します。Tab キーを押してドロップターゲットにいどうし、Enter キーを押してドロップするか、Esc キーを押してキャンセルします。`,
  "dragStartedTouch": `ドラッグを開始しました。ドロップのターゲットに移動し、ダブルタップしてドロップします。`,
  "dragStartedVirtual": `ドラッグを開始しました。ドロップのターゲットに移動し、クリックまたは Enter キーを押してドロップします。`,
  "dropCanceled": `ドロップがキャンセルされました。`,
  "dropComplete": `ドロップが完了しました。`,
  "dropDescriptionKeyboard": `Enter キーを押してドロップします。Esc キーを押してドラッグをキャンセルします。`,
  "dropDescriptionTouch": `ダブルタップしてドロップします。`,
  "dropDescriptionVirtual": `クリックしてドロップします。`,
  "dropIndicator": `ドロップインジケーター`,
  "dropOnItem": (args2) => `${args2.itemText} にドロップ`,
  "dropOnRoot": `ドロップ場所`,
  "endDragKeyboard": `ドラッグしています。Enter キーを押してドラッグをキャンセルします。`,
  "endDragTouch": `ドラッグしています。ダブルタップしてドラッグをキャンセルします。`,
  "endDragVirtual": `ドラッグしています。クリックしてドラッグをキャンセルします。`,
  "insertAfter": (args2) => `${args2.itemText} の後に挿入`,
  "insertBefore": (args2) => `${args2.itemText} の前に挿入`,
  "insertBetween": (args2) => `${args2.beforeItemText} と ${args2.afterItemText} の間に挿入`
};

// node_modules/@react-aria/dnd/dist/ko-KR.mjs
var $a97fefa2956f4bcb$exports = {};
$a97fefa2956f4bcb$exports = {
  "dragDescriptionKeyboard": `드래그를 시작하려면 Enter를 누르세요.`,
  "dragDescriptionKeyboardAlt": `드래그를 시작하려면 Alt + Enter를 누르십시오.`,
  "dragDescriptionLongPress": `드래그를 시작하려면 길게 누르십시오.`,
  "dragDescriptionTouch": `드래그를 시작하려면 더블 탭하세요.`,
  "dragDescriptionVirtual": `드래그를 시작하려면 클릭하세요.`,
  "dragItem": (args2) => `${args2.itemText} 드래그`,
  "dragSelectedItems": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)}개 선택 항목`,
    other: () => `${formatter.number(args2.count)}개 선택 항목`
  })} 드래그`,
  "dragSelectedKeyboard": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)}개 선택 항목`,
    other: () => `${formatter.number(args2.count)}개 선택 항목`
  })}을 드래그하려면 Enter를 누르십시오.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)}개 선택 항목`,
    other: () => `${formatter.number(args2.count)}개 선택 항목`
  })}을 드래그하려면 Alt + Enter를 누르십시오.`,
  "dragSelectedLongPress": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)}개 선택 항목`,
    other: () => `${formatter.number(args2.count)}개 선택 항목`
  })}을 드래그하려면 길게 누르십시오.`,
  "dragStartedKeyboard": `드래그가 시작되었습니다. Tab을 눌러 드롭 대상으로 이동한 다음 Enter를 눌러 드롭하거나 Esc를 눌러 취소하세요.`,
  "dragStartedTouch": `드래그가 시작되었습니다. 드롭 대상으로 이동한 다음 더블 탭하여 드롭하세요.`,
  "dragStartedVirtual": `드래그가 시작되었습니다. 드롭 대상으로 이동한 다음 클릭하거나 Enter를 눌러 드롭하세요.`,
  "dropCanceled": `드롭이 취소되었습니다.`,
  "dropComplete": `드롭이 완료되었습니다.`,
  "dropDescriptionKeyboard": `드롭하려면 Enter를 누르세요. 드래그를 취소하려면 Esc를 누르세요.`,
  "dropDescriptionTouch": `더블 탭하여 드롭하세요.`,
  "dropDescriptionVirtual": `드롭하려면 클릭하세요.`,
  "dropIndicator": `드롭 표시기`,
  "dropOnItem": (args2) => `${args2.itemText}에 드롭`,
  "dropOnRoot": `드롭 대상`,
  "endDragKeyboard": `드래그 중입니다. 드래그를 취소하려면 Enter를 누르세요.`,
  "endDragTouch": `드래그 중입니다. 드래그를 취소하려면 더블 탭하세요.`,
  "endDragVirtual": `드래그 중입니다. 드래그를 취소하려면 클릭하세요.`,
  "insertAfter": (args2) => `${args2.itemText} 이후에 삽입`,
  "insertBefore": (args2) => `${args2.itemText} 이전에 삽입`,
  "insertBetween": (args2) => `${args2.beforeItemText} 및 ${args2.afterItemText} 사이에 삽입`
};

// node_modules/@react-aria/dnd/dist/lt-LT.mjs
var $5fb5837f94e1c150$exports = {};
$5fb5837f94e1c150$exports = {
  "dragDescriptionKeyboard": `Paspauskite „Enter“, kad pradėtumėte vilkti.`,
  "dragDescriptionKeyboardAlt": `Paspauskite „Alt + Enter“, kad pradėtumėte vilkti.`,
  "dragDescriptionLongPress": `Palaikykite nuspaudę, kad pradėtumėte vilkti.`,
  "dragDescriptionTouch": `Palieskite dukart, kad pradėtumėte vilkti.`,
  "dragDescriptionVirtual": `Spustelėkite, kad pradėtumėte vilkti.`,
  "dragItem": (args2) => `Vilkti ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Vilkti ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} pasirinktą elementą`,
    other: () => `${formatter.number(args2.count)} pasirinktus elementus`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Paspauskite „Enter“, jei norite nuvilkti ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} pasirinktą elementą`,
    other: () => `${formatter.number(args2.count)} pasirinktus elementus`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Paspauskite „Alt + Enter“, kad nuvilktumėte ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} pasirinktą elementą`,
    other: () => `${formatter.number(args2.count)} pasirinktus elementus`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Nuspaudę palaikykite, kad nuvilktumėte ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} pasirinktą elementą`,
    other: () => `${formatter.number(args2.count)} pasirinktus elementus`
  })}.`,
  "dragStartedKeyboard": `Pradėta vilkti. Paspauskite „Tab“, kad pereitumėte į tiesioginę paskirties vietą, tada paspauskite „Enter“, kad numestumėte, arba „Escape“, kad atšauktumėte.`,
  "dragStartedTouch": `Pradėta vilkti. Eikite į tiesioginę paskirties vietą, tada palieskite dukart, kad numestumėte.`,
  "dragStartedVirtual": `Pradėta vilkti. Eikite į tiesioginę paskirties vietą ir spustelėkite arba paspauskite „Enter“, kad numestumėte.`,
  "dropCanceled": `Numetimas atšauktas.`,
  "dropComplete": `Numesta.`,
  "dropDescriptionKeyboard": `Paspauskite „Enter“, kad numestumėte. Paspauskite „Escape“, kad atšauktumėte vilkimą.`,
  "dropDescriptionTouch": `Palieskite dukart, kad numestumėte.`,
  "dropDescriptionVirtual": `Spustelėkite, kad numestumėte.`,
  "dropIndicator": `numetimo indikatorius`,
  "dropOnItem": (args2) => `Numesti ant ${args2.itemText}`,
  "dropOnRoot": `Numesti ant`,
  "endDragKeyboard": `Velkama. Paspauskite „Enter“, kad atšauktumėte vilkimą.`,
  "endDragTouch": `Velkama. Spustelėkite dukart, kad atšauktumėte vilkimą.`,
  "endDragVirtual": `Velkama. Spustelėkite, kad atšauktumėte vilkimą.`,
  "insertAfter": (args2) => `Įterpti po ${args2.itemText}`,
  "insertBefore": (args2) => `Įterpti prieš ${args2.itemText}`,
  "insertBetween": (args2) => `Įterpti tarp ${args2.beforeItemText} ir ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/lv-LV.mjs
var $5b2e5709864cc922$exports = {};
$5b2e5709864cc922$exports = {
  "dragDescriptionKeyboard": `Nospiediet Enter, lai sāktu vilkšanu.`,
  "dragDescriptionKeyboardAlt": `Nospiediet taustiņu kombināciju Alt+Enter, lai sāktu vilkšanu.`,
  "dragDescriptionLongPress": `Turiet nospiestu, lai sāktu vilkšanu.`,
  "dragDescriptionTouch": `Veiciet dubultskārienu, lai sāktu vilkšanu.`,
  "dragDescriptionVirtual": `Noklikšķiniet, lai sāktu vilkšanu.`,
  "dragItem": (args2) => `Velciet ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Velciet ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} atlasīto vienumu`,
    other: () => `${formatter.number(args2.count)} atlasītos vienumus`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Nospiediet taustiņu Enter, lai vilktu ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} atlasīto vienumu`,
    other: () => `${formatter.number(args2.count)} atlasītos vienumus`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Nospiediet taustiņu kombināciju Alt+Enter, lai vilktu ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} atlasīto vienumu`,
    other: () => `${formatter.number(args2.count)} atlasītos vienumus`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Turiet nospiestu, lai vilktu ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} atlasīto vienumu`,
    other: () => `${formatter.number(args2.count)} atlasītos vienumus`
  })}.`,
  "dragStartedKeyboard": `Uzsākta vilkšana. Nospiediet taustiņu Tab, lai pārietu uz nomešanas mērķi, pēc tam nospiediet Enter, lai nomestu, vai nospiediet Escape, lai atceltu.`,
  "dragStartedTouch": `Uzsākta vilkšana. Pārejiet uz nomešanas mērķi, pēc tam veiciet dubultskārienu, lai nomestu.`,
  "dragStartedVirtual": `Uzsākta vilkšana. Pārejiet uz nomešanas mērķi, pēc tam nospiediet Enter, lai nomestu.`,
  "dropCanceled": `Nomešana atcelta.`,
  "dropComplete": `Nomešana pabeigta.`,
  "dropDescriptionKeyboard": `Nospiediet Enter, lai nomestu. Nospiediet Escape, lai atceltu vilkšanu.`,
  "dropDescriptionTouch": `Veiciet dubultskārienu, lai nomestu.`,
  "dropDescriptionVirtual": `Noklikšķiniet, lai nomestu.`,
  "dropIndicator": `nomešanas indikators`,
  "dropOnItem": (args2) => `Nometiet uz ${args2.itemText}`,
  "dropOnRoot": `Nometiet uz`,
  "endDragKeyboard": `Notiek vilkšana. Nospiediet Enter, lai atceltu vilkšanu.`,
  "endDragTouch": `Notiek vilkšana. Veiciet dubultskārienu, lai atceltu vilkšanu.`,
  "endDragVirtual": `Notiek vilkšana. Noklikšķiniet, lai atceltu vilkšanu.`,
  "insertAfter": (args2) => `Ievietojiet pēc ${args2.itemText}`,
  "insertBefore": (args2) => `Ievietojiet pirms ${args2.itemText}`,
  "insertBetween": (args2) => `Ievietojiet starp ${args2.beforeItemText} un ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/nb-NO.mjs
var $ee15bb8efb18cc69$exports = {};
$ee15bb8efb18cc69$exports = {
  "dragDescriptionKeyboard": `Trykk på Enter for å begynne å dra.`,
  "dragDescriptionKeyboardAlt": `Trykk på Alt + Enter for å begynne å dra.`,
  "dragDescriptionLongPress": `Trykk lenge for å begynne å dra.`,
  "dragDescriptionTouch": `Dobbelttrykk for å begynne å dra.`,
  "dragDescriptionVirtual": `Klikk for å begynne å dra.`,
  "dragItem": (args2) => `Dra ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Dra ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} merket element`,
    other: () => `${formatter.number(args2.count)} merkede elementer`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Trykk Enter for å dra ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valgt element`,
    other: () => `${formatter.number(args2.count)} valgte elementer`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Trykk på Alt + Enter for å dra ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valgt element`,
    other: () => `${formatter.number(args2.count)} valgte elementer`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Trykk lenge for å dra ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valgt element`,
    other: () => `${formatter.number(args2.count)} valgte elementer`
  })}.`,
  "dragStartedKeyboard": `Begynte å dra. Trykk på Tab for å navigere til et mål, og trykk deretter på Enter for å slippe eller på Esc for å avbryte.`,
  "dragStartedTouch": `Begynte å dra. Naviger til et mål, og dobbelttrykk for å slippe.`,
  "dragStartedVirtual": `Begynte å dra. Naviger til et mål, og klikk eller trykk på Enter for å slippe.`,
  "dropCanceled": `Avbrøt slipping.`,
  "dropComplete": `Slippingen er fullført.`,
  "dropDescriptionKeyboard": `Trykk på Enter for å slippe. Trykk på Esc hvis du vil avbryte draingen.`,
  "dropDescriptionTouch": `Dobbelttrykk for å slippe.`,
  "dropDescriptionVirtual": `Klikk for å slippe.`,
  "dropIndicator": `slippeindikator`,
  "dropOnItem": (args2) => `Slipp på ${args2.itemText}`,
  "dropOnRoot": `Slipp på`,
  "endDragKeyboard": `Drar. Trykk på Enter hvis du vil avbryte.`,
  "endDragTouch": `Drar. Dobbelttrykk hvis du vil avbryte.`,
  "endDragVirtual": `Drar. Klikk hvis du vil avbryte.`,
  "insertAfter": (args2) => `Sett inn etter ${args2.itemText}`,
  "insertBefore": (args2) => `Sett inn før ${args2.itemText}`,
  "insertBetween": (args2) => `Sett inn mellom ${args2.beforeItemText} og ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/nl-NL.mjs
var $1daf2d4602e26ac4$exports = {};
$1daf2d4602e26ac4$exports = {
  "dragDescriptionKeyboard": `Druk op Enter om te slepen.`,
  "dragDescriptionKeyboardAlt": `Druk op Alt + Enter om te slepen.`,
  "dragDescriptionLongPress": `Houd lang ingedrukt om te slepen.`,
  "dragDescriptionTouch": `Dubbeltik om te slepen.`,
  "dragDescriptionVirtual": `Klik om met slepen te starten.`,
  "dragItem": (args2) => `${args2.itemText} slepen`,
  "dragSelectedItems": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} geselecteerd item`,
    other: () => `${formatter.number(args2.count)} geselecteerde items`
  })} slepen`,
  "dragSelectedKeyboard": (args2, formatter) => `Druk op Enter om ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} geselecteerd item`,
    other: () => `${formatter.number(args2.count)} geselecteerde items`
  })} te slepen.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Druk op Alt + Enter om ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} geselecteerd item`,
    other: () => `${formatter.number(args2.count)} geselecteerde items`
  })} te slepen.`,
  "dragSelectedLongPress": (args2, formatter) => `Houd lang ingedrukt om ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} geselecteerd item`,
    other: () => `${formatter.number(args2.count)} geselecteerde items`
  })} te slepen.`,
  "dragStartedKeyboard": `Begonnen met slepen. Druk op Tab om naar een locatie te gaan. Druk dan op Enter om neer te zetten, of op Esc om te annuleren.`,
  "dragStartedTouch": `Begonnen met slepen. Ga naar de gewenste locatie en dubbeltik om neer te zetten.`,
  "dragStartedVirtual": `Begonnen met slepen. Ga naar de gewenste locatie en klik of druk op Enter om neer te zetten.`,
  "dropCanceled": `Neerzetten geannuleerd.`,
  "dropComplete": `Neerzetten voltooid.`,
  "dropDescriptionKeyboard": `Druk op Enter om neer te zetten. Druk op Esc om het slepen te annuleren.`,
  "dropDescriptionTouch": `Dubbeltik om neer te zetten.`,
  "dropDescriptionVirtual": `Klik om neer te zetten.`,
  "dropIndicator": `aanwijzer voor neerzetten`,
  "dropOnItem": (args2) => `Neerzetten op ${args2.itemText}`,
  "dropOnRoot": `Neerzetten op`,
  "endDragKeyboard": `Bezig met slepen. Druk op Enter om te annuleren.`,
  "endDragTouch": `Bezig met slepen. Dubbeltik om te annuleren.`,
  "endDragVirtual": `Bezig met slepen. Klik om te annuleren.`,
  "insertAfter": (args2) => `Plaatsen na ${args2.itemText}`,
  "insertBefore": (args2) => `Plaatsen vóór ${args2.itemText}`,
  "insertBetween": (args2) => `Plaatsen tussen ${args2.beforeItemText} en ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/pl-PL.mjs
var $7115429b0f60511f$exports = {};
$7115429b0f60511f$exports = {
  "dragDescriptionKeyboard": `Naciśnij Enter, aby rozpocząć przeciąganie.`,
  "dragDescriptionKeyboardAlt": `Naciśnij Alt + Enter, aby rozpocząć przeciąganie.`,
  "dragDescriptionLongPress": `Naciśnij i przytrzymaj, aby rozpocząć przeciąganie.`,
  "dragDescriptionTouch": `Dotknij dwukrotnie, aby rozpocząć przeciąganie.`,
  "dragDescriptionVirtual": `Kliknij, aby rozpocząć przeciąganie.`,
  "dragItem": (args2) => `Przeciągnij ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Przeciągnij ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} wybrany element`,
    other: () => `${formatter.number(args2.count)} wybranych elementów`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Naciśnij Enter, aby przeciągnąć ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} wybrany element`,
    other: () => `${formatter.number(args2.count)} wybrane(-ych) elementy(-ów)`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Naciśnij Alt + Enter, aby przeciągnąć ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} wybrany element`,
    other: () => `${formatter.number(args2.count)} wybrane(-ych) elementy(-ów)`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Naciśnij i przytrzymaj, aby przeciągnąć ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} wybrany element`,
    other: () => `${formatter.number(args2.count)} wybrane(-ych) elementy(-ów)`
  })}.`,
  "dragStartedKeyboard": `Rozpoczęto przeciąganie. Naciśnij Tab, aby wybrać miejsce docelowe, a następnie naciśnij Enter, aby upuścić, lub Escape, aby anulować.`,
  "dragStartedTouch": `Rozpoczęto przeciąganie. Wybierz miejsce, w którym chcesz upuścić element, a następnie dotknij dwukrotnie, aby upuścić.F`,
  "dragStartedVirtual": `Rozpoczęto przeciąganie. Wybierz miejsce, w którym chcesz upuścić element, a następnie kliknij lub naciśnij Enter, aby upuścić.`,
  "dropCanceled": `Anulowano upuszczenie.`,
  "dropComplete": `Zakończono upuszczanie.`,
  "dropDescriptionKeyboard": `Naciśnij Enter, aby upuścić. Naciśnij Escape, aby anulować przeciągnięcie.`,
  "dropDescriptionTouch": `Dotknij dwukrotnie, aby upuścić.`,
  "dropDescriptionVirtual": `Kliknij, aby upuścić.`,
  "dropIndicator": `wskaźnik upuszczenia`,
  "dropOnItem": (args2) => `Upuść na ${args2.itemText}`,
  "dropOnRoot": `Upuść`,
  "endDragKeyboard": `Przeciąganie. Naciśnij Enter, aby anulować przeciągnięcie.`,
  "endDragTouch": `Przeciąganie. Kliknij dwukrotnie, aby anulować przeciągnięcie.`,
  "endDragVirtual": `Przeciąganie. Kliknij, aby anulować przeciąganie.`,
  "insertAfter": (args2) => `Umieść za ${args2.itemText}`,
  "insertBefore": (args2) => `Umieść przed ${args2.itemText}`,
  "insertBetween": (args2) => `Umieść między ${args2.beforeItemText} i ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/pt-BR.mjs
var $5edd453ae5d4a8bc$exports = {};
$5edd453ae5d4a8bc$exports = {
  "dragDescriptionKeyboard": `Pressione Enter para começar a arrastar.`,
  "dragDescriptionKeyboardAlt": `Pressione Alt + Enter para começar a arrastar.`,
  "dragDescriptionLongPress": `Pressione e segure para começar a arrastar.`,
  "dragDescriptionTouch": `Toque duas vezes para começar a arrastar.`,
  "dragDescriptionVirtual": `Clique para começar a arrastar.`,
  "dragItem": (args2) => `Arrastar ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Arrastar ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} item selecionado`,
    other: () => `${formatter.number(args2.count)} itens selecionados`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Pressione Enter para arrastar ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} o item selecionado`,
    other: () => `${formatter.number(args2.count)} os itens selecionados`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Pressione Alt + Enter para arrastar ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} o item selecionado`,
    other: () => `${formatter.number(args2.count)} os itens selecionados`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Pressione e segure para arrastar ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} o item selecionado`,
    other: () => `${formatter.number(args2.count)} os itens selecionados`
  })}.`,
  "dragStartedKeyboard": `Comece a arrastar. Pressione Tab para navegar até um alvo e, em seguida, pressione Enter para soltar ou pressione Escape para cancelar.`,
  "dragStartedTouch": `Comece a arrastar. Navegue até um alvo e toque duas vezes para soltar.`,
  "dragStartedVirtual": `Comece a arrastar. Navegue até um alvo e clique ou pressione Enter para soltar.`,
  "dropCanceled": `Liberação cancelada.`,
  "dropComplete": `Liberação concluída.`,
  "dropDescriptionKeyboard": `Pressione Enter para soltar. Pressione Escape para cancelar.`,
  "dropDescriptionTouch": `Toque duas vezes para soltar.`,
  "dropDescriptionVirtual": `Clique para soltar.`,
  "dropIndicator": `indicador de liberação`,
  "dropOnItem": (args2) => `Soltar em ${args2.itemText}`,
  "dropOnRoot": `Soltar`,
  "endDragKeyboard": `Arrastando. Pressione Enter para cancelar.`,
  "endDragTouch": `Arrastando. Toque duas vezes para cancelar.`,
  "endDragVirtual": `Arrastando. Clique para cancelar.`,
  "insertAfter": (args2) => `Inserir após ${args2.itemText}`,
  "insertBefore": (args2) => `Inserir antes de ${args2.itemText}`,
  "insertBetween": (args2) => `Inserir entre ${args2.beforeItemText} e ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/pt-PT.mjs
var $5f431994f708535e$exports = {};
$5f431994f708535e$exports = {
  "dragDescriptionKeyboard": `Prima Enter para iniciar o arrasto.`,
  "dragDescriptionKeyboardAlt": `Prima Alt + Enter para iniciar o arrasto.`,
  "dragDescriptionLongPress": `Prima longamente para começar a arrastar.`,
  "dragDescriptionTouch": `Faça duplo toque para começar a arrastar.`,
  "dragDescriptionVirtual": `Clique para iniciar o arrasto.`,
  "dragItem": (args2) => `Arrastar ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Arrastar ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} item selecionado`,
    other: () => `${formatter.number(args2.count)} itens selecionados`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Prima Enter para arrastar ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} o item selecionado`,
    other: () => `${formatter.number(args2.count)} os itens selecionados`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Prima Alt + Enter para arrastar ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} o item selecionado`,
    other: () => `${formatter.number(args2.count)} os itens selecionados`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Prima longamente para arrastar ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} o item selecionado`,
    other: () => `${formatter.number(args2.count)} os itens selecionados`
  })}.`,
  "dragStartedKeyboard": `Arrasto iniciado. Prima a tecla de tabulação para navegar para um destino para largar, e em seguida prima Enter para largar ou prima Escape para cancelar.`,
  "dragStartedTouch": `Arrasto iniciado. Navegue para um destino para largar, e em seguida faça duplo toque para largar.`,
  "dragStartedVirtual": `Arrasto iniciado. Navegue para um destino para largar, e em seguida clique ou prima Enter para largar.`,
  "dropCanceled": `Largar cancelado.`,
  "dropComplete": `Largar completo.`,
  "dropDescriptionKeyboard": `Prima Enter para largar. Prima Escape para cancelar o arrasto.`,
  "dropDescriptionTouch": `Faça duplo toque para largar.`,
  "dropDescriptionVirtual": `Clique para largar.`,
  "dropIndicator": `Indicador de largar`,
  "dropOnItem": (args2) => `Largar em ${args2.itemText}`,
  "dropOnRoot": `Largar em`,
  "endDragKeyboard": `A arrastar. Prima Enter para cancelar o arrasto.`,
  "endDragTouch": `A arrastar. Faça duplo toque para cancelar o arrasto.`,
  "endDragVirtual": `A arrastar. Clique para cancelar o arrasto.`,
  "insertAfter": (args2) => `Inserir depois de ${args2.itemText}`,
  "insertBefore": (args2) => `Inserir antes de ${args2.itemText}`,
  "insertBetween": (args2) => `Inserir entre ${args2.beforeItemText} e ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/ro-RO.mjs
var $107b5e2e45e971f1$exports = {};
$107b5e2e45e971f1$exports = {
  "dragDescriptionKeyboard": `Apăsați pe Enter pentru a începe glisarea.`,
  "dragDescriptionKeyboardAlt": `Apăsați pe Alt + Enter pentru a începe glisarea.`,
  "dragDescriptionLongPress": `Apăsați lung pentru a începe glisarea.`,
  "dragDescriptionTouch": `Atingeți de două ori pentru a începe să glisați.`,
  "dragDescriptionVirtual": `Faceți clic pentru a începe glisarea.`,
  "dragItem": (args2) => `Glisați ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Glisați ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} element selectat`,
    other: () => `${formatter.number(args2.count)} elemente selectate`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Apăsați pe Enter pentru a glisa ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} element selectat`,
    other: () => `${formatter.number(args2.count)} elemente selectate`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Apăsați pe Alt + Enter pentru a glisa ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} element selectat`,
    other: () => `${formatter.number(args2.count)} elemente selectate`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Apăsați lung pentru a glisa ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} element selectat`,
    other: () => `${formatter.number(args2.count)} elemente selectate`
  })}.`,
  "dragStartedKeyboard": `A început glisarea. Apăsați pe Tab pentru a naviga la o țintă de fixare, apoi apăsați pe Enter pentru a fixa sau apăsați pe Escape pentru a anula glisarea.`,
  "dragStartedTouch": `A început glisarea. Navigați la o țintă de fixare, apoi atingeți de două ori pentru a fixa.`,
  "dragStartedVirtual": `A început glisarea. Navigați la o țintă de fixare, apoi faceți clic sau apăsați pe Enter pentru a fixa.`,
  "dropCanceled": `Fixare anulată.`,
  "dropComplete": `Fixare finalizată.`,
  "dropDescriptionKeyboard": `Apăsați pe Enter pentru a fixa. Apăsați pe Escape pentru a anula glisarea.`,
  "dropDescriptionTouch": `Atingeți de două ori pentru a fixa.`,
  "dropDescriptionVirtual": `Faceți clic pentru a fixa.`,
  "dropIndicator": `indicator de fixare`,
  "dropOnItem": (args2) => `Fixați pe ${args2.itemText}`,
  "dropOnRoot": `Fixare pe`,
  "endDragKeyboard": `Se glisează. Apăsați pe Enter pentru a anula glisarea.`,
  "endDragTouch": `Se glisează. Atingeți de două ori pentru a anula glisarea.`,
  "endDragVirtual": `Se glisează. Faceți clic pentru a anula glisarea.`,
  "insertAfter": (args2) => `Inserați după ${args2.itemText}`,
  "insertBefore": (args2) => `Inserați înainte de ${args2.itemText}`,
  "insertBetween": (args2) => `Inserați între ${args2.beforeItemText} și ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/ru-RU.mjs
var $d4b9c2f01c1892f7$exports = {};
$d4b9c2f01c1892f7$exports = {
  "dragDescriptionKeyboard": `Нажмите клавишу Enter для начала перетаскивания.`,
  "dragDescriptionKeyboardAlt": `Нажмите Alt + Enter, чтобы начать перетаскивать.`,
  "dragDescriptionLongPress": `Нажмите и удерживайте, чтобы начать перетаскивать.`,
  "dragDescriptionTouch": `Дважды нажмите для начала перетаскивания.`,
  "dragDescriptionVirtual": `Щелкните для начала перетаскивания.`,
  "dragItem": (args2) => `Перетащить ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Перетащить ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} выбранный элемент`,
    other: () => `${formatter.number(args2.count)} выбранных элем`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Нажмите Enter для перетаскивания ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} выбранного элемента`,
    other: () => `${formatter.number(args2.count)} выбранных элементов`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Нажмите Alt + Enter для перетаскивания ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} выбранного элемента`,
    other: () => `${formatter.number(args2.count)} выбранных элементов`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Нажмите и удерживайте для перетаскивания ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} выбранного элемента`,
    other: () => `${formatter.number(args2.count)} выбранных элементов`
  })}.`,
  "dragStartedKeyboard": `Начато перетаскивание. Нажмите клавишу Tab для выбора цели, затем нажмите клавишу Enter, чтобы применить перетаскивание, или клавишу Escape для отмены действия.`,
  "dragStartedTouch": `Начато перетаскивание. Выберите цель, затем дважды нажмите, чтобы применить перетаскивание.`,
  "dragStartedVirtual": `Начато перетаскивание. Нажмите клавишу Tab для выбора цели, затем нажмите клавишу Enter, чтобы применить перетаскивание.`,
  "dropCanceled": `Перетаскивание отменено.`,
  "dropComplete": `Перетаскивание завершено.`,
  "dropDescriptionKeyboard": `Нажмите клавишу Enter, чтобы применить перетаскивание. Нажмите клавишу Escape для отмены.`,
  "dropDescriptionTouch": `Дважды нажмите, чтобы применить перетаскивание.`,
  "dropDescriptionVirtual": `Щелкните, чтобы применить перетаскивание.`,
  "dropIndicator": `индикатор перетаскивания`,
  "dropOnItem": (args2) => `Перетащить на ${args2.itemText}`,
  "dropOnRoot": `Перетащить на`,
  "endDragKeyboard": `Перетаскивание. Нажмите клавишу Enter для отмены.`,
  "endDragTouch": `Перетаскивание. Дважды нажмите для отмены.`,
  "endDragVirtual": `Перетаскивание. Щелкните для отмены.`,
  "insertAfter": (args2) => `Вставить после ${args2.itemText}`,
  "insertBefore": (args2) => `Вставить перед ${args2.itemText}`,
  "insertBetween": (args2) => `Вставить между ${args2.beforeItemText} и ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/sk-SK.mjs
var $dbdc1942894e83e4$exports = {};
$dbdc1942894e83e4$exports = {
  "dragDescriptionKeyboard": `Stlačením klávesu Enter začnete presúvanie.`,
  "dragDescriptionKeyboardAlt": `Stlačením klávesov Alt + Enter začnete presúvanie.`,
  "dragDescriptionLongPress": `Dlhým stlačením začnete presúvanie.`,
  "dragDescriptionTouch": `Dvojitým kliknutím začnete presúvanie.`,
  "dragDescriptionVirtual": `Kliknutím začnete presúvanie.`,
  "dragItem": (args2) => `Presunúť položku ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Presunúť ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} vybratú položku`,
    other: () => `${formatter.number(args2.count)} vybraté položky`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Stlačením klávesu Enter presuniete ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} vybratú položku`,
    other: () => `${formatter.number(args2.count)} vybratých položiek`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Stlačením klávesov Alt + Enter presuniete ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} vybratú položku`,
    other: () => `${formatter.number(args2.count)} vybratých položiek`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Dlhým stlačením presuniete ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} vybratú položku`,
    other: () => `${formatter.number(args2.count)} vybratých položiek`
  })}.`,
  "dragStartedKeyboard": `Presúvanie sa začalo. Do cieľového umiestnenia prejdete stlačením klávesu Tab. Ak chcete položku umiestniť, stlačte kláves Enter alebo stlačte kláves Esc, ak chcete presúvanie zrušiť.`,
  "dragStartedTouch": `Presúvanie sa začalo. Prejdite na cieľové umiestnenie a dvojitým kliknutím umiestnite položku.`,
  "dragStartedVirtual": `Presúvanie sa začalo. Prejdite na cieľové umiestnenie a kliknutím alebo stlačením klávesu Enter umiestnite položku.`,
  "dropCanceled": `Umiestnenie zrušené.`,
  "dropComplete": `Umiestnenie dokončené.`,
  "dropDescriptionKeyboard": `Stlačením klávesu Enter umiestnite položku. Stlačením klávesu Esc zrušíte presúvanie.`,
  "dropDescriptionTouch": `Dvojitým kliknutím umiestnite položku.`,
  "dropDescriptionVirtual": `Kliknutím umiestnite položku.`,
  "dropIndicator": `indikátor umiestnenia`,
  "dropOnItem": (args2) => `Umiestniť na položku ${args2.itemText}`,
  "dropOnRoot": `Umiestniť na`,
  "endDragKeyboard": `Prebieha presúvanie. Ak ho chcete zrušiť, stlačte kláves Enter.`,
  "endDragTouch": `Prebieha presúvanie. Dvojitým kliknutím ho môžete zrušiť.`,
  "endDragVirtual": `Prebieha presúvanie.`,
  "insertAfter": (args2) => `Vložiť za položku ${args2.itemText}`,
  "insertBefore": (args2) => `Vložiť pred položku ${args2.itemText}`,
  "insertBetween": (args2) => `Vložiť medzi položky ${args2.beforeItemText} a ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/sl-SI.mjs
var $fbaaaaebd547d998$exports = {};
$fbaaaaebd547d998$exports = {
  "dragDescriptionKeyboard": `Pritisnite tipko Enter za začetek vlečenja.`,
  "dragDescriptionKeyboardAlt": `Pritisnite tipki Alt + Enter za začetek vlečenja.`,
  "dragDescriptionLongPress": `Pritisnite in zadržite za začetek vlečenja.`,
  "dragDescriptionTouch": `Dvotapnite za začetek vlečenja.`,
  "dragDescriptionVirtual": `Kliknite za začetek vlečenja.`,
  "dragItem": (args2) => `Povleci ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Povlecite ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} izbran element`,
    other: () => `izbrane elemente (${formatter.number(args2.count)})`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Pritisnite tipko Enter, da povlečete ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} izbrani element`,
    other: () => `${formatter.number(args2.count)} izbranih elementov`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Pritisnite tipki Alt + Enter, da povlečete ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} izbrani element`,
    other: () => `${formatter.number(args2.count)} izbranih elementov`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Pritisnite in zadržite, da povlečete ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} izbrani element`,
    other: () => `${formatter.number(args2.count)} izbranih elementov`
  })}.`,
  "dragStartedKeyboard": `Vlečenje se je začelo. Pritisnite tipko Tab za pomik na mesto, kamor želite spustiti elemente, in pritisnite tipko Enter, da jih spustite, ali tipko Escape, da prekličete postopek.`,
  "dragStartedTouch": `Vlečenje se je začelo. Pomaknite se na mesto, kamor želite spustiti elemente, in dvotapnite, da jih spustite.`,
  "dragStartedVirtual": `Vlečenje se je začelo. Pomaknite se na mesto, kamor želite spustiti elemente, in kliknite ali pritisnite tipko Enter, da jih spustite.`,
  "dropCanceled": `Spust je preklican.`,
  "dropComplete": `Spust je končan.`,
  "dropDescriptionKeyboard": `Pritisnite tipko Enter, da spustite. Pritisnite tipko Escape, da prekličete vlečenje.`,
  "dropDescriptionTouch": `Dvotapnite, da spustite.`,
  "dropDescriptionVirtual": `Kliknite, da spustite.`,
  "dropIndicator": `indikator spusta`,
  "dropOnItem": (args2) => `Spusti na mesto ${args2.itemText}`,
  "dropOnRoot": `Spusti na mesto`,
  "endDragKeyboard": `Vlečenje. Pritisnite tipko Enter za preklic vlečenja.`,
  "endDragTouch": `Vlečenje. Dvotapnite za preklic vlečenja.`,
  "endDragVirtual": `Vlečenje. Kliknite, da prekličete vlečenje.`,
  "insertAfter": (args2) => `Vstavi za ${args2.itemText}`,
  "insertBefore": (args2) => `Vstavi pred ${args2.itemText}`,
  "insertBetween": (args2) => `Vstavi med ${args2.beforeItemText} in ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/sr-SP.mjs
var $a0caa33f1e264489$exports = {};
$a0caa33f1e264489$exports = {
  "dragDescriptionKeyboard": `Pritisnite Enter da biste započeli prevlačenje.`,
  "dragDescriptionKeyboardAlt": `Pritisnite Alt + Enter da biste započeli prevlačenje.`,
  "dragDescriptionLongPress": `Pritisnite dugo da biste započeli prevlačenje.`,
  "dragDescriptionTouch": `Dvaput dodirnite da biste započeli prevlačenje.`,
  "dragDescriptionVirtual": `Kliknite da biste započeli prevlačenje.`,
  "dragItem": (args2) => `Prevucite ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Prevucite ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} izabranu stavku`,
    other: () => `${formatter.number(args2.count)} izabrane stavke`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Pritisnite Enter da biste prevukli ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} izabranu stavku`,
    other: () => `${formatter.number(args2.count)} izabranih stavki`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Pritisnite Alt + Enter da biste prevukli ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} izabranu stavku`,
    other: () => `${formatter.number(args2.count)} izabranih stavki`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Pritisnite dugo da biste prevukli ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} izabranu stavku`,
    other: () => `${formatter.number(args2.count)} izabranih stavki`
  })}.`,
  "dragStartedKeyboard": `Prevlačenje je započeto. Pritisnite Tab da biste otišli do cilja za otpuštanje, zatim pritisnite Enter za ispuštanje ili pritisnite Escape za otkazivanje.`,
  "dragStartedTouch": `Prevlačenje je započeto. Idite do cilja za otpuštanje, a zatim dvaput dodirnite za otpuštanje.`,
  "dragStartedVirtual": `Prevlačenje je započeto. Idite do cilja za otpuštanje, a zatim kliknite ili pritinite Enter za otpuštanje.`,
  "dropCanceled": `Otpuštanje je otkazano.`,
  "dropComplete": `Prevlačenje je završeno.`,
  "dropDescriptionKeyboard": `Pritisnite Enter da biste otpustili. Pritisnite Escape da biste otkazali prevlačenje.`,
  "dropDescriptionTouch": `Dvaput dodirnite za otpuštanje.`,
  "dropDescriptionVirtual": `Kliknite za otpuštanje.`,
  "dropIndicator": `Indikator otpuštanja`,
  "dropOnItem": (args2) => `Otpusti na ${args2.itemText}`,
  "dropOnRoot": `Otpusti na`,
  "endDragKeyboard": `Prevlačenje u toku. Pritisnite Enter da biste otkazali prevlačenje.`,
  "endDragTouch": `Prevlačenje u toku. Dvaput dodirnite da biste otkazali prevlačenje.`,
  "endDragVirtual": `Prevlačenje u toku. Kliknite da biste otkazali prevlačenje.`,
  "insertAfter": (args2) => `Umetnite posle ${args2.itemText}`,
  "insertBefore": (args2) => `Umetnite ispred ${args2.itemText}`,
  "insertBetween": (args2) => `Umetnite između ${args2.beforeItemText} i ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/sv-SE.mjs
var $d576b66176f5c0ff$exports = {};
$d576b66176f5c0ff$exports = {
  "dragDescriptionKeyboard": `Tryck på enter för att börja dra.`,
  "dragDescriptionKeyboardAlt": `Tryck på Alt + Retur för att börja dra.`,
  "dragDescriptionLongPress": `Tryck länge för att börja dra.`,
  "dragDescriptionTouch": `Dubbeltryck för att börja dra.`,
  "dragDescriptionVirtual": `Klicka för att börja dra.`,
  "dragItem": (args2) => `Dra ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Dra ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valt objekt`,
    other: () => `${formatter.number(args2.count)} valda objekt`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Tryck på Retur för att dra ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} markerat objekt`,
    other: () => `${formatter.number(args2.count)} markerade objekt`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Tryck på Alt + Retur för att dra ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} markerat objekt`,
    other: () => `${formatter.number(args2.count)} markerade objekt`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Tryck länge för att dra ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} markerat objekt`,
    other: () => `${formatter.number(args2.count)} markerade objekt`
  })}.`,
  "dragStartedKeyboard": `Börja dra. Tryck på tabb för att navigera till målet, tryck på enter för att släppa eller på escape för att avbryta.`,
  "dragStartedTouch": `Börja dra. Navigera till ett mål och dubbeltryck för att släppa.`,
  "dragStartedVirtual": `Börja dra. Navigera till ett mål och klicka eller tryck på enter för att släppa.`,
  "dropCanceled": `Släppåtgärd avbröts.`,
  "dropComplete": `Släppåtgärd klar.`,
  "dropDescriptionKeyboard": `Tryck på enter för att släppa. Tryck på escape för att avbryta dragåtgärd.`,
  "dropDescriptionTouch": `Dubbeltryck för att släppa.`,
  "dropDescriptionVirtual": `Klicka för att släppa.`,
  "dropIndicator": `släppindikator`,
  "dropOnItem": (args2) => `Släpp på ${args2.itemText}`,
  "dropOnRoot": `Släpp på`,
  "endDragKeyboard": `Drar. Tryck på enter för att avbryta dragåtgärd.`,
  "endDragTouch": `Drar. Dubbeltryck för att avbryta dragåtgärd.`,
  "endDragVirtual": `Drar. Klicka för att avbryta dragåtgärd.`,
  "insertAfter": (args2) => `Infoga efter ${args2.itemText}`,
  "insertBefore": (args2) => `Infoga före ${args2.itemText}`,
  "insertBetween": (args2) => `Infoga mellan ${args2.beforeItemText} och ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/tr-TR.mjs
var $0681f168c13d8f2a$exports = {};
$0681f168c13d8f2a$exports = {
  "dragDescriptionKeyboard": `Sürüklemeyi başlatmak için Enter'a basın.`,
  "dragDescriptionKeyboardAlt": `Sürüklemeyi başlatmak için Alt + Enter'a basın.`,
  "dragDescriptionLongPress": `Sürüklemeye başlamak için uzun basın.`,
  "dragDescriptionTouch": `Sürüklemeyi başlatmak için çift tıklayın.`,
  "dragDescriptionVirtual": `Sürüklemeyi başlatmak için tıklayın.`,
  "dragItem": (args2) => `${args2.itemText}’i sürükle`,
  "dragSelectedItems": (args2, formatter) => `Sürükle ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} seçili öge`,
    other: () => `${formatter.number(args2.count)} seçili öge`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} seçilmiş öğe`,
    other: () => `${formatter.number(args2.count)} seçilmiş öğe`
  })} öğesini sürüklemek için Enter'a basın.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} seçilmiş öğe`,
    other: () => `${formatter.number(args2.count)} seçilmiş öğe`
  })} öğesini sürüklemek için Alt + Enter tuşuna basın.`,
  "dragSelectedLongPress": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} seçilmiş öğe`,
    other: () => `${formatter.number(args2.count)} seçilmiş öğe`
  })} öğesini sürüklemek için uzun basın.`,
  "dragStartedKeyboard": `Sürükleme başlatıldı. Bir bırakma hedefine gitmek için Tab’a basın, ardından bırakmak için Enter’a basın veya iptal etmek için Escape’e basın.`,
  "dragStartedTouch": `Sürükleme başlatıldı. Bir bırakma hedefine gidin, ardından bırakmak için çift tıklayın.`,
  "dragStartedVirtual": `Sürükleme başlatıldı. Bir bırakma hedefine gidin, ardından bırakmak için Enter’a tıklayın veya basın.`,
  "dropCanceled": `Bırakma iptal edildi.`,
  "dropComplete": `Bırakma tamamlandı.`,
  "dropDescriptionKeyboard": `Bırakmak için Enter'a basın. Sürüklemeyi iptal etmek için Escape'e basın.`,
  "dropDescriptionTouch": `Bırakmak için çift tıklayın.`,
  "dropDescriptionVirtual": `Bırakmak için tıklayın.`,
  "dropIndicator": `bırakma göstergesi`,
  "dropOnItem": (args2) => `${args2.itemText} üzerine bırak`,
  "dropOnRoot": `Bırakın`,
  "endDragKeyboard": `Sürükleme. Sürüklemeyi iptal etmek için Enter'a basın.`,
  "endDragTouch": `Sürükleme. Sürüklemeyi iptal etmek için çift tıklayın.`,
  "endDragVirtual": `Sürükleme. Sürüklemeyi iptal etmek için tıklayın.`,
  "insertAfter": (args2) => `${args2.itemText}’den sonra gir`,
  "insertBefore": (args2) => `${args2.itemText}’den önce gir`,
  "insertBetween": (args2) => `${args2.beforeItemText} ve ${args2.afterItemText} arasına gir`
};

// node_modules/@react-aria/dnd/dist/uk-UA.mjs
var $2bfbc1f42c1cf5a7$exports = {};
$2bfbc1f42c1cf5a7$exports = {
  "dragDescriptionKeyboard": `Натисніть Enter, щоб почати перетягування.`,
  "dragDescriptionKeyboardAlt": `Натисніть Alt + Enter, щоб почати перетягування.`,
  "dragDescriptionLongPress": `Натисніть і утримуйте, щоб почати перетягування.`,
  "dragDescriptionTouch": `Натисніть двічі, щоб почати перетягування.`,
  "dragDescriptionVirtual": `Натисніть, щоб почати перетягування.`,
  "dragItem": (args2) => `Перетягнути ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Перетягніть ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} вибраний елемент`,
    other: () => `${formatter.number(args2.count)} вибраних елем`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Натисніть Enter, щоб перетягнути ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} вибраний елемент`,
    other: () => `${formatter.number(args2.count)} вибраних елементи(-ів)`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Натисніть Alt + Enter, щоб перетягнути ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} вибраний елемент`,
    other: () => `${formatter.number(args2.count)} вибраних елементи(-ів)`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Утримуйте, щоб перетягнути ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} вибраний елемент`,
    other: () => `${formatter.number(args2.count)} вибраних елементи(-ів)`
  })}.`,
  "dragStartedKeyboard": `Перетягування почалося. Натисніть Tab, щоб перейти до цілі перетягування, потім натисніть Enter, щоб перетягнути, або Escape, щоб скасувати.`,
  "dragStartedTouch": `Перетягування почалося. Перейдіть до цілі перетягування, потім натисніть двічі, щоб перетягнути.`,
  "dragStartedVirtual": `Перетягування почалося. Перейдіть до цілі перетягування, потім натисніть Enter, щоб перетягнути.`,
  "dropCanceled": `Перетягування скасовано.`,
  "dropComplete": `Перетягування завершено.`,
  "dropDescriptionKeyboard": `Натисніть Enter, щоб перетягнути. Натисніть Escape, щоб скасувати перетягування.`,
  "dropDescriptionTouch": `Натисніть двічі, щоб перетягнути.`,
  "dropDescriptionVirtual": `Натисніть, щоб перетягнути.`,
  "dropIndicator": `індикатор перетягування`,
  "dropOnItem": (args2) => `Перетягнути на ${args2.itemText}`,
  "dropOnRoot": `Перетягнути на`,
  "endDragKeyboard": `Триває перетягування. Натисніть Enter, щоб скасувати перетягування.`,
  "endDragTouch": `Триває перетягування. Натисніть двічі, щоб скасувати перетягування.`,
  "endDragVirtual": `Триває перетягування. Натисніть, щоб скасувати перетягування.`,
  "insertAfter": (args2) => `Вставити після ${args2.itemText}`,
  "insertBefore": (args2) => `Вставити перед ${args2.itemText}`,
  "insertBetween": (args2) => `Вставити між ${args2.beforeItemText} і ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/zh-CN.mjs
var $d0f488d433b55b8a$exports = {};
$d0f488d433b55b8a$exports = {
  "dragDescriptionKeyboard": `按 Enter 开始拖动。`,
  "dragDescriptionKeyboardAlt": `按 Alt + Enter 开始拖动。`,
  "dragDescriptionLongPress": `长按以开始拖动。`,
  "dragDescriptionTouch": `双击开始拖动。`,
  "dragDescriptionVirtual": `单击开始拖动。`,
  "dragItem": (args2) => `拖动 ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `拖动 ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} 选中项目`,
    other: () => `${formatter.number(args2.count)} 选中项目`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `按 Enter 以拖动 ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} 个选定项`,
    other: () => `${formatter.number(args2.count)} 个选定项`
  })}。`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `按 Alt + Enter 以拖动 ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} 个选定项`,
    other: () => `${formatter.number(args2.count)} 个选定项`
  })}。`,
  "dragSelectedLongPress": (args2, formatter) => `长按以拖动 ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} 个选定项`,
    other: () => `${formatter.number(args2.count)} 个选定项`
  })}。`,
  "dragStartedKeyboard": `已开始拖动。按 Tab 导航到放置目标，然后按 Enter 放置或按 Escape 取消。`,
  "dragStartedTouch": `已开始拖动。导航到放置目标，然后双击放置。`,
  "dragStartedVirtual": `已开始拖动。导航到放置目标，然后单击或按 Enter 放置。`,
  "dropCanceled": `放置已取消。`,
  "dropComplete": `放置已完成。`,
  "dropDescriptionKeyboard": `按 Enter 放置。按 Escape 取消拖动。`,
  "dropDescriptionTouch": `双击放置。`,
  "dropDescriptionVirtual": `单击放置。`,
  "dropIndicator": `放置标记`,
  "dropOnItem": (args2) => `放置于 ${args2.itemText}`,
  "dropOnRoot": `放置于`,
  "endDragKeyboard": `正在拖动。按 Enter 取消拖动。`,
  "endDragTouch": `正在拖动。双击取消拖动。`,
  "endDragVirtual": `正在拖动。单击取消拖动。`,
  "insertAfter": (args2) => `插入到 ${args2.itemText} 之后`,
  "insertBefore": (args2) => `插入到 ${args2.itemText} 之前`,
  "insertBetween": (args2) => `插入到 ${args2.beforeItemText} 和 ${args2.afterItemText} 之间`
};

// node_modules/@react-aria/dnd/dist/zh-TW.mjs
var $46168b0dce85301e$exports = {};
$46168b0dce85301e$exports = {
  "dragDescriptionKeyboard": `按 Enter 鍵以開始拖曳。`,
  "dragDescriptionKeyboardAlt": `按 Alt+Enter 鍵以開始拖曳。`,
  "dragDescriptionLongPress": `長按以開始拖曳。`,
  "dragDescriptionTouch": `輕點兩下以開始拖曳。`,
  "dragDescriptionVirtual": `按一下滑鼠以開始拖曳。`,
  "dragItem": (args2) => `拖曳「${args2.itemText}」`,
  "dragSelectedItems": (args2, formatter) => `拖曳 ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} 個選定項目`,
    other: () => `${formatter.number(args2.count)} 個選定項目`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `按 Enter 鍵以拖曳 ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} 個選定項目`,
    other: () => `${formatter.number(args2.count)} 個選定項目`
  })}。`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `按 Alt+Enter 鍵以拖曳 ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} 個選定項目`,
    other: () => `${formatter.number(args2.count)} 個選定項目`
  })}。`,
  "dragSelectedLongPress": (args2, formatter) => `長按以拖曳 ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} 個選定項目`,
    other: () => `${formatter.number(args2.count)} 個選定項目`
  })}。`,
  "dragStartedKeyboard": `已開始拖曳。按 Tab 鍵以瀏覽至放置目標，然後按 Enter 鍵以放置，或按 Escape 鍵以取消。`,
  "dragStartedTouch": `已開始拖曳。瀏覽至放置目標，然後輕點兩下以放置。`,
  "dragStartedVirtual": `已開始拖曳。瀏覽至放置目標，然後按一下滑鼠或按 Enter 鍵以放置。`,
  "dropCanceled": `放置已取消。`,
  "dropComplete": `放置已完成。`,
  "dropDescriptionKeyboard": `按 Enter 鍵以放置。按 Escape 鍵以取消拖曳。`,
  "dropDescriptionTouch": `輕點兩下以放置。`,
  "dropDescriptionVirtual": `按一下滑鼠以放置。`,
  "dropIndicator": `放置指示器`,
  "dropOnItem": (args2) => `放置在「${args2.itemText}」上`,
  "dropOnRoot": `放置在`,
  "endDragKeyboard": `拖曳中。按 Enter 鍵以取消拖曳。`,
  "endDragTouch": `拖曳中。輕點兩下以取消拖曳。`,
  "endDragVirtual": `拖曳中。按一下滑鼠以取消拖曳。`,
  "insertAfter": (args2) => `插入至「${args2.itemText}」之後`,
  "insertBefore": (args2) => `插入至「${args2.itemText}」之前`,
  "insertBetween": (args2) => `插入至「${args2.beforeItemText}」和「${args2.afterItemText}」之間`
};

// node_modules/@react-aria/dnd/dist/import.mjs
var import_react30 = __toESM(require_react(), 1);

// node_modules/@react-aria/live-announcer/dist/import.mjs
var $319e236875307eab$var$LIVEREGION_TIMEOUT_DELAY = 7e3;
var $319e236875307eab$var$liveAnnouncer = null;
function $319e236875307eab$export$a9b970dcc4ae71a9(message, assertiveness = "assertive", timeout = $319e236875307eab$var$LIVEREGION_TIMEOUT_DELAY) {
  if (!$319e236875307eab$var$liveAnnouncer)
    $319e236875307eab$var$liveAnnouncer = new $319e236875307eab$var$LiveAnnouncer();
  $319e236875307eab$var$liveAnnouncer.announce(message, assertiveness, timeout);
}
function $319e236875307eab$export$d10ae4f68404609a(assertiveness) {
  if ($319e236875307eab$var$liveAnnouncer)
    $319e236875307eab$var$liveAnnouncer.clear(assertiveness);
}
var $319e236875307eab$var$LiveAnnouncer = class {
  createLog(ariaLive) {
    let node4 = document.createElement("div");
    node4.setAttribute("role", "log");
    node4.setAttribute("aria-live", ariaLive);
    node4.setAttribute("aria-relevant", "additions");
    return node4;
  }
  destroy() {
    if (!this.node)
      return;
    document.body.removeChild(this.node);
    this.node = null;
  }
  announce(message, assertiveness = "assertive", timeout = $319e236875307eab$var$LIVEREGION_TIMEOUT_DELAY) {
    if (!this.node)
      return;
    let node4 = document.createElement("div");
    node4.textContent = message;
    if (assertiveness === "assertive")
      this.assertiveLog.appendChild(node4);
    else
      this.politeLog.appendChild(node4);
    if (message !== "")
      setTimeout(() => {
        node4.remove();
      }, timeout);
  }
  clear(assertiveness) {
    if (!this.node)
      return;
    if (!assertiveness || assertiveness === "assertive")
      this.assertiveLog.innerHTML = "";
    if (!assertiveness || assertiveness === "polite")
      this.politeLog.innerHTML = "";
  }
  constructor() {
    this.node = document.createElement("div");
    this.node.dataset.liveAnnouncer = "true";
    Object.assign(this.node.style, {
      border: 0,
      clip: "rect(0 0 0 0)",
      clipPath: "inset(50%)",
      height: "1px",
      margin: "-1px",
      overflow: "hidden",
      padding: 0,
      position: "absolute",
      width: "1px",
      whiteSpace: "nowrap"
    });
    this.assertiveLog = this.createLog("assertive");
    this.node.appendChild(this.assertiveLog);
    this.politeLog = this.createLog("polite");
    this.node.appendChild(this.politeLog);
    document.body.prepend(this.node);
  }
};

// node_modules/@react-aria/dnd/dist/import.mjs
var import_react_dom2 = __toESM(require_react_dom(), 1);
function $parcel$interopDefault2(a3) {
  return a3 && a3.__esModule ? a3.default : a3;
}
var $103790afe9474d1c$export$60b7b4bcf3903d8e;
(function(DROP_OPERATION) {
  DROP_OPERATION[DROP_OPERATION["none"] = 0] = "none";
  DROP_OPERATION[DROP_OPERATION["cancel"] = 0] = "cancel";
  DROP_OPERATION[DROP_OPERATION["move"] = 1] = "move";
  DROP_OPERATION[DROP_OPERATION["copy"] = 2] = "copy";
  DROP_OPERATION[DROP_OPERATION["link"] = 4] = "link";
  DROP_OPERATION[DROP_OPERATION["all"] = 7] = "all";
})($103790afe9474d1c$export$60b7b4bcf3903d8e || ($103790afe9474d1c$export$60b7b4bcf3903d8e = {}));
var $103790afe9474d1c$export$9bbdfc78cf083e16 = {
  ...$103790afe9474d1c$export$60b7b4bcf3903d8e,
  copyMove: 3,
  copyLink: 6,
  linkMove: 5,
  all: 7,
  uninitialized: 7
};
var $103790afe9474d1c$export$dd0165308d8bff45 = $103790afe9474d1c$var$invert($103790afe9474d1c$export$9bbdfc78cf083e16);
$103790afe9474d1c$export$dd0165308d8bff45[7] = "all";
var $103790afe9474d1c$export$d7ebf00f36b7a95e = $103790afe9474d1c$var$invert($103790afe9474d1c$export$60b7b4bcf3903d8e);
var $103790afe9474d1c$export$608ecc6f1b23c35d = {
  none: "cancel",
  link: "link",
  copy: "copy",
  move: "move"
};
var $103790afe9474d1c$export$5eacb0769d26d3b2 = $103790afe9474d1c$var$invert($103790afe9474d1c$export$608ecc6f1b23c35d);
function $103790afe9474d1c$var$invert(object2) {
  let res = {};
  for (let key in object2)
    res[object2[key]] = key;
  return res;
}
var $103790afe9474d1c$export$4a7729b856e9a690 = /* @__PURE__ */ new Set([
  "text/plain",
  "text/uri-list",
  "text/html"
]);
var $103790afe9474d1c$export$fd9f9fc120c5402d = "application/vnd.react-aria.items+json";
var $103790afe9474d1c$export$f8fc6581787339b3 = "application/octet-stream";
var $7252cd45fc48c07c$export$dfdf5deeaf27473f = /* @__PURE__ */ new WeakMap();
var $7252cd45fc48c07c$export$990fced5dfac2637 = Symbol();
function $7252cd45fc48c07c$export$3093291712f09a77(state) {
  let { id: id2 } = $7252cd45fc48c07c$export$dfdf5deeaf27473f.get(state);
  if (!id2)
    throw new Error("Droppable item outside a droppable collection");
  return id2;
}
function $7252cd45fc48c07c$export$7e397efd01d3db27(state) {
  let { ref } = $7252cd45fc48c07c$export$dfdf5deeaf27473f.get(state);
  if (!ref)
    throw new Error("Droppable item outside a droppable collection");
  return ref;
}
function $7252cd45fc48c07c$export$e1d41611756c6326(items) {
  let types3 = /* @__PURE__ */ new Set();
  for (let item2 of items)
    for (let type2 of Object.keys(item2))
      types3.add(type2);
  return types3;
}
function $7252cd45fc48c07c$var$mapModality(modality) {
  if (!modality)
    modality = "virtual";
  if (modality === "pointer")
    modality = "virtual";
  if (modality === "virtual" && typeof window !== "undefined" && "ontouchstart" in window)
    modality = "touch";
  return modality;
}
function $7252cd45fc48c07c$export$49bac5d6d4b352ea() {
  return $7252cd45fc48c07c$var$mapModality((0, $507fabe10e71c6fb$export$98e20ec92f614cfe)());
}
function $7252cd45fc48c07c$export$1fb2158d224b542c() {
  return $7252cd45fc48c07c$var$mapModality((0, $507fabe10e71c6fb$export$630ff653c5ada6a9)());
}
function $7252cd45fc48c07c$export$f9c1490890ddd063(dataTransfer, items) {
  let groupedByType = /* @__PURE__ */ new Map();
  let needsCustomData = false;
  let customData = [];
  for (let item2 of items) {
    let types3 = Object.keys(item2);
    if (types3.length > 1)
      needsCustomData = true;
    let dataByType = {};
    for (let type2 of types3) {
      let typeItems = groupedByType.get(type2);
      if (!typeItems) {
        typeItems = [];
        groupedByType.set(type2, typeItems);
      } else
        needsCustomData = true;
      let data = item2[type2];
      dataByType[type2] = data;
      typeItems.push(data);
    }
    customData.push(dataByType);
  }
  for (let [type2, items2] of groupedByType)
    if ((0, $103790afe9474d1c$export$4a7729b856e9a690).has(type2)) {
      let data = items2.join("\n");
      dataTransfer.items.add(data, type2);
    } else
      dataTransfer.items.add(items2[0], type2);
  if (needsCustomData) {
    let data = JSON.stringify(customData);
    dataTransfer.items.add(data, (0, $103790afe9474d1c$export$fd9f9fc120c5402d));
  }
}
var $7252cd45fc48c07c$export$7f04ce188c91447c = class {
  has(type2) {
    if (this.includesUnknownTypes || type2 === $7252cd45fc48c07c$export$990fced5dfac2637 && this.types.has((0, $103790afe9474d1c$export$f8fc6581787339b3)))
      return true;
    return typeof type2 === "string" && this.types.has(type2);
  }
  constructor(dataTransfer) {
    this.types = /* @__PURE__ */ new Set();
    let hasFiles = false;
    for (let item2 of dataTransfer.items)
      if (item2.type !== (0, $103790afe9474d1c$export$fd9f9fc120c5402d)) {
        if (item2.kind === "file")
          hasFiles = true;
        if (item2.type)
          this.types.add(item2.type);
        else
          this.types.add((0, $103790afe9474d1c$export$f8fc6581787339b3));
      }
    this.includesUnknownTypes = !hasFiles && dataTransfer.types.includes("Files");
  }
};
function $7252cd45fc48c07c$export$d9e760437831f8b3(dataTransfer) {
  let items = [];
  let hasCustomType = false;
  if (dataTransfer.types.includes((0, $103790afe9474d1c$export$fd9f9fc120c5402d)))
    try {
      let data = dataTransfer.getData((0, $103790afe9474d1c$export$fd9f9fc120c5402d));
      let parsed = JSON.parse(data);
      for (let item2 of parsed)
        items.push({
          kind: "text",
          types: new Set(Object.keys(item2)),
          getText: (type2) => Promise.resolve(item2[type2])
        });
      hasCustomType = true;
    } catch (e6) {
    }
  if (!hasCustomType) {
    let stringItems = /* @__PURE__ */ new Map();
    for (let item2 of dataTransfer.items) {
      if (item2.kind === "string")
        stringItems.set(item2.type || (0, $103790afe9474d1c$export$f8fc6581787339b3), dataTransfer.getData(item2.type));
      else if (item2.kind === "file") {
        if (typeof item2.webkitGetAsEntry === "function") {
          let entry = item2.webkitGetAsEntry();
          if (!entry)
            continue;
          if (entry.isFile)
            items.push($7252cd45fc48c07c$var$createFileItem(item2.getAsFile()));
          else if (entry.isDirectory)
            items.push($7252cd45fc48c07c$var$createDirectoryItem(entry));
        } else
          items.push($7252cd45fc48c07c$var$createFileItem(item2.getAsFile()));
      }
    }
    if (stringItems.size > 0)
      items.push({
        kind: "text",
        types: new Set(stringItems.keys()),
        getText: (type2) => Promise.resolve(stringItems.get(type2))
      });
  }
  return items;
}
function $7252cd45fc48c07c$var$blobToString(blob) {
  if (typeof blob.text === "function")
    return blob.text();
  return new Promise((resolve3, reject) => {
    let reader = new FileReader();
    reader.onload = () => {
      resolve3(reader.result);
    };
    reader.onerror = reject;
    reader.readAsText(blob);
  });
}
function $7252cd45fc48c07c$var$createFileItem(file) {
  return {
    kind: "file",
    type: file.type || (0, $103790afe9474d1c$export$f8fc6581787339b3),
    name: file.name,
    getText: () => $7252cd45fc48c07c$var$blobToString(file),
    getFile: () => Promise.resolve(file)
  };
}
function $7252cd45fc48c07c$var$createDirectoryItem(entry) {
  return {
    kind: "directory",
    name: entry.name,
    getEntries: () => $7252cd45fc48c07c$var$getEntries(entry)
  };
}
async function* $7252cd45fc48c07c$var$getEntries(item2) {
  let reader = item2.createReader();
  let entries2;
  do {
    entries2 = await new Promise((resolve3, reject) => {
      reader.readEntries(resolve3, reject);
    });
    for (let entry of entries2) {
      if (entry.isFile) {
        let file = await $7252cd45fc48c07c$var$getEntryFile(entry);
        yield $7252cd45fc48c07c$var$createFileItem(file);
      } else if (entry.isDirectory)
        yield $7252cd45fc48c07c$var$createDirectoryItem(entry);
    }
  } while (entries2.length > 0);
}
function $7252cd45fc48c07c$var$getEntryFile(entry) {
  return new Promise((resolve3, reject) => entry.file(resolve3, reject));
}
var $7252cd45fc48c07c$export$6ca6700462636d0b = {
  draggingKeys: /* @__PURE__ */ new Set()
};
function $7252cd45fc48c07c$export$f2be18a910c0caa6(ref) {
  $7252cd45fc48c07c$export$6ca6700462636d0b.draggingCollectionRef = ref;
}
function $7252cd45fc48c07c$export$72cb63bdda528276(keys3) {
  $7252cd45fc48c07c$export$6ca6700462636d0b.draggingKeys = keys3;
}
function $7252cd45fc48c07c$export$dac8db29d42db9a1(ref) {
  $7252cd45fc48c07c$export$6ca6700462636d0b.dropCollectionRef = ref;
}
function $7252cd45fc48c07c$export$70936501603e6c57() {
  $7252cd45fc48c07c$export$6ca6700462636d0b = {
    draggingKeys: /* @__PURE__ */ new Set()
  };
}
function $7252cd45fc48c07c$export$6c10d32b362bfa5f(state) {
  $7252cd45fc48c07c$export$6ca6700462636d0b = state;
}
function $7252cd45fc48c07c$export$78bf638634500fa5(ref) {
  let { draggingCollectionRef, dropCollectionRef } = $7252cd45fc48c07c$export$6ca6700462636d0b;
  return (draggingCollectionRef === null || draggingCollectionRef === void 0 ? void 0 : draggingCollectionRef.current) != null && draggingCollectionRef.current === ((ref === null || ref === void 0 ? void 0 : ref.current) || (dropCollectionRef === null || dropCollectionRef === void 0 ? void 0 : dropCollectionRef.current));
}
var $7252cd45fc48c07c$export$8e6636520ac15722;
function $7252cd45fc48c07c$export$64f52ed7349ddb84(dropEffect) {
  $7252cd45fc48c07c$export$8e6636520ac15722 = dropEffect;
}
var $7252cd45fc48c07c$export$f0130eb70b6347b8 = (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).none;
function $7252cd45fc48c07c$export$6539bc8c3a0a2d67(o5) {
  $7252cd45fc48c07c$export$f0130eb70b6347b8 = o5;
}
var $67560de7c78cb232$var$dropTargets = /* @__PURE__ */ new Map();
var $67560de7c78cb232$var$dropItems = /* @__PURE__ */ new Map();
var $67560de7c78cb232$var$dragSession = null;
var $67560de7c78cb232$var$subscriptions = /* @__PURE__ */ new Set();
function $67560de7c78cb232$export$c28d9fb4a54e471a(target) {
  $67560de7c78cb232$var$dropTargets.set(target.element, target);
  $67560de7c78cb232$var$dragSession === null || $67560de7c78cb232$var$dragSession === void 0 ? void 0 : $67560de7c78cb232$var$dragSession.updateValidDropTargets();
  return () => {
    $67560de7c78cb232$var$dropTargets.delete(target.element);
    $67560de7c78cb232$var$dragSession === null || $67560de7c78cb232$var$dragSession === void 0 ? void 0 : $67560de7c78cb232$var$dragSession.updateValidDropTargets();
  };
}
function $67560de7c78cb232$export$aef80212ac99c003(item2) {
  $67560de7c78cb232$var$dropItems.set(item2.element, item2);
  return () => {
    $67560de7c78cb232$var$dropItems.delete(item2.element);
  };
}
function $67560de7c78cb232$export$549dbcf8649bf3b2(target, stringFormatter) {
  if ($67560de7c78cb232$var$dragSession)
    throw new Error("Cannot begin dragging while already dragging");
  $67560de7c78cb232$var$dragSession = new $67560de7c78cb232$var$DragSession(target, stringFormatter);
  requestAnimationFrame(() => {
    $67560de7c78cb232$var$dragSession.setup();
    if ((0, $7252cd45fc48c07c$export$1fb2158d224b542c)() === "keyboard")
      $67560de7c78cb232$var$dragSession.next();
  });
  for (let cb of $67560de7c78cb232$var$subscriptions)
    cb();
}
function $67560de7c78cb232$export$418e185dd3f1b968() {
  let [session, setSession] = (0, import_react30.useState)($67560de7c78cb232$var$dragSession);
  (0, import_react30.useEffect)(() => {
    let cb = () => setSession($67560de7c78cb232$var$dragSession);
    $67560de7c78cb232$var$subscriptions.add(cb);
    return () => {
      $67560de7c78cb232$var$subscriptions.delete(cb);
    };
  }, []);
  return session;
}
function $67560de7c78cb232$export$403bc76cbf68cf60() {
  return !!$67560de7c78cb232$var$dragSession;
}
function $67560de7c78cb232$var$endDragging() {
  $67560de7c78cb232$var$dragSession = null;
  for (let cb of $67560de7c78cb232$var$subscriptions)
    cb();
}
var $67560de7c78cb232$var$CANCELED_EVENTS = [
  "pointerdown",
  "pointermove",
  "pointerenter",
  "pointerleave",
  "pointerover",
  "pointerout",
  "pointerup",
  "mousedown",
  "mousemove",
  "mouseenter",
  "mouseleave",
  "mouseover",
  "mouseout",
  "mouseup",
  "touchstart",
  "touchmove",
  "touchend",
  "focusin",
  "focusout"
];
var $67560de7c78cb232$var$CLICK_EVENTS = [
  "pointerup",
  "mouseup",
  "touchend"
];
var $67560de7c78cb232$var$MESSAGES = {
  keyboard: "dragStartedKeyboard",
  touch: "dragStartedTouch",
  virtual: "dragStartedVirtual"
};
var $67560de7c78cb232$var$DragSession = class {
  setup() {
    document.addEventListener("keydown", this.onKeyDown, true);
    document.addEventListener("keyup", this.onKeyUp, true);
    window.addEventListener("focus", this.onFocus, true);
    window.addEventListener("blur", this.onBlur, true);
    document.addEventListener("click", this.onClick, true);
    document.addEventListener("pointerdown", this.onPointerDown, true);
    for (let event of $67560de7c78cb232$var$CANCELED_EVENTS)
      document.addEventListener(event, this.cancelEvent, true);
    this.mutationObserver = new MutationObserver(() => this.updateValidDropTargets());
    this.updateValidDropTargets();
    (0, $319e236875307eab$export$a9b970dcc4ae71a9)(this.stringFormatter.format($67560de7c78cb232$var$MESSAGES[(0, $7252cd45fc48c07c$export$1fb2158d224b542c)()]));
  }
  teardown() {
    document.removeEventListener("keydown", this.onKeyDown, true);
    document.removeEventListener("keyup", this.onKeyUp, true);
    window.removeEventListener("focus", this.onFocus, true);
    window.removeEventListener("blur", this.onBlur, true);
    document.removeEventListener("click", this.onClick, true);
    document.removeEventListener("pointerdown", this.onPointerDown, true);
    for (let event of $67560de7c78cb232$var$CANCELED_EVENTS)
      document.removeEventListener(event, this.cancelEvent, true);
    this.mutationObserver.disconnect();
    this.restoreAriaHidden();
  }
  onKeyDown(e6) {
    var _this_currentDropTarget;
    this.cancelEvent(e6);
    if (e6.key === "Escape") {
      this.cancel();
      return;
    }
    if (e6.key === "Tab" && !(e6.metaKey || e6.altKey || e6.ctrlKey)) {
      if (e6.shiftKey)
        this.previous();
      else
        this.next();
    }
    if (typeof ((_this_currentDropTarget = this.currentDropTarget) === null || _this_currentDropTarget === void 0 ? void 0 : _this_currentDropTarget.onKeyDown) === "function")
      this.currentDropTarget.onKeyDown(e6, this.dragTarget);
  }
  onKeyUp(e6) {
    this.cancelEvent(e6);
    if (e6.key === "Enter") {
      if (e6.altKey)
        this.activate();
      else
        this.drop();
    }
  }
  onFocus(e6) {
    if (e6.target !== this.dragTarget.element)
      this.cancelEvent(e6);
    if (!(e6.target instanceof HTMLElement) || e6.target === this.dragTarget.element)
      return;
    let dropTarget = this.validDropTargets.find((target) => target.element === e6.target) || this.validDropTargets.find((target) => target.element.contains(e6.target));
    if (!dropTarget) {
      if (this.currentDropTarget)
        this.currentDropTarget.element.focus();
      else
        this.dragTarget.element.focus();
      return;
    }
    let item2 = $67560de7c78cb232$var$dropItems.get(e6.target);
    this.setCurrentDropTarget(dropTarget, item2);
  }
  onBlur(e6) {
    if (e6.target !== this.dragTarget.element)
      this.cancelEvent(e6);
    if (!e6.relatedTarget || !(e6.relatedTarget instanceof HTMLElement)) {
      if (this.currentDropTarget)
        this.currentDropTarget.element.focus();
      else
        this.dragTarget.element.focus();
    }
  }
  onClick(e6) {
    this.cancelEvent(e6);
    if ((0, $6a7db85432448f7f$export$60278871457622de)(e6) || this.isVirtualClick) {
      if (e6.target === this.dragTarget.element) {
        this.cancel();
        return;
      }
      let dropTarget = this.validDropTargets.find((target) => target.element.contains(e6.target));
      if (dropTarget) {
        let item2 = $67560de7c78cb232$var$dropItems.get(e6.target);
        this.setCurrentDropTarget(dropTarget, item2);
        this.drop(item2);
      }
    }
  }
  onPointerDown(e6) {
    this.cancelEvent(e6);
    this.isVirtualClick = (0, $6a7db85432448f7f$export$29bf1b5f2c56cf63)(e6);
  }
  cancelEvent(e6) {
    var _this_dragTarget;
    if ((e6.type === "focusin" || e6.type === "focusout") && e6.target === ((_this_dragTarget = this.dragTarget) === null || _this_dragTarget === void 0 ? void 0 : _this_dragTarget.element))
      return;
    if (!$67560de7c78cb232$var$CLICK_EVENTS.includes(e6.type))
      e6.preventDefault();
    e6.stopPropagation();
    e6.stopImmediatePropagation();
  }
  updateValidDropTargets() {
    if (!this.mutationObserver)
      return;
    this.mutationObserver.disconnect();
    if (this.restoreAriaHidden)
      this.restoreAriaHidden();
    this.validDropTargets = $67560de7c78cb232$var$findValidDropTargets(this.dragTarget);
    if (this.validDropTargets.length > 0) {
      let nearestIndex = this.findNearestDropTarget();
      this.validDropTargets = [
        ...this.validDropTargets.slice(nearestIndex),
        ...this.validDropTargets.slice(0, nearestIndex)
      ];
    }
    if (this.currentDropTarget && !this.validDropTargets.includes(this.currentDropTarget))
      this.setCurrentDropTarget(this.validDropTargets[0]);
    let types3 = (0, $7252cd45fc48c07c$export$e1d41611756c6326)(this.dragTarget.items);
    let validDropItems = [
      ...$67560de7c78cb232$var$dropItems.values()
    ].filter((item2) => {
      if (typeof item2.getDropOperation === "function")
        return item2.getDropOperation(types3, this.dragTarget.allowedDropOperations) !== "cancel";
      return true;
    });
    let visibleDropTargets = this.validDropTargets.filter((target) => !validDropItems.some((item2) => target.element.contains(item2.element)));
    this.restoreAriaHidden = (0, $5e3802645cc19319$export$1c3ebcada18427bf)([
      this.dragTarget.element,
      ...validDropItems.map((item2) => item2.element),
      ...visibleDropTargets.map((target) => target.element)
    ]);
    this.mutationObserver.observe(document.body, {
      subtree: true,
      attributes: true,
      attributeFilter: [
        "aria-hidden"
      ]
    });
  }
  next() {
    if (!this.currentDropTarget) {
      this.setCurrentDropTarget(this.validDropTargets[0]);
      return;
    }
    let index3 = this.validDropTargets.indexOf(this.currentDropTarget);
    if (index3 < 0) {
      this.setCurrentDropTarget(this.validDropTargets[0]);
      return;
    }
    if (index3 === this.validDropTargets.length - 1) {
      if (!this.dragTarget.element.closest('[aria-hidden="true"]')) {
        this.setCurrentDropTarget(null);
        this.dragTarget.element.focus();
      } else
        this.setCurrentDropTarget(this.validDropTargets[0]);
    } else
      this.setCurrentDropTarget(this.validDropTargets[index3 + 1]);
  }
  previous() {
    if (!this.currentDropTarget) {
      this.setCurrentDropTarget(this.validDropTargets[this.validDropTargets.length - 1]);
      return;
    }
    let index3 = this.validDropTargets.indexOf(this.currentDropTarget);
    if (index3 < 0) {
      this.setCurrentDropTarget(this.validDropTargets[this.validDropTargets.length - 1]);
      return;
    }
    if (index3 === 0) {
      if (!this.dragTarget.element.closest('[aria-hidden="true"]')) {
        this.setCurrentDropTarget(null);
        this.dragTarget.element.focus();
      } else
        this.setCurrentDropTarget(this.validDropTargets[this.validDropTargets.length - 1]);
    } else
      this.setCurrentDropTarget(this.validDropTargets[index3 - 1]);
  }
  findNearestDropTarget() {
    let dragTargetRect = this.dragTarget.element.getBoundingClientRect();
    let minDistance = Infinity;
    let nearest = -1;
    for (let i6 = 0; i6 < this.validDropTargets.length; i6++) {
      let dropTarget = this.validDropTargets[i6];
      let rect = dropTarget.element.getBoundingClientRect();
      let dx = rect.left - dragTargetRect.left;
      let dy = rect.top - dragTargetRect.top;
      let dist = dx * dx + dy * dy;
      if (dist < minDistance) {
        minDistance = dist;
        nearest = i6;
      }
    }
    return nearest;
  }
  setCurrentDropTarget(dropTarget, item2) {
    if (dropTarget !== this.currentDropTarget) {
      if (this.currentDropTarget && typeof this.currentDropTarget.onDropExit === "function") {
        let rect = this.currentDropTarget.element.getBoundingClientRect();
        this.currentDropTarget.onDropExit({
          type: "dropexit",
          x: rect.left + rect.width / 2,
          y: rect.top + rect.height / 2
        });
      }
      this.currentDropTarget = dropTarget;
      if (dropTarget) {
        if (typeof dropTarget.onDropEnter === "function") {
          let rect = dropTarget.element.getBoundingClientRect();
          dropTarget.onDropEnter({
            type: "dropenter",
            x: rect.left + rect.width / 2,
            y: rect.top + rect.height / 2
          }, this.dragTarget);
        }
        if (!item2)
          dropTarget === null || dropTarget === void 0 ? void 0 : dropTarget.element.focus();
      }
    }
    if (item2 !== this.currentDropItem) {
      if (item2 && typeof this.currentDropTarget.onDropTargetEnter === "function")
        this.currentDropTarget.onDropTargetEnter(item2 === null || item2 === void 0 ? void 0 : item2.target);
      item2 === null || item2 === void 0 ? void 0 : item2.element.focus();
      this.currentDropItem = item2;
      if (!this.initialFocused) {
        (0, $319e236875307eab$export$a9b970dcc4ae71a9)(item2 === null || item2 === void 0 ? void 0 : item2.element.getAttribute("aria-label"), "polite");
        this.initialFocused = true;
      }
    }
  }
  end() {
    this.teardown();
    $67560de7c78cb232$var$endDragging();
    if (typeof this.dragTarget.onDragEnd === "function") {
      let target = this.currentDropTarget && this.dropOperation !== "cancel" ? this.currentDropTarget : this.dragTarget;
      let rect = target.element.getBoundingClientRect();
      this.dragTarget.onDragEnd({
        type: "dragend",
        x: rect.x + rect.width / 2,
        y: rect.y + rect.height / 2,
        dropOperation: this.dropOperation || "cancel"
      });
    }
    if (this.currentDropTarget) {
      if (!this.dragTarget.element.contains(this.currentDropTarget.element)) {
        this.dragTarget.element.dispatchEvent(new FocusEvent("blur"));
        this.dragTarget.element.dispatchEvent(new FocusEvent("focusout", {
          bubbles: true
        }));
      }
      (0, import_react_dom2.flushSync)(() => {
        this.currentDropTarget.element.blur();
      });
      this.currentDropTarget.element.focus();
    }
    this.setCurrentDropTarget(null);
  }
  cancel() {
    this.setCurrentDropTarget(null);
    this.end();
    if (!this.dragTarget.element.closest('[aria-hidden="true"]'))
      this.dragTarget.element.focus();
    (0, $319e236875307eab$export$a9b970dcc4ae71a9)(this.stringFormatter.format("dropCanceled"));
  }
  drop(item2) {
    if (!this.currentDropTarget) {
      this.cancel();
      return;
    }
    if (typeof (item2 === null || item2 === void 0 ? void 0 : item2.getDropOperation) === "function") {
      let types3 = (0, $7252cd45fc48c07c$export$e1d41611756c6326)(this.dragTarget.items);
      this.dropOperation = item2.getDropOperation(types3, this.dragTarget.allowedDropOperations);
    } else if (typeof this.currentDropTarget.getDropOperation === "function") {
      let types3 = (0, $7252cd45fc48c07c$export$e1d41611756c6326)(this.dragTarget.items);
      this.dropOperation = this.currentDropTarget.getDropOperation(types3, this.dragTarget.allowedDropOperations);
    } else
      this.dropOperation = this.dragTarget.allowedDropOperations[0];
    if (typeof this.currentDropTarget.onDrop === "function") {
      let items = this.dragTarget.items.map((item3) => ({
        kind: "text",
        types: new Set(Object.keys(item3)),
        getText: (type2) => Promise.resolve(item3[type2])
      }));
      let rect = this.currentDropTarget.element.getBoundingClientRect();
      this.currentDropTarget.onDrop({
        type: "drop",
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2,
        items,
        dropOperation: this.dropOperation
      }, item2 === null || item2 === void 0 ? void 0 : item2.target);
    }
    this.end();
    (0, $319e236875307eab$export$a9b970dcc4ae71a9)(this.stringFormatter.format("dropComplete"));
  }
  activate() {
    if (this.currentDropTarget && typeof this.currentDropTarget.onDropActivate === "function") {
      let rect = this.currentDropTarget.element.getBoundingClientRect();
      this.currentDropTarget.onDropActivate({
        type: "dropactivate",
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2
      });
    }
  }
  constructor(target, stringFormatter) {
    this.dragTarget = target;
    this.stringFormatter = stringFormatter;
    this.onKeyDown = this.onKeyDown.bind(this);
    this.onKeyUp = this.onKeyUp.bind(this);
    this.onFocus = this.onFocus.bind(this);
    this.onBlur = this.onBlur.bind(this);
    this.onClick = this.onClick.bind(this);
    this.onPointerDown = this.onPointerDown.bind(this);
    this.cancelEvent = this.cancelEvent.bind(this);
    this.initialFocused = false;
  }
};
function $67560de7c78cb232$var$findValidDropTargets(options) {
  let types3 = (0, $7252cd45fc48c07c$export$e1d41611756c6326)(options.items);
  return [
    ...$67560de7c78cb232$var$dropTargets.values()
  ].filter((target) => {
    if (target.element.closest('[aria-hidden="true"]'))
      return false;
    if (typeof target.getDropOperation === "function")
      return target.getDropOperation(types3, options.allowedDropOperations) !== "cancel";
    return true;
  });
}
var $865c2eb7c00a83f1$exports = {};
$865c2eb7c00a83f1$exports = {
  "ar-AE": $7dfcac1a0c98c789$exports,
  "bg-BG": $f311c26671219eca$exports,
  "cs-CZ": $1aa4ade186550f72$exports,
  "da-DK": $b6b0ea1b94a7633c$exports,
  "de-DE": $d10e4f47c744ad52$exports,
  "el-GR": $b3d2bb9abce688ab$exports,
  "en-US": $f9b46437e610cca1$exports,
  "es-ES": $204b5c01bd3acf26$exports,
  "et-EE": $110bdd83348ecbc0$exports,
  "fi-FI": $87d3ccd5e347c7cc$exports,
  "fr-FR": $a5de891427686596$exports,
  "he-IL": $ad7f4c66d85b4494$exports,
  "hr-HR": $4aa59f3c6a796cae$exports,
  "hu-HU": $d8d3646556c40586$exports,
  "it-IT": $982d558b45395246$exports,
  "ja-JP": $6a0cf387b9de036c$exports,
  "ko-KR": $a97fefa2956f4bcb$exports,
  "lt-LT": $5fb5837f94e1c150$exports,
  "lv-LV": $5b2e5709864cc922$exports,
  "nb-NO": $ee15bb8efb18cc69$exports,
  "nl-NL": $1daf2d4602e26ac4$exports,
  "pl-PL": $7115429b0f60511f$exports,
  "pt-BR": $5edd453ae5d4a8bc$exports,
  "pt-PT": $5f431994f708535e$exports,
  "ro-RO": $107b5e2e45e971f1$exports,
  "ru-RU": $d4b9c2f01c1892f7$exports,
  "sk-SK": $dbdc1942894e83e4$exports,
  "sl-SI": $fbaaaaebd547d998$exports,
  "sr-SP": $a0caa33f1e264489$exports,
  "sv-SE": $d576b66176f5c0ff$exports,
  "tr-TR": $0681f168c13d8f2a$exports,
  "uk-UA": $2bfbc1f42c1cf5a7$exports,
  "zh-CN": $d0f488d433b55b8a$exports,
  "zh-TW": $46168b0dce85301e$exports
};
var $8253ed7ece74b463$var$MESSAGES = {
  keyboard: {
    start: "dragDescriptionKeyboard",
    end: "endDragKeyboard"
  },
  touch: {
    start: "dragDescriptionTouch",
    end: "endDragTouch"
  },
  virtual: {
    start: "dragDescriptionVirtual",
    end: "endDragVirtual"
  }
};
function $8253ed7ece74b463$export$7941f8aafa4b6021(options) {
  let { hasDragButton } = options;
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault2($865c2eb7c00a83f1$exports)), "@react-aria/dnd");
  let state = (0, import_react30.useRef)({
    options,
    x: 0,
    y: 0
  }).current;
  state.options = options;
  let isDraggingRef = (0, import_react30.useRef)(false);
  let [isDragging, setDraggingState] = (0, import_react30.useState)(false);
  let setDragging = (isDragging2) => {
    isDraggingRef.current = isDragging2;
    setDraggingState(isDragging2);
  };
  let { addGlobalListener, removeAllGlobalListeners } = (0, $03deb23ff14920c4$export$4eaf04e54aa8eed6)();
  let modalityOnPointerDown = (0, import_react30.useRef)(null);
  let onDragStart = (e6) => {
    var _options_preview;
    if (e6.defaultPrevented)
      return;
    e6.stopPropagation();
    if (modalityOnPointerDown.current === "virtual") {
      e6.preventDefault();
      startDragging(e6.target);
      modalityOnPointerDown.current = null;
      return;
    }
    if (typeof options.onDragStart === "function")
      options.onDragStart({
        type: "dragstart",
        x: e6.clientX,
        y: e6.clientY
      });
    let items = options.getItems();
    (0, $7252cd45fc48c07c$export$f9c1490890ddd063)(e6.dataTransfer, items);
    let allowed = (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).all;
    if (typeof options.getAllowedDropOperations === "function") {
      let allowedOperations = options.getAllowedDropOperations();
      allowed = (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).none;
      for (let operation of allowedOperations)
        allowed |= (0, $103790afe9474d1c$export$60b7b4bcf3903d8e)[operation] || (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).none;
    }
    (0, $7252cd45fc48c07c$export$6539bc8c3a0a2d67)(allowed);
    e6.dataTransfer.effectAllowed = (0, $103790afe9474d1c$export$dd0165308d8bff45)[allowed] || "none";
    if (typeof ((_options_preview = options.preview) === null || _options_preview === void 0 ? void 0 : _options_preview.current) === "function")
      options.preview.current(items, (node4) => {
        let size3 = node4.getBoundingClientRect();
        let rect = e6.currentTarget.getBoundingClientRect();
        let x4 = e6.clientX - rect.x;
        let y4 = e6.clientY - rect.y;
        if (x4 > size3.width || y4 > size3.height) {
          x4 = size3.width / 2;
          y4 = size3.height / 2;
        }
        let height = 2 * Math.round(size3.height / 2);
        node4.style.height = `${height}px`;
        e6.dataTransfer.setDragImage(node4, x4, y4);
      });
    addGlobalListener(window, "drop", (e7) => {
      e7.preventDefault();
      e7.stopPropagation();
      console.warn("Drags initiated from the React Aria useDrag hook may only be dropped on a target created with useDrop. This ensures that a keyboard and screen reader accessible alternative is available.");
    }, {
      once: true
    });
    state.x = e6.clientX;
    state.y = e6.clientY;
    requestAnimationFrame(() => {
      setDragging(true);
    });
  };
  let onDrag = (e6) => {
    e6.stopPropagation();
    if (e6.clientX === state.x && e6.clientY === state.y)
      return;
    if (typeof options.onDragMove === "function")
      options.onDragMove({
        type: "dragmove",
        x: e6.clientX,
        y: e6.clientY
      });
    state.x = e6.clientX;
    state.y = e6.clientY;
  };
  let onDragEnd = (e6) => {
    e6.stopPropagation();
    if (typeof options.onDragEnd === "function") {
      let event = {
        type: "dragend",
        x: e6.clientX,
        y: e6.clientY,
        dropOperation: (0, $103790afe9474d1c$export$608ecc6f1b23c35d)[e6.dataTransfer.dropEffect]
      };
      if (0, $7252cd45fc48c07c$export$8e6636520ac15722)
        event.dropOperation = (0, $103790afe9474d1c$export$608ecc6f1b23c35d)[0, $7252cd45fc48c07c$export$8e6636520ac15722];
      options.onDragEnd(event);
    }
    setDragging(false);
    removeAllGlobalListeners();
    (0, $7252cd45fc48c07c$export$6539bc8c3a0a2d67)((0, $103790afe9474d1c$export$60b7b4bcf3903d8e).none);
    (0, $7252cd45fc48c07c$export$64f52ed7349ddb84)(void 0);
  };
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    return () => {
      if (isDraggingRef.current) {
        if (typeof state.options.onDragEnd === "function") {
          let event = {
            type: "dragend",
            x: 0,
            y: 0,
            dropOperation: (0, $103790afe9474d1c$export$608ecc6f1b23c35d)[(0, $7252cd45fc48c07c$export$8e6636520ac15722) || "none"]
          };
          state.options.onDragEnd(event);
        }
        setDragging(false);
        (0, $7252cd45fc48c07c$export$6539bc8c3a0a2d67)((0, $103790afe9474d1c$export$60b7b4bcf3903d8e).none);
        (0, $7252cd45fc48c07c$export$64f52ed7349ddb84)(void 0);
      }
    };
  }, [
    state
  ]);
  let onPress = (e6) => {
    if (e6.pointerType !== "keyboard" && e6.pointerType !== "virtual")
      return;
    startDragging(e6.target);
  };
  let startDragging = (target) => {
    if (typeof state.options.onDragStart === "function") {
      let rect = target.getBoundingClientRect();
      state.options.onDragStart({
        type: "dragstart",
        x: rect.x + rect.width / 2,
        y: rect.y + rect.height / 2
      });
    }
    $67560de7c78cb232$export$549dbcf8649bf3b2({
      element: target,
      items: state.options.getItems(),
      allowedDropOperations: typeof state.options.getAllowedDropOperations === "function" ? state.options.getAllowedDropOperations() : [
        "move",
        "copy",
        "link"
      ],
      onDragEnd(e6) {
        setDragging(false);
        if (typeof state.options.onDragEnd === "function")
          state.options.onDragEnd(e6);
      }
    }, stringFormatter);
    setDragging(true);
  };
  let modality = (0, $7252cd45fc48c07c$export$49bac5d6d4b352ea)();
  let message = !isDragging ? $8253ed7ece74b463$var$MESSAGES[modality].start : $8253ed7ece74b463$var$MESSAGES[modality].end;
  let descriptionProps = (0, $ef06256079686ba0$export$f8aeda7b10753fa1)(stringFormatter.format(message));
  let interactions;
  if (!hasDragButton)
    interactions = {
      ...descriptionProps,
      onPointerDown(e6) {
        modalityOnPointerDown.current = (0, $6a7db85432448f7f$export$29bf1b5f2c56cf63)(e6.nativeEvent) ? "virtual" : e6.pointerType;
        if (e6.width < 1 && e6.height < 1)
          modalityOnPointerDown.current = "virtual";
        else {
          let rect = e6.currentTarget.getBoundingClientRect();
          let offsetX = e6.clientX - rect.x;
          let offsetY = e6.clientY - rect.y;
          let centerX = rect.width / 2;
          let centerY = rect.height / 2;
          if (Math.abs(offsetX - centerX) <= 0.5 && Math.abs(offsetY - centerY) <= 0.5)
            modalityOnPointerDown.current = "virtual";
          else
            modalityOnPointerDown.current = e6.pointerType;
        }
      },
      onKeyDownCapture(e6) {
        if (e6.target === e6.currentTarget && e6.key === "Enter") {
          e6.preventDefault();
          e6.stopPropagation();
        }
      },
      onKeyUpCapture(e6) {
        if (e6.target === e6.currentTarget && e6.key === "Enter") {
          e6.preventDefault();
          e6.stopPropagation();
          startDragging(e6.target);
        }
      },
      onClick(e6) {
        if ((0, $6a7db85432448f7f$export$60278871457622de)(e6.nativeEvent) || modalityOnPointerDown.current === "virtual") {
          e6.preventDefault();
          e6.stopPropagation();
          startDragging(e6.target);
        }
      }
    };
  return {
    dragProps: {
      ...interactions,
      draggable: "true",
      onDragStart,
      onDrag,
      onDragEnd
    },
    dragButtonProps: {
      ...descriptionProps,
      onPress
    },
    isDragging
  };
}
var $224594fe3e57ff1e$var$MESSAGES = {
  keyboard: "dropDescriptionKeyboard",
  touch: "dropDescriptionTouch",
  virtual: "dropDescriptionVirtual"
};
function $224594fe3e57ff1e$export$62447ad3d2ec7da6() {
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault2($865c2eb7c00a83f1$exports)), "@react-aria/dnd");
  let modality = (0, $7252cd45fc48c07c$export$49bac5d6d4b352ea)();
  let dragSession = $67560de7c78cb232$export$418e185dd3f1b968();
  let descriptionProps = (0, $ef06256079686ba0$export$f8aeda7b10753fa1)(dragSession ? stringFormatter.format($224594fe3e57ff1e$var$MESSAGES[modality]) : "");
  return {
    dropProps: {
      ...descriptionProps,
      // Mobile Safari does not properly bubble click events on elements except links or inputs
      // unless there is an onclick handler bound directly to the element itself. By adding this
      // handler, React will take care of adding that for us, and we are able to handle document
      // level click events in the DragManager.
      // See https://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
      onClick: () => {
      }
    }
  };
}
var $5c06e4929e123553$var$DROP_ACTIVATE_TIMEOUT = 800;
function $5c06e4929e123553$export$ccdee5eaf73cf661(options) {
  let { hasDropButton } = options;
  let [isDropTarget, setDropTarget] = (0, import_react30.useState)(false);
  let state = (0, import_react30.useRef)({
    x: 0,
    y: 0,
    dragOverElements: /* @__PURE__ */ new Set(),
    dropEffect: "none",
    allowedOperations: (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).all,
    dropActivateTimer: null
  }).current;
  let fireDropEnter = (e6) => {
    setDropTarget(true);
    if (typeof options.onDropEnter === "function") {
      let rect = e6.currentTarget.getBoundingClientRect();
      options.onDropEnter({
        type: "dropenter",
        x: e6.clientX - rect.x,
        y: e6.clientY - rect.y
      });
    }
  };
  let fireDropExit = (e6) => {
    setDropTarget(false);
    if (typeof options.onDropExit === "function") {
      let rect = e6.currentTarget.getBoundingClientRect();
      options.onDropExit({
        type: "dropexit",
        x: e6.clientX - rect.x,
        y: e6.clientY - rect.y
      });
    }
  };
  let onDragOver = (e6) => {
    e6.preventDefault();
    e6.stopPropagation();
    let allowedOperations = $5c06e4929e123553$var$getAllowedOperations(e6);
    if (e6.clientX === state.x && e6.clientY === state.y && allowedOperations === state.allowedOperations) {
      e6.dataTransfer.dropEffect = state.dropEffect;
      return;
    }
    state.x = e6.clientX;
    state.y = e6.clientY;
    let prevDropEffect = state.dropEffect;
    if (allowedOperations !== state.allowedOperations) {
      let allowedOps = $5c06e4929e123553$var$allowedOperationsToArray(allowedOperations);
      let dropOperation = allowedOps[0];
      if (typeof options.getDropOperation === "function") {
        let types3 = new (0, $7252cd45fc48c07c$export$7f04ce188c91447c)(e6.dataTransfer);
        dropOperation = $5c06e4929e123553$var$getDropOperation(allowedOperations, options.getDropOperation(types3, allowedOps));
      }
      state.dropEffect = (0, $103790afe9474d1c$export$5eacb0769d26d3b2)[dropOperation] || "none";
    }
    if (typeof options.getDropOperationForPoint === "function") {
      let types3 = new (0, $7252cd45fc48c07c$export$7f04ce188c91447c)(e6.dataTransfer);
      let rect = e6.currentTarget.getBoundingClientRect();
      let dropOperation = $5c06e4929e123553$var$getDropOperation(allowedOperations, options.getDropOperationForPoint(types3, $5c06e4929e123553$var$allowedOperationsToArray(allowedOperations), state.x - rect.x, state.y - rect.y));
      state.dropEffect = (0, $103790afe9474d1c$export$5eacb0769d26d3b2)[dropOperation] || "none";
    }
    state.allowedOperations = allowedOperations;
    e6.dataTransfer.dropEffect = state.dropEffect;
    if (state.dropEffect === "none" && prevDropEffect !== "none")
      fireDropExit(e6);
    else if (state.dropEffect !== "none" && prevDropEffect === "none")
      fireDropEnter(e6);
    if (typeof options.onDropMove === "function" && state.dropEffect !== "none") {
      let rect = e6.currentTarget.getBoundingClientRect();
      options.onDropMove({
        type: "dropmove",
        x: state.x - rect.x,
        y: state.y - rect.y
      });
    }
    clearTimeout(state.dropActivateTimer);
    if (typeof options.onDropActivate === "function" && state.dropEffect !== "none") {
      let rect = e6.currentTarget.getBoundingClientRect();
      state.dropActivateTimer = setTimeout(() => {
        options.onDropActivate({
          type: "dropactivate",
          x: state.x - rect.x,
          y: state.y - rect.y
        });
      }, $5c06e4929e123553$var$DROP_ACTIVATE_TIMEOUT);
    }
  };
  let onDragEnter = (e6) => {
    e6.preventDefault();
    e6.stopPropagation();
    state.dragOverElements.add(e6.target);
    if (state.dragOverElements.size > 1)
      return;
    let allowedOperationsBits = $5c06e4929e123553$var$getAllowedOperations(e6);
    let allowedOperations = $5c06e4929e123553$var$allowedOperationsToArray(allowedOperationsBits);
    let dropOperation = allowedOperations[0];
    if (typeof options.getDropOperation === "function") {
      let types3 = new (0, $7252cd45fc48c07c$export$7f04ce188c91447c)(e6.dataTransfer);
      dropOperation = $5c06e4929e123553$var$getDropOperation(allowedOperationsBits, options.getDropOperation(types3, allowedOperations));
    }
    if (typeof options.getDropOperationForPoint === "function") {
      let types3 = new (0, $7252cd45fc48c07c$export$7f04ce188c91447c)(e6.dataTransfer);
      let rect = e6.currentTarget.getBoundingClientRect();
      dropOperation = $5c06e4929e123553$var$getDropOperation(allowedOperationsBits, options.getDropOperationForPoint(types3, allowedOperations, e6.clientX - rect.x, e6.clientY - rect.y));
    }
    state.x = e6.clientX;
    state.y = e6.clientY;
    state.allowedOperations = allowedOperationsBits;
    state.dropEffect = (0, $103790afe9474d1c$export$5eacb0769d26d3b2)[dropOperation] || "none";
    e6.dataTransfer.dropEffect = state.dropEffect;
    if (dropOperation !== "cancel")
      fireDropEnter(e6);
  };
  let onDragLeave = (e6) => {
    e6.preventDefault();
    e6.stopPropagation();
    state.dragOverElements.delete(e6.target);
    for (let element4 of state.dragOverElements)
      if (!e6.currentTarget.contains(element4))
        state.dragOverElements.delete(element4);
    if (state.dragOverElements.size > 0)
      return;
    if (state.dropEffect !== "none")
      fireDropExit(e6);
    clearTimeout(state.dropActivateTimer);
  };
  let onDrop = (e6) => {
    e6.preventDefault();
    e6.stopPropagation();
    (0, $7252cd45fc48c07c$export$64f52ed7349ddb84)(state.dropEffect);
    if (typeof options.onDrop === "function") {
      let dropOperation = (0, $103790afe9474d1c$export$608ecc6f1b23c35d)[state.dropEffect];
      let items = (0, $7252cd45fc48c07c$export$d9e760437831f8b3)(e6.dataTransfer);
      let rect = e6.currentTarget.getBoundingClientRect();
      let event = {
        type: "drop",
        x: e6.clientX - rect.x,
        y: e6.clientY - rect.y,
        items,
        dropOperation
      };
      options.onDrop(event);
    }
    let dndStateSnapshot = {
      ...(0, $7252cd45fc48c07c$export$6ca6700462636d0b)
    };
    state.dragOverElements.clear();
    fireDropExit(e6);
    clearTimeout(state.dropActivateTimer);
    if (dndStateSnapshot.draggingCollectionRef == null)
      (0, $7252cd45fc48c07c$export$64f52ed7349ddb84)(void 0);
    else
      (0, $7252cd45fc48c07c$export$6c10d32b362bfa5f)(dndStateSnapshot);
  };
  let onDropEnter = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    if (typeof options.onDropEnter === "function")
      options.onDropEnter(e6);
  });
  let onDropExit = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    if (typeof options.onDropExit === "function")
      options.onDropExit(e6);
  });
  let onDropActivate = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    if (typeof options.onDropActivate === "function")
      options.onDropActivate(e6);
  });
  let onKeyboardDrop = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    if (typeof options.onDrop === "function")
      options.onDrop(e6);
  });
  let getDropOperationKeyboard = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((types3, allowedOperations) => {
    if (options.getDropOperation)
      return options.getDropOperation(types3, allowedOperations);
    return allowedOperations[0];
  });
  let { ref } = options;
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => $67560de7c78cb232$export$c28d9fb4a54e471a({
    element: ref.current,
    getDropOperation: getDropOperationKeyboard,
    onDropEnter(e6) {
      setDropTarget(true);
      onDropEnter(e6);
    },
    onDropExit(e6) {
      setDropTarget(false);
      onDropExit(e6);
    },
    onDrop: onKeyboardDrop,
    onDropActivate
  }), [
    ref,
    getDropOperationKeyboard,
    onDropEnter,
    onDropExit,
    onKeyboardDrop,
    onDropActivate
  ]);
  let { dropProps } = (0, $224594fe3e57ff1e$export$62447ad3d2ec7da6)();
  return {
    dropProps: {
      ...!hasDropButton && dropProps,
      onDragEnter,
      onDragOver,
      onDragLeave,
      onDrop
    },
    dropButtonProps: {
      ...hasDropButton && dropProps
    },
    isDropTarget
  };
}
function $5c06e4929e123553$var$getAllowedOperations(e6) {
  let allowedOperations = (0, $103790afe9474d1c$export$9bbdfc78cf083e16)[e6.dataTransfer.effectAllowed];
  if (0, $7252cd45fc48c07c$export$f0130eb70b6347b8)
    allowedOperations &= (0, $7252cd45fc48c07c$export$f0130eb70b6347b8);
  let allowedModifiers = (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).none;
  if ((0, $c87311424ea30a05$export$9ac100e40613ea10)()) {
    if (e6.altKey)
      allowedModifiers |= (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).copy;
    if (e6.ctrlKey && !(0, $c87311424ea30a05$export$7bef049ce92e4224)())
      allowedModifiers |= (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).link;
    if (e6.metaKey)
      allowedModifiers |= (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).move;
  } else {
    if (e6.altKey)
      allowedModifiers |= (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).link;
    if (e6.shiftKey)
      allowedModifiers |= (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).move;
    if (e6.ctrlKey)
      allowedModifiers |= (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).copy;
  }
  if (allowedModifiers)
    return allowedOperations & allowedModifiers;
  return allowedOperations;
}
function $5c06e4929e123553$var$allowedOperationsToArray(allowedOperationsBits) {
  let allowedOperations = [];
  if (allowedOperationsBits & (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).move)
    allowedOperations.push("move");
  if (allowedOperationsBits & (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).copy)
    allowedOperations.push("copy");
  if (allowedOperationsBits & (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).link)
    allowedOperations.push("link");
  return allowedOperations;
}
function $5c06e4929e123553$var$getDropOperation(allowedOperations, operation) {
  let op = (0, $103790afe9474d1c$export$60b7b4bcf3903d8e)[operation];
  return allowedOperations & op ? operation : "cancel";
}
var $80d9daea3067eff3$var$AUTOSCROLL_AREA_SIZE = 20;
function $80d9daea3067eff3$export$6323452ca4533ed8(ref) {
  let scrollableRef = (0, import_react30.useRef)(null);
  let scrollableX = (0, import_react30.useRef)(true);
  let scrollableY = (0, import_react30.useRef)(true);
  (0, import_react30.useEffect)(() => {
    if (ref.current) {
      scrollableRef.current = (0, $62d8ded9296f3872$export$2bb74740c4e19def)(ref.current) ? ref.current : (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref.current);
      let style = window.getComputedStyle(scrollableRef.current);
      scrollableX.current = /(auto|scroll)/.test(style.overflowX);
      scrollableY.current = /(auto|scroll)/.test(style.overflowY);
    }
  }, [
    ref
  ]);
  let state = (0, import_react30.useRef)({
    timer: null,
    dx: 0,
    dy: 0
  }).current;
  (0, import_react30.useEffect)(() => {
    return () => {
      if (state.timer) {
        cancelAnimationFrame(state.timer);
        state.timer = null;
      }
    };
  }, [
    state
  ]);
  let scroll = (0, import_react30.useCallback)(() => {
    if (scrollableX.current)
      scrollableRef.current.scrollLeft += state.dx;
    if (scrollableY.current)
      scrollableRef.current.scrollTop += state.dy;
    if (state.timer)
      state.timer = requestAnimationFrame(scroll);
  }, [
    scrollableRef,
    state
  ]);
  return {
    move(x4, y4) {
      if (!(0, $c87311424ea30a05$export$78551043582a6a98)() || (0, $c87311424ea30a05$export$fedb369cb70207f1)() || !scrollableRef.current)
        return;
      let box = scrollableRef.current.getBoundingClientRect();
      let left = $80d9daea3067eff3$var$AUTOSCROLL_AREA_SIZE;
      let top = $80d9daea3067eff3$var$AUTOSCROLL_AREA_SIZE;
      let bottom = box.height - $80d9daea3067eff3$var$AUTOSCROLL_AREA_SIZE;
      let right = box.width - $80d9daea3067eff3$var$AUTOSCROLL_AREA_SIZE;
      if (x4 < left || x4 > right || y4 < top || y4 > bottom) {
        if (x4 < left)
          state.dx = x4 - left;
        else if (x4 > right)
          state.dx = x4 - right;
        if (y4 < top)
          state.dy = y4 - top;
        else if (y4 > bottom)
          state.dy = y4 - bottom;
        if (!state.timer)
          state.timer = requestAnimationFrame(scroll);
      } else
        this.stop();
    },
    stop() {
      if (state.timer) {
        cancelAnimationFrame(state.timer);
        state.timer = null;
      }
    }
  };
}
var $4b52e4eff84e5217$var$DROP_POSITIONS = [
  "before",
  "on",
  "after"
];
var $4b52e4eff84e5217$var$DROP_POSITIONS_RTL = [
  "after",
  "on",
  "before"
];
function $4b52e4eff84e5217$export$f4e2f423c21f7b04(props, state, ref) {
  let localState = (0, import_react30.useRef)({
    props,
    state,
    nextTarget: null,
    dropOperation: null
  }).current;
  localState.props = props;
  localState.state = state;
  let defaultOnDrop = (0, import_react30.useCallback)(async (e6) => {
    let { onInsert, onRootDrop, onItemDrop, onReorder, acceptedDragTypes = "all", shouldAcceptItemDrop } = localState.props;
    let { draggingKeys } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
    let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);
    let { target, dropOperation, items } = e6;
    let filteredItems = items;
    if (acceptedDragTypes !== "all" || shouldAcceptItemDrop)
      filteredItems = items.filter((item2) => {
        let itemTypes;
        if (item2.kind === "directory")
          itemTypes = /* @__PURE__ */ new Set([
            (0, $7252cd45fc48c07c$export$990fced5dfac2637)
          ]);
        else
          itemTypes = item2.kind === "file" ? /* @__PURE__ */ new Set([
            item2.type
          ]) : item2.types;
        if (acceptedDragTypes === "all" || acceptedDragTypes.some((type2) => itemTypes.has(type2))) {
          if (target.type === "item" && target.dropPosition === "on" && shouldAcceptItemDrop)
            return shouldAcceptItemDrop(target, itemTypes);
          return true;
        }
        return false;
      });
    if (filteredItems.length > 0) {
      if (target.type === "root" && onRootDrop)
        await onRootDrop({
          items: filteredItems,
          dropOperation
        });
      if (target.type === "item") {
        if (target.dropPosition === "on" && onItemDrop)
          await onItemDrop({
            items: filteredItems,
            dropOperation,
            isInternal,
            target
          });
        if (target.dropPosition !== "on") {
          if (!isInternal && onInsert)
            await onInsert({
              items: filteredItems,
              dropOperation,
              target
            });
          if (isInternal && onReorder)
            await onReorder({
              keys: draggingKeys,
              dropOperation,
              target
            });
        }
      }
    }
  }, [
    localState,
    ref
  ]);
  let autoScroll = (0, $80d9daea3067eff3$export$6323452ca4533ed8)(ref);
  let { dropProps } = (0, $5c06e4929e123553$export$ccdee5eaf73cf661)({
    ref,
    onDropEnter() {
      state.setTarget(localState.nextTarget);
    },
    onDropMove(e6) {
      state.setTarget(localState.nextTarget);
      autoScroll.move(e6.x, e6.y);
    },
    getDropOperationForPoint(types3, allowedOperations, x4, y4) {
      let { draggingKeys, dropCollectionRef } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
      let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);
      let isValidDropTarget = (target2) => state.getDropOperation({
        target: target2,
        types: types3,
        allowedOperations,
        isInternal,
        draggingKeys
      }) !== "cancel";
      let target = props.dropTargetDelegate.getDropTargetFromPoint(x4, y4, isValidDropTarget);
      if (!target) {
        localState.dropOperation = "cancel";
        localState.nextTarget = null;
        return "cancel";
      }
      localState.dropOperation = state.getDropOperation({
        target,
        types: types3,
        allowedOperations,
        isInternal,
        draggingKeys
      });
      if (localState.dropOperation === "cancel") {
        let rootTarget = {
          type: "root"
        };
        let dropOperation = state.getDropOperation({
          target: rootTarget,
          types: types3,
          allowedOperations,
          isInternal,
          draggingKeys
        });
        if (dropOperation !== "cancel") {
          target = rootTarget;
          localState.dropOperation = dropOperation;
        }
      }
      if (target && localState.dropOperation !== "cancel" && (ref === null || ref === void 0 ? void 0 : ref.current) !== (dropCollectionRef === null || dropCollectionRef === void 0 ? void 0 : dropCollectionRef.current))
        (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(ref);
      localState.nextTarget = localState.dropOperation === "cancel" ? null : target;
      return localState.dropOperation;
    },
    onDropExit() {
      (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(void 0);
      state.setTarget(null);
      autoScroll.stop();
    },
    onDropActivate(e6) {
      var _state_target, _state_target1;
      if (((_state_target = state.target) === null || _state_target === void 0 ? void 0 : _state_target.type) === "item" && ((_state_target1 = state.target) === null || _state_target1 === void 0 ? void 0 : _state_target1.dropPosition) === "on" && typeof props.onDropActivate === "function")
        props.onDropActivate({
          type: "dropactivate",
          x: e6.x,
          y: e6.y,
          target: state.target
        });
    },
    onDrop(e6) {
      (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(ref);
      if (state.target)
        onDrop(e6, state.target);
      let { draggingCollectionRef } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
      if (draggingCollectionRef == null)
        (0, $7252cd45fc48c07c$export$70936501603e6c57)();
    }
  });
  let droppingState = (0, import_react30.useRef)(null);
  let onDrop = (0, import_react30.useCallback)((e6, target) => {
    var _state_collection_getItem;
    let { state: state2 } = localState;
    state2.selectionManager.setFocused(true);
    let focusedKey = state2.selectionManager.focusedKey;
    if ((0, $7252cd45fc48c07c$export$6ca6700462636d0b).draggingKeys.has((_state_collection_getItem = state2.collection.getItem(focusedKey)) === null || _state_collection_getItem === void 0 ? void 0 : _state_collection_getItem.parentKey)) {
      focusedKey = state2.collection.getItem(focusedKey).parentKey;
      state2.selectionManager.setFocusedKey(focusedKey);
    }
    droppingState.current = {
      timeout: null,
      focusedKey,
      collection: state2.collection,
      selectedKeys: state2.selectionManager.selectedKeys
    };
    let onDropFn = localState.props.onDrop || defaultOnDrop;
    onDropFn({
      type: "drop",
      x: e6.x,
      y: e6.y,
      target,
      items: e6.items,
      dropOperation: e6.dropOperation
    });
    droppingState.current.timeout = setTimeout(() => {
      let { state: state3 } = localState;
      if (target.type === "item" && target.dropPosition === "on" && state3.collection.getItem(target.key) != null) {
        state3.selectionManager.setFocusedKey(target.key);
        state3.selectionManager.setFocused(true);
        (0, $507fabe10e71c6fb$export$8397ddfc504fdb9a)("keyboard");
      } else if (!state3.selectionManager.isSelected(focusedKey))
        (0, $507fabe10e71c6fb$export$8397ddfc504fdb9a)("keyboard");
      droppingState.current = null;
    }, 50);
  }, [
    localState,
    defaultOnDrop
  ]);
  (0, import_react30.useEffect)(() => {
    return () => {
      if (droppingState.current)
        clearTimeout(droppingState.current.timeout);
    };
  }, []);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (droppingState.current && state.selectionManager.isFocused && state.collection.size > droppingState.current.collection.size && state.selectionManager.isSelectionEqual(droppingState.current.selectedKeys)) {
      let newKeys = /* @__PURE__ */ new Set();
      for (let key of state.collection.getKeys())
        if (!droppingState.current.collection.getItem(key))
          newKeys.add(key);
      state.selectionManager.setSelectedKeys(newKeys);
      if (state.selectionManager.focusedKey === droppingState.current.focusedKey) {
        let first = newKeys.keys().next().value;
        let item2 = state.collection.getItem(first);
        if ((item2 === null || item2 === void 0 ? void 0 : item2.type) === "cell")
          first = item2.parentKey;
        state.selectionManager.setFocusedKey(first);
        if (state.selectionManager.selectionMode === "none")
          (0, $507fabe10e71c6fb$export$8397ddfc504fdb9a)("keyboard");
      }
      droppingState.current = null;
    }
  });
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  (0, import_react30.useEffect)(() => {
    let getNextTarget = (target, wrap3 = true, horizontal = false) => {
      if (!target)
        return {
          type: "root"
        };
      let { keyboardDelegate } = localState.props;
      let nextKey;
      if ((target === null || target === void 0 ? void 0 : target.type) === "item")
        nextKey = horizontal ? keyboardDelegate.getKeyRightOf(target.key) : keyboardDelegate.getKeyBelow(target.key);
      else
        nextKey = horizontal && direction === "rtl" ? keyboardDelegate.getLastKey() : keyboardDelegate.getFirstKey();
      let dropPositions = horizontal && direction === "rtl" ? $4b52e4eff84e5217$var$DROP_POSITIONS_RTL : $4b52e4eff84e5217$var$DROP_POSITIONS;
      let dropPosition = dropPositions[0];
      if (target.type === "item") {
        let nextCollectionKey = horizontal && direction === "rtl" ? localState.state.collection.getKeyBefore(target.key) : localState.state.collection.getKeyAfter(target.key);
        if (nextKey == null || nextKey === nextCollectionKey) {
          let positionIndex = dropPositions.indexOf(target.dropPosition);
          let nextDropPosition = dropPositions[positionIndex + 1];
          if (positionIndex < dropPositions.length - 1 && !(nextDropPosition === dropPositions[2] && nextKey != null))
            return {
              type: "item",
              key: target.key,
              dropPosition: nextDropPosition
            };
          if (target.dropPosition === dropPositions[2])
            dropPosition = "on";
        } else
          dropPosition = target.dropPosition;
      }
      if (nextKey == null) {
        if (wrap3)
          return {
            type: "root"
          };
        return null;
      }
      return {
        type: "item",
        key: nextKey,
        dropPosition
      };
    };
    let getPreviousTarget = (target, wrap3 = true, horizontal = false) => {
      let { keyboardDelegate } = localState.props;
      let nextKey;
      if ((target === null || target === void 0 ? void 0 : target.type) === "item")
        nextKey = horizontal ? keyboardDelegate.getKeyLeftOf(target.key) : keyboardDelegate.getKeyAbove(target.key);
      else
        nextKey = horizontal && direction === "rtl" ? keyboardDelegate.getFirstKey() : keyboardDelegate.getLastKey();
      let dropPositions = horizontal && direction === "rtl" ? $4b52e4eff84e5217$var$DROP_POSITIONS_RTL : $4b52e4eff84e5217$var$DROP_POSITIONS;
      let dropPosition = !target || target.type === "root" ? dropPositions[2] : "on";
      if ((target === null || target === void 0 ? void 0 : target.type) === "item") {
        let prevCollectionKey = horizontal && direction === "rtl" ? localState.state.collection.getKeyAfter(target.key) : localState.state.collection.getKeyBefore(target.key);
        if (nextKey == null || nextKey === prevCollectionKey) {
          let positionIndex = dropPositions.indexOf(target.dropPosition);
          let nextDropPosition = dropPositions[positionIndex - 1];
          if (positionIndex > 0 && nextDropPosition !== dropPositions[2])
            return {
              type: "item",
              key: target.key,
              dropPosition: nextDropPosition
            };
          if (target.dropPosition === dropPositions[0])
            dropPosition = "on";
        } else
          dropPosition = target.dropPosition;
      }
      if (nextKey == null) {
        if (wrap3)
          return {
            type: "root"
          };
        return null;
      }
      return {
        type: "item",
        key: nextKey,
        dropPosition
      };
    };
    let nextValidTarget = (target, types3, allowedDropOperations, getNextTarget2, wrap3 = true) => {
      let seenRoot = 0;
      let operation;
      let { draggingKeys } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
      let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);
      do {
        let nextTarget = getNextTarget2(target, wrap3);
        if (!nextTarget)
          return null;
        target = nextTarget;
        operation = localState.state.getDropOperation({
          target: nextTarget,
          types: types3,
          allowedOperations: allowedDropOperations,
          isInternal,
          draggingKeys
        });
        if (target.type === "root")
          seenRoot++;
      } while (operation === "cancel" && !localState.state.isDropTarget(target) && seenRoot < 2);
      if (operation === "cancel")
        return null;
      return target;
    };
    return $67560de7c78cb232$export$c28d9fb4a54e471a({
      element: ref.current,
      getDropOperation(types3, allowedOperations) {
        if (localState.state.target) {
          let { draggingKeys } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
          let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);
          return localState.state.getDropOperation({
            target: localState.state.target,
            types: types3,
            allowedOperations,
            isInternal,
            draggingKeys
          });
        }
        let target = nextValidTarget(null, types3, allowedOperations, getNextTarget);
        return target ? "move" : "cancel";
      },
      onDropEnter(e6, drag) {
        let types3 = (0, $7252cd45fc48c07c$export$e1d41611756c6326)(drag.items);
        let selectionManager = localState.state.selectionManager;
        let target;
        (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(ref);
        let key = selectionManager.focusedKey;
        let dropPosition = "after";
        let item2 = localState.state.collection.getItem(key);
        if ((item2 === null || item2 === void 0 ? void 0 : item2.type) === "cell")
          key = item2.parentKey;
        if (selectionManager.isSelected(key)) {
          if (selectionManager.selectedKeys.size > 1 && selectionManager.firstSelectedKey === key)
            dropPosition = "before";
          else
            key = selectionManager.lastSelectedKey;
        }
        if (key != null) {
          target = {
            type: "item",
            key,
            dropPosition
          };
          let { draggingKeys } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
          let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);
          var _nextValidTarget;
          if (localState.state.getDropOperation({
            target,
            types: types3,
            allowedOperations: drag.allowedDropOperations,
            isInternal,
            draggingKeys
          }) === "cancel")
            target = (_nextValidTarget = nextValidTarget(target, types3, drag.allowedDropOperations, getNextTarget, false)) !== null && _nextValidTarget !== void 0 ? _nextValidTarget : nextValidTarget(target, types3, drag.allowedDropOperations, getPreviousTarget, false);
        }
        if (!target)
          target = nextValidTarget(null, types3, drag.allowedDropOperations, getNextTarget);
        localState.state.setTarget(target);
      },
      onDropExit() {
        (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(void 0);
        localState.state.setTarget(null);
      },
      onDropTargetEnter(target) {
        localState.state.setTarget(target);
      },
      onDropActivate(e6) {
        var _localState_state_target, _localState_state_target1;
        if (((_localState_state_target = localState.state.target) === null || _localState_state_target === void 0 ? void 0 : _localState_state_target.type) === "item" && ((_localState_state_target1 = localState.state.target) === null || _localState_state_target1 === void 0 ? void 0 : _localState_state_target1.dropPosition) === "on" && typeof localState.props.onDropActivate === "function")
          localState.props.onDropActivate({
            type: "dropactivate",
            x: e6.x,
            y: e6.y,
            target: localState.state.target
          });
      },
      onDrop(e6, target) {
        (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(ref);
        if (localState.state.target)
          onDrop(e6, target || localState.state.target);
      },
      onKeyDown(e6, drag) {
        let { keyboardDelegate } = localState.props;
        let types3 = (0, $7252cd45fc48c07c$export$e1d41611756c6326)(drag.items);
        switch (e6.key) {
          case "ArrowDown":
            if (keyboardDelegate.getKeyBelow) {
              let target = nextValidTarget(localState.state.target, types3, drag.allowedDropOperations, getNextTarget);
              localState.state.setTarget(target);
            }
            break;
          case "ArrowUp":
            if (keyboardDelegate.getKeyAbove) {
              let target = nextValidTarget(localState.state.target, types3, drag.allowedDropOperations, getPreviousTarget);
              localState.state.setTarget(target);
            }
            break;
          case "ArrowLeft":
            if (keyboardDelegate.getKeyLeftOf) {
              let target = nextValidTarget(localState.state.target, types3, drag.allowedDropOperations, (target2, wrap3) => getPreviousTarget(target2, wrap3, true));
              localState.state.setTarget(target);
            }
            break;
          case "ArrowRight":
            if (keyboardDelegate.getKeyRightOf) {
              let target = nextValidTarget(localState.state.target, types3, drag.allowedDropOperations, (target2, wrap3) => getNextTarget(target2, wrap3, true));
              localState.state.setTarget(target);
            }
            break;
          case "Home":
            if (keyboardDelegate.getFirstKey) {
              let target = nextValidTarget(null, types3, drag.allowedDropOperations, getNextTarget);
              localState.state.setTarget(target);
            }
            break;
          case "End":
            if (keyboardDelegate.getLastKey) {
              let target = nextValidTarget(null, types3, drag.allowedDropOperations, getPreviousTarget);
              localState.state.setTarget(target);
            }
            break;
          case "PageDown":
            if (keyboardDelegate.getKeyPageBelow) {
              let target = localState.state.target;
              if (!target)
                target = nextValidTarget(null, types3, drag.allowedDropOperations, getNextTarget);
              else {
                let nextKey = keyboardDelegate.getKeyPageBelow(target.type === "item" ? target.key : keyboardDelegate.getFirstKey());
                let dropPosition = target.type === "item" ? target.dropPosition : "after";
                if (nextKey == null || target.type === "item" && target.key === keyboardDelegate.getLastKey()) {
                  nextKey = keyboardDelegate.getLastKey();
                  dropPosition = "after";
                }
                target = {
                  type: "item",
                  key: nextKey,
                  dropPosition
                };
                let { draggingCollectionRef, draggingKeys } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
                let isInternal = (draggingCollectionRef === null || draggingCollectionRef === void 0 ? void 0 : draggingCollectionRef.current) === (ref === null || ref === void 0 ? void 0 : ref.current);
                let operation = localState.state.getDropOperation({
                  target,
                  types: types3,
                  allowedOperations: drag.allowedDropOperations,
                  isInternal,
                  draggingKeys
                });
                var _nextValidTarget;
                if (operation === "cancel")
                  target = (_nextValidTarget = nextValidTarget(target, types3, drag.allowedDropOperations, getNextTarget, false)) !== null && _nextValidTarget !== void 0 ? _nextValidTarget : nextValidTarget(target, types3, drag.allowedDropOperations, getPreviousTarget, false);
              }
              localState.state.setTarget(target !== null && target !== void 0 ? target : localState.state.target);
            }
            break;
          case "PageUp": {
            if (!keyboardDelegate.getKeyPageAbove)
              break;
            let target = localState.state.target;
            if (!target)
              target = nextValidTarget(null, types3, drag.allowedDropOperations, getPreviousTarget);
            else if (target.type === "item") {
              if (target.key === keyboardDelegate.getFirstKey())
                target = {
                  type: "root"
                };
              else {
                let nextKey = keyboardDelegate.getKeyPageAbove(target.key);
                let dropPosition = target.dropPosition;
                if (nextKey == null) {
                  nextKey = keyboardDelegate.getFirstKey();
                  dropPosition = "before";
                }
                target = {
                  type: "item",
                  key: nextKey,
                  dropPosition
                };
              }
              let { draggingKeys } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
              let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);
              let operation = localState.state.getDropOperation({
                target,
                types: types3,
                allowedOperations: drag.allowedDropOperations,
                isInternal,
                draggingKeys
              });
              var _nextValidTarget1;
              if (operation === "cancel")
                target = (_nextValidTarget1 = nextValidTarget(target, types3, drag.allowedDropOperations, getPreviousTarget, false)) !== null && _nextValidTarget1 !== void 0 ? _nextValidTarget1 : nextValidTarget(target, types3, drag.allowedDropOperations, getNextTarget, false);
            }
            localState.state.setTarget(target !== null && target !== void 0 ? target : localState.state.target);
            break;
          }
        }
      }
    });
  }, [
    localState,
    ref,
    onDrop,
    direction
  ]);
  let id2 = (0, $bdb11010cef70236$export$f680877a34711e37)();
  (0, $7252cd45fc48c07c$export$dfdf5deeaf27473f).set(state, {
    id: id2,
    ref
  });
  return {
    collectionProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(dropProps, {
      id: id2,
      // Remove description from collection element. If dropping on the entire collection,
      // there should be a drop indicator that has this description, so no need to double announce.
      "aria-describedby": null
    })
  };
}
function $bfaab576ce1c580e$export$f7b0c5d28b66b6a5(options, state, ref) {
  let { dropProps } = (0, $224594fe3e57ff1e$export$62447ad3d2ec7da6)();
  let droppableCollectionRef = (0, $7252cd45fc48c07c$export$7e397efd01d3db27)(state);
  (0, import_react30.useEffect)(() => {
    if (ref.current)
      return $67560de7c78cb232$export$aef80212ac99c003({
        element: ref.current,
        target: options.target,
        getDropOperation(types3, allowedOperations) {
          let { draggingKeys: draggingKeys2 } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
          let isInternal2 = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(droppableCollectionRef);
          return state.getDropOperation({
            target: options.target,
            types: types3,
            allowedOperations,
            isInternal: isInternal2,
            draggingKeys: draggingKeys2
          });
        }
      });
  }, [
    ref,
    options.target,
    state,
    droppableCollectionRef
  ]);
  let dragSession = $67560de7c78cb232$export$418e185dd3f1b968();
  let { draggingKeys } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
  let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(droppableCollectionRef);
  let isValidDropTarget = dragSession && state.getDropOperation({
    target: options.target,
    types: (0, $7252cd45fc48c07c$export$e1d41611756c6326)(dragSession.dragTarget.items),
    allowedOperations: dragSession.dragTarget.allowedDropOperations,
    isInternal,
    draggingKeys
  }) !== "cancel";
  let isDropTarget = state.isDropTarget(options.target);
  (0, import_react30.useEffect)(() => {
    if (dragSession && isDropTarget && ref.current)
      ref.current.focus();
  }, [
    isDropTarget,
    dragSession,
    ref
  ]);
  return {
    dropProps: {
      ...dropProps,
      "aria-hidden": !dragSession || isValidDropTarget ? void 0 : "true"
    },
    isDropTarget
  };
}
function $ddf25448c71fc93a$export$8d0e41d2815afac5(props, state, ref) {
  let { target } = props;
  let { collection: collection2 } = state;
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault2($865c2eb7c00a83f1$exports)), "@react-aria/dnd");
  let dragSession = $67560de7c78cb232$export$418e185dd3f1b968();
  let { dropProps } = (0, $bfaab576ce1c580e$export$f7b0c5d28b66b6a5)(props, state, ref);
  let id2 = (0, $bdb11010cef70236$export$f680877a34711e37)();
  let getText = (key) => {
    var _collection_getTextValue, _collection_getItem;
    var _collection_getTextValue1;
    return (_collection_getTextValue1 = (_collection_getTextValue = collection2.getTextValue) === null || _collection_getTextValue === void 0 ? void 0 : _collection_getTextValue.call(collection2, key)) !== null && _collection_getTextValue1 !== void 0 ? _collection_getTextValue1 : (_collection_getItem = collection2.getItem(key)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue;
  };
  let label = "";
  let labelledBy;
  if (target.type === "root") {
    label = stringFormatter.format("dropOnRoot");
    labelledBy = `${id2} ${(0, $7252cd45fc48c07c$export$3093291712f09a77)(state)}`;
  } else if (target.dropPosition === "on")
    label = stringFormatter.format("dropOnItem", {
      itemText: getText(target.key)
    });
  else {
    let before;
    let after;
    if (collection2.getFirstKey() === target.key && target.dropPosition === "before")
      before = null;
    else
      before = target.dropPosition === "before" ? collection2.getKeyBefore(target.key) : target.key;
    if (collection2.getLastKey() === target.key && target.dropPosition === "after")
      after = null;
    else
      after = target.dropPosition === "after" ? collection2.getKeyAfter(target.key) : target.key;
    if (before && after)
      label = stringFormatter.format("insertBetween", {
        beforeItemText: getText(before),
        afterItemText: getText(after)
      });
    else if (before)
      label = stringFormatter.format("insertAfter", {
        itemText: getText(before)
      });
    else if (after)
      label = stringFormatter.format("insertBefore", {
        itemText: getText(after)
      });
  }
  let isDropTarget = state.isDropTarget(target);
  let ariaHidden = !dragSession ? "true" : dropProps["aria-hidden"];
  return {
    dropIndicatorProps: {
      ...dropProps,
      id: id2,
      "aria-roledescription": stringFormatter.format("dropIndicator"),
      "aria-label": label,
      "aria-labelledby": labelledBy,
      "aria-hidden": ariaHidden,
      tabIndex: -1
    },
    isDropTarget,
    // If aria-hidden, we are either not in a drag session or the drop target is invalid.
    // In that case, there's no need to render anything at all unless we need to show the indicator visually.
    // This can happen when dragging using the native DnD API as opposed to keyboard dragging.
    isHidden: !isDropTarget && !!ariaHidden
  };
}
var $fd98cf7cbf233429$var$MESSAGES = {
  keyboard: {
    selected: "dragSelectedKeyboard",
    notSelected: "dragDescriptionKeyboard"
  },
  touch: {
    selected: "dragSelectedLongPress",
    notSelected: "dragDescriptionLongPress"
  },
  virtual: {
    selected: "dragDescriptionVirtual",
    notSelected: "dragDescriptionVirtual"
  }
};
function $fd98cf7cbf233429$export$b35afafff42da2d9(props, state) {
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault2($865c2eb7c00a83f1$exports)), "@react-aria/dnd");
  let isDisabled = state.selectionManager.isDisabled(props.key);
  let { dragProps, dragButtonProps } = (0, $8253ed7ece74b463$export$7941f8aafa4b6021)({
    getItems() {
      return state.getItems(props.key);
    },
    preview: state.preview,
    getAllowedDropOperations: state.getAllowedDropOperations,
    hasDragButton: props.hasDragButton,
    onDragStart(e6) {
      state.startDrag(props.key, e6);
      (0, $7252cd45fc48c07c$export$72cb63bdda528276)(state.draggingKeys);
    },
    onDragMove(e6) {
      state.moveDrag(e6);
    },
    onDragEnd(e6) {
      let { dropOperation } = e6;
      let isInternal = dropOperation === "cancel" ? false : (0, $7252cd45fc48c07c$export$78bf638634500fa5)();
      state.endDrag({
        ...e6,
        keys: state.draggingKeys,
        isInternal
      });
      (0, $7252cd45fc48c07c$export$70936501603e6c57)();
    }
  });
  let item2 = state.collection.getItem(props.key);
  let numKeysForDrag = state.getKeysForDrag(props.key).size;
  let isSelected = numKeysForDrag > 1 && state.selectionManager.isSelected(props.key);
  let dragButtonLabel;
  let description;
  let modality = (0, $7252cd45fc48c07c$export$49bac5d6d4b352ea)();
  if (!props.hasDragButton && state.selectionManager.selectionMode !== "none") {
    let msg2 = $fd98cf7cbf233429$var$MESSAGES[modality][isSelected ? "selected" : "notSelected"];
    if (props.hasAction && modality === "keyboard")
      msg2 += "Alt";
    if (isSelected)
      description = stringFormatter.format(msg2, {
        count: numKeysForDrag
      });
    else
      description = stringFormatter.format(msg2);
    delete dragProps.onClick;
  } else if (isSelected)
    dragButtonLabel = stringFormatter.format("dragSelectedItems", {
      count: numKeysForDrag
    });
  else {
    var _state_collection_getTextValue, _state_collection;
    var _state_collection_getTextValue1, _ref;
    let itemText = (_ref = (_state_collection_getTextValue1 = (_state_collection_getTextValue = (_state_collection = state.collection).getTextValue) === null || _state_collection_getTextValue === void 0 ? void 0 : _state_collection_getTextValue.call(_state_collection, props.key)) !== null && _state_collection_getTextValue1 !== void 0 ? _state_collection_getTextValue1 : item2 === null || item2 === void 0 ? void 0 : item2.textValue) !== null && _ref !== void 0 ? _ref : "";
    dragButtonLabel = stringFormatter.format("dragItem", {
      itemText
    });
  }
  let descriptionProps = (0, $ef06256079686ba0$export$f8aeda7b10753fa1)(description);
  if (description)
    Object.assign(dragProps, descriptionProps);
  if (!props.hasDragButton && props.hasAction) {
    let { onKeyDownCapture, onKeyUpCapture } = dragProps;
    if (modality === "touch")
      delete dragProps["aria-describedby"];
    dragProps.onKeyDownCapture = (e6) => {
      if (e6.altKey)
        onKeyDownCapture(e6);
    };
    dragProps.onKeyUpCapture = (e6) => {
      if (e6.altKey)
        onKeyUpCapture(e6);
    };
  }
  return {
    dragProps: isDisabled ? {} : dragProps,
    dragButtonProps: {
      ...dragButtonProps,
      isDisabled,
      "aria-label": dragButtonLabel
    }
  };
}
function $4ac1fdc3a0fcd564$export$2962a7984b2f0a80(props, state, ref) {
  let { draggingCollectionRef } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
  if (state.draggingKeys.size > 0 && (draggingCollectionRef === null || draggingCollectionRef === void 0 ? void 0 : draggingCollectionRef.current) !== ref.current)
    (0, $7252cd45fc48c07c$export$f2be18a910c0caa6)(ref);
}
var $9fcc7f0d70d084ee$var$globalEvents = /* @__PURE__ */ new Map();
function $9fcc7f0d70d084ee$var$addGlobalEventListener(event, fn2) {
  let eventData = $9fcc7f0d70d084ee$var$globalEvents.get(event);
  if (!eventData) {
    let handlers = /* @__PURE__ */ new Set();
    let listener = (e6) => {
      for (let handler of handlers)
        handler(e6);
    };
    eventData = {
      listener,
      handlers
    };
    $9fcc7f0d70d084ee$var$globalEvents.set(event, eventData);
    document.addEventListener(event, listener);
  }
  eventData.handlers.add(fn2);
  return () => {
    eventData.handlers.delete(fn2);
    if (eventData.handlers.size === 0) {
      document.removeEventListener(event, eventData.listener);
      $9fcc7f0d70d084ee$var$globalEvents.delete(event);
    }
  };
}
function $9fcc7f0d70d084ee$export$2314ca2a3e892862(options) {
  let isFocusedRef = (0, import_react30.useRef)(false);
  let { focusProps } = (0, $a1ea59d68270f0dd$export$f8168d8dd8fd66e6)({
    onFocusChange: (isFocused) => {
      isFocusedRef.current = isFocused;
    }
  });
  let onBeforeCopy = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    if (isFocusedRef.current && options.getItems)
      e6.preventDefault();
  });
  let onCopy = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    var _options_onCopy;
    if (!isFocusedRef.current || !options.getItems)
      return;
    e6.preventDefault();
    (0, $7252cd45fc48c07c$export$f9c1490890ddd063)(e6.clipboardData, options.getItems());
    (_options_onCopy = options.onCopy) === null || _options_onCopy === void 0 ? void 0 : _options_onCopy.call(options);
  });
  let onBeforeCut = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    if (isFocusedRef.current && options.onCut && options.getItems)
      e6.preventDefault();
  });
  let onCut = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    if (!isFocusedRef.current || !options.onCut || !options.getItems)
      return;
    e6.preventDefault();
    (0, $7252cd45fc48c07c$export$f9c1490890ddd063)(e6.clipboardData, options.getItems());
    options.onCut();
  });
  let onBeforePaste = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    if (isFocusedRef.current && options.onPaste)
      e6.preventDefault();
  });
  let onPaste = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    if (!isFocusedRef.current || !options.onPaste)
      return;
    e6.preventDefault();
    let items = (0, $7252cd45fc48c07c$export$d9e760437831f8b3)(e6.clipboardData);
    options.onPaste(items);
  });
  (0, import_react30.useEffect)(() => {
    return (0, $ff5963eb1fccf552$export$e08e3b67e392101e)($9fcc7f0d70d084ee$var$addGlobalEventListener("beforecopy", onBeforeCopy), $9fcc7f0d70d084ee$var$addGlobalEventListener("copy", onCopy), $9fcc7f0d70d084ee$var$addGlobalEventListener("beforecut", onBeforeCut), $9fcc7f0d70d084ee$var$addGlobalEventListener("cut", onCut), $9fcc7f0d70d084ee$var$addGlobalEventListener("beforepaste", onBeforePaste), $9fcc7f0d70d084ee$var$addGlobalEventListener("paste", onPaste));
  }, [
    onBeforeCopy,
    onCopy,
    onBeforeCut,
    onCut,
    onBeforePaste,
    onPaste
  ]);
  return {
    clipboardProps: focusProps
  };
}
function $ad0e3f3d9c50e4ba$var$DragPreview(props, ref) {
  let render3 = props.children;
  let [children, setChildren] = (0, import_react30.useState)(null);
  let domRef = (0, import_react30.useRef)(null);
  (0, import_react30.useImperativeHandle)(ref, () => (items, callback) => {
    (0, import_react_dom2.flushSync)(() => {
      setChildren(render3(items));
    });
    callback(domRef.current);
    requestAnimationFrame(() => {
      setChildren(null);
    });
  }, [
    render3
  ]);
  if (!children)
    return null;
  return (0, import_react30.default).createElement("div", {
    style: {
      zIndex: -100,
      position: "absolute",
      top: 0,
      left: -1e5
    },
    ref: domRef
  }, children);
}
var $ad0e3f3d9c50e4ba$export$905ab40ac2179daa = (0, import_react30.default).forwardRef($ad0e3f3d9c50e4ba$var$DragPreview);

// node_modules/@keystar/ui/dist/DropZone-019a8b81.js
var import_react31 = __toESM(require_react(), 1);
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var localizedMessages3 = {
  "ar-AE": {
    dropzoneLabel: "DropZone"
  },
  "bg-BG": {
    dropzoneLabel: "DropZone"
  },
  "cs-CZ": {
    dropzoneLabel: "Místo pro přetažení"
  },
  "da-DK": {
    dropzoneLabel: "DropZone"
  },
  "de-DE": {
    dropzoneLabel: "Ablegebereich"
  },
  "el-GR": {
    dropzoneLabel: "DropZone"
  },
  "en-US": {
    dropzoneLabel: "DropZone"
  },
  "es-ES": {
    dropzoneLabel: "DropZone"
  },
  "et-EE": {
    dropzoneLabel: "DropZone"
  },
  "fi-FI": {
    dropzoneLabel: "DropZone"
  },
  "fr-FR": {
    dropzoneLabel: "DropZone"
  },
  "he-IL": {
    dropzoneLabel: "DropZone"
  },
  "hr-HR": {
    dropzoneLabel: "Zona spuštanja"
  },
  "hu-HU": {
    dropzoneLabel: "DropZone"
  },
  "it-IT": {
    dropzoneLabel: "Zona di rilascio"
  },
  "ja-JP": {
    dropzoneLabel: "ドロップゾーン"
  },
  "ko-KR": {
    dropzoneLabel: "드롭 영역"
  },
  "lt-LT": {
    dropzoneLabel: "„DropZone“"
  },
  "lv-LV": {
    dropzoneLabel: "DropZone"
  },
  "nb-NO": {
    dropzoneLabel: "Droppsone"
  },
  "nl-NL": {
    dropzoneLabel: "DropZone"
  },
  "pl-PL": {
    dropzoneLabel: "Strefa upuszczania"
  },
  "pt-BR": {
    dropzoneLabel: "DropZone"
  },
  "pt-PT": {
    dropzoneLabel: "DropZone"
  },
  "ro-RO": {
    dropzoneLabel: "Zonă de plasare"
  },
  "ru-RU": {
    dropzoneLabel: "DropZone"
  },
  "sk-SK": {
    dropzoneLabel: "DropZone"
  },
  "sl-SI": {
    dropzoneLabel: "DropZone"
  },
  "sr-SP": {
    dropzoneLabel: "DropZone"
  },
  "sv-SE": {
    dropzoneLabel: "DropZone"
  },
  "tr-TR": {
    dropzoneLabel: "DropZone"
  },
  "uk-UA": {
    dropzoneLabel: "DropZone"
  },
  "zh-CN": {
    dropzoneLabel: "放置区域"
  },
  "zh-TW": {
    dropzoneLabel: "放置區"
  }
};
var dropZoneClassList = new ClassList("DropZone");
var DropZone = forwardRefWithAs(function DropZone2(props, forwardedRef) {
  let dropzoneRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let buttonRef = (0, import_react31.useRef)(null);
  let {
    dropProps,
    dropButtonProps,
    isDropTarget
  } = $5c06e4929e123553$export$ccdee5eaf73cf661({
    ...props,
    ref: buttonRef,
    hasDropButton: true
  });
  let {
    clipboardProps
  } = $9fcc7f0d70d084ee$export$2314ca2a3e892862({
    onPaste: (items) => {
      var _props$onDrop;
      return (_props$onDrop = props.onDrop) === null || _props$onDrop === void 0 ? void 0 : _props$onDrop.call(props, {
        type: "drop",
        items,
        x: 0,
        y: 0,
        dropOperation: "copy"
      });
    }
  });
  let {
    focusProps,
    isFocused,
    isFocusVisible
  } = $f7dceffc5ad7768b$export$4e328f61c538687f();
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages3);
  let labelId = $bdb11010cef70236$export$b4cc09c592e8fdb8();
  let dropzoneId = $bdb11010cef70236$export$b4cc09c592e8fdb8();
  let ariaLabel = props["aria-label"] || stringFormatter.format("dropzoneLabel");
  let messageId = props["aria-labelledby"];
  let ariaLabelledby = [dropzoneId, labelId, messageId].filter(Boolean).join(" ");
  let labelProps = $313b98861ee5dd6c$export$d6875122194c7b44({
    "aria-labelledby": ariaLabelledby
  });
  let slots = {
    icon: {
      color: isDropTarget ? "accent" : "neutral"
    },
    label: {
      id: labelId,
      color: isDropTarget ? "accent" : void 0
    }
  };
  let children = useRenderProps(props, {
    isDropTarget
  });
  let styleProps = useStyleProps(props);
  let ElementType = props.elementType || "div";
  return (0, import_jsx_runtime15.jsxs)(ElementType, {
    ...dropProps,
    ...styleProps,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(props, {
      labelable: true
    }),
    ...toDataAttributes({
      isDropTarget,
      isFocused,
      isFocusVisible
    }, {
      omitFalsyValues: true,
      trimBooleanKeys: true
    }),
    ref: dropzoneRef,
    className: classNames(dropZoneClassList.element("root"), css({
      border: `${tokenSchema.size.border.medium} dashed ${tokenSchema.color.border.neutral}`,
      borderRadius: tokenSchema.size.radius.regular,
      display: "flex",
      flexDirection: "column",
      gap: tokenSchema.size.space.medium,
      "&[data-drop-target]": {
        backgroundColor: tokenSchema.color.alias.backgroundSelected,
        borderColor: tokenSchema.color.alias.focusRing,
        borderStyle: "solid",
        cursor: "copy"
      },
      "&[data-focus-visible]": {
        borderColor: tokenSchema.color.alias.focusRing
      }
    }), styleProps.className),
    children: [(0, import_jsx_runtime15.jsxs)($5c3e21d68f1c4674$export$439d29a4e110a164, {
      children: [(0, import_jsx_runtime15.jsx)("div", {
        id: dropzoneId,
        "aria-hidden": "true",
        children: ariaLabel
      }), (0, import_jsx_runtime15.jsx)("button", {
        ...$3ef42575df84b30b$export$9d1611c77c2fe928(dropButtonProps, focusProps, clipboardProps, labelProps),
        ref: buttonRef
      })]
    }), (0, import_jsx_runtime15.jsx)(SlotProvider, {
      slots,
      children
    })]
  });
});

// node_modules/@keystar/ui/dist/keystar-ui-drag-and-drop.js
var import_react33 = __toESM(require_react());
var import_jsx_runtime16 = __toESM(require_jsx_runtime());

// node_modules/@react-stately/dnd/dist/import.mjs
var import_react32 = __toESM(require_react(), 1);
function $b45bbbaf0c3785df$export$29efd034f1d79f81(props) {
  let { getItems, collection: collection2, selectionManager, onDragStart, onDragMove, onDragEnd, preview, getAllowedDropOperations } = props;
  let [, setDragging] = (0, import_react32.useState)(false);
  let draggingKeys = (0, import_react32.useRef)(/* @__PURE__ */ new Set());
  let draggedKey = (0, import_react32.useRef)(null);
  let getKeys = (key) => {
    let keys3 = new Set(selectionManager.isSelected(key) ? new Set([
      ...selectionManager.selectedKeys
    ].filter((key2) => !!collection2.getItem(key2))) : []);
    keys3.add(key);
    return keys3;
  };
  return {
    collection: collection2,
    selectionManager,
    get draggedKey() {
      return draggedKey.current;
    },
    get draggingKeys() {
      return draggingKeys.current;
    },
    isDragging(key) {
      return draggingKeys.current.has(key);
    },
    getKeysForDrag: getKeys,
    getItems(key) {
      return getItems(getKeys(key));
    },
    preview,
    getAllowedDropOperations,
    startDrag(key, event) {
      let keys3 = getKeys(key);
      draggingKeys.current = keys3;
      draggedKey.current = key;
      selectionManager.setFocused(false);
      setDragging(true);
      if (typeof onDragStart === "function")
        onDragStart({
          ...event,
          keys: keys3
        });
    },
    moveDrag(event) {
      if (typeof onDragMove === "function")
        onDragMove({
          ...event,
          keys: draggingKeys.current
        });
    },
    endDrag(event) {
      let { isInternal } = event;
      if (typeof onDragEnd === "function")
        onDragEnd({
          ...event,
          keys: draggingKeys.current,
          isInternal
        });
      draggingKeys.current = /* @__PURE__ */ new Set();
      draggedKey.current = null;
      setDragging(false);
    }
  };
}
function $e672e8bc247525d1$export$926850f6ecef79d0(props) {
  let { acceptedDragTypes = "all", onInsert, onRootDrop, onItemDrop, onReorder, shouldAcceptItemDrop, collection: collection2, selectionManager, onDropEnter, getDropOperation, onDrop } = props;
  let [target, setTarget] = (0, import_react32.useState)(null);
  let targetRef = (0, import_react32.useRef)(null);
  let getOppositeTarget = (target2) => {
    if (target2.dropPosition === "before") {
      let key = collection2.getKeyBefore(target2.key);
      return key != null ? {
        type: "item",
        key,
        dropPosition: "after"
      } : null;
    } else if (target2.dropPosition === "after") {
      let key = collection2.getKeyAfter(target2.key);
      return key != null ? {
        type: "item",
        key,
        dropPosition: "before"
      } : null;
    }
  };
  let defaultGetDropOperation = (0, import_react32.useCallback)((e6) => {
    let { target: target2, types: types3, allowedOperations, isInternal, draggingKeys } = e6;
    if (acceptedDragTypes === "all" || acceptedDragTypes.some((type2) => types3.has(type2))) {
      let isValidInsert = onInsert && target2.type === "item" && !isInternal && (target2.dropPosition === "before" || target2.dropPosition === "after");
      let isValidReorder = onReorder && target2.type === "item" && isInternal && (target2.dropPosition === "before" || target2.dropPosition === "after");
      let isValidRootDrop = onRootDrop && target2.type === "root" && !isInternal;
      let isValidOnItemDrop = onItemDrop && target2.type === "item" && target2.dropPosition === "on" && !(isInternal && draggingKeys.has(target2.key)) && (!shouldAcceptItemDrop || shouldAcceptItemDrop(target2, types3));
      if (onDrop || isValidInsert || isValidReorder || isValidRootDrop || isValidOnItemDrop) {
        if (getDropOperation)
          return getDropOperation(target2, types3, allowedOperations);
        else
          return allowedOperations[0];
      }
    }
    return "cancel";
  }, [
    acceptedDragTypes,
    getDropOperation,
    onInsert,
    onRootDrop,
    onItemDrop,
    shouldAcceptItemDrop,
    onReorder,
    onDrop
  ]);
  return {
    collection: collection2,
    selectionManager,
    target,
    setTarget(newTarget) {
      if (this.isDropTarget(newTarget))
        return;
      let target2 = targetRef.current;
      if (target2 && typeof props.onDropExit === "function")
        props.onDropExit({
          type: "dropexit",
          x: 0,
          y: 0,
          target: target2
        });
      if (newTarget && typeof onDropEnter === "function")
        onDropEnter({
          type: "dropenter",
          x: 0,
          y: 0,
          target: newTarget
        });
      targetRef.current = newTarget;
      setTarget(newTarget);
    },
    isDropTarget(dropTarget) {
      let target2 = targetRef.current;
      if ($e672e8bc247525d1$var$isEqualDropTarget(dropTarget, target2))
        return true;
      if ((dropTarget === null || dropTarget === void 0 ? void 0 : dropTarget.type) === "item" && (target2 === null || target2 === void 0 ? void 0 : target2.type) === "item" && dropTarget.key !== target2.key && dropTarget.dropPosition !== target2.dropPosition && dropTarget.dropPosition !== "on" && target2.dropPosition !== "on")
        return $e672e8bc247525d1$var$isEqualDropTarget(getOppositeTarget(dropTarget), target2) || $e672e8bc247525d1$var$isEqualDropTarget(dropTarget, getOppositeTarget(target2));
      return false;
    },
    getDropOperation(e6) {
      return defaultGetDropOperation(e6);
    }
  };
}
function $e672e8bc247525d1$var$isEqualDropTarget(a3, b2) {
  if (!a3)
    return !b2;
  switch (a3.type) {
    case "root":
      return (b2 === null || b2 === void 0 ? void 0 : b2.type) === "root";
    case "item":
      return (b2 === null || b2 === void 0 ? void 0 : b2.type) === "item" && (b2 === null || b2 === void 0 ? void 0 : b2.key) === a3.key && (b2 === null || b2 === void 0 ? void 0 : b2.dropPosition) === a3.dropPosition;
  }
}

// node_modules/@keystar/ui/dist/keystar-ui-drag-and-drop.js
function FileTrigger(props, ref) {
  let {
    acceptedFileTypes,
    allowsMultiple,
    children,
    defaultCamera,
    onSelect,
    ...rest
  } = props;
  let inputRef = $df56164dff5785e2$export$4338b53315abf666(ref);
  let domProps = $65484d02dcb7eb3e$export$457c3d6518dd4c6f(rest);
  return (0, import_jsx_runtime16.jsxs)(import_jsx_runtime16.Fragment, {
    children: [(0, import_jsx_runtime16.jsx)($f1ab8c75478c6f73$export$3351871ee4b288b8, {
      onPress: () => {
        var _inputRef$current;
        if (inputRef.current.value) {
          inputRef.current.value = "";
        }
        (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.click();
      },
      children
    }), (0, import_jsx_runtime16.jsx)("input", {
      ...domProps,
      accept: acceptedFileTypes === null || acceptedFileTypes === void 0 ? void 0 : acceptedFileTypes.toString(),
      capture: defaultCamera,
      multiple: allowsMultiple,
      onChange: (e6) => onSelect === null || onSelect === void 0 ? void 0 : onSelect(e6.target.files),
      ref: inputRef,
      style: {
        display: "none"
      },
      type: "file"
    })]
  });
}
var _FileTrigger = (0, import_react33.forwardRef)(FileTrigger);
function useDragAndDrop(options) {
  let dragAndDropHooks = (0, import_react33.useMemo)(() => {
    let {
      onDrop,
      onInsert,
      onItemDrop,
      onReorder,
      onRootDrop,
      getItems
    } = options;
    let isDraggable = !!getItems;
    let isDroppable = !!(onDrop || onInsert || onItemDrop || onReorder || onRootDrop);
    let hooks = {};
    if (isDraggable) {
      hooks.useDraggableCollectionState = function useDraggableCollectionStateOverride(props) {
        return $b45bbbaf0c3785df$export$29efd034f1d79f81({
          ...props,
          ...options
        });
      };
      hooks.useDraggableCollection = $4ac1fdc3a0fcd564$export$2962a7984b2f0a80;
      hooks.useDraggableItem = $fd98cf7cbf233429$export$b35afafff42da2d9;
      hooks.DragPreview = $ad0e3f3d9c50e4ba$export$905ab40ac2179daa;
    }
    if (isDroppable) {
      hooks.useDroppableCollectionState = function useDroppableCollectionStateOverride(props) {
        return $e672e8bc247525d1$export$926850f6ecef79d0({
          ...props,
          ...options
        });
      }, hooks.useDroppableItem = $bfaab576ce1c580e$export$f7b0c5d28b66b6a5;
      hooks.useDroppableCollection = function useDroppableCollectionOverride(props, state, ref) {
        return $4b52e4eff84e5217$export$f4e2f423c21f7b04({
          ...props,
          ...options
        }, state, ref);
      };
      hooks.useDropIndicator = $ddf25448c71fc93a$export$8d0e41d2815afac5;
    }
    if (isDraggable || isDroppable) {
      hooks.isVirtualDragging = $67560de7c78cb232$export$403bc76cbf68cf60;
    }
    return hooks;
  }, [options]);
  return {
    dragAndDropHooks
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-trash2Icon.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime());
var trash2Icon = (0, import_jsx_runtime17.jsx)("path", {
  d: "M3 6h18M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2M10 11v6M14 11v6"
});

// node_modules/@react-stately/collections/dist/import.mjs
var import_react34 = __toESM(require_react(), 1);
function $c1d7fb2ec91bae71$var$Item(props) {
  return null;
}
$c1d7fb2ec91bae71$var$Item.getCollectionNode = function* getCollectionNode(props, context) {
  let { childItems, title, children } = props;
  let rendered = props.title || props.children;
  let textValue = props.textValue || (typeof rendered === "string" ? rendered : "") || props["aria-label"] || "";
  if (!textValue && !(context === null || context === void 0 ? void 0 : context.suppressTextValueWarning))
    console.warn("<Item> with non-plain text contents is unsupported by type to select for accessibility. Please add a `textValue` prop.");
  yield {
    type: "item",
    props,
    rendered,
    textValue,
    "aria-label": props["aria-label"],
    hasChildNodes: $c1d7fb2ec91bae71$var$hasChildItems(props),
    *childNodes() {
      if (childItems)
        for (let child of childItems)
          yield {
            type: "item",
            value: child
          };
      else if (title) {
        let items = [];
        (0, import_react34.default).Children.forEach(children, (child) => {
          items.push({
            type: "item",
            element: child
          });
        });
        yield* items;
      }
    }
  };
};
function $c1d7fb2ec91bae71$var$hasChildItems(props) {
  if (props.hasChildItems != null)
    return props.hasChildItems;
  if (props.childItems)
    return true;
  if (props.title && (0, import_react34.default).Children.count(props.children) > 0)
    return true;
  return false;
}
var $c1d7fb2ec91bae71$export$6d08773d2e66f8f2 = $c1d7fb2ec91bae71$var$Item;
function $9fc4852771d079eb$var$Section(props) {
  return null;
}
$9fc4852771d079eb$var$Section.getCollectionNode = function* getCollectionNode2(props) {
  let { children, title, items } = props;
  yield {
    type: "section",
    props,
    hasChildNodes: true,
    rendered: title,
    "aria-label": props["aria-label"],
    *childNodes() {
      if (typeof children === "function") {
        if (!items)
          throw new Error("props.children was a function but props.items is missing");
        for (let item2 of items)
          yield {
            type: "item",
            value: item2,
            renderer: children
          };
      } else {
        let items2 = [];
        (0, import_react34.default).Children.forEach(children, (child) => {
          items2.push({
            type: "item",
            element: child
          });
        });
        yield* items2;
      }
    }
  };
};
var $9fc4852771d079eb$export$6e2c8f0811a474ce = $9fc4852771d079eb$var$Section;
var $eb2240fc39a57fa5$export$bf788dd355e3a401 = class {
  build(props, context) {
    this.context = context;
    return $eb2240fc39a57fa5$var$iterable(() => this.iterateCollection(props));
  }
  *iterateCollection(props) {
    let { children, items } = props;
    if (typeof children === "function") {
      if (!items)
        throw new Error("props.children was a function but props.items is missing");
      for (let item2 of props.items)
        yield* this.getFullNode({
          value: item2
        }, {
          renderer: children
        });
    } else {
      let items2 = [];
      (0, import_react34.default).Children.forEach(children, (child) => {
        items2.push(child);
      });
      let index3 = 0;
      for (let item2 of items2) {
        let nodes = this.getFullNode({
          element: item2,
          index: index3
        }, {});
        for (let node4 of nodes) {
          index3++;
          yield node4;
        }
      }
    }
  }
  getKey(item2, partialNode, state, parentKey) {
    if (item2.key != null)
      return item2.key;
    if (partialNode.type === "cell" && partialNode.key != null)
      return `${parentKey}${partialNode.key}`;
    let v6 = partialNode.value;
    if (v6 != null) {
      var _v_key;
      let key = (_v_key = v6.key) !== null && _v_key !== void 0 ? _v_key : v6.id;
      if (key == null)
        throw new Error("No key found for item");
      return key;
    }
    return parentKey ? `${parentKey}.${partialNode.index}` : `$.${partialNode.index}`;
  }
  getChildState(state, partialNode) {
    return {
      renderer: partialNode.renderer || state.renderer
    };
  }
  *getFullNode(partialNode, state, parentKey, parentNode) {
    let element4 = partialNode.element;
    if (!element4 && partialNode.value && state && state.renderer) {
      let cached = this.cache.get(partialNode.value);
      if (cached && (!cached.shouldInvalidate || !cached.shouldInvalidate(this.context))) {
        cached.index = partialNode.index;
        cached.parentKey = parentNode ? parentNode.key : null;
        yield cached;
        return;
      }
      element4 = state.renderer(partialNode.value);
    }
    if ((0, import_react34.default).isValidElement(element4)) {
      let type2 = element4.type;
      if (typeof type2 !== "function" && typeof type2.getCollectionNode !== "function") {
        let name2 = typeof element4.type === "function" ? element4.type.name : element4.type;
        throw new Error(`Unknown element <${name2}> in collection.`);
      }
      let childNodes = type2.getCollectionNode(element4.props, this.context);
      let index3 = partialNode.index;
      let result = childNodes.next();
      while (!result.done && result.value) {
        let childNode = result.value;
        partialNode.index = index3;
        let nodeKey = childNode.key;
        if (!nodeKey)
          nodeKey = childNode.element ? null : this.getKey(element4, partialNode, state, parentKey);
        let nodes = this.getFullNode({
          ...childNode,
          key: nodeKey,
          index: index3,
          wrapper: $eb2240fc39a57fa5$var$compose(partialNode.wrapper, childNode.wrapper)
        }, this.getChildState(state, childNode), parentKey ? `${parentKey}${element4.key}` : element4.key, parentNode);
        let children = [
          ...nodes
        ];
        for (let node5 of children) {
          node5.value = childNode.value || partialNode.value;
          if (node5.value)
            this.cache.set(node5.value, node5);
          if (partialNode.type && node5.type !== partialNode.type)
            throw new Error(`Unsupported type <${$eb2240fc39a57fa5$var$capitalize(node5.type)}> in <${$eb2240fc39a57fa5$var$capitalize(parentNode.type)}>. Only <${$eb2240fc39a57fa5$var$capitalize(partialNode.type)}> is supported.`);
          index3++;
          yield node5;
        }
        result = childNodes.next(children);
      }
      return;
    }
    if (partialNode.key == null)
      return;
    let builder = this;
    let node4 = {
      type: partialNode.type,
      props: partialNode.props,
      key: partialNode.key,
      parentKey: parentNode ? parentNode.key : null,
      value: partialNode.value,
      level: parentNode ? parentNode.level + 1 : 0,
      index: partialNode.index,
      rendered: partialNode.rendered,
      textValue: partialNode.textValue,
      "aria-label": partialNode["aria-label"],
      wrapper: partialNode.wrapper,
      shouldInvalidate: partialNode.shouldInvalidate,
      hasChildNodes: partialNode.hasChildNodes,
      childNodes: $eb2240fc39a57fa5$var$iterable(function* () {
        if (!partialNode.hasChildNodes)
          return;
        let index3 = 0;
        for (let child of partialNode.childNodes()) {
          if (child.key != null)
            child.key = `${node4.key}${child.key}`;
          child.index = index3;
          let nodes = builder.getFullNode(child, builder.getChildState(state, child), node4.key, node4);
          for (let node5 of nodes) {
            index3++;
            yield node5;
          }
        }
      })
    };
    yield node4;
  }
  constructor() {
    this.cache = /* @__PURE__ */ new WeakMap();
  }
};
function $eb2240fc39a57fa5$var$iterable(iterator) {
  let cache3 = [];
  let iterable = null;
  return {
    *[Symbol.iterator]() {
      for (let item2 of cache3)
        yield item2;
      if (!iterable)
        iterable = iterator();
      for (let item2 of iterable) {
        cache3.push(item2);
        yield item2;
      }
    }
  };
}
function $eb2240fc39a57fa5$var$compose(outer, inner) {
  if (outer && inner)
    return (element4) => outer(inner(element4));
  if (outer)
    return outer;
  if (inner)
    return inner;
}
function $eb2240fc39a57fa5$var$capitalize(str) {
  return str[0].toUpperCase() + str.slice(1);
}
function $7613b1592d41b092$export$6cd28814d92fa9c9(props, factory, context) {
  let builder = (0, import_react34.useMemo)(() => new (0, $eb2240fc39a57fa5$export$bf788dd355e3a401)(), []);
  let { children, items, collection: collection2 } = props;
  let result = (0, import_react34.useMemo)(() => {
    if (collection2)
      return collection2;
    let nodes = builder.build({
      children,
      items
    }, context);
    return factory(nodes);
  }, [
    builder,
    children,
    items,
    collection2,
    context,
    factory
  ]);
  return result;
}
function $c5a24bc478652b5f$export$1005530eda016c13(node4, collection2) {
  if (typeof collection2.getChildren === "function")
    return collection2.getChildren(node4.key);
  return node4.childNodes;
}
function $c5a24bc478652b5f$export$fbdeaa6a76694f71(iterable) {
  return $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, 0);
}
function $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, index3) {
  if (index3 < 0)
    return void 0;
  let i6 = 0;
  for (let item2 of iterable) {
    if (i6 === index3)
      return item2;
    i6++;
  }
}
function $c5a24bc478652b5f$export$7475b2c64539e4cf(iterable) {
  let lastItem = void 0;
  for (let value2 of iterable)
    lastItem = value2;
  return lastItem;
}
function $c5a24bc478652b5f$export$8c434b3a7a4dad6(collection2, a3, b2) {
  if (a3.parentKey === b2.parentKey)
    return a3.index - b2.index;
  let aAncestors = [
    ...$c5a24bc478652b5f$var$getAncestors(collection2, a3),
    a3
  ];
  let bAncestors = [
    ...$c5a24bc478652b5f$var$getAncestors(collection2, b2),
    b2
  ];
  let firstNonMatchingAncestor = aAncestors.slice(0, bAncestors.length).findIndex((a4, i6) => a4 !== bAncestors[i6]);
  if (firstNonMatchingAncestor !== -1) {
    a3 = aAncestors[firstNonMatchingAncestor];
    b2 = bAncestors[firstNonMatchingAncestor];
    return a3.index - b2.index;
  }
  if (aAncestors.findIndex((node4) => node4 === b2) >= 0)
    return 1;
  else if (bAncestors.findIndex((node4) => node4 === a3) >= 0)
    return -1;
  return -1;
}
function $c5a24bc478652b5f$var$getAncestors(collection2, node4) {
  let parents = [];
  while ((node4 === null || node4 === void 0 ? void 0 : node4.parentKey) != null) {
    node4 = collection2.getItem(node4.parentKey);
    parents.unshift(node4);
  }
  return parents;
}
var $453cc9f0df89c0a5$var$cache = /* @__PURE__ */ new WeakMap();
function $453cc9f0df89c0a5$export$77d5aafae4e095b2(collection2) {
  let count = $453cc9f0df89c0a5$var$cache.get(collection2);
  if (count != null)
    return count;
  count = 0;
  let countItems = (items) => {
    for (let item2 of items)
      if (item2.type === "section")
        countItems((0, $c5a24bc478652b5f$export$1005530eda016c13)(item2, collection2));
      else
        count++;
  };
  countItems(collection2);
  $453cc9f0df89c0a5$var$cache.set(collection2, count);
  return count;
}

// node_modules/@react-stately/selection/dist/import.mjs
var import_react35 = __toESM(require_react(), 1);
var $e40ea825a81a3709$export$52baac22726c72bf = class _$e40ea825a81a3709$export$52baac22726c72bf extends Set {
  constructor(keys3, anchorKey, currentKey) {
    super(keys3);
    if (keys3 instanceof _$e40ea825a81a3709$export$52baac22726c72bf) {
      this.anchorKey = anchorKey || keys3.anchorKey;
      this.currentKey = currentKey || keys3.currentKey;
    } else {
      this.anchorKey = anchorKey;
      this.currentKey = currentKey;
    }
  }
};
function $7af3f5b51489e0b5$var$equalSets(setA, setB) {
  if (setA.size !== setB.size)
    return false;
  for (let item2 of setA) {
    if (!setB.has(item2))
      return false;
  }
  return true;
}
function $7af3f5b51489e0b5$export$253fe78d46329472(props) {
  let { selectionMode = "none", disallowEmptySelection, allowDuplicateSelectionEvents, selectionBehavior: selectionBehaviorProp = "toggle", disabledBehavior = "all" } = props;
  let isFocusedRef = (0, import_react35.useRef)(false);
  let [, setFocused] = (0, import_react35.useState)(false);
  let focusedKeyRef = (0, import_react35.useRef)(null);
  let childFocusStrategyRef = (0, import_react35.useRef)(null);
  let [, setFocusedKey] = (0, import_react35.useState)(null);
  let selectedKeysProp = (0, import_react35.useMemo)(() => $7af3f5b51489e0b5$var$convertSelection(props.selectedKeys), [
    props.selectedKeys
  ]);
  let defaultSelectedKeys = (0, import_react35.useMemo)(() => $7af3f5b51489e0b5$var$convertSelection(props.defaultSelectedKeys, new (0, $e40ea825a81a3709$export$52baac22726c72bf)()), [
    props.defaultSelectedKeys
  ]);
  let [selectedKeys, setSelectedKeys] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(selectedKeysProp, defaultSelectedKeys, props.onSelectionChange);
  let disabledKeysProp = (0, import_react35.useMemo)(() => props.disabledKeys ? new Set(props.disabledKeys) : /* @__PURE__ */ new Set(), [
    props.disabledKeys
  ]);
  let [selectionBehavior, setSelectionBehavior] = (0, import_react35.useState)(selectionBehaviorProp);
  if (selectionBehaviorProp === "replace" && selectionBehavior === "toggle" && typeof selectedKeys === "object" && selectedKeys.size === 0)
    setSelectionBehavior("replace");
  let lastSelectionBehavior = (0, import_react35.useRef)(selectionBehaviorProp);
  (0, import_react35.useEffect)(() => {
    if (selectionBehaviorProp !== lastSelectionBehavior.current) {
      setSelectionBehavior(selectionBehaviorProp);
      lastSelectionBehavior.current = selectionBehaviorProp;
    }
  }, [
    selectionBehaviorProp
  ]);
  return {
    selectionMode,
    disallowEmptySelection,
    selectionBehavior,
    setSelectionBehavior,
    get isFocused() {
      return isFocusedRef.current;
    },
    setFocused(f6) {
      isFocusedRef.current = f6;
      setFocused(f6);
    },
    get focusedKey() {
      return focusedKeyRef.current;
    },
    get childFocusStrategy() {
      return childFocusStrategyRef.current;
    },
    setFocusedKey(k2, childFocusStrategy = "first") {
      focusedKeyRef.current = k2;
      childFocusStrategyRef.current = childFocusStrategy;
      setFocusedKey(k2);
    },
    selectedKeys,
    setSelectedKeys(keys3) {
      if (allowDuplicateSelectionEvents || !$7af3f5b51489e0b5$var$equalSets(keys3, selectedKeys))
        setSelectedKeys(keys3);
    },
    disabledKeys: disabledKeysProp,
    disabledBehavior
  };
}
function $7af3f5b51489e0b5$var$convertSelection(selection, defaultValue) {
  if (!selection)
    return defaultValue;
  return selection === "all" ? "all" : new (0, $e40ea825a81a3709$export$52baac22726c72bf)(selection);
}
var $d496c0a20b6e58ec$export$6c8a5aaad13c9852 = class {
  /**
  * The type of selection that is allowed in the collection.
  */
  get selectionMode() {
    return this.state.selectionMode;
  }
  /**
  * Whether the collection allows empty selection.
  */
  get disallowEmptySelection() {
    return this.state.disallowEmptySelection;
  }
  /**
  * The selection behavior for the collection.
  */
  get selectionBehavior() {
    return this.state.selectionBehavior;
  }
  /**
  * Sets the selection behavior for the collection.
  */
  setSelectionBehavior(selectionBehavior) {
    this.state.setSelectionBehavior(selectionBehavior);
  }
  /**
  * Whether the collection is currently focused.
  */
  get isFocused() {
    return this.state.isFocused;
  }
  /**
  * Sets whether the collection is focused.
  */
  setFocused(isFocused) {
    this.state.setFocused(isFocused);
  }
  /**
  * The current focused key in the collection.
  */
  get focusedKey() {
    return this.state.focusedKey;
  }
  /** Whether the first or last child of the focused key should receive focus. */
  get childFocusStrategy() {
    return this.state.childFocusStrategy;
  }
  /**
  * Sets the focused key.
  */
  setFocusedKey(key, childFocusStrategy) {
    if (key == null || this.collection.getItem(key))
      this.state.setFocusedKey(key, childFocusStrategy);
  }
  /**
  * The currently selected keys in the collection.
  */
  get selectedKeys() {
    return this.state.selectedKeys === "all" ? new Set(this.getSelectAllKeys()) : this.state.selectedKeys;
  }
  /**
  * The raw selection value for the collection.
  * Either 'all' for select all, or a set of keys.
  */
  get rawSelection() {
    return this.state.selectedKeys;
  }
  /**
  * Returns whether a key is selected.
  */
  isSelected(key) {
    if (this.state.selectionMode === "none")
      return false;
    key = this.getKey(key);
    return this.state.selectedKeys === "all" ? this.canSelectItem(key) : this.state.selectedKeys.has(key);
  }
  /**
  * Whether the selection is empty.
  */
  get isEmpty() {
    return this.state.selectedKeys !== "all" && this.state.selectedKeys.size === 0;
  }
  /**
  * Whether all items in the collection are selected.
  */
  get isSelectAll() {
    if (this.isEmpty)
      return false;
    if (this.state.selectedKeys === "all")
      return true;
    if (this._isSelectAll != null)
      return this._isSelectAll;
    let allKeys = this.getSelectAllKeys();
    let selectedKeys = this.state.selectedKeys;
    this._isSelectAll = allKeys.every((k2) => selectedKeys.has(k2));
    return this._isSelectAll;
  }
  get firstSelectedKey() {
    let first = null;
    for (let key of this.state.selectedKeys) {
      let item2 = this.collection.getItem(key);
      if (!first || item2 && (0, $c5a24bc478652b5f$export$8c434b3a7a4dad6)(this.collection, item2, first) < 0)
        first = item2;
    }
    return first === null || first === void 0 ? void 0 : first.key;
  }
  get lastSelectedKey() {
    let last2 = null;
    for (let key of this.state.selectedKeys) {
      let item2 = this.collection.getItem(key);
      if (!last2 || item2 && (0, $c5a24bc478652b5f$export$8c434b3a7a4dad6)(this.collection, item2, last2) > 0)
        last2 = item2;
    }
    return last2 === null || last2 === void 0 ? void 0 : last2.key;
  }
  get disabledKeys() {
    return this.state.disabledKeys;
  }
  get disabledBehavior() {
    return this.state.disabledBehavior;
  }
  /**
  * Extends the selection to the given key.
  */
  extendSelection(toKey) {
    if (this.selectionMode === "none")
      return;
    if (this.selectionMode === "single") {
      this.replaceSelection(toKey);
      return;
    }
    toKey = this.getKey(toKey);
    let selection;
    if (this.state.selectedKeys === "all")
      selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)([
        toKey
      ], toKey, toKey);
    else {
      let selectedKeys = this.state.selectedKeys;
      let anchorKey = selectedKeys.anchorKey || toKey;
      selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)(selectedKeys, anchorKey, toKey);
      for (let key of this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey))
        selection.delete(key);
      for (let key of this.getKeyRange(toKey, anchorKey))
        if (this.canSelectItem(key))
          selection.add(key);
    }
    this.state.setSelectedKeys(selection);
  }
  getKeyRange(from4, to) {
    let fromItem = this.collection.getItem(from4);
    let toItem = this.collection.getItem(to);
    if (fromItem && toItem) {
      if ((0, $c5a24bc478652b5f$export$8c434b3a7a4dad6)(this.collection, fromItem, toItem) <= 0)
        return this.getKeyRangeInternal(from4, to);
      return this.getKeyRangeInternal(to, from4);
    }
    return [];
  }
  getKeyRangeInternal(from4, to) {
    let keys3 = [];
    let key = from4;
    while (key) {
      let item2 = this.collection.getItem(key);
      if (item2 && item2.type === "item" || item2.type === "cell" && this.allowsCellSelection)
        keys3.push(key);
      if (key === to)
        return keys3;
      key = this.collection.getKeyAfter(key);
    }
    return [];
  }
  getKey(key) {
    let item2 = this.collection.getItem(key);
    if (!item2)
      return key;
    if (item2.type === "cell" && this.allowsCellSelection)
      return key;
    while (item2.type !== "item" && item2.parentKey != null)
      item2 = this.collection.getItem(item2.parentKey);
    if (!item2 || item2.type !== "item")
      return null;
    return item2.key;
  }
  /**
  * Toggles whether the given key is selected.
  */
  toggleSelection(key) {
    if (this.selectionMode === "none")
      return;
    if (this.selectionMode === "single" && !this.isSelected(key)) {
      this.replaceSelection(key);
      return;
    }
    key = this.getKey(key);
    if (key == null)
      return;
    let keys3 = new (0, $e40ea825a81a3709$export$52baac22726c72bf)(this.state.selectedKeys === "all" ? this.getSelectAllKeys() : this.state.selectedKeys);
    if (keys3.has(key))
      keys3.delete(key);
    else if (this.canSelectItem(key)) {
      keys3.add(key);
      keys3.anchorKey = key;
      keys3.currentKey = key;
    }
    if (this.disallowEmptySelection && keys3.size === 0)
      return;
    this.state.setSelectedKeys(keys3);
  }
  /**
  * Replaces the selection with only the given key.
  */
  replaceSelection(key) {
    if (this.selectionMode === "none")
      return;
    key = this.getKey(key);
    if (key == null)
      return;
    let selection = this.canSelectItem(key) ? new (0, $e40ea825a81a3709$export$52baac22726c72bf)([
      key
    ], key, key) : new (0, $e40ea825a81a3709$export$52baac22726c72bf)();
    this.state.setSelectedKeys(selection);
  }
  /**
  * Replaces the selection with the given keys.
  */
  setSelectedKeys(keys3) {
    if (this.selectionMode === "none")
      return;
    let selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)();
    for (let key of keys3) {
      key = this.getKey(key);
      if (key != null) {
        selection.add(key);
        if (this.selectionMode === "single")
          break;
      }
    }
    this.state.setSelectedKeys(selection);
  }
  getSelectAllKeys() {
    let keys3 = [];
    let addKeys = (key) => {
      while (key) {
        if (this.canSelectItem(key)) {
          let item2 = this.collection.getItem(key);
          if (item2.type === "item")
            keys3.push(key);
          if (item2.hasChildNodes && (this.allowsCellSelection || item2.type !== "item"))
            addKeys((0, $c5a24bc478652b5f$export$fbdeaa6a76694f71)((0, $c5a24bc478652b5f$export$1005530eda016c13)(item2, this.collection)).key);
        }
        key = this.collection.getKeyAfter(key);
      }
    };
    addKeys(this.collection.getFirstKey());
    return keys3;
  }
  /**
  * Selects all items in the collection.
  */
  selectAll() {
    if (!this.isSelectAll && this.selectionMode === "multiple")
      this.state.setSelectedKeys("all");
  }
  /**
  * Removes all keys from the selection.
  */
  clearSelection() {
    if (!this.disallowEmptySelection && (this.state.selectedKeys === "all" || this.state.selectedKeys.size > 0))
      this.state.setSelectedKeys(new (0, $e40ea825a81a3709$export$52baac22726c72bf)());
  }
  /**
  * Toggles between select all and an empty selection.
  */
  toggleSelectAll() {
    if (this.isSelectAll)
      this.clearSelection();
    else
      this.selectAll();
  }
  select(key, e6) {
    if (this.selectionMode === "none")
      return;
    if (this.selectionMode === "single") {
      if (this.isSelected(key) && !this.disallowEmptySelection)
        this.toggleSelection(key);
      else
        this.replaceSelection(key);
    } else if (this.selectionBehavior === "toggle" || e6 && (e6.pointerType === "touch" || e6.pointerType === "virtual"))
      this.toggleSelection(key);
    else
      this.replaceSelection(key);
  }
  /**
  * Returns whether the current selection is equal to the given selection.
  */
  isSelectionEqual(selection) {
    if (selection === this.state.selectedKeys)
      return true;
    let selectedKeys = this.selectedKeys;
    if (selection.size !== selectedKeys.size)
      return false;
    for (let key of selection) {
      if (!selectedKeys.has(key))
        return false;
    }
    for (let key of selectedKeys) {
      if (!selection.has(key))
        return false;
    }
    return true;
  }
  canSelectItem(key) {
    if (this.state.selectionMode === "none" || this.state.disabledKeys.has(key))
      return false;
    let item2 = this.collection.getItem(key);
    if (!item2 || item2.type === "cell" && !this.allowsCellSelection)
      return false;
    return true;
  }
  isDisabled(key) {
    return this.state.disabledKeys.has(key) && this.state.disabledBehavior === "all";
  }
  isLink(key) {
    var _this_collection_getItem_props, _this_collection_getItem;
    return !!((_this_collection_getItem = this.collection.getItem(key)) === null || _this_collection_getItem === void 0 ? void 0 : (_this_collection_getItem_props = _this_collection_getItem.props) === null || _this_collection_getItem_props === void 0 ? void 0 : _this_collection_getItem_props.href);
  }
  constructor(collection2, state, options) {
    this.collection = collection2;
    this.state = state;
    var _options_allowsCellSelection;
    this.allowsCellSelection = (_options_allowsCellSelection = options === null || options === void 0 ? void 0 : options.allowsCellSelection) !== null && _options_allowsCellSelection !== void 0 ? _options_allowsCellSelection : false;
    this._isSelectAll = null;
  }
};

// node_modules/@react-stately/list/dist/import.mjs
var import_react36 = __toESM(require_react(), 1);
var $a02d57049d202695$export$d085fb9e920b5ca7 = class {
  *[Symbol.iterator]() {
    yield* this.iterable;
  }
  get size() {
    return this.keyMap.size;
  }
  getKeys() {
    return this.keyMap.keys();
  }
  getKeyBefore(key) {
    let node4 = this.keyMap.get(key);
    return node4 ? node4.prevKey : null;
  }
  getKeyAfter(key) {
    let node4 = this.keyMap.get(key);
    return node4 ? node4.nextKey : null;
  }
  getFirstKey() {
    return this.firstKey;
  }
  getLastKey() {
    return this.lastKey;
  }
  getItem(key) {
    return this.keyMap.get(key);
  }
  at(idx) {
    const keys3 = [
      ...this.getKeys()
    ];
    return this.getItem(keys3[idx]);
  }
  getChildren(key) {
    let node4 = this.keyMap.get(key);
    return (node4 === null || node4 === void 0 ? void 0 : node4.childNodes) || [];
  }
  constructor(nodes) {
    this.keyMap = /* @__PURE__ */ new Map();
    this.iterable = nodes;
    let visit2 = (node4) => {
      this.keyMap.set(node4.key, node4);
      if (node4.childNodes && node4.type === "section")
        for (let child of node4.childNodes)
          visit2(child);
    };
    for (let node4 of nodes)
      visit2(node4);
    let last2;
    let index3 = 0;
    for (let [key, node4] of this.keyMap) {
      if (last2) {
        last2.nextKey = key;
        node4.prevKey = last2.key;
      } else {
        this.firstKey = key;
        node4.prevKey = void 0;
      }
      if (node4.type === "item")
        node4.index = index3++;
      last2 = node4;
      last2.nextKey = void 0;
    }
    this.lastKey = last2 === null || last2 === void 0 ? void 0 : last2.key;
  }
};
function $e72dd72e1c76a225$export$2f645645f7bca764(props) {
  let { filter: filter3 } = props;
  let selectionState = (0, $7af3f5b51489e0b5$export$253fe78d46329472)(props);
  let disabledKeys = (0, import_react36.useMemo)(() => props.disabledKeys ? new Set(props.disabledKeys) : /* @__PURE__ */ new Set(), [
    props.disabledKeys
  ]);
  let factory = (0, import_react36.useCallback)((nodes) => filter3 ? new (0, $a02d57049d202695$export$d085fb9e920b5ca7)(filter3(nodes)) : new (0, $a02d57049d202695$export$d085fb9e920b5ca7)(nodes), [
    filter3
  ]);
  let context = (0, import_react36.useMemo)(() => ({
    suppressTextValueWarning: props.suppressTextValueWarning
  }), [
    props.suppressTextValueWarning
  ]);
  let collection2 = (0, $7613b1592d41b092$export$6cd28814d92fa9c9)(props, factory, context);
  let selectionManager = (0, import_react36.useMemo)(() => new (0, $d496c0a20b6e58ec$export$6c8a5aaad13c9852)(collection2, selectionState), [
    collection2,
    selectionState
  ]);
  const cachedCollection = (0, import_react36.useRef)(null);
  (0, import_react36.useEffect)(() => {
    if (selectionState.focusedKey != null && !collection2.getItem(selectionState.focusedKey)) {
      const startItem = cachedCollection.current.getItem(selectionState.focusedKey);
      const cachedItemNodes = [
        ...cachedCollection.current.getKeys()
      ].map((key) => {
        const itemNode = cachedCollection.current.getItem(key);
        return itemNode.type === "item" ? itemNode : null;
      }).filter((node4) => node4 !== null);
      const itemNodes = [
        ...collection2.getKeys()
      ].map((key) => {
        const itemNode = collection2.getItem(key);
        return itemNode.type === "item" ? itemNode : null;
      }).filter((node4) => node4 !== null);
      const diff = cachedItemNodes.length - itemNodes.length;
      let index3 = Math.min(diff > 1 ? Math.max(startItem.index - diff + 1, 0) : startItem.index, itemNodes.length - 1);
      let newNode;
      while (index3 >= 0) {
        if (!selectionManager.isDisabled(itemNodes[index3].key)) {
          newNode = itemNodes[index3];
          break;
        }
        if (index3 < itemNodes.length - 1)
          index3++;
        else {
          if (index3 > startItem.index)
            index3 = startItem.index;
          index3--;
        }
      }
      selectionState.setFocusedKey(newNode ? newNode.key : null);
    }
    cachedCollection.current = collection2;
  }, [
    collection2,
    selectionManager,
    selectionState,
    selectionState.focusedKey
  ]);
  return {
    collection: collection2,
    disabledKeys,
    selectionManager
  };
}
function $a0d645289fe9b86b$export$e7f05e985daf4b5f(props) {
  var _props_defaultSelectedKey;
  let [selectedKey, setSelectedKey] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(props.selectedKey, (_props_defaultSelectedKey = props.defaultSelectedKey) !== null && _props_defaultSelectedKey !== void 0 ? _props_defaultSelectedKey : null, props.onSelectionChange);
  let selectedKeys = (0, import_react36.useMemo)(() => selectedKey != null ? [
    selectedKey
  ] : [], [
    selectedKey
  ]);
  let { collection: collection2, disabledKeys, selectionManager } = (0, $e72dd72e1c76a225$export$2f645645f7bca764)({
    ...props,
    selectionMode: "single",
    disallowEmptySelection: true,
    allowDuplicateSelectionEvents: true,
    selectedKeys,
    onSelectionChange: (keys3) => {
      var _keys_values_next_value;
      let key = (_keys_values_next_value = keys3.values().next().value) !== null && _keys_values_next_value !== void 0 ? _keys_values_next_value : null;
      if (key === selectedKey && props.onSelectionChange)
        props.onSelectionChange(key);
      setSelectedKey(key);
    }
  });
  let selectedItem = selectedKey != null ? collection2.getItem(selectedKey) : null;
  return {
    collection: collection2,
    disabledKeys,
    selectionManager,
    selectedKey,
    setSelectedKey,
    selectedItem
  };
}

// node_modules/@react-aria/progress/dist/import.mjs
function $204d9ebcedfb8806$export$ed5abd763a836edc(props) {
  let { value: value2 = 0, minValue = 0, maxValue = 100, valueLabel, isIndeterminate, formatOptions = {
    style: "percent"
  } } = props;
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let { labelProps, fieldProps } = (0, $d191a55c9702f145$export$8467354a121f1b9f)({
    ...props,
    // Progress bar is not an HTML input element so it
    // shouldn't be labeled by a <label> element.
    labelElementType: "span"
  });
  value2 = (0, $9446cca9a3875146$export$7d15b64cf5a3a4c4)(value2, minValue, maxValue);
  let percentage = (value2 - minValue) / (maxValue - minValue);
  let formatter = (0, $a916eb452884faea$export$b7a616150fdb9f44)(formatOptions);
  if (!isIndeterminate && !valueLabel) {
    let valueToFormat = formatOptions.style === "percent" ? percentage : value2;
    valueLabel = formatter.format(valueToFormat);
  }
  return {
    progressBarProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, {
      ...fieldProps,
      "aria-valuenow": isIndeterminate ? void 0 : value2,
      "aria-valuemin": minValue,
      "aria-valuemax": maxValue,
      "aria-valuetext": isIndeterminate ? void 0 : valueLabel,
      role: "progressbar"
    }),
    labelProps
  };
}

// node_modules/@react-aria/meter/dist/import.mjs
function $0002d7e1d16de204$export$e969dbfa146870ff(props) {
  let { progressBarProps, labelProps } = (0, $204d9ebcedfb8806$export$ed5abd763a836edc)(props);
  return {
    meterProps: {
      ...progressBarProps,
      // Use the meter role if available, but fall back to progressbar if not
      // Chrome currently falls back from meter automatically, and Firefox
      // does not support meter at all. Safari 13+ seems to support meter properly.
      // https://bugs.chromium.org/p/chromium/issues/detail?id=944542
      // https://bugzilla.mozilla.org/show_bug.cgi?id=1460378
      role: "meter progressbar"
    },
    labelProps
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-progress.js
var import_react37 = __toESM(require_react());
var import_jsx_runtime18 = __toESM(require_jsx_runtime());
var BarBase = (0, import_react37.forwardRef)(function BarBase2(props, forwardedRef) {
  let {
    value: value2 = 0,
    minValue = 0,
    maxValue = 100,
    label,
    barClassName,
    showValueLabel = !!label,
    isIndeterminate,
    barProps,
    labelProps,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledby,
    ...otherProps
  } = props;
  let styleProps = useStyleProps(otherProps);
  value2 = $9446cca9a3875146$export$7d15b64cf5a3a4c4(value2, minValue, maxValue);
  let barStyle = {};
  if (!isIndeterminate) {
    let percentage = (value2 - minValue) / (maxValue - minValue);
    barStyle.width = `${Math.round(percentage * 100)}%`;
  }
  warning(!!(label || ariaLabel || ariaLabelledby), "If you do not provide a visible label via children, you must specify an aria-label or aria-labelledby attribute for accessibility.");
  return (0, import_jsx_runtime18.jsxs)("div", {
    ...barProps,
    ...styleProps,
    ref: forwardedRef,
    className: classNames(css({
      "--bar-fill": tokenSchema.color.background.accentEmphasis,
      alignItems: "flex-start",
      display: "inline-flex",
      gap: tokenSchema.size.space.regular,
      flexFlow: "wrap",
      isolation: "isolate",
      justifyContent: "space-between",
      minWidth: 0,
      position: "relative",
      verticalAlign: "top",
      width: tokenSchema.size.alias.singleLineWidth
    }), barClassName, styleProps.className),
    children: [label && (0, import_jsx_runtime18.jsx)(Text2, {
      ...labelProps,
      flex: true,
      children: label
    }), showValueLabel && barProps && (0, import_jsx_runtime18.jsx)(Text2, {
      flexShrink: 0,
      children: barProps["aria-valuetext"]
    }), (0, import_jsx_runtime18.jsx)("div", {
      className: css({
        backgroundColor: tokenSchema.color.border.muted,
        borderRadius: tokenSchema.size.radius.full,
        height: tokenSchema.size.space.regular,
        minWidth: 0,
        overflow: "hidden",
        width: "100%",
        zIndex: "1"
      }),
      children: (0, import_jsx_runtime18.jsx)("div", {
        ...toDataAttributes({
          indeterminate: isIndeterminate !== null && isIndeterminate !== void 0 ? isIndeterminate : void 0
        }),
        className: css({
          backgroundColor: "var(--bar-fill)",
          height: tokenSchema.size.space.regular,
          transition: transition("width", {
            duration: "regular"
          }),
          "&[data-indeterminate]": {
            animation: `${indeterminateLoopLtr} ${tokenSchema.animation.duration.long} ${tokenSchema.animation.easing.easeInOut} infinite`,
            willChange: "transform",
            "[dir=rtl] &": {
              animationName: indeterminateLoopRtl
            }
          }
        }),
        style: barStyle
      })
    })]
  });
});
var indeterminateLoopLtr = keyframes({
  from: {
    transform: "translate(-100%)"
  },
  to: {
    transform: "translate(100%)"
  }
});
var indeterminateLoopRtl = keyframes({
  from: {
    transform: "translate(100%)"
  },
  to: {
    transform: "translate(-100%)"
  }
});
var Meter = (0, import_react37.forwardRef)(function Meter2(props, forwardedRef) {
  let {
    tone,
    ...otherProps
  } = props;
  const {
    meterProps,
    labelProps
  } = $0002d7e1d16de204$export$e969dbfa146870ff(props);
  return (0, import_jsx_runtime18.jsx)(BarBase, {
    ...otherProps,
    ref: forwardedRef,
    barClassName: css({
      '&[data-tone="positive"]': {
        "--bar-fill": tokenSchema.color.background.positiveEmphasis
      },
      '&[data-tone="caution"]': {
        "--bar-fill": tokenSchema.color.background.cautionEmphasis
      },
      '&[data-tone="critical"]': {
        "--bar-fill": tokenSchema.color.background.criticalEmphasis
      }
    }),
    barProps: {
      ...meterProps,
      ...toDataAttributes({
        tone
      })
    },
    labelProps
  });
});
var ProgressBar = (0, import_react37.forwardRef)(function ProgressBar2(props, forwardedRef) {
  const {
    progressBarProps,
    labelProps
  } = $204d9ebcedfb8806$export$ed5abd763a836edc(props);
  return (0, import_jsx_runtime18.jsx)(BarBase, {
    ...props,
    ref: forwardedRef,
    barProps: progressBarProps,
    labelProps
  });
});
var ProgressCircle = (0, import_react37.forwardRef)(function ProgressCircle2(props, forwardRef28) {
  let {
    value: value2 = 0,
    minValue = 0,
    maxValue = 100,
    size: size3 = "medium",
    isIndeterminate,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledby,
    ...otherProps
  } = props;
  value2 = $9446cca9a3875146$export$7d15b64cf5a3a4c4(value2, minValue, maxValue);
  let {
    progressBarProps
  } = $204d9ebcedfb8806$export$ed5abd763a836edc({
    ...props,
    value: value2
  });
  let styleProps = useStyleProps(otherProps);
  warning(!!(ariaLabel || ariaLabelledby), "ProgressCircle requires an aria-label or aria-labelledby attribute for accessibility.");
  return (0, import_jsx_runtime18.jsx)("div", {
    ...styleProps,
    ...progressBarProps,
    ref: forwardRef28,
    ...toDataAttributes({
      indeterminate: isIndeterminate !== null && isIndeterminate !== void 0 ? isIndeterminate : void 0,
      size: size3 === "medium" ? void 0 : size3
    }),
    className: classNames(css({
      height: "var(--diameter)",
      width: "var(--diameter)",
      "--PI": 3.14159,
      "--diameter": tokenSchema.size.element.regular,
      "--radius": "calc(var(--diameter) / 2)",
      "--stroke-width": tokenSchema.size.scale[40],
      // TODO: component tokent
      "--offset-radius": "calc(var(--radius) - var(--stroke-width) / 2)",
      "--circumference": `calc(var(--offset-radius) * var(--PI) * 2)`,
      ["&[data-size=small]"]: {
        "--diameter": tokenSchema.size.element.xsmall,
        "--stroke-width": tokenSchema.size.border.medium
      },
      ["&[data-size=large]"]: {
        "--diameter": tokenSchema.size.element.xlarge,
        "--stroke-width": tokenSchema.size.border.large
      }
    }), styleProps.className),
    style: {
      // @ts-ignore
      "--percent": (value2 - minValue) / (maxValue - minValue),
      ...styleProps.style
    },
    children: (0, import_jsx_runtime18.jsxs)("svg", {
      ...toDataAttributes({
        indeterminate: isIndeterminate !== null && isIndeterminate !== void 0 ? isIndeterminate : void 0
      }),
      role: "presentation",
      tabIndex: -1,
      className: css({
        height: "var(--diameter)",
        width: "var(--diameter)",
        "&[data-indeterminate]": {
          animation: `${rotateAnimation} ${tokenSchema.animation.duration.xlong} linear infinite`
        }
      }),
      children: [(0, import_jsx_runtime18.jsx)("circle", {
        className: circle({
          stroke: tokenSchema.color.border.muted
        })
      }), (0, import_jsx_runtime18.jsx)("circle", {
        ...toDataAttributes({
          indeterminate: isIndeterminate !== null && isIndeterminate !== void 0 ? isIndeterminate : void 0
        }),
        className: circle({
          stroke: tokenSchema.color.background.accentEmphasis,
          strokeDasharray: "var(--circumference)",
          strokeLinecap: "round",
          "&:not([data-indeterminate])": {
            strokeDashoffset: `calc(var(--circumference) - var(--percent) * var(--circumference))`,
            transition: transition("stroke-dashoffset", {
              duration: "regular"
            }),
            transform: "rotate(-90deg)",
            transformOrigin: "center"
          },
          "&[data-indeterminate]": {
            animation: `${dashAnimation} ${tokenSchema.animation.duration.xlong} ${tokenSchema.animation.easing.easeInOut} infinite`
          }
        })
      })]
    })
  });
});
function circle(styles2) {
  return css([{
    cx: "var(--radius)",
    cy: "var(--radius)",
    r: "var(--offset-radius)",
    fill: "transparent",
    strokeWidth: "var(--stroke-width)"
  }, styles2]);
}
var rotateAnimation = keyframes({
  from: {
    transform: "rotate(0deg)"
  },
  to: {
    transform: "rotate(360deg)"
  }
});
var dashAnimation = keyframes({
  from: {
    strokeDashoffset: "calc(var(--circumference) * 1.25)"
  },
  to: {
    strokeDashoffset: "calc(var(--circumference) * -0.75)"
  }
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-minusIcon.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime());
var minusIcon = (0, import_jsx_runtime19.jsx)("path", {
  d: "M5 12h14"
});

// node_modules/@react-aria/checkbox/dist/import.mjs
var import_react38 = __toESM(require_react(), 1);

// node_modules/@react-aria/toggle/dist/import.mjs
function $d2c8e2b0480f3f34$export$cbe85ee05b554577(props, state, ref) {
  let { isDisabled = false, isReadOnly = false, value: value2, name: name2, children, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledby, validationState = "valid", isInvalid } = props;
  let onChange2 = (e6) => {
    e6.stopPropagation();
    state.setSelected(e6.target.checked);
  };
  let hasChildren = children != null;
  let hasAriaLabel = ariaLabel != null || ariaLabelledby != null;
  if (!hasChildren && !hasAriaLabel)
    console.warn("If you do not provide children, you must specify an aria-label for accessibility");
  let { pressProps, isPressed } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    isDisabled
  });
  let { pressProps: labelProps, isPressed: isLabelPressed } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    isDisabled: isDisabled || isReadOnly,
    onPress() {
      state.toggle();
    }
  });
  let { focusableProps } = (0, $e6afbd83fe6ebbd2$export$4c014de7c8940b4c)(props, ref);
  let interactions = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(pressProps, focusableProps);
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  (0, $99facab73266f662$export$5add1d006293d136)(ref, state.isSelected, state.setSelected);
  return {
    labelProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(labelProps, {
      onClick: (e6) => e6.preventDefault()
    }),
    inputProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, {
      "aria-invalid": isInvalid || validationState === "invalid" || void 0,
      "aria-errormessage": props["aria-errormessage"],
      "aria-controls": props["aria-controls"],
      "aria-readonly": isReadOnly || void 0,
      onChange: onChange2,
      disabled: isDisabled,
      ...value2 == null ? {} : {
        value: value2
      },
      name: name2,
      type: "checkbox",
      ...interactions
    }),
    isSelected: state.isSelected,
    isPressed: isPressed || isLabelPressed,
    isDisabled,
    isReadOnly,
    isInvalid: isInvalid || validationState === "invalid"
  };
}

// node_modules/@react-aria/checkbox/dist/import.mjs
function $406796ff087fe49b$export$e375f10ce42261c5(props, state, inputRef) {
  let validationState = (0, $e5be200c675c3b3a$export$fc1a364ae1f3ff10)({
    ...props,
    value: state.isSelected
  });
  let { isInvalid, validationErrors, validationDetails } = validationState.displayValidation;
  let { labelProps, inputProps, isSelected, isPressed, isDisabled, isReadOnly } = (0, $d2c8e2b0480f3f34$export$cbe85ee05b554577)({
    ...props,
    isInvalid
  }, state, inputRef);
  (0, $e93e671b31057976$export$b8473d3665f3a75a)(props, validationState, inputRef);
  let { isIndeterminate, isRequired, validationBehavior = "aria" } = props;
  (0, import_react38.useEffect)(() => {
    if (inputRef.current)
      inputRef.current.indeterminate = !!isIndeterminate;
  });
  return {
    labelProps,
    inputProps: {
      ...inputProps,
      checked: isSelected,
      "aria-required": isRequired && validationBehavior === "aria" || void 0,
      required: isRequired && validationBehavior === "native"
    },
    isSelected,
    isPressed,
    isDisabled,
    isReadOnly,
    isInvalid,
    validationErrors,
    validationDetails
  };
}
var $1ae600c947479353$export$ec98120685d4f57d = /* @__PURE__ */ new WeakMap();
function $1e9fce0cfacc738b$export$49ff6f28c54f1cbe(props, state) {
  let { isDisabled, name: name2, validationBehavior = "aria" } = props;
  let { isInvalid, validationErrors, validationDetails } = state.displayValidation;
  let { labelProps, fieldProps, descriptionProps, errorMessageProps } = (0, $2baaea4c71418dea$export$294aa081a6c6f55d)({
    ...props,
    // Checkbox group is not an HTML input element so it
    // shouldn't be labeled by a <label> element.
    labelElementType: "span",
    isInvalid,
    errorMessage: props.errorMessage || validationErrors
  });
  (0, $1ae600c947479353$export$ec98120685d4f57d).set(state, {
    name: name2,
    descriptionId: descriptionProps.id,
    errorMessageId: errorMessageProps.id,
    validationBehavior
  });
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let { focusWithinProps } = (0, $9ab94262bd0047c7$export$420e68273165f4ec)({
    onBlurWithin: props.onBlur,
    onFocusWithin: props.onFocus,
    onFocusWithinChange: props.onFocusChange
  });
  return {
    groupProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, {
      role: "group",
      "aria-disabled": isDisabled || void 0,
      ...fieldProps,
      ...focusWithinProps
    }),
    labelProps,
    descriptionProps,
    errorMessageProps,
    isInvalid,
    validationErrors,
    validationDetails
  };
}
function $fba3e38d5ca8983f$export$353b32fc6898d37d(props, state, inputRef) {
  const toggleState = (0, $3017fa7ffdddec74$export$8042c6c013fd5226)({
    isReadOnly: props.isReadOnly || state.isReadOnly,
    isSelected: state.isSelected(props.value),
    onChange(isSelected) {
      if (isSelected)
        state.addValue(props.value);
      else
        state.removeValue(props.value);
      if (props.onChange)
        props.onChange(isSelected);
    }
  });
  let { name: name2, descriptionId, errorMessageId, validationBehavior } = (0, $1ae600c947479353$export$ec98120685d4f57d).get(state);
  var _props_validationBehavior;
  validationBehavior = (_props_validationBehavior = props.validationBehavior) !== null && _props_validationBehavior !== void 0 ? _props_validationBehavior : validationBehavior;
  let { realtimeValidation } = (0, $e5be200c675c3b3a$export$fc1a364ae1f3ff10)({
    ...props,
    value: toggleState.isSelected,
    // Server validation is handled at the group level.
    name: void 0,
    validationBehavior: "aria"
  });
  let nativeValidation = (0, import_react38.useRef)((0, $e5be200c675c3b3a$export$dad6ae84456c676a));
  let updateValidation = () => {
    state.setInvalid(props.value, realtimeValidation.isInvalid ? realtimeValidation : nativeValidation.current);
  };
  (0, import_react38.useEffect)(updateValidation);
  let combinedRealtimeValidation = state.realtimeValidation.isInvalid ? state.realtimeValidation : realtimeValidation;
  let displayValidation = validationBehavior === "native" ? state.displayValidation : combinedRealtimeValidation;
  var _props_isRequired;
  let res = (0, $406796ff087fe49b$export$e375f10ce42261c5)({
    ...props,
    isReadOnly: props.isReadOnly || state.isReadOnly,
    isDisabled: props.isDisabled || state.isDisabled,
    name: props.name || name2,
    isRequired: (_props_isRequired = props.isRequired) !== null && _props_isRequired !== void 0 ? _props_isRequired : state.isRequired,
    validationBehavior,
    [(0, $e5be200c675c3b3a$export$a763b9476acd3eb)]: {
      realtimeValidation: combinedRealtimeValidation,
      displayValidation,
      resetValidation: state.resetValidation,
      commitValidation: state.commitValidation,
      updateValidation(v6) {
        nativeValidation.current = v6;
        updateValidation();
      }
    }
  }, toggleState, inputRef);
  return {
    ...res,
    inputProps: {
      ...res.inputProps,
      "aria-describedby": [
        props["aria-describedby"],
        state.isInvalid ? errorMessageId : null,
        descriptionId
      ].filter(Boolean).join(" ") || void 0
    }
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-checkbox.js
var import_react40 = __toESM(require_react());

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-checkIcon.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime());
var checkIcon = (0, import_jsx_runtime20.jsx)("path", {
  d: "M20 6 9 17l-5-5"
});

// node_modules/@keystar/ui/dist/keystar-ui-checkbox.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime());

// node_modules/@react-stately/checkbox/dist/import.mjs
var import_react39 = __toESM(require_react(), 1);
function $587d3ad58be6d31f$export$daff6da51032a415(props = {}) {
  let [selectedValues, setValue] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(props.value, props.defaultValue || [], props.onChange);
  let isRequired = !!props.isRequired && selectedValues.length === 0;
  let invalidValues = (0, import_react39.useRef)(/* @__PURE__ */ new Map());
  let validation = (0, $e5be200c675c3b3a$export$fc1a364ae1f3ff10)({
    ...props,
    value: selectedValues
  });
  let isInvalid = validation.displayValidation.isInvalid;
  var _props_validationState;
  const state = {
    ...validation,
    value: selectedValues,
    setValue(value2) {
      if (props.isReadOnly || props.isDisabled)
        return;
      setValue(value2);
    },
    isDisabled: props.isDisabled || false,
    isReadOnly: props.isReadOnly || false,
    isSelected(value2) {
      return selectedValues.includes(value2);
    },
    addValue(value2) {
      if (props.isReadOnly || props.isDisabled)
        return;
      if (!selectedValues.includes(value2))
        setValue(selectedValues.concat(value2));
    },
    removeValue(value2) {
      if (props.isReadOnly || props.isDisabled)
        return;
      if (selectedValues.includes(value2))
        setValue(selectedValues.filter((existingValue) => existingValue !== value2));
    },
    toggleValue(value2) {
      if (props.isReadOnly || props.isDisabled)
        return;
      if (selectedValues.includes(value2))
        setValue(selectedValues.filter((existingValue) => existingValue !== value2));
      else
        setValue(selectedValues.concat(value2));
    },
    setInvalid(value2, v6) {
      let s4 = new Map(invalidValues.current);
      if (v6.isInvalid)
        s4.set(value2, v6);
      else
        s4.delete(value2);
      invalidValues.current = s4;
      validation.updateValidation((0, $e5be200c675c3b3a$export$75ee7c75d68f5b0e)(...s4.values()));
    },
    validationState: (_props_validationState = props.validationState) !== null && _props_validationState !== void 0 ? _props_validationState : isInvalid ? "invalid" : null,
    isInvalid,
    isRequired
  };
  return state;
}

// node_modules/@keystar/ui/dist/keystar-ui-checkbox.js
var CheckboxGroupContext = import_react40.default.createContext(null);
var checkboxClassList = new ClassList("Checkbox", ["indicator"]);
function Checkbox(props) {
  let {
    isIndeterminate = false,
    isDisabled = false,
    autoFocus,
    children,
    ...otherProps
  } = props;
  let styleProps = useStyleProps(otherProps);
  let inputRef = (0, import_react40.useRef)(null);
  let groupState = (0, import_react40.useContext)(CheckboxGroupContext);
  let {
    inputProps
  } = groupState ? (
    // eslint-disable-next-line react-hooks/rules-of-hooks
    $fba3e38d5ca8983f$export$353b32fc6898d37d({
      ...props,
      // Value is optional for standalone checkboxes, but required for
      // CheckboxGroup items; it's passed explicitly here to avoid
      // typescript error (requires ignore).
      // @ts-ignore
      value: props.value
    }, groupState.state, inputRef)
  ) : (
    // eslint-disable-next-line react-hooks/rules-of-hooks
    $406796ff087fe49b$export$e375f10ce42261c5(props, $3017fa7ffdddec74$export$8042c6c013fd5226(props), inputRef)
  );
  const labelClassName = css({
    alignItems: "flex-start",
    display: "inline-flex",
    gap: tokenSchema.size.space.regular,
    position: "relative",
    userSelect: "none"
  });
  const slots = (0, import_react40.useMemo)(() => ({
    text: {
      color: "inherit"
    },
    description: {
      color: "neutralTertiary"
    }
  }), []);
  return (0, import_jsx_runtime21.jsxs)("label", {
    "data-disabled": isDisabled,
    className: classNames(styleProps.className, labelClassName),
    style: styleProps.style,
    children: [(0, import_jsx_runtime21.jsx)(FocusRing, {
      autoFocus,
      children: (0, import_jsx_runtime21.jsx)("input", {
        ...inputProps,
        ref: inputRef,
        className: classNames(css({
          position: "absolute",
          zIndex: 1,
          inset: 0,
          opacity: 1e-4
        }))
      })
    }), (0, import_jsx_runtime21.jsx)(Indicator, {
      isIndeterminate
    }), (0, import_jsx_runtime21.jsx)(SlotProvider, {
      slots,
      children: children && (0, import_jsx_runtime21.jsx)(Content2, {
        children: isReactText(children) ? (0, import_jsx_runtime21.jsx)(Text2, {
          children
        }) : children
      })
    })]
  });
}
var sizeToken = tokenSchema.size.element.xsmall;
var Indicator = (props) => {
  let {
    isIndeterminate
  } = props;
  return (0, import_jsx_runtime21.jsx)("span", {
    className: classNames(css({
      backgroundColor: tokenSchema.color.background.canvas,
      borderRadius: tokenSchema.size.radius.small,
      color: tokenSchema.color.foreground.onEmphasis,
      display: "flex",
      flexShrink: 0,
      justifyContent: "center",
      alignItems: "center",
      position: "relative",
      height: sizeToken,
      width: sizeToken,
      // indicator icons
      [checkboxClassList.selector("indicator")]: {
        opacity: 0,
        transform: `scale(0) translate3d(0, 0, 0)`,
        transition: transition(["opacity", "transform"]),
        willChange: "opacity, transform"
      },
      // focus ring
      "::after": {
        borderRadius: `calc(${tokenSchema.size.alias.focusRingGap} + ${tokenSchema.size.radius.small})`,
        content: '""',
        inset: 0,
        margin: 0,
        position: "absolute",
        transition: transition(["box-shadow", "margin"], {
          easing: "easeOut"
        })
      },
      'input[type="checkbox"][data-focus=visible] + &::after': {
        boxShadow: `0 0 0 ${tokenSchema.size.alias.focusRing} ${tokenSchema.color.alias.focusRing}`,
        margin: `calc(${tokenSchema.size.alias.focusRingGap} * -1)`
      },
      // border / background
      "&::before": {
        border: `${tokenSchema.size.border.medium} solid ${tokenSchema.color.alias.borderIdle}`,
        borderRadius: `inherit`,
        content: '""',
        inset: 0,
        margin: 0,
        position: "absolute",
        transition: transition(["border-color", "border-width"])
      },
      'input[type="checkbox"]:disabled + &': {
        color: tokenSchema.color.alias.foregroundDisabled,
        "&::before": {
          borderColor: tokenSchema.color.alias.borderDisabled
        }
      },
      'input[type="checkbox"]:enabled:hover + &::before': {
        borderColor: tokenSchema.color.alias.borderHovered
      },
      'input[type="checkbox"]:enabled:active + &::before': {
        borderColor: tokenSchema.color.alias.borderPressed
      },
      // checked states
      'input[type="checkbox"]:checked + &, input[type="checkbox"]:indeterminate + &': {
        "&::before": {
          borderWidth: `calc(${sizeToken} / 2)`
        },
        [checkboxClassList.selector("indicator")]: {
          opacity: 1,
          transform: `scale(1)`
        }
      },
      'input[type="checkbox"]:enabled:checked + &::before, input[type="checkbox"]:enabled:indeterminate + &::before': {
        borderColor: tokenSchema.color.scale.indigo9
      },
      'input[type="checkbox"]:enabled:checked:hover + &::before, input[type="checkbox"]:enabled:indeterminate:hover + &::before': {
        borderColor: tokenSchema.color.scale.indigo10
      },
      'input[type="checkbox"]:enabled:checked:active + &::before, input[type="checkbox"]:enabled:indeterminate:active + &::before': {
        borderColor: tokenSchema.color.scale.indigo11
      }
    })),
    children: (0, import_jsx_runtime21.jsx)("span", {
      className: checkboxClassList.element("indicator"),
      children: (0, import_jsx_runtime21.jsx)(Icon, {
        size: "small",
        src: isIndeterminate ? minusIcon : checkIcon,
        strokeScaling: false
      })
    })
  });
};
var Content2 = (props) => {
  return (0, import_jsx_runtime21.jsx)("div", {
    className: classNames(css({
      color: tokenSchema.color.alias.foregroundIdle,
      display: "grid",
      paddingTop: `calc((${sizeToken} - ${tokenSchema.typography.text.regular.capheight}) / 2)`,
      gap: tokenSchema.size.space.large,
      'input[type="checkbox"]:hover ~ &': {
        color: tokenSchema.color.alias.foregroundHovered
      },
      'input[type="checkbox"]:disabled ~ &': {
        color: tokenSchema.color.alias.foregroundDisabled
      }
    })),
    ...props
  });
};
var CheckboxGroup = (0, import_react40.forwardRef)(function CheckboxGroup2(props, forwardedRef) {
  props = useProviderProps(props);
  props = validateFieldProps(props);
  let {
    children,
    orientation = "vertical",
    validationState
  } = props;
  let state = $587d3ad58be6d31f$export$daff6da51032a415(props);
  let {
    labelProps,
    groupProps,
    descriptionProps,
    errorMessageProps
  } = $1e9fce0cfacc738b$export$49ff6f28c54f1cbe(props, state);
  return (0, import_jsx_runtime21.jsx)(FieldPrimitive, {
    ...props,
    ref: forwardedRef,
    labelProps,
    descriptionProps,
    errorMessageProps,
    supplementRequiredState: true,
    children: (0, import_jsx_runtime21.jsx)("div", {
      ...groupProps,
      ...toDataAttributes({
        orientation
      }),
      className: classNames(css({
        display: "flex",
        gap: tokenSchema.size.space.large,
        '&[data-orientation="vertical"]': {
          flexDirection: "column"
        }
      })),
      children: (0, import_jsx_runtime21.jsx)(CheckboxGroupContext.Provider, {
        value: {
          validationState,
          state
        },
        children
      })
    })
  });
});

// node_modules/@react-aria/grid/dist/ar-AE.mjs
var $682989befd4f478d$exports = {};
$682989befd4f478d$exports = {
  "deselectedItem": (args2) => `${args2.item} غير المحدد`,
  "longPressToSelect": `اضغط مطولًا للدخول إلى وضع التحديد.`,
  "select": `تحديد`,
  "selectedAll": `جميع العناصر المحددة.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `لم يتم تحديد عناصر`,
    one: () => `${formatter.number(args2.count)} عنصر محدد`,
    other: () => `${formatter.number(args2.count)} عنصر محدد`
  })}.`,
  "selectedItem": (args2) => `${args2.item} المحدد`
};

// node_modules/@react-aria/grid/dist/bg-BG.mjs
var $f7fca02019afd941$exports = {};
$f7fca02019afd941$exports = {
  "deselectedItem": (args2) => `${args2.item} не е избран.`,
  "longPressToSelect": `Натиснете и задръжте за да влезете в избирателен режим.`,
  "select": `Изберете`,
  "selectedAll": `Всички елементи са избрани.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `Няма избрани елементи`,
    one: () => `${formatter.number(args2.count)} избран елемент`,
    other: () => `${formatter.number(args2.count)} избрани елементи`
  })}.`,
  "selectedItem": (args2) => `${args2.item} избран.`
};

// node_modules/@react-aria/grid/dist/cs-CZ.mjs
var $8f86f40be75387f1$exports = {};
$8f86f40be75387f1$exports = {
  "deselectedItem": (args2) => `Položka ${args2.item} není vybrána.`,
  "longPressToSelect": `Dlouhým stisknutím přejdete do režimu výběru.`,
  "select": `Vybrat`,
  "selectedAll": `Vybrány všechny položky.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `Nevybrány žádné položky`,
    one: () => `Vybrána ${formatter.number(args2.count)} položka`,
    other: () => `Vybráno ${formatter.number(args2.count)} položek`
  })}.`,
  "selectedItem": (args2) => `Vybrána položka ${args2.item}.`
};

// node_modules/@react-aria/grid/dist/da-DK.mjs
var $db24ba43c8d652ee$exports = {};
$db24ba43c8d652ee$exports = {
  "deselectedItem": (args2) => `${args2.item} ikke valgt.`,
  "longPressToSelect": `Lav et langt tryk for at aktivere valgtilstand.`,
  "select": `Vælg`,
  "selectedAll": `Alle elementer valgt.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `Ingen elementer valgt`,
    one: () => `${formatter.number(args2.count)} element valgt`,
    other: () => `${formatter.number(args2.count)} elementer valgt`
  })}.`,
  "selectedItem": (args2) => `${args2.item} valgt.`
};

// node_modules/@react-aria/grid/dist/de-DE.mjs
var $f8f1e72c8b5447d6$exports = {};
$f8f1e72c8b5447d6$exports = {
  "deselectedItem": (args2) => `${args2.item} nicht ausgewählt.`,
  "longPressToSelect": `Gedrückt halten, um Auswahlmodus zu öffnen.`,
  "select": `Auswählen`,
  "selectedAll": `Alle Elemente ausgewählt.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `Keine Elemente ausgewählt`,
    one: () => `${formatter.number(args2.count)} Element ausgewählt`,
    other: () => `${formatter.number(args2.count)} Elemente ausgewählt`
  })}.`,
  "selectedItem": (args2) => `${args2.item} ausgewählt.`
};

// node_modules/@react-aria/grid/dist/el-GR.mjs
var $9a73ed2983c3ab0b$exports = {};
$9a73ed2983c3ab0b$exports = {
  "deselectedItem": (args2) => `Δεν επιλέχθηκε το στοιχείο ${args2.item}.`,
  "longPressToSelect": `Πατήστε παρατεταμένα για να μπείτε σε λειτουργία επιλογής.`,
  "select": `Επιλογή`,
  "selectedAll": `Επιλέχθηκαν όλα τα στοιχεία.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `Δεν επιλέχθηκαν στοιχεία`,
    one: () => `Επιλέχθηκε ${formatter.number(args2.count)} στοιχείο`,
    other: () => `Επιλέχθηκαν ${formatter.number(args2.count)} στοιχεία`
  })}.`,
  "selectedItem": (args2) => `Επιλέχθηκε το στοιχείο ${args2.item}.`
};

// node_modules/@react-aria/grid/dist/en-US.mjs
var $583de0b3587601b9$exports = {};
$583de0b3587601b9$exports = {
  "deselectedItem": (args2) => `${args2.item} not selected.`,
  "select": `Select`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `No items selected`,
    one: () => `${formatter.number(args2.count)} item selected`,
    other: () => `${formatter.number(args2.count)} items selected`
  })}.`,
  "selectedAll": `All items selected.`,
  "selectedItem": (args2) => `${args2.item} selected.`,
  "longPressToSelect": `Long press to enter selection mode.`
};

// node_modules/@react-aria/grid/dist/es-ES.mjs
var $147159c978043442$exports = {};
$147159c978043442$exports = {
  "deselectedItem": (args2) => `${args2.item} no seleccionado.`,
  "longPressToSelect": `Mantenga pulsado para abrir el modo de selección.`,
  "select": `Seleccionar`,
  "selectedAll": `Todos los elementos seleccionados.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `Ningún elemento seleccionado`,
    one: () => `${formatter.number(args2.count)} elemento seleccionado`,
    other: () => `${formatter.number(args2.count)} elementos seleccionados`
  })}.`,
  "selectedItem": (args2) => `${args2.item} seleccionado.`
};

// node_modules/@react-aria/grid/dist/et-EE.mjs
var $5cbb62c8a19173ac$exports = {};
$5cbb62c8a19173ac$exports = {
  "deselectedItem": (args2) => `${args2.item} pole valitud.`,
  "longPressToSelect": `Valikurežiimi sisenemiseks vajutage pikalt.`,
  "select": `Vali`,
  "selectedAll": `Kõik üksused valitud.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `Üksusi pole valitud`,
    one: () => `${formatter.number(args2.count)} üksus valitud`,
    other: () => `${formatter.number(args2.count)} üksust valitud`
  })}.`,
  "selectedItem": (args2) => `${args2.item} valitud.`
};

// node_modules/@react-aria/grid/dist/fi-FI.mjs
var $a33d71dc804cc59e$exports = {};
$a33d71dc804cc59e$exports = {
  "deselectedItem": (args2) => `Kohdetta ${args2.item} ei valittu.`,
  "longPressToSelect": `Siirry valintatilaan painamalla pitkään.`,
  "select": `Valitse`,
  "selectedAll": `Kaikki kohteet valittu.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `Ei yhtään kohdetta valittu`,
    one: () => `${formatter.number(args2.count)} kohde valittu`,
    other: () => `${formatter.number(args2.count)} kohdetta valittu`
  })}.`,
  "selectedItem": (args2) => `${args2.item} valittu.`
};

// node_modules/@react-aria/grid/dist/fr-FR.mjs
var $92d800447793d084$exports = {};
$92d800447793d084$exports = {
  "deselectedItem": (args2) => `${args2.item} non sélectionné.`,
  "longPressToSelect": `Appuyez de manière prolongée pour passer en mode de sélection.`,
  "select": `Sélectionner`,
  "selectedAll": `Tous les éléments sélectionnés.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `Aucun élément sélectionné`,
    one: () => `${formatter.number(args2.count)} élément sélectionné`,
    other: () => `${formatter.number(args2.count)} éléments sélectionnés`
  })}.`,
  "selectedItem": (args2) => `${args2.item} sélectionné.`
};

// node_modules/@react-aria/grid/dist/he-IL.mjs
var $fe732cdb32124ea8$exports = {};
$fe732cdb32124ea8$exports = {
  "deselectedItem": (args2) => `${args2.item} לא נבחר.`,
  "longPressToSelect": `הקשה ארוכה לכניסה למצב בחירה.`,
  "select": `בחר`,
  "selectedAll": `כל הפריטים נבחרו.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `לא נבחרו פריטים`,
    one: () => `פריט ${formatter.number(args2.count)} נבחר`,
    other: () => `${formatter.number(args2.count)} פריטים נבחרו`
  })}.`,
  "selectedItem": (args2) => `${args2.item} נבחר.`
};

// node_modules/@react-aria/grid/dist/hr-HR.mjs
var $e41234e934efb4f5$exports = {};
$e41234e934efb4f5$exports = {
  "deselectedItem": (args2) => `Stavka ${args2.item} nije odabrana.`,
  "longPressToSelect": `Dugo pritisnite za ulazak u način odabira.`,
  "select": `Odaberite`,
  "selectedAll": `Odabrane su sve stavke.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `Nije odabrana nijedna stavka`,
    one: () => `Odabrana je ${formatter.number(args2.count)} stavka`,
    other: () => `Odabrano je ${formatter.number(args2.count)} stavki`
  })}.`,
  "selectedItem": (args2) => `Stavka ${args2.item} je odabrana.`
};

// node_modules/@react-aria/grid/dist/hu-HU.mjs
var $1b0393182473bf9e$exports = {};
$1b0393182473bf9e$exports = {
  "deselectedItem": (args2) => `${args2.item} nincs kijelölve.`,
  "longPressToSelect": `Nyomja hosszan a kijelöléshez.`,
  "select": `Kijelölés`,
  "selectedAll": `Az összes elem kijelölve.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `Egy elem sincs kijelölve`,
    one: () => `${formatter.number(args2.count)} elem kijelölve`,
    other: () => `${formatter.number(args2.count)} elem kijelölve`
  })}.`,
  "selectedItem": (args2) => `${args2.item} kijelölve.`
};

// node_modules/@react-aria/grid/dist/it-IT.mjs
var $2eed782c1c110ce7$exports = {};
$2eed782c1c110ce7$exports = {
  "deselectedItem": (args2) => `${args2.item} non selezionato.`,
  "longPressToSelect": `Premi a lungo per passare alla modalità di selezione.`,
  "select": `Seleziona`,
  "selectedAll": `Tutti gli elementi selezionati.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `Nessun elemento selezionato`,
    one: () => `${formatter.number(args2.count)} elemento selezionato`,
    other: () => `${formatter.number(args2.count)} elementi selezionati`
  })}.`,
  "selectedItem": (args2) => `${args2.item} selezionato.`
};

// node_modules/@react-aria/grid/dist/ja-JP.mjs
var $8b5d459f86e9b23c$exports = {};
$8b5d459f86e9b23c$exports = {
  "deselectedItem": (args2) => `${args2.item} が選択されていません。`,
  "longPressToSelect": `長押しして選択モードを開きます。`,
  "select": `選択`,
  "selectedAll": `すべての項目を選択しました。`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `項目が選択されていません`,
    one: () => `${formatter.number(args2.count)} 項目を選択しました`,
    other: () => `${formatter.number(args2.count)} 項目を選択しました`
  })}。`,
  "selectedItem": (args2) => `${args2.item} を選択しました。`
};

// node_modules/@react-aria/grid/dist/ko-KR.mjs
var $1949c3ad17295fd4$exports = {};
$1949c3ad17295fd4$exports = {
  "deselectedItem": (args2) => `${args2.item}이(가) 선택되지 않았습니다.`,
  "longPressToSelect": `선택 모드로 들어가려면 길게 누르십시오.`,
  "select": `선택`,
  "selectedAll": `모든 항목이 선택되었습니다.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `선택된 항목이 없습니다`,
    one: () => `${formatter.number(args2.count)}개 항목이 선택되었습니다`,
    other: () => `${formatter.number(args2.count)}개 항목이 선택되었습니다`
  })}.`,
  "selectedItem": (args2) => `${args2.item}이(가) 선택되었습니다.`
};

// node_modules/@react-aria/grid/dist/lt-LT.mjs
var $f5e3df4dc8aa7b54$exports = {};
$f5e3df4dc8aa7b54$exports = {
  "deselectedItem": (args2) => `${args2.item} nepasirinkta.`,
  "longPressToSelect": `Norėdami įjungti pasirinkimo režimą, paspauskite ir palaikykite.`,
  "select": `Pasirinkti`,
  "selectedAll": `Pasirinkti visi elementai.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `Nepasirinktas nė vienas elementas`,
    one: () => `Pasirinktas ${formatter.number(args2.count)} elementas`,
    other: () => `Pasirinkta elementų: ${formatter.number(args2.count)}`
  })}.`,
  "selectedItem": (args2) => `Pasirinkta: ${args2.item}.`
};

// node_modules/@react-aria/grid/dist/lv-LV.mjs
var $9dd86690a5c2b2c5$exports = {};
$9dd86690a5c2b2c5$exports = {
  "deselectedItem": (args2) => `Vienums ${args2.item} nav atlasīts.`,
  "longPressToSelect": `Ilgi turiet nospiestu. lai ieslēgtu atlases režīmu.`,
  "select": `Atlasīt`,
  "selectedAll": `Atlasīti visi vienumi.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `Nav atlasīts neviens vienums`,
    one: () => `Atlasīto vienumu skaits: ${formatter.number(args2.count)}`,
    other: () => `Atlasīto vienumu skaits: ${formatter.number(args2.count)}`
  })}.`,
  "selectedItem": (args2) => `Atlasīts vienums ${args2.item}.`
};

// node_modules/@react-aria/grid/dist/nb-NO.mjs
var $843964c3bf9a7d24$exports = {};
$843964c3bf9a7d24$exports = {
  "deselectedItem": (args2) => `${args2.item} er ikke valgt.`,
  "longPressToSelect": `Bruk et langt trykk for å gå inn i valgmodus.`,
  "select": `Velg`,
  "selectedAll": `Alle elementer er valgt.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `Ingen elementer er valgt`,
    one: () => `${formatter.number(args2.count)} element er valgt`,
    other: () => `${formatter.number(args2.count)} elementer er valgt`
  })}.`,
  "selectedItem": (args2) => `${args2.item} er valgt.`
};

// node_modules/@react-aria/grid/dist/nl-NL.mjs
var $73f50e845f9ef3b4$exports = {};
$73f50e845f9ef3b4$exports = {
  "deselectedItem": (args2) => `${args2.item} niet geselecteerd.`,
  "longPressToSelect": `Druk lang om de selectiemodus te openen.`,
  "select": `Selecteren`,
  "selectedAll": `Alle items geselecteerd.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `Geen items geselecteerd`,
    one: () => `${formatter.number(args2.count)} item geselecteerd`,
    other: () => `${formatter.number(args2.count)} items geselecteerd`
  })}.`,
  "selectedItem": (args2) => `${args2.item} geselecteerd.`
};

// node_modules/@react-aria/grid/dist/pl-PL.mjs
var $87f92a7e077514b2$exports = {};
$87f92a7e077514b2$exports = {
  "deselectedItem": (args2) => `Nie zaznaczono ${args2.item}.`,
  "longPressToSelect": `Naciśnij i przytrzymaj, aby wejść do trybu wyboru.`,
  "select": `Zaznacz`,
  "selectedAll": `Wszystkie zaznaczone elementy.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `Nie zaznaczono żadnych elementów`,
    one: () => `${formatter.number(args2.count)} zaznaczony element`,
    other: () => `${formatter.number(args2.count)} zaznaczonych elementów`
  })}.`,
  "selectedItem": (args2) => `Zaznaczono ${args2.item}.`
};

// node_modules/@react-aria/grid/dist/pt-BR.mjs
var $c28c98d58ee9ff6f$exports = {};
$c28c98d58ee9ff6f$exports = {
  "deselectedItem": (args2) => `${args2.item} não selecionado.`,
  "longPressToSelect": `Mantenha pressionado para entrar no modo de seleção.`,
  "select": `Selecionar`,
  "selectedAll": `Todos os itens selecionados.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `Nenhum item selecionado`,
    one: () => `${formatter.number(args2.count)} item selecionado`,
    other: () => `${formatter.number(args2.count)} itens selecionados`
  })}.`,
  "selectedItem": (args2) => `${args2.item} selecionado.`
};

// node_modules/@react-aria/grid/dist/pt-PT.mjs
var $b6b1503b17b2254d$exports = {};
$b6b1503b17b2254d$exports = {
  "deselectedItem": (args2) => `${args2.item} não selecionado.`,
  "longPressToSelect": `Prima continuamente para entrar no modo de seleção.`,
  "select": `Selecionar`,
  "selectedAll": `Todos os itens selecionados.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `Nenhum item selecionado`,
    one: () => `${formatter.number(args2.count)} item selecionado`,
    other: () => `${formatter.number(args2.count)} itens selecionados`
  })}.`,
  "selectedItem": (args2) => `${args2.item} selecionado.`
};

// node_modules/@react-aria/grid/dist/ro-RO.mjs
var $8bdaeb71e50c3e1a$exports = {};
$8bdaeb71e50c3e1a$exports = {
  "deselectedItem": (args2) => `${args2.item} neselectat.`,
  "longPressToSelect": `Apăsați lung pentru a intra în modul de selectare.`,
  "select": `Selectare`,
  "selectedAll": `Toate elementele selectate.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `Niciun element selectat`,
    one: () => `${formatter.number(args2.count)} element selectat`,
    other: () => `${formatter.number(args2.count)} elemente selectate`
  })}.`,
  "selectedItem": (args2) => `${args2.item} selectat.`
};

// node_modules/@react-aria/grid/dist/ru-RU.mjs
var $ec2b852dd7c3d1f2$exports = {};
$ec2b852dd7c3d1f2$exports = {
  "deselectedItem": (args2) => `${args2.item} не выбрано.`,
  "longPressToSelect": `Нажмите и удерживайте для входа в режим выбора.`,
  "select": `Выбрать`,
  "selectedAll": `Выбраны все элементы.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `Нет выбранных элементов`,
    one: () => `${formatter.number(args2.count)} элемент выбран`,
    other: () => `${formatter.number(args2.count)} элементов выбрано`
  })}.`,
  "selectedItem": (args2) => `${args2.item} выбрано.`
};

// node_modules/@react-aria/grid/dist/sk-SK.mjs
var $79e6d900d6a4f82d$exports = {};
$79e6d900d6a4f82d$exports = {
  "deselectedItem": (args2) => `Nevybraté položky: ${args2.item}.`,
  "longPressToSelect": `Dlhším stlačením prejdite do režimu výberu.`,
  "select": `Vybrať`,
  "selectedAll": `Všetky vybraté položky.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `Žiadne vybraté položky`,
    one: () => `${formatter.number(args2.count)} vybratá položka`,
    other: () => `Počet vybratých položiek:${formatter.number(args2.count)}`
  })}.`,
  "selectedItem": (args2) => `Vybraté položky: ${args2.item}.`
};

// node_modules/@react-aria/grid/dist/sl-SI.mjs
var $f4c1f0d5d4d03d80$exports = {};
$f4c1f0d5d4d03d80$exports = {
  "deselectedItem": (args2) => `Element ${args2.item} ni izbran.`,
  "longPressToSelect": `Za izbirni način pritisnite in dlje časa držite.`,
  "select": `Izberite`,
  "selectedAll": `Vsi elementi so izbrani.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `Noben element ni izbran`,
    one: () => `${formatter.number(args2.count)} element je izbran`,
    other: () => `${formatter.number(args2.count)} elementov je izbranih`
  })}.`,
  "selectedItem": (args2) => `Element ${args2.item} je izbran.`
};

// node_modules/@react-aria/grid/dist/sr-SP.mjs
var $46252cd87269b10b$exports = {};
$46252cd87269b10b$exports = {
  "deselectedItem": (args2) => `${args2.item} nije izabrano.`,
  "longPressToSelect": `Dugo pritisnite za ulazak u režim biranja.`,
  "select": `Izaberite`,
  "selectedAll": `Izabrane su sve stavke.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `Nije izabrana nijedna stavka`,
    one: () => `Izabrana je ${formatter.number(args2.count)} stavka`,
    other: () => `Izabrano je ${formatter.number(args2.count)} stavki`
  })}.`,
  "selectedItem": (args2) => `${args2.item} je izabrano.`
};

// node_modules/@react-aria/grid/dist/sv-SE.mjs
var $d4d5d8dab362555c$exports = {};
$d4d5d8dab362555c$exports = {
  "deselectedItem": (args2) => `${args2.item} ej markerat.`,
  "longPressToSelect": `Tryck länge när du vill öppna väljarläge.`,
  "select": `Markera`,
  "selectedAll": `Alla markerade objekt.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `Inga markerade objekt`,
    one: () => `${formatter.number(args2.count)} markerat objekt`,
    other: () => `${formatter.number(args2.count)} markerade objekt`
  })}.`,
  "selectedItem": (args2) => `${args2.item} markerat.`
};

// node_modules/@react-aria/grid/dist/tr-TR.mjs
var $3d55d1f97c377e83$exports = {};
$3d55d1f97c377e83$exports = {
  "deselectedItem": (args2) => `${args2.item} seçilmedi.`,
  "longPressToSelect": `Seçim moduna girmek için uzun basın.`,
  "select": `Seç`,
  "selectedAll": `Tüm ögeler seçildi.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `Hiçbir öge seçilmedi`,
    one: () => `${formatter.number(args2.count)} öge seçildi`,
    other: () => `${formatter.number(args2.count)} öge seçildi`
  })}.`,
  "selectedItem": (args2) => `${args2.item} seçildi.`
};

// node_modules/@react-aria/grid/dist/uk-UA.mjs
var $5368512f1c703a3f$exports = {};
$5368512f1c703a3f$exports = {
  "deselectedItem": (args2) => `${args2.item} не вибрано.`,
  "longPressToSelect": `Виконайте довге натиснення, щоб перейти в режим вибору.`,
  "select": `Вибрати`,
  "selectedAll": `Усі елементи вибрано.`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `Жодних елементів не вибрано`,
    one: () => `${formatter.number(args2.count)} елемент вибрано`,
    other: () => `Вибрано елементів: ${formatter.number(args2.count)}`
  })}.`,
  "selectedItem": (args2) => `${args2.item} вибрано.`
};

// node_modules/@react-aria/grid/dist/zh-CN.mjs
var $f1316b1074463583$exports = {};
$f1316b1074463583$exports = {
  "deselectedItem": (args2) => `未选择 ${args2.item}。`,
  "longPressToSelect": `长按以进入选择模式。`,
  "select": `选择`,
  "selectedAll": `已选择所有项目。`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `未选择项目`,
    one: () => `已选择 ${formatter.number(args2.count)} 个项目`,
    other: () => `已选择 ${formatter.number(args2.count)} 个项目`
  })}。`,
  "selectedItem": (args2) => `已选择 ${args2.item}。`
};

// node_modules/@react-aria/grid/dist/zh-TW.mjs
var $7e60654723031b6f$exports = {};
$7e60654723031b6f$exports = {
  "deselectedItem": (args2) => `未選取「${args2.item}」。`,
  "longPressToSelect": `長按以進入選擇模式。`,
  "select": `選取`,
  "selectedAll": `已選取所有項目。`,
  "selectedCount": (args2, formatter) => `${formatter.plural(args2.count, {
    "=0": `未選取任何項目`,
    one: () => `已選取 ${formatter.number(args2.count)} 個項目`,
    other: () => `已選取 ${formatter.number(args2.count)} 個項目`
  })}。`,
  "selectedItem": (args2) => `已選取「${args2.item}」。`
};

// node_modules/@react-stately/virtualizer/dist/import.mjs
var import_react41 = __toESM(require_react(), 1);
var $c74cda7d31af1253$export$c84671f46d6a1ca = class {
  /**
  * Returns whether the layout should invalidate in response to
  * visible rectangle changes. By default, it only invalidates
  * when the collection view's size changes. Return true always
  * to make the layout invalidate while scrolling (e.g. sticky headers).
  */
  shouldInvalidate(newRect, oldRect) {
    return newRect.width !== oldRect.width || newRect.height !== oldRect.height;
  }
  /**
  * This method allows the layout to perform any pre-computation
  * it needs to in order to prepare {@link LayoutInfo}s for retrieval.
  * Called by the collection view before {@link getVisibleLayoutInfos}
  * or {@link getLayoutInfo} are called.
  */
  validate(invalidationContext) {
  }
  /**
  * Returns a {@link DragTarget} describing a view at the given point to be dragged.
  * Return `null` to cancel the drag. The default implementation returns the view at the given point.
  * @param point The point at which the drag occurred.
  */
  // getDragTarget(point: Point): DragTarget | null {
  //   let target = this.virtualizer.keyAtPoint(point);
  //   if (!target) {
  //     return null;
  //   }
  //   return {
  //     type: 'item',
  //     key: target
  //   };
  // }
  /**
  * Returns a {@link DragTarget} object describing where a drop should occur. Return `null`
  * to reject the drop. The dropped items will be inserted before the resulting target.
  * @param point The point at which the drop occurred.
  */
  // getDropTarget(point: Point): DropTarget | null {
  //   return null;
  // }
  /**
  * Returns the starting attributes for an animated insertion.
  * The view is animated from this {@link LayoutInfo} to the one returned by {@link getLayoutInfo}.
  * The default implementation just returns its input.
  *
  * @param layoutInfo The proposed LayoutInfo for this view.
  */
  getInitialLayoutInfo(layoutInfo) {
    return layoutInfo;
  }
  /**
  * Returns the ending attributes for an animated removal.
  * The view is animated from the {@link LayoutInfo} returned by {@link getLayoutInfo}
  * to the one returned by this method. The default implementation returns its input.
  *
  * @param layoutInfo The original LayoutInfo for this view.
  */
  getFinalLayoutInfo(layoutInfo) {
    return layoutInfo;
  }
};
var $d7fd61009c21d0bb$export$7e0eeb9da702a085 = class _$d7fd61009c21d0bb$export$7e0eeb9da702a085 {
  /**
  * Returns a copy of the LayoutInfo.
  */
  copy() {
    let res = new _$d7fd61009c21d0bb$export$7e0eeb9da702a085(this.type, this.key, this.rect.copy());
    res.estimatedSize = this.estimatedSize;
    res.opacity = this.opacity;
    res.transform = this.transform;
    res.parentKey = this.parentKey;
    res.isSticky = this.isSticky;
    res.zIndex = this.zIndex;
    res.allowOverflow = this.allowOverflow;
    return res;
  }
  /**
  * @param type A string representing the view type. Should be `'item'` for item views.
                           Other types are used by supplementary views.
  * @param key The unique key for this view.
  * @param rect The rectangle describing the size and position of this view.
  */
  constructor(type2, key, rect) {
    this.type = type2;
    this.key = key;
    this.parentKey = null;
    this.rect = rect;
    this.estimatedSize = false;
    this.isSticky = false;
    this.opacity = 1;
    this.transform = null;
    this.zIndex = 0;
    this.allowOverflow = false;
  }
};
var $3041db3296945e6e$export$baf26146a414f24a = class _$3041db3296945e6e$export$baf26146a414f24a {
  /**
  * Returns a copy of this point.
  */
  copy() {
    return new _$3041db3296945e6e$export$baf26146a414f24a(this.x, this.y);
  }
  /**
  * Checks if two points are equal.
  */
  equals(point3) {
    return this.x === point3.x && this.y === point3.y;
  }
  /**
  * Returns true if this point is the origin.
  */
  isOrigin() {
    return this.x === 0 && this.y === 0;
  }
  constructor(x4 = 0, y4 = 0) {
    this.x = x4;
    this.y = y4;
  }
};
var $60423f92c7f9ad87$export$c79fc6492f3af13d = class _$60423f92c7f9ad87$export$c79fc6492f3af13d {
  /**
  * The maximum x-coordinate in the rectangle.
  */
  get maxX() {
    return this.x + this.width;
  }
  /**
  * The maximum y-coordinate in the rectangle.
  */
  get maxY() {
    return this.y + this.height;
  }
  /**
  * The area of the rectangle.
  */
  get area() {
    return this.width * this.height;
  }
  /**
  * The top left corner of the rectangle.
  */
  get topLeft() {
    return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.x, this.y);
  }
  /**
  * The top right corner of the rectangle.
  */
  get topRight() {
    return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.maxX, this.y);
  }
  /**
  * The bottom left corner of the rectangle.
  */
  get bottomLeft() {
    return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.x, this.maxY);
  }
  /**
  * The bottom right corner of the rectangle.
  */
  get bottomRight() {
    return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.maxX, this.maxY);
  }
  /**
  * Returns whether this rectangle intersects another rectangle.
  * @param rect - The rectangle to check.
  */
  intersects(rect) {
    return this.x <= rect.x + rect.width && rect.x <= this.x + this.width && this.y <= rect.y + rect.height && rect.y <= this.y + this.height;
  }
  /**
  * Returns whether this rectangle fully contains another rectangle.
  * @param rect - The rectangle to check.
  */
  containsRect(rect) {
    return this.x <= rect.x && this.y <= rect.y && this.maxX >= rect.maxX && this.maxY >= rect.maxY;
  }
  /**
  * Returns whether the rectangle contains the given point.
  * @param point - The point to check.
  */
  containsPoint(point3) {
    return this.x <= point3.x && this.y <= point3.y && this.maxX >= point3.x && this.maxY >= point3.y;
  }
  /**
  * Returns the first corner of this rectangle (from top to bottom, left to right)
  * that is contained in the given rectangle, or null of the rectangles do not intersect.
  * @param rect - The rectangle to check.
  */
  getCornerInRect(rect) {
    for (let key of [
      "topLeft",
      "topRight",
      "bottomLeft",
      "bottomRight"
    ]) {
      if (rect.containsPoint(this[key]))
        return key;
    }
    return null;
  }
  equals(rect) {
    return rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;
  }
  pointEquals(point3) {
    return this.x === point3.x && this.y === point3.y;
  }
  sizeEquals(size3) {
    return this.width === size3.width && this.height === size3.height;
  }
  /**
  * Returns the union of this Rect and another.
  */
  union(other) {
    let x4 = Math.min(this.x, other.x);
    let y4 = Math.min(this.y, other.y);
    let width = Math.max(this.maxX, other.maxX) - x4;
    let height = Math.max(this.maxY, other.maxY) - y4;
    return new _$60423f92c7f9ad87$export$c79fc6492f3af13d(x4, y4, width, height);
  }
  /**
  * Returns the intersection of this Rect with another.
  * If the rectangles do not intersect, an all zero Rect is returned.
  */
  intersection(other) {
    if (!this.intersects(other))
      return new _$60423f92c7f9ad87$export$c79fc6492f3af13d(0, 0, 0, 0);
    let x4 = Math.max(this.x, other.x);
    let y4 = Math.max(this.y, other.y);
    return new _$60423f92c7f9ad87$export$c79fc6492f3af13d(x4, y4, Math.min(this.maxX, other.maxX) - x4, Math.min(this.maxY, other.maxY) - y4);
  }
  /**
  * Returns a copy of this rectangle.
  */
  copy() {
    return new _$60423f92c7f9ad87$export$c79fc6492f3af13d(this.x, this.y, this.width, this.height);
  }
  constructor(x4 = 0, y4 = 0, width = 0, height = 0) {
    this.x = x4;
    this.y = y4;
    this.width = width;
    this.height = height;
  }
};
var $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec = class _$ee1bfa90a957fb8a$export$cb6da89c6af1a8ec {
  /**
  * Returns a copy of this size.
  */
  copy() {
    return new _$ee1bfa90a957fb8a$export$cb6da89c6af1a8ec(this.width, this.height);
  }
  /**
  * Returns whether this size is equal to another one.
  */
  equals(other) {
    return this.width === other.width && this.height === other.height;
  }
  /**
  * The total area of the Size.
  */
  get area() {
    return this.width * this.height;
  }
  constructor(width = 0, height = 0) {
    this.width = width;
    this.height = height;
  }
};
var $ad1d98aa8f0c31b4$var$KEY = 0;
var $ad1d98aa8f0c31b4$export$1a5223887c560441 = class {
  /**
  * Prepares the view for reuse. Called just before the view is removed from the DOM.
  */
  prepareForReuse() {
    this.content = null;
    this.rendered = null;
    this.layoutInfo = null;
  }
  constructor(virtualizer) {
    this.virtualizer = virtualizer;
    this.key = ++$ad1d98aa8f0c31b4$var$KEY;
  }
};
var $3eb131dcf37ad5f8$var$perf = typeof window !== "undefined" ? window.performance : null;
var $3eb131dcf37ad5f8$var$perfNow = $3eb131dcf37ad5f8$var$perf && ($3eb131dcf37ad5f8$var$perf.now || $3eb131dcf37ad5f8$var$perf.webkitNow || $3eb131dcf37ad5f8$var$perf.msNow || $3eb131dcf37ad5f8$var$perf.mozNow);
var $3eb131dcf37ad5f8$var$getTime = $3eb131dcf37ad5f8$var$perfNow ? $3eb131dcf37ad5f8$var$perfNow.bind($3eb131dcf37ad5f8$var$perf) : function() {
  return Date.now ? Date.now() : (/* @__PURE__ */ new Date()).getTime();
};
var $3eb131dcf37ad5f8$var$fixTs;
function $3eb131dcf37ad5f8$export$dc0b63720788090c(begin, end, duration, ease, fn2) {
  let canceled = false;
  let raf_id;
  let promise = new Promise((resolve3) => {
    let start2 = $3eb131dcf37ad5f8$var$getTime();
    let diffX = end.x - begin.x;
    let diffY = end.y - begin.y;
    raf_id = requestAnimationFrame(function run(t5) {
      if ($3eb131dcf37ad5f8$var$fixTs == null)
        $3eb131dcf37ad5f8$var$fixTs = t5 > 1e12 !== $3eb131dcf37ad5f8$var$getTime() > 1e12;
      if ($3eb131dcf37ad5f8$var$fixTs)
        t5 = $3eb131dcf37ad5f8$var$getTime();
      let delta = t5 - start2;
      if (delta > duration) {
        fn2(end);
        resolve3();
      } else {
        let proceed = fn2(new (0, $3041db3296945e6e$export$baf26146a414f24a)(begin.x + diffX * ease(delta / duration), begin.y + diffY * ease(delta / duration)));
        if (proceed !== false && !canceled)
          raf_id = requestAnimationFrame(run);
      }
    });
  });
  promise.cancel = function() {
    canceled = true;
    cancelAnimationFrame(raf_id);
  };
  return promise;
}
function $3eb131dcf37ad5f8$export$57636bb43b1ccbb0(t5) {
  return Math.sin(t5 * Math.PI / 2);
}
function $fc36f9a046a9ce79$export$37a26b283fd7740e(a3, b2) {
  let res = /* @__PURE__ */ new Set();
  for (let key of a3.keys())
    if (!b2.has(key))
      res.add(key);
  return res;
}
function $fc36f9a046a9ce79$export$acaf96a27438246b(a3, b2) {
  let toRemove = $fc36f9a046a9ce79$export$37a26b283fd7740e(a3, b2);
  let toAdd = $fc36f9a046a9ce79$export$37a26b283fd7740e(b2, a3);
  let toUpdate = /* @__PURE__ */ new Set();
  for (let key of a3.keys())
    if (b2.has(key))
      toUpdate.add(key);
  return {
    toRemove,
    toAdd,
    toUpdate
  };
}
function* $fc36f9a046a9ce79$export$cfc14088dfefce5f(...iterators) {
  for (let iterator of iterators)
    yield* iterator;
}
function $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64(a3, b2) {
  if (a3 === b2)
    return true;
  if (a3.size !== b2.size)
    return false;
  for (let key of a3) {
    if (!b2.has(key))
      return false;
  }
  return true;
}
var $364191b3decf3697$var$RollingAverage = class {
  addSample(sample) {
    this.count++;
    this.value += (sample - this.value) / this.count;
  }
  constructor() {
    this.count = 0;
    this.value = 0;
  }
};
var $364191b3decf3697$export$4455ee6afb38dcbb = class {
  setVisibleRect(rect) {
    let time2 = performance.now() - this.startTime;
    if (time2 < 500) {
      this.averageTime.addSample(time2);
      if (rect.x !== this.visibleRect.x && time2 > 0)
        this.velocity.x = (rect.x - this.visibleRect.x) / time2;
      if (rect.y !== this.visibleRect.y && time2 > 0)
        this.velocity.y = (rect.y - this.visibleRect.y) / time2;
    }
    this.startTime = performance.now();
    this.visibleRect = rect;
  }
  collectMetrics() {
    let time2 = performance.now() - this.startTime;
    if (time2 < 500)
      this.averagePerf.addSample(time2);
    if (this.visibleRect.height > 0) {
      let o5 = Math.abs(this.velocity.y * (this.averageTime.value + this.averagePerf.value));
      this.overscanY.addSample(o5);
    }
    if (this.visibleRect.width > 0) {
      let o5 = Math.abs(this.velocity.x * (this.averageTime.value + this.averagePerf.value));
      this.overscanX.addSample(o5);
    }
  }
  getOverscannedRect() {
    let overscanned = this.visibleRect.copy();
    let overscanY = Math.round(Math.min(this.visibleRect.height * 2, this.overscanY.value) / 100) * 100;
    if (this.velocity.y > 0) {
      overscanned.y -= overscanY * 0.2;
      overscanned.height += overscanY + overscanY * 0.2;
    } else {
      overscanned.y -= overscanY;
      overscanned.height += overscanY + overscanY * 0.2;
    }
    let overscanX = Math.round(Math.min(this.visibleRect.width * 2, this.overscanX.value) / 100) * 100;
    if (this.velocity.x > 0) {
      overscanned.x -= overscanX * 0.2;
      overscanned.width += overscanX + overscanX * 0.2;
    } else {
      overscanned.x -= overscanX;
      overscanned.width += overscanX + overscanX * 0.2;
    }
    return overscanned;
  }
  constructor() {
    this.startTime = 0;
    this.averagePerf = new $364191b3decf3697$var$RollingAverage();
    this.averageTime = new $364191b3decf3697$var$RollingAverage();
    this.velocity = new (0, $3041db3296945e6e$export$baf26146a414f24a)(5, 5);
    this.overscanX = new $364191b3decf3697$var$RollingAverage();
    this.overscanY = new $364191b3decf3697$var$RollingAverage();
    this.visibleRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)();
  }
};
var $8e135e531d8dcb66$export$febc5573c75cefb0 = class {
  constructor() {
    this.level = 0;
    this.actions = [];
    this.animated = true;
    this.initialMap = /* @__PURE__ */ new Map();
    this.finalMap = /* @__PURE__ */ new Map();
    this.initialLayoutInfo = /* @__PURE__ */ new Map();
    this.finalLayoutInfo = /* @__PURE__ */ new Map();
    this.removed = /* @__PURE__ */ new Map();
    this.toRemove = /* @__PURE__ */ new Map();
  }
};
var $38b9490c1cca8fc4$export$89be5a243e59c4b2 = class {
  _setContentSize(size3) {
    this._contentSize = size3;
    this.delegate.setContentSize(size3);
  }
  _setContentOffset(offset) {
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(offset.x, offset.y, this._visibleRect.width, this._visibleRect.height);
    this.delegate.setVisibleRect(rect);
  }
  /**
  * Get the size of the scrollable content.
  */
  get contentSize() {
    return this._contentSize;
  }
  /**
  * Get the collection view's currently visible rectangle.
  */
  get visibleRect() {
    return this._visibleRect;
  }
  /**
  * Set the collection view's currently visible rectangle.
  */
  set visibleRect(rect) {
    this._setVisibleRect(rect);
  }
  _setVisibleRect(rect, forceUpdate = false) {
    let current = this._visibleRect;
    if (rect.equals(current))
      return;
    if (this.shouldOverscan)
      this._overscanManager.setVisibleRect(rect);
    let shouldInvalidate = this.layout && this.layout.shouldInvalidate(rect, this._visibleRect);
    this._resetAnimatedContentOffset();
    this._visibleRect = rect;
    if (shouldInvalidate)
      this.relayoutNow({
        offsetChanged: !rect.pointEquals(current),
        sizeChanged: !rect.sizeEquals(current)
      });
    else
      this.updateSubviews(forceUpdate);
  }
  get collection() {
    return this._collection;
  }
  set collection(data) {
    this._setData(data);
  }
  _setData(data) {
    if (data === this._collection)
      return;
    if (this._collection)
      this._runTransaction(() => {
        this._collection = data;
      }, this.transitionDuration > 0);
    else {
      this._collection = data;
      this.reloadData();
    }
  }
  /**
  * Reloads the data from the data source and relayouts the collection view.
  * Does not animate any changes. Equivalent to re-assigning the same data source
  * to the collection view.
  */
  reloadData() {
    this.relayout({
      contentChanged: true
    });
  }
  /**
  * Returns the item with the given key.
  */
  getItem(key) {
    return this._collection ? this._collection.getItem(key) : null;
  }
  /** The set of persisted keys are always present in the DOM, even if not currently in view. */
  get persistedKeys() {
    return this._persistedKeys;
  }
  /** The set of persisted keys are always present in the DOM, even if not currently in view. */
  set persistedKeys(persistedKeys) {
    if (!(0, $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64)(persistedKeys, this._persistedKeys)) {
      this._persistedKeys = persistedKeys;
      this.updateSubviews();
    }
  }
  /** Returns whether the given key, or an ancestor, is persisted. */
  isPersistedKey(key) {
    if (this._persistedKeys.has(key))
      return true;
    for (let k2 of this._persistedKeys)
      while (k2 != null) {
        let layoutInfo = this.layout.getLayoutInfo(k2);
        if (!layoutInfo)
          break;
        k2 = layoutInfo.parentKey;
        if (k2 === key)
          return true;
      }
    return false;
  }
  /**
  * Get the collection view's layout.
  */
  get layout() {
    return this._layout;
  }
  /**
  * Set the collection view's layout.
  */
  set layout(layout) {
    this.setLayout(layout);
  }
  /**
  * Sets the collection view's layout, optionally with an animated transition
  * from the current layout to the new layout.
  * @param layout The layout to switch to.
  * @param animated Whether to animate the layout change.
  */
  setLayout(layout, animated = false) {
    if (layout === this._layout)
      return;
    let applyLayout = () => {
      if (this._layout)
        this._layout.virtualizer = null;
      layout.virtualizer = this;
      this._layout = layout;
    };
    if (animated)
      this._runTransaction(applyLayout);
    else {
      applyLayout();
      this.relayout();
    }
  }
  _getReuseType(layoutInfo, content3) {
    if (layoutInfo.type === "item" && content3) {
      let type2 = this.delegate.getType ? this.delegate.getType(content3) : "item";
      let reuseType = type2 === "item" ? "item" : layoutInfo.type + "_" + type2;
      return {
        type: type2,
        reuseType
      };
    }
    return {
      type: layoutInfo.type,
      reuseType: layoutInfo.type
    };
  }
  getReusableView(layoutInfo) {
    let content3 = this.getItem(layoutInfo.key);
    let { reuseType } = this._getReuseType(layoutInfo, content3);
    if (!this._reusableViews[reuseType])
      this._reusableViews[reuseType] = [];
    let reusable = this._reusableViews[reuseType];
    let view = reusable.length > 0 ? reusable.pop() : new (0, $ad1d98aa8f0c31b4$export$1a5223887c560441)(this);
    view.viewType = reuseType;
    if (!this._animatedContentOffset.isOrigin()) {
      layoutInfo = layoutInfo.copy();
      layoutInfo.rect.x += this._animatedContentOffset.x;
      layoutInfo.rect.y += this._animatedContentOffset.y;
    }
    view.layoutInfo = layoutInfo;
    this._renderView(view);
    return view;
  }
  _renderView(reusableView) {
    let { type: type2, key } = reusableView.layoutInfo;
    reusableView.content = this.getItem(key);
    reusableView.rendered = this._renderContent(type2, reusableView.content);
  }
  _renderContent(type2, content3) {
    let cached = this._renderedContent.get(content3);
    if (cached != null)
      return cached;
    let rendered = this.delegate.renderView(type2, content3);
    if (content3)
      this._renderedContent.set(content3, rendered);
    return rendered;
  }
  /**
  * Returns an array of all currently visible views, including both
  * item views and supplementary views.
  */
  get visibleViews() {
    return Array.from(this._visibleViews.values());
  }
  /**
  * Gets the visible view for the given type and key. Returns null if
  * the view is not currently visible.
  *
  * @param key The key of the view to retrieve.
  */
  getView(key) {
    return this._visibleViews.get(key) || null;
  }
  /**
  * Returns an array of visible views matching the given type.
  * @param type The view type to find.
  */
  getViewsOfType(type2) {
    return this.visibleViews.filter((v6) => v6.layoutInfo && v6.layoutInfo.type === type2);
  }
  /**
  * Returns the key for the given view. Returns null
  * if the view is not currently visible.
  */
  keyForView(view) {
    if (view && view.layoutInfo)
      return view.layoutInfo.key;
    return null;
  }
  /**
  * Returns the key for the item view currently at the given point.
  */
  keyAtPoint(point3) {
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(point3.x, point3.y, 1, 1);
    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);
    for (let layoutInfo of layoutInfos) {
      if (layoutInfo.rect.intersects(rect))
        return layoutInfo.key;
    }
    return null;
  }
  /**
  * Cleanup for when the Virtualizer will be unmounted.
  */
  willUnmount() {
    cancelAnimationFrame(this._relayoutRaf);
  }
  /**
  * Triggers a layout invalidation, and updates the visible subviews.
  */
  relayout(context = {}) {
    if (this._scrollAnimation || typeof requestAnimationFrame === "undefined")
      return;
    if (this._invalidationContext) {
      Object.assign(this._invalidationContext, context);
      return;
    }
    this._invalidationContext = context;
  }
  /**
  * Performs a relayout immediately. Prefer {@link relayout} over this method
  * where possible, since it coalesces multiple layout passes in the same tick.
  */
  relayoutNow(context = this._invalidationContext || {}) {
    if (this._relayoutRaf) {
      cancelAnimationFrame(this._relayoutRaf);
      this._relayoutRaf = null;
      context = {
        ...this._invalidationContext,
        ...context
      };
    }
    this._invalidationContext = null;
    if (!this.layout || !this._collection || this._scrollAnimation)
      return;
    let scrollAnchor = this._getScrollAnchor();
    if (typeof context.beforeLayout === "function")
      context.beforeLayout();
    this.layout.validate(context);
    this._setContentSize(this.layout.getContentSize());
    if (typeof context.afterLayout === "function")
      context.afterLayout();
    let visibleRect = this.getVisibleRect();
    let restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);
    let contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;
    let contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;
    contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));
    contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));
    let hasLayoutUpdates = false;
    if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {
      if (context.animated || !this._animatedContentOffset.isOrigin()) {
        this._animatedContentOffset.x += visibleRect.x - contentOffsetX;
        this._animatedContentOffset.y += visibleRect.y - contentOffsetY;
        hasLayoutUpdates = this.updateSubviews(context.contentChanged);
      } else
        this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(contentOffsetX, contentOffsetY));
    } else
      hasLayoutUpdates = this.updateSubviews(context.contentChanged);
    if (!(context.transaction && context.animated))
      this._applyLayoutInfos();
    if (context.animated && hasLayoutUpdates) {
      this._enableTransitions();
      let done = () => {
        this._disableTransitions();
        if (!this._animatedContentOffset.isOrigin()) {
          let { x: x4, y: y4 } = this.getVisibleRect();
          this._resetAnimatedContentOffset();
          this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x4, y4));
        }
        if (typeof context.afterAnimation === "function")
          context.afterAnimation();
      };
      setTimeout(done, this.transitionDuration + 100);
      return;
    } else if (typeof context.afterAnimation === "function")
      context.afterAnimation();
  }
  /**
  * Corrects DOM order of visible views to match item order of collection.
  */
  _correctItemOrder() {
    if (this._isScrolling || this._transaction)
      return;
    for (let key of this._visibleLayoutInfos.keys()) {
      let view = this._visibleViews.get(key);
      this._children.delete(view);
      this._children.add(view);
    }
  }
  _enableTransitions() {
    this.delegate.beginAnimations();
  }
  _disableTransitions() {
    this.delegate.endAnimations();
  }
  _getScrollAnchor() {
    if (!this.anchorScrollPosition)
      return null;
    let visibleRect = this.getVisibleRect();
    if (this.delegate.getScrollAnchor) {
      let key = this.delegate.getScrollAnchor(visibleRect);
      if (key != null) {
        let layoutInfo = this.layout.getLayoutInfo(key);
        let corner = layoutInfo.rect.getCornerInRect(visibleRect);
        if (corner) {
          let key2 = layoutInfo.key;
          let offset = layoutInfo.rect[corner].y - visibleRect.y;
          return {
            key: key2,
            layoutInfo,
            corner,
            offset
          };
        }
      }
    }
    if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop)
      return null;
    let cornerAnchor = null;
    for (let [key, view] of this._visibleViews) {
      let layoutInfo = view.layoutInfo;
      if (layoutInfo && layoutInfo.rect.area > 0) {
        let corner = layoutInfo.rect.getCornerInRect(visibleRect);
        if (corner) {
          let offset = layoutInfo.rect[corner].y - visibleRect.y;
          if (!cornerAnchor || offset < cornerAnchor.offset)
            cornerAnchor = {
              key,
              layoutInfo,
              corner,
              offset
            };
        }
      }
    }
    return cornerAnchor;
  }
  _restoreScrollAnchor(scrollAnchor, context) {
    let contentOffset = this.getVisibleRect();
    if (scrollAnchor) {
      var _context_transaction;
      let finalAnchor = ((_context_transaction = context.transaction) === null || _context_transaction === void 0 ? void 0 : _context_transaction.animated) ? context.transaction.finalMap.get(scrollAnchor.key) : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.key);
      if (finalAnchor) {
        let adjustment = finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y - scrollAnchor.offset;
        contentOffset.y += adjustment;
      }
    }
    return contentOffset;
  }
  getVisibleRect() {
    let v6 = this.visibleRect;
    let x4 = v6.x - this._animatedContentOffset.x;
    let y4 = v6.y - this._animatedContentOffset.y;
    return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x4, y4, v6.width, v6.height);
  }
  getVisibleLayoutInfos() {
    let rect = this.shouldOverscan ? this._overscanManager.getOverscannedRect() : this.getVisibleRect();
    this._visibleLayoutInfos = this._getLayoutInfoMap(rect);
    return this._visibleLayoutInfos;
  }
  _getLayoutInfoMap(rect, copy3 = false) {
    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);
    let map4 = /* @__PURE__ */ new Map();
    for (let layoutInfo of layoutInfos) {
      if (copy3)
        layoutInfo = layoutInfo.copy();
      map4.set(layoutInfo.key, layoutInfo);
    }
    return map4;
  }
  updateSubviews(forceUpdate = false) {
    if (!this._collection)
      return;
    let visibleLayoutInfos = this.getVisibleLayoutInfos();
    let currentlyVisible = this._visibleViews;
    let toAdd, toRemove, toUpdate;
    if (forceUpdate) {
      toAdd = visibleLayoutInfos;
      toRemove = currentlyVisible;
      toUpdate = /* @__PURE__ */ new Set();
    } else {
      ({ toAdd, toRemove, toUpdate } = (0, $fc36f9a046a9ce79$export$acaf96a27438246b)(currentlyVisible, visibleLayoutInfos));
      for (let key of toUpdate) {
        let view = currentlyVisible.get(key);
        if (!view || !view.layoutInfo)
          continue;
        let item2 = this.getItem(visibleLayoutInfos.get(key).key);
        if (view.content === item2)
          toUpdate.delete(key);
        else {
          let { reuseType } = this._getReuseType(view.layoutInfo, item2);
          if (view.viewType !== reuseType) {
            toUpdate.delete(key);
            toAdd.add(key);
            toRemove.add(key);
          }
        }
      }
      if (toAdd.size === 0 && toRemove.size === 0 && toUpdate.size === 0) {
        if (this._transaction)
          this._applyLayoutInfos();
        return;
      }
    }
    let removed = /* @__PURE__ */ new Set();
    for (let key of toRemove.keys()) {
      let view = this._visibleViews.get(key);
      if (view) {
        removed.add(view);
        this._visibleViews.delete(key);
        if (this._transaction)
          this._transaction.toRemove.set(key, view);
        else
          this.reuseView(view);
      }
    }
    for (let key of toAdd.keys()) {
      let layoutInfo = visibleLayoutInfos.get(key);
      let view;
      if (this._transaction) {
        if (this._transaction.initialLayoutInfo.has(key))
          layoutInfo = this._transaction.initialLayoutInfo.get(key);
        view = this._transaction.toRemove.get(key);
        if (view) {
          this._transaction.toRemove.delete(key);
          this._applyLayoutInfo(view, layoutInfo);
        }
      }
      if (!view) {
        view = this.getReusableView(layoutInfo);
        if (!removed.has(view))
          this._children.add(view);
      }
      this._visibleViews.set(key, view);
      removed.delete(view);
    }
    for (let key of toUpdate) {
      let view = currentlyVisible.get(key);
      this._renderedContent.delete(key);
      this._renderView(view);
    }
    if (!this._transaction)
      this.removeViews(removed);
    this._correctItemOrder();
    this._flushVisibleViews();
    let hasLayoutUpdates = this._transaction && (toAdd.size > 0 || toRemove.size > 0 || this._hasLayoutUpdates());
    if (hasLayoutUpdates)
      requestAnimationFrame(() => {
        if (this._transaction)
          requestAnimationFrame(() => this._applyLayoutInfos());
      });
    return hasLayoutUpdates;
  }
  afterRender() {
    if (this._transactionQueue.length > 0)
      this._processTransactionQueue();
    else if (this._invalidationContext)
      this.relayoutNow();
    if (this.shouldOverscan)
      this._overscanManager.collectMetrics();
  }
  _flushVisibleViews() {
    let viewsByParentKey = /* @__PURE__ */ new Map([
      [
        null,
        []
      ]
    ]);
    for (let view of this._children) {
      var _view_layoutInfo, _viewsByParentKey_get, _view_layoutInfo1, _view_layoutInfo2, _view_layoutInfo3;
      if (((_view_layoutInfo = view.layoutInfo) === null || _view_layoutInfo === void 0 ? void 0 : _view_layoutInfo.parentKey) != null && !viewsByParentKey.has(view.layoutInfo.parentKey))
        viewsByParentKey.set(view.layoutInfo.parentKey, []);
      (_viewsByParentKey_get = viewsByParentKey.get((_view_layoutInfo1 = view.layoutInfo) === null || _view_layoutInfo1 === void 0 ? void 0 : _view_layoutInfo1.parentKey)) === null || _viewsByParentKey_get === void 0 ? void 0 : _viewsByParentKey_get.push(view);
      if (!viewsByParentKey.has((_view_layoutInfo2 = view.layoutInfo) === null || _view_layoutInfo2 === void 0 ? void 0 : _view_layoutInfo2.key))
        viewsByParentKey.set((_view_layoutInfo3 = view.layoutInfo) === null || _view_layoutInfo3 === void 0 ? void 0 : _view_layoutInfo3.key, []);
    }
    let buildTree = (parent, views) => views.map((view) => {
      let children2 = viewsByParentKey.get(view.layoutInfo.key);
      return this.delegate.renderWrapper(parent, view, children2, (childViews) => buildTree(view, childViews));
    });
    let children = buildTree(null, viewsByParentKey.get(null));
    this.delegate.setVisibleViews(children);
  }
  _applyLayoutInfo(view, layoutInfo) {
    if (view.layoutInfo === layoutInfo)
      return false;
    view.layoutInfo = layoutInfo;
    return true;
  }
  _applyLayoutInfos() {
    let updated = false;
    for (let view of this._visibleViews.values()) {
      let cur = view.layoutInfo;
      if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {
        let layoutInfo = this.layout.getLayoutInfo(cur.key);
        if (this._applyLayoutInfo(view, layoutInfo))
          updated = true;
      }
    }
    if (this._transaction) {
      for (let view of this._transaction.toRemove.values()) {
        let cur = view.layoutInfo;
        if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {
          let layoutInfo = this.layout.getLayoutInfo(cur.key);
          if (this._applyLayoutInfo(view, layoutInfo))
            updated = true;
        }
      }
      for (let view of this._transaction.removed.values()) {
        let cur = view.layoutInfo;
        let layoutInfo = this._transaction.finalLayoutInfo.get(cur.key) || cur;
        layoutInfo = this.layout.getFinalLayoutInfo(layoutInfo.copy());
        if (this._applyLayoutInfo(view, layoutInfo))
          updated = true;
      }
    }
    if (updated)
      this._flushVisibleViews();
  }
  _hasLayoutUpdates() {
    if (!this._transaction)
      return false;
    for (let view of this._visibleViews.values()) {
      let cur = view.layoutInfo;
      if (!cur)
        return true;
      let layoutInfo = this.layout.getLayoutInfo(cur.key);
      if (
        // Uses equals rather than pointEquals so that width/height changes are taken into account
        !cur.rect.equals(layoutInfo.rect) || cur.opacity !== layoutInfo.opacity || cur.transform !== layoutInfo.transform
      )
        return true;
    }
    return false;
  }
  reuseView(view) {
    view.prepareForReuse();
    this._reusableViews[view.viewType].push(view);
  }
  removeViews(toRemove) {
    for (let view of toRemove)
      this._children.delete(view);
  }
  updateItemSize(key, size3) {
    if (!this.layout.updateItemSize)
      return;
    if (this._scrollAnimation) {
      this._sizeUpdateQueue.set(key, size3);
      return;
    }
    let changed = this.layout.updateItemSize(key, size3);
    if (changed)
      this.relayout();
  }
  startScrolling() {
    this._isScrolling = true;
  }
  endScrolling() {
    this._isScrolling = false;
    this._correctItemOrder();
    this._flushVisibleViews();
  }
  _resetAnimatedContentOffset() {
    if (!this._animatedContentOffset.isOrigin()) {
      this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);
      this._applyLayoutInfos();
    }
  }
  /**
  * Scrolls the item with the given key into view, optionally with an animation.
  * @param key The key of the item to scroll into view.
  * @param duration The duration of the scroll animation.
  */
  scrollToItem(key, options) {
    if (key == null)
      return;
    let layoutInfo = this.layout.getLayoutInfo(key);
    if (!layoutInfo)
      return;
    let { duration = 300, shouldScrollX = true, shouldScrollY = true, offsetX = 0, offsetY = 0 } = options;
    let x4 = this.visibleRect.x;
    let y4 = this.visibleRect.y;
    let minX = layoutInfo.rect.x - offsetX;
    let minY = layoutInfo.rect.y - offsetY;
    let maxX = x4 + this.visibleRect.width;
    let maxY = y4 + this.visibleRect.height;
    if (shouldScrollX) {
      if (minX <= x4 || maxX === 0)
        x4 = minX;
      else if (layoutInfo.rect.maxX > maxX)
        x4 += layoutInfo.rect.maxX - maxX;
    }
    if (shouldScrollY) {
      if (minY <= y4 || maxY === 0)
        y4 = minY;
      else if (layoutInfo.rect.maxY > maxY)
        y4 += layoutInfo.rect.maxY - maxY;
    }
    return this.scrollTo(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x4, y4), duration);
  }
  /**
  * Performs an animated scroll to the given offset.
  * @param offset - The offset to scroll to.
  * @param duration The duration of the animation.
  * @returns A promise that resolves when the animation is complete.
  */
  scrollTo(offset, duration = 300) {
    if (this._scrollAnimation) {
      this._scrollAnimation.cancel();
      this._scrollAnimation = null;
    }
    if (duration <= 0 || this.visibleRect.pointEquals(offset)) {
      this._setContentOffset(offset);
      return Promise.resolve();
    }
    this.startScrolling();
    this._scrollAnimation = (0, $3eb131dcf37ad5f8$export$dc0b63720788090c)(this.visibleRect, offset, duration, (0, $3eb131dcf37ad5f8$export$57636bb43b1ccbb0), (offset2) => {
      this._setContentOffset(offset2);
    });
    this._scrollAnimation.then(() => {
      this._scrollAnimation = null;
      for (let [key, size3] of this._sizeUpdateQueue)
        this.updateItemSize(key, size3);
      this._sizeUpdateQueue.clear();
      this.relayout();
      this._processTransactionQueue();
      this.endScrolling();
    });
    return this._scrollAnimation;
  }
  _runTransaction(action, animated) {
    this._startTransaction();
    if (this._nextTransaction)
      this._nextTransaction.actions.push(action);
    this._endTransaction(animated);
  }
  _startTransaction() {
    if (!this._nextTransaction)
      this._nextTransaction = new (0, $8e135e531d8dcb66$export$febc5573c75cefb0)();
    this._nextTransaction.level++;
  }
  _endTransaction(animated) {
    if (!this._nextTransaction)
      return false;
    if (animated != null)
      this._nextTransaction.animated = animated;
    if (--this._nextTransaction.level > 0)
      return false;
    if (this._nextTransaction.actions.length === 0) {
      this._nextTransaction = null;
      return false;
    }
    if (this._nextTransaction.animated == null)
      this._nextTransaction.animated = true;
    this._transactionQueue.push(this._nextTransaction);
    this._nextTransaction = null;
    return true;
  }
  _processTransactionQueue() {
    if (this._transaction || this._scrollAnimation)
      return;
    let next2 = this._transactionQueue.shift();
    if (next2)
      this._performTransaction(next2);
  }
  _getContentRect() {
    return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, 0, this.contentSize.width, this.contentSize.height);
  }
  _performTransaction(transaction) {
    this._transaction = transaction;
    this.relayoutNow({
      transaction,
      animated: transaction.animated,
      beforeLayout: () => {
        if (transaction.animated)
          transaction.initialMap = this._getLayoutInfoMap(this._getContentRect(), true);
        for (let action of transaction.actions)
          action();
      },
      afterLayout: () => {
        if (transaction.animated) {
          transaction.finalMap = this._getLayoutInfoMap(this._getContentRect());
          this._setupTransactionAnimations(transaction);
        } else
          this._transaction = null;
      },
      afterAnimation: () => {
        if (transaction.toRemove.size > 0 || transaction.removed.size > 0)
          for (let view of (0, $fc36f9a046a9ce79$export$cfc14088dfefce5f)(transaction.toRemove.values(), transaction.removed.values())) {
            this._children.delete(view);
            this.reuseView(view);
          }
        this._transaction = null;
        this._correctItemOrder();
        this._flushVisibleViews();
        this._processTransactionQueue();
      }
    });
  }
  _setupTransactionAnimations(transaction) {
    let { initialMap, finalMap } = transaction;
    for (let [key, layoutInfo] of initialMap)
      if (finalMap.has(key))
        transaction.initialLayoutInfo.set(key, layoutInfo);
      else
        transaction.finalLayoutInfo.set(layoutInfo.key, layoutInfo);
    for (let [key, layoutInfo] of finalMap)
      if (!initialMap.has(key)) {
        let initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo.copy());
        transaction.initialLayoutInfo.set(key, initialLayoutInfo);
      }
    for (let [key, view] of this._visibleViews)
      if (!finalMap.has(key) && view.layoutInfo.rect.width > 0) {
        transaction.removed.set(key, view);
        this._visibleViews.delete(key);
        if (view.layoutInfo) {
          if (!transaction.finalLayoutInfo.has(view.layoutInfo.key))
            transaction.finalLayoutInfo.set(view.layoutInfo.key, view.layoutInfo);
        }
      }
  }
  constructor(options = {}) {
    this._contentSize = new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)();
    this._visibleRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)();
    this._reusableViews = {};
    this._visibleLayoutInfos = /* @__PURE__ */ new Map();
    this._visibleViews = /* @__PURE__ */ new Map();
    this._renderedContent = /* @__PURE__ */ new WeakMap();
    this._children = /* @__PURE__ */ new Set();
    this._invalidationContext = null;
    this._overscanManager = new (0, $364191b3decf3697$export$4455ee6afb38dcbb)();
    this._persistedKeys = /* @__PURE__ */ new Set();
    this._scrollAnimation = null;
    this._isScrolling = false;
    this._sizeUpdateQueue = /* @__PURE__ */ new Map();
    this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);
    this._transaction = null;
    this._nextTransaction = null;
    this._transactionQueue = [];
    var _options_transitionDuration;
    this.transitionDuration = (_options_transitionDuration = options.transitionDuration) !== null && _options_transitionDuration !== void 0 ? _options_transitionDuration : 500;
    this.anchorScrollPosition = options.anchorScrollPosition || false;
    this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;
    this.shouldOverscan = options.shouldOverscan !== false;
    for (let key of [
      "delegate",
      "size",
      "layout",
      "collection"
    ])
      if (options[key])
        this[key] = options[key];
  }
};
function $fc0b13b484ac1194$export$1505db82fe357e65(opts) {
  let [visibleViews, setVisibleViews] = (0, import_react41.useState)([]);
  let [contentSize, setContentSize] = (0, import_react41.useState)(new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)());
  let [isAnimating, setAnimating] = (0, import_react41.useState)(false);
  let [isScrolling, setScrolling] = (0, import_react41.useState)(false);
  let virtualizer = (0, import_react41.useMemo)(() => new (0, $38b9490c1cca8fc4$export$89be5a243e59c4b2)(), []);
  virtualizer.delegate = {
    setVisibleViews,
    setVisibleRect(rect) {
      virtualizer.visibleRect = rect;
      opts.onVisibleRectChange(rect);
    },
    setContentSize,
    renderView: opts.renderView,
    renderWrapper: opts.renderWrapper,
    beginAnimations: () => setAnimating(true),
    endAnimations: () => setAnimating(false),
    getScrollAnchor: opts.getScrollAnchor
  };
  virtualizer.layout = opts.layout;
  virtualizer.collection = opts.collection;
  virtualizer.transitionDuration = opts.transitionDuration;
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    virtualizer.afterRender();
  });
  (0, import_react41.useEffect)(() => {
    return () => virtualizer.willUnmount();
  }, []);
  let setVisibleRect = (0, import_react41.useCallback)((rect) => {
    virtualizer.visibleRect = rect;
  }, [
    virtualizer
  ]);
  let startScrolling = (0, import_react41.useCallback)(() => {
    virtualizer.startScrolling();
    setScrolling(true);
  }, [
    virtualizer
  ]);
  let endScrolling = (0, import_react41.useCallback)(() => {
    virtualizer.endScrolling();
    setScrolling(false);
  }, [
    virtualizer
  ]);
  let state = (0, import_react41.useMemo)(() => ({
    virtualizer,
    visibleViews,
    setVisibleRect,
    contentSize,
    isAnimating,
    isScrolling,
    startScrolling,
    endScrolling
  }), [
    virtualizer,
    visibleViews,
    setVisibleRect,
    contentSize,
    isAnimating,
    isScrolling,
    startScrolling,
    endScrolling
  ]);
  return state;
}

// node_modules/@react-aria/grid/dist/import.mjs
var import_react43 = __toESM(require_react(), 1);

// node_modules/@react-aria/selection/dist/import.mjs
var import_react_dom3 = __toESM(require_react_dom(), 1);
var import_react42 = __toESM(require_react(), 1);
function $feb5ffebff200149$export$d3e3bd3e26688c04(e6) {
  return (0, $c87311424ea30a05$export$e1865c3bedcd822b)() ? e6.altKey : e6.ctrlKey;
}
function $feb5ffebff200149$export$16792effe837dba3(e6) {
  if ((0, $c87311424ea30a05$export$9ac100e40613ea10)())
    return e6.metaKey;
  return e6.ctrlKey;
}
var $fb3050f43d946246$var$TYPEAHEAD_DEBOUNCE_WAIT_MS = 1e3;
function $fb3050f43d946246$export$e32c88dfddc6e1d8(options) {
  let { keyboardDelegate, selectionManager, onTypeSelect } = options;
  let state = (0, import_react42.useRef)({
    search: "",
    timeout: null
  }).current;
  let onKeyDown = (e6) => {
    let character2 = $fb3050f43d946246$var$getStringForKey(e6.key);
    if (!character2 || e6.ctrlKey || e6.metaKey || !e6.currentTarget.contains(e6.target))
      return;
    if (character2 === " " && state.search.trim().length > 0) {
      e6.preventDefault();
      if (!("continuePropagation" in e6))
        e6.stopPropagation();
    }
    state.search += character2;
    let key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey);
    if (key == null)
      key = keyboardDelegate.getKeyForSearch(state.search);
    if (key != null) {
      selectionManager.setFocusedKey(key);
      if (onTypeSelect)
        onTypeSelect(key);
    }
    clearTimeout(state.timeout);
    state.timeout = setTimeout(() => {
      state.search = "";
    }, $fb3050f43d946246$var$TYPEAHEAD_DEBOUNCE_WAIT_MS);
  };
  return {
    typeSelectProps: {
      // Using a capturing listener to catch the keydown event before
      // other hooks in order to handle the Spacebar event.
      onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : null
    }
  };
}
function $fb3050f43d946246$var$getStringForKey(key) {
  if (key.length === 1 || !/^[A-Z]/i.test(key))
    return key;
  return "";
}
function $ae20dd8cbca75726$export$d6daf82dcd84e87c(options) {
  let { selectionManager: manager, keyboardDelegate: delegate, ref, autoFocus = false, shouldFocusWrap = false, disallowEmptySelection = false, disallowSelectAll = false, selectOnFocus = manager.selectionBehavior === "replace", disallowTypeAhead = false, shouldUseVirtualFocus, allowsTabNavigation = false, isVirtualized, scrollRef = ref, linkBehavior = "action" } = options;
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let router = (0, $ea8dcbcb9ea1b556$export$9a302a45f65d0572)();
  let onKeyDown = (e6) => {
    if (e6.altKey && e6.key === "Tab")
      e6.preventDefault();
    if (!ref.current.contains(e6.target))
      return;
    const navigateToKey = (key, childFocus) => {
      if (key != null) {
        if (manager.isLink(key) && linkBehavior === "selection" && selectOnFocus && !(0, $feb5ffebff200149$export$d3e3bd3e26688c04)(e6)) {
          (0, import_react_dom3.flushSync)(() => {
            manager.setFocusedKey(key, childFocus);
          });
          let item2 = scrollRef.current.querySelector(`[data-key="${CSS.escape(key.toString())}"]`);
          router.open(item2, e6);
          return;
        }
        manager.setFocusedKey(key, childFocus);
        if (manager.isLink(key) && linkBehavior === "override")
          return;
        if (e6.shiftKey && manager.selectionMode === "multiple")
          manager.extendSelection(key);
        else if (selectOnFocus && !(0, $feb5ffebff200149$export$d3e3bd3e26688c04)(e6))
          manager.replaceSelection(key);
      }
    };
    switch (e6.key) {
      case "ArrowDown":
        if (delegate.getKeyBelow) {
          var _delegate_getFirstKey, _delegate_getFirstKey1;
          e6.preventDefault();
          let nextKey = manager.focusedKey != null ? delegate.getKeyBelow(manager.focusedKey) : (_delegate_getFirstKey = delegate.getFirstKey) === null || _delegate_getFirstKey === void 0 ? void 0 : _delegate_getFirstKey.call(delegate);
          if (nextKey == null && shouldFocusWrap)
            nextKey = (_delegate_getFirstKey1 = delegate.getFirstKey) === null || _delegate_getFirstKey1 === void 0 ? void 0 : _delegate_getFirstKey1.call(delegate, manager.focusedKey);
          navigateToKey(nextKey);
        }
        break;
      case "ArrowUp":
        if (delegate.getKeyAbove) {
          var _delegate_getLastKey, _delegate_getLastKey1;
          e6.preventDefault();
          let nextKey = manager.focusedKey != null ? delegate.getKeyAbove(manager.focusedKey) : (_delegate_getLastKey = delegate.getLastKey) === null || _delegate_getLastKey === void 0 ? void 0 : _delegate_getLastKey.call(delegate);
          if (nextKey == null && shouldFocusWrap)
            nextKey = (_delegate_getLastKey1 = delegate.getLastKey) === null || _delegate_getLastKey1 === void 0 ? void 0 : _delegate_getLastKey1.call(delegate, manager.focusedKey);
          navigateToKey(nextKey);
        }
        break;
      case "ArrowLeft":
        if (delegate.getKeyLeftOf) {
          var _delegate_getFirstKey2, _delegate_getLastKey2;
          e6.preventDefault();
          let nextKey = delegate.getKeyLeftOf(manager.focusedKey);
          if (nextKey == null && shouldFocusWrap)
            nextKey = direction === "rtl" ? (_delegate_getFirstKey2 = delegate.getFirstKey) === null || _delegate_getFirstKey2 === void 0 ? void 0 : _delegate_getFirstKey2.call(delegate, manager.focusedKey) : (_delegate_getLastKey2 = delegate.getLastKey) === null || _delegate_getLastKey2 === void 0 ? void 0 : _delegate_getLastKey2.call(delegate, manager.focusedKey);
          navigateToKey(nextKey, direction === "rtl" ? "first" : "last");
        }
        break;
      case "ArrowRight":
        if (delegate.getKeyRightOf) {
          var _delegate_getLastKey3, _delegate_getFirstKey3;
          e6.preventDefault();
          let nextKey = delegate.getKeyRightOf(manager.focusedKey);
          if (nextKey == null && shouldFocusWrap)
            nextKey = direction === "rtl" ? (_delegate_getLastKey3 = delegate.getLastKey) === null || _delegate_getLastKey3 === void 0 ? void 0 : _delegate_getLastKey3.call(delegate, manager.focusedKey) : (_delegate_getFirstKey3 = delegate.getFirstKey) === null || _delegate_getFirstKey3 === void 0 ? void 0 : _delegate_getFirstKey3.call(delegate, manager.focusedKey);
          navigateToKey(nextKey, direction === "rtl" ? "last" : "first");
        }
        break;
      case "Home":
        if (delegate.getFirstKey) {
          e6.preventDefault();
          let firstKey = delegate.getFirstKey(manager.focusedKey, (0, $feb5ffebff200149$export$16792effe837dba3)(e6));
          manager.setFocusedKey(firstKey);
          if ((0, $feb5ffebff200149$export$16792effe837dba3)(e6) && e6.shiftKey && manager.selectionMode === "multiple")
            manager.extendSelection(firstKey);
          else if (selectOnFocus)
            manager.replaceSelection(firstKey);
        }
        break;
      case "End":
        if (delegate.getLastKey) {
          e6.preventDefault();
          let lastKey = delegate.getLastKey(manager.focusedKey, (0, $feb5ffebff200149$export$16792effe837dba3)(e6));
          manager.setFocusedKey(lastKey);
          if ((0, $feb5ffebff200149$export$16792effe837dba3)(e6) && e6.shiftKey && manager.selectionMode === "multiple")
            manager.extendSelection(lastKey);
          else if (selectOnFocus)
            manager.replaceSelection(lastKey);
        }
        break;
      case "PageDown":
        if (delegate.getKeyPageBelow) {
          e6.preventDefault();
          let nextKey = delegate.getKeyPageBelow(manager.focusedKey);
          navigateToKey(nextKey);
        }
        break;
      case "PageUp":
        if (delegate.getKeyPageAbove) {
          e6.preventDefault();
          let nextKey = delegate.getKeyPageAbove(manager.focusedKey);
          navigateToKey(nextKey);
        }
        break;
      case "a":
        if ((0, $feb5ffebff200149$export$16792effe837dba3)(e6) && manager.selectionMode === "multiple" && disallowSelectAll !== true) {
          e6.preventDefault();
          manager.selectAll();
        }
        break;
      case "Escape":
        e6.preventDefault();
        if (!disallowEmptySelection)
          manager.clearSelection();
        break;
      case "Tab":
        if (!allowsTabNavigation) {
          if (e6.shiftKey)
            ref.current.focus();
          else {
            let walker = (0, $9bf71ea28793e738$export$2d6ec8fc375ceafa)(ref.current, {
              tabbable: true
            });
            let next2;
            let last2;
            do {
              last2 = walker.lastChild();
              if (last2)
                next2 = last2;
            } while (last2);
            if (next2 && !next2.contains(document.activeElement))
              (0, $7215afc6de606d6b$export$de79e2c695e052f3)(next2);
          }
          break;
        }
    }
  };
  let scrollPos = (0, import_react42.useRef)({
    top: 0,
    left: 0
  });
  (0, $e9faafb641e167db$export$90fc3a17d93f704c)(scrollRef, "scroll", isVirtualized ? null : () => {
    scrollPos.current = {
      top: scrollRef.current.scrollTop,
      left: scrollRef.current.scrollLeft
    };
  });
  let onFocus = (e6) => {
    if (manager.isFocused) {
      if (!e6.currentTarget.contains(e6.target))
        manager.setFocused(false);
      return;
    }
    if (!e6.currentTarget.contains(e6.target))
      return;
    manager.setFocused(true);
    if (manager.focusedKey == null) {
      let navigateToFirstKey = (key) => {
        if (key != null) {
          manager.setFocusedKey(key);
          if (selectOnFocus)
            manager.replaceSelection(key);
        }
      };
      let relatedTarget = e6.relatedTarget;
      var _manager_lastSelectedKey, _manager_firstSelectedKey;
      if (relatedTarget && e6.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING)
        navigateToFirstKey((_manager_lastSelectedKey = manager.lastSelectedKey) !== null && _manager_lastSelectedKey !== void 0 ? _manager_lastSelectedKey : delegate.getLastKey());
      else
        navigateToFirstKey((_manager_firstSelectedKey = manager.firstSelectedKey) !== null && _manager_firstSelectedKey !== void 0 ? _manager_firstSelectedKey : delegate.getFirstKey());
    } else if (!isVirtualized) {
      scrollRef.current.scrollTop = scrollPos.current.top;
      scrollRef.current.scrollLeft = scrollPos.current.left;
    }
    if (!isVirtualized && manager.focusedKey != null) {
      let element4 = scrollRef.current.querySelector(`[data-key="${CSS.escape(manager.focusedKey.toString())}"]`);
      if (element4) {
        if (!element4.contains(document.activeElement))
          (0, $7215afc6de606d6b$export$de79e2c695e052f3)(element4);
        let modality = (0, $507fabe10e71c6fb$export$630ff653c5ada6a9)();
        if (modality === "keyboard")
          (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(element4, {
            containingElement: ref.current
          });
      }
    }
  };
  let onBlur = (e6) => {
    if (!e6.currentTarget.contains(e6.relatedTarget))
      manager.setFocused(false);
  };
  const autoFocusRef = (0, import_react42.useRef)(autoFocus);
  (0, import_react42.useEffect)(() => {
    if (autoFocusRef.current) {
      let focusedKey = null;
      if (autoFocus === "first")
        focusedKey = delegate.getFirstKey();
      if (autoFocus === "last")
        focusedKey = delegate.getLastKey();
      let selectedKeys = manager.selectedKeys;
      if (selectedKeys.size) {
        for (let key of selectedKeys)
          if (manager.canSelectItem(key)) {
            focusedKey = key;
            break;
          }
      }
      manager.setFocused(true);
      manager.setFocusedKey(focusedKey);
      if (focusedKey == null && !shouldUseVirtualFocus)
        (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
    }
  }, []);
  let lastFocusedKey = (0, import_react42.useRef)(manager.focusedKey);
  (0, import_react42.useEffect)(() => {
    let modality = (0, $507fabe10e71c6fb$export$630ff653c5ada6a9)();
    if (manager.isFocused && manager.focusedKey != null && (scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current)) {
      let element4 = scrollRef.current.querySelector(`[data-key="${CSS.escape(manager.focusedKey.toString())}"]`);
      if (element4 && (modality === "keyboard" || autoFocusRef.current)) {
        if (!isVirtualized)
          (0, $2f04cbc44ee30ce0$export$53a0910f038337bd)(scrollRef.current, element4);
        if (modality !== "virtual")
          (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(element4, {
            containingElement: ref.current
          });
      }
    }
    if (manager.isFocused && manager.focusedKey == null && lastFocusedKey.current != null)
      (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
    lastFocusedKey.current = manager.focusedKey;
    autoFocusRef.current = false;
  }, [
    isVirtualized,
    scrollRef,
    manager.focusedKey,
    manager.isFocused,
    ref
  ]);
  let handlers = {
    onKeyDown,
    onFocus,
    onBlur,
    onMouseDown(e6) {
      if (scrollRef.current === e6.target)
        e6.preventDefault();
    }
  };
  let { typeSelectProps } = (0, $fb3050f43d946246$export$e32c88dfddc6e1d8)({
    keyboardDelegate: delegate,
    selectionManager: manager
  });
  if (!disallowTypeAhead)
    handlers = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(typeSelectProps, handlers);
  let tabIndex;
  if (!shouldUseVirtualFocus)
    tabIndex = manager.focusedKey == null ? 0 : -1;
  return {
    collectionProps: {
      ...handlers,
      tabIndex
    }
  };
}
function $880e95eb8b93ba9a$export$ecf600387e221c37(options) {
  let { selectionManager: manager, key, ref, shouldSelectOnPressUp, shouldUseVirtualFocus, focus, isDisabled, onAction, allowsDifferentPressOrigin, linkBehavior = "action" } = options;
  let router = (0, $ea8dcbcb9ea1b556$export$9a302a45f65d0572)();
  let onSelect = (e6) => {
    if (e6.pointerType === "keyboard" && (0, $feb5ffebff200149$export$d3e3bd3e26688c04)(e6))
      manager.toggleSelection(key);
    else {
      if (manager.selectionMode === "none")
        return;
      if (manager.isLink(key)) {
        if (linkBehavior === "selection") {
          router.open(ref.current, e6);
          manager.setSelectedKeys(manager.selectedKeys);
          return;
        } else if (linkBehavior === "override" || linkBehavior === "none")
          return;
      }
      if (manager.selectionMode === "single") {
        if (manager.isSelected(key) && !manager.disallowEmptySelection)
          manager.toggleSelection(key);
        else
          manager.replaceSelection(key);
      } else if (e6 && e6.shiftKey)
        manager.extendSelection(key);
      else if (manager.selectionBehavior === "toggle" || e6 && ((0, $feb5ffebff200149$export$16792effe837dba3)(e6) || e6.pointerType === "touch" || e6.pointerType === "virtual"))
        manager.toggleSelection(key);
      else
        manager.replaceSelection(key);
    }
  };
  (0, import_react42.useEffect)(() => {
    let isFocused = key === manager.focusedKey;
    if (isFocused && manager.isFocused && !shouldUseVirtualFocus) {
      if (focus)
        focus();
      else if (document.activeElement !== ref.current)
        (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
    }
  }, [
    ref,
    key,
    manager.focusedKey,
    manager.childFocusStrategy,
    manager.isFocused,
    shouldUseVirtualFocus
  ]);
  isDisabled = isDisabled || manager.isDisabled(key);
  let itemProps = {};
  if (!shouldUseVirtualFocus && !isDisabled)
    itemProps = {
      tabIndex: key === manager.focusedKey ? 0 : -1,
      onFocus(e6) {
        if (e6.target === ref.current)
          manager.setFocusedKey(key);
      }
    };
  else if (isDisabled)
    itemProps.onMouseDown = (e6) => {
      e6.preventDefault();
    };
  let isLinkOverride = manager.isLink(key) && linkBehavior === "override";
  let hasLinkAction = manager.isLink(key) && linkBehavior !== "selection" && linkBehavior !== "none";
  let allowsSelection = !isDisabled && manager.canSelectItem(key) && !isLinkOverride;
  let allowsActions = (onAction || hasLinkAction) && !isDisabled;
  let hasPrimaryAction = allowsActions && (manager.selectionBehavior === "replace" ? !allowsSelection : !allowsSelection || manager.isEmpty);
  let hasSecondaryAction = allowsActions && allowsSelection && manager.selectionBehavior === "replace";
  let hasAction = hasPrimaryAction || hasSecondaryAction;
  let modality = (0, import_react42.useRef)(null);
  let longPressEnabled = hasAction && allowsSelection;
  let longPressEnabledOnPressStart = (0, import_react42.useRef)(false);
  let hadPrimaryActionOnPressStart = (0, import_react42.useRef)(false);
  let performAction = (e6) => {
    if (onAction)
      onAction();
    if (hasLinkAction)
      router.open(ref.current, e6);
  };
  let itemPressProps = {};
  if (shouldSelectOnPressUp) {
    itemPressProps.onPressStart = (e6) => {
      modality.current = e6.pointerType;
      longPressEnabledOnPressStart.current = longPressEnabled;
      if (e6.pointerType === "keyboard" && (!hasAction || $880e95eb8b93ba9a$var$isSelectionKey()))
        onSelect(e6);
    };
    if (!allowsDifferentPressOrigin)
      itemPressProps.onPress = (e6) => {
        if (hasPrimaryAction || hasSecondaryAction && e6.pointerType !== "mouse") {
          if (e6.pointerType === "keyboard" && !$880e95eb8b93ba9a$var$isActionKey())
            return;
          performAction(e6);
        } else if (e6.pointerType !== "keyboard" && allowsSelection)
          onSelect(e6);
      };
    else {
      itemPressProps.onPressUp = hasPrimaryAction ? null : (e6) => {
        if (e6.pointerType !== "keyboard" && allowsSelection)
          onSelect(e6);
      };
      itemPressProps.onPress = hasPrimaryAction ? performAction : null;
    }
  } else {
    itemPressProps.onPressStart = (e6) => {
      modality.current = e6.pointerType;
      longPressEnabledOnPressStart.current = longPressEnabled;
      hadPrimaryActionOnPressStart.current = hasPrimaryAction;
      if (allowsSelection && (e6.pointerType === "mouse" && !hasPrimaryAction || e6.pointerType === "keyboard" && (!allowsActions || $880e95eb8b93ba9a$var$isSelectionKey())))
        onSelect(e6);
    };
    itemPressProps.onPress = (e6) => {
      if (e6.pointerType === "touch" || e6.pointerType === "pen" || e6.pointerType === "virtual" || e6.pointerType === "keyboard" && hasAction && $880e95eb8b93ba9a$var$isActionKey() || e6.pointerType === "mouse" && hadPrimaryActionOnPressStart.current) {
        if (hasAction)
          performAction(e6);
        else if (allowsSelection)
          onSelect(e6);
      }
    };
  }
  itemProps["data-key"] = key;
  itemPressProps.preventFocusOnPress = shouldUseVirtualFocus;
  let { pressProps, isPressed } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)(itemPressProps);
  let onDoubleClick = hasSecondaryAction ? (e6) => {
    if (modality.current === "mouse") {
      e6.stopPropagation();
      e6.preventDefault();
      performAction(e6);
    }
  } : void 0;
  let { longPressProps } = (0, $8a26561d2877236e$export$c24ed0104d07eab9)({
    isDisabled: !longPressEnabled,
    onLongPress(e6) {
      if (e6.pointerType === "touch") {
        onSelect(e6);
        manager.setSelectionBehavior("toggle");
      }
    }
  });
  let onDragStartCapture = (e6) => {
    if (modality.current === "touch" && longPressEnabledOnPressStart.current)
      e6.preventDefault();
  };
  let onClick = manager.isLink(key) ? (e6) => {
    if (!(0, $ea8dcbcb9ea1b556$export$95185d699e05d4d7).isOpening)
      e6.preventDefault();
  } : void 0;
  return {
    itemProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(itemProps, allowsSelection || hasPrimaryAction ? pressProps : {}, longPressEnabled ? longPressProps : {}, {
      onDoubleClick,
      onDragStartCapture,
      onClick
    }),
    isPressed,
    isSelected: manager.isSelected(key),
    isFocused: manager.isFocused && manager.focusedKey === key,
    isDisabled,
    allowsSelection,
    hasAction
  };
}
function $880e95eb8b93ba9a$var$isActionKey() {
  let event = window.event;
  return (event === null || event === void 0 ? void 0 : event.key) === "Enter";
}
function $880e95eb8b93ba9a$var$isSelectionKey() {
  let event = window.event;
  return (event === null || event === void 0 ? void 0 : event.key) === " " || (event === null || event === void 0 ? void 0 : event.code) === "Space";
}
var $2a25aae57d74318e$export$a05409b8bb224a5a = class {
  getNextKey(key) {
    key = this.collection.getKeyAfter(key);
    while (key != null) {
      let item2 = this.collection.getItem(key);
      if (item2.type === "item" && !this.disabledKeys.has(key))
        return key;
      key = this.collection.getKeyAfter(key);
    }
    return null;
  }
  getPreviousKey(key) {
    key = this.collection.getKeyBefore(key);
    while (key != null) {
      let item2 = this.collection.getItem(key);
      if (item2.type === "item" && !this.disabledKeys.has(key))
        return key;
      key = this.collection.getKeyBefore(key);
    }
    return null;
  }
  findKey(key, nextKey, shouldSkip) {
    let item2 = this.getItem(key);
    if (!item2)
      return null;
    let prevRect = item2.getBoundingClientRect();
    do {
      key = nextKey(key);
      item2 = this.getItem(key);
    } while (item2 && shouldSkip(prevRect, item2.getBoundingClientRect()));
    return key;
  }
  isSameRow(prevRect, itemRect) {
    return prevRect.top === itemRect.top || prevRect.left !== itemRect.left;
  }
  isSameColumn(prevRect, itemRect) {
    return prevRect.left === itemRect.left || prevRect.top !== itemRect.top;
  }
  getKeyBelow(key) {
    if (this.layout === "grid" && this.orientation === "vertical")
      return this.findKey(key, (key2) => this.getNextKey(key2), this.isSameRow);
    else
      return this.getNextKey(key);
  }
  getKeyAbove(key) {
    if (this.layout === "grid" && this.orientation === "vertical")
      return this.findKey(key, (key2) => this.getPreviousKey(key2), this.isSameRow);
    else
      return this.getPreviousKey(key);
  }
  getNextColumn(key, right) {
    return right ? this.getPreviousKey(key) : this.getNextKey(key);
  }
  getKeyRightOf(key) {
    if (this.layout === "grid") {
      if (this.orientation === "vertical")
        return this.getNextColumn(key, this.direction === "rtl");
      else
        return this.findKey(key, (key2) => this.getNextColumn(key2, this.direction === "rtl"), this.isSameColumn);
    } else if (this.orientation === "horizontal")
      return this.getNextColumn(key, this.direction === "rtl");
    return null;
  }
  getKeyLeftOf(key) {
    if (this.layout === "grid") {
      if (this.orientation === "vertical")
        return this.getNextColumn(key, this.direction === "ltr");
      else
        return this.findKey(key, (key2) => this.getNextColumn(key2, this.direction === "ltr"), this.isSameColumn);
    } else if (this.orientation === "horizontal")
      return this.getNextColumn(key, this.direction === "ltr");
    return null;
  }
  getFirstKey() {
    let key = this.collection.getFirstKey();
    while (key != null) {
      let item2 = this.collection.getItem(key);
      if ((item2 === null || item2 === void 0 ? void 0 : item2.type) === "item" && !this.disabledKeys.has(key))
        return key;
      key = this.collection.getKeyAfter(key);
    }
    return null;
  }
  getLastKey() {
    let key = this.collection.getLastKey();
    while (key != null) {
      let item2 = this.collection.getItem(key);
      if (item2.type === "item" && !this.disabledKeys.has(key))
        return key;
      key = this.collection.getKeyBefore(key);
    }
    return null;
  }
  getItem(key) {
    return this.ref.current.querySelector(`[data-key="${CSS.escape(key.toString())}"]`);
  }
  getKeyPageAbove(key) {
    let menu = this.ref.current;
    let item2 = this.getItem(key);
    if (!item2)
      return null;
    if (!(0, $62d8ded9296f3872$export$2bb74740c4e19def)(menu))
      return this.getFirstKey();
    let containerRect = menu.getBoundingClientRect();
    let itemRect = item2.getBoundingClientRect();
    if (this.orientation === "horizontal") {
      let containerX = containerRect.x - menu.scrollLeft;
      let pageX = Math.max(0, itemRect.x - containerX + itemRect.width - containerRect.width);
      while (item2 && itemRect.x - containerX > pageX) {
        key = this.getKeyAbove(key);
        item2 = key == null ? null : this.getItem(key);
        itemRect = item2 === null || item2 === void 0 ? void 0 : item2.getBoundingClientRect();
      }
    } else {
      let containerY = containerRect.y - menu.scrollTop;
      let pageY = Math.max(0, itemRect.y - containerY + itemRect.height - containerRect.height);
      while (item2 && itemRect.y - containerY > pageY) {
        key = this.getKeyAbove(key);
        item2 = key == null ? null : this.getItem(key);
        itemRect = item2 === null || item2 === void 0 ? void 0 : item2.getBoundingClientRect();
      }
    }
    return key !== null && key !== void 0 ? key : this.getFirstKey();
  }
  getKeyPageBelow(key) {
    let menu = this.ref.current;
    let item2 = this.getItem(key);
    if (!item2)
      return null;
    if (!(0, $62d8ded9296f3872$export$2bb74740c4e19def)(menu))
      return this.getLastKey();
    let containerRect = menu.getBoundingClientRect();
    let itemRect = item2.getBoundingClientRect();
    if (this.orientation === "horizontal") {
      let containerX = containerRect.x - menu.scrollLeft;
      let pageX = Math.min(menu.scrollWidth, itemRect.x - containerX - itemRect.width + containerRect.width);
      while (item2 && itemRect.x - containerX < pageX) {
        key = this.getKeyBelow(key);
        item2 = key == null ? null : this.getItem(key);
        itemRect = item2 === null || item2 === void 0 ? void 0 : item2.getBoundingClientRect();
      }
    } else {
      let containerY = containerRect.y - menu.scrollTop;
      let pageY = Math.min(menu.scrollHeight, itemRect.y - containerY - itemRect.height + containerRect.height);
      while (item2 && itemRect.y - containerY < pageY) {
        key = this.getKeyBelow(key);
        item2 = key == null ? null : this.getItem(key);
        itemRect = item2 === null || item2 === void 0 ? void 0 : item2.getBoundingClientRect();
      }
    }
    return key !== null && key !== void 0 ? key : this.getLastKey();
  }
  getKeyForSearch(search2, fromKey) {
    if (!this.collator)
      return null;
    let collection2 = this.collection;
    let key = fromKey || this.getFirstKey();
    while (key != null) {
      let item2 = collection2.getItem(key);
      let substring = item2.textValue.slice(0, search2.length);
      if (item2.textValue && this.collator.compare(substring, search2) === 0)
        return key;
      key = this.getKeyBelow(key);
    }
    return null;
  }
  constructor(...args2) {
    if (args2.length === 1) {
      let opts = args2[0];
      this.collection = opts.collection;
      this.ref = opts.ref;
      this.collator = opts.collator;
      this.disabledKeys = opts.disabledKeys || /* @__PURE__ */ new Set();
      this.orientation = opts.orientation;
      this.direction = opts.direction;
      this.layout = opts.layout || "stack";
    } else {
      this.collection = args2[0];
      this.disabledKeys = args2[1];
      this.ref = args2[2];
      this.collator = args2[3];
      this.layout = "stack";
      this.orientation = "vertical";
    }
    if (this.layout === "stack" && this.orientation === "vertical") {
      this.getKeyLeftOf = void 0;
      this.getKeyRightOf = void 0;
    }
  }
};
function $982254629710d113$export$b95089534ab7c1fd(props) {
  let { selectionManager, collection: collection2, disabledKeys, ref, keyboardDelegate } = props;
  let collator = (0, $325a3faab7a68acd$export$a16aca283550c30d)({
    usage: "search",
    sensitivity: "base"
  });
  let disabledBehavior = selectionManager.disabledBehavior;
  let delegate = (0, import_react42.useMemo)(() => keyboardDelegate || new (0, $2a25aae57d74318e$export$a05409b8bb224a5a)(collection2, disabledBehavior === "selection" ? /* @__PURE__ */ new Set() : disabledKeys, ref, collator), [
    keyboardDelegate,
    collection2,
    disabledKeys,
    ref,
    collator,
    disabledBehavior
  ]);
  let { collectionProps } = (0, $ae20dd8cbca75726$export$d6daf82dcd84e87c)({
    ...props,
    ref,
    selectionManager,
    keyboardDelegate: delegate
  });
  return {
    listProps: collectionProps
  };
}

// node_modules/@react-aria/grid/dist/import.mjs
function $parcel$interopDefault3(a3) {
  return a3 && a3.__esModule ? a3.default : a3;
}
var $d1c300d9c497e402$export$de9feff04fda126e = class {
  isCell(node4) {
    return node4.type === "cell";
  }
  isRow(node4) {
    return node4.type === "row" || node4.type === "item";
  }
  findPreviousKey(fromKey, pred) {
    let key = fromKey != null ? this.collection.getKeyBefore(fromKey) : this.collection.getLastKey();
    while (key != null) {
      let item2 = this.collection.getItem(key);
      if (!this.disabledKeys.has(key) && (!pred || pred(item2)))
        return key;
      key = this.collection.getKeyBefore(key);
    }
  }
  findNextKey(fromKey, pred) {
    let key = fromKey != null ? this.collection.getKeyAfter(fromKey) : this.collection.getFirstKey();
    while (key != null) {
      let item2 = this.collection.getItem(key);
      if (!this.disabledKeys.has(key) && (!pred || pred(item2)))
        return key;
      key = this.collection.getKeyAfter(key);
    }
  }
  getKeyBelow(key) {
    let startItem = this.collection.getItem(key);
    if (!startItem)
      return;
    if (this.isCell(startItem))
      key = startItem.parentKey;
    key = this.findNextKey(key);
    if (key != null) {
      if (this.isCell(startItem)) {
        let item2 = this.collection.getItem(key);
        return (0, $c5a24bc478652b5f$export$5f3398f8733f90e2)((0, $c5a24bc478652b5f$export$1005530eda016c13)(item2, this.collection), startItem.index).key;
      }
      if (this.focusMode === "row")
        return key;
    }
  }
  getKeyAbove(key) {
    let startItem = this.collection.getItem(key);
    if (!startItem)
      return;
    if (this.isCell(startItem))
      key = startItem.parentKey;
    key = this.findPreviousKey(key);
    if (key != null) {
      if (this.isCell(startItem)) {
        let item2 = this.collection.getItem(key);
        return (0, $c5a24bc478652b5f$export$5f3398f8733f90e2)((0, $c5a24bc478652b5f$export$1005530eda016c13)(item2, this.collection), startItem.index).key;
      }
      if (this.focusMode === "row")
        return key;
    }
  }
  getKeyRightOf(key) {
    let item2 = this.collection.getItem(key);
    if (!item2)
      return;
    if (this.isRow(item2)) {
      let children = (0, $c5a24bc478652b5f$export$1005530eda016c13)(item2, this.collection);
      return this.direction === "rtl" ? (0, $c5a24bc478652b5f$export$7475b2c64539e4cf)(children).key : (0, $c5a24bc478652b5f$export$fbdeaa6a76694f71)(children).key;
    }
    if (this.isCell(item2)) {
      let parent = this.collection.getItem(item2.parentKey);
      let children = (0, $c5a24bc478652b5f$export$1005530eda016c13)(parent, this.collection);
      let next2 = this.direction === "rtl" ? (0, $c5a24bc478652b5f$export$5f3398f8733f90e2)(children, item2.index - 1) : (0, $c5a24bc478652b5f$export$5f3398f8733f90e2)(children, item2.index + 1);
      if (next2)
        return next2.key;
      if (this.focusMode === "row")
        return item2.parentKey;
      return this.direction === "rtl" ? this.getFirstKey(key) : this.getLastKey(key);
    }
  }
  getKeyLeftOf(key) {
    let item2 = this.collection.getItem(key);
    if (!item2)
      return;
    if (this.isRow(item2)) {
      let children = (0, $c5a24bc478652b5f$export$1005530eda016c13)(item2, this.collection);
      return this.direction === "rtl" ? (0, $c5a24bc478652b5f$export$fbdeaa6a76694f71)(children).key : (0, $c5a24bc478652b5f$export$7475b2c64539e4cf)(children).key;
    }
    if (this.isCell(item2)) {
      let parent = this.collection.getItem(item2.parentKey);
      let children = (0, $c5a24bc478652b5f$export$1005530eda016c13)(parent, this.collection);
      let prev2 = this.direction === "rtl" ? (0, $c5a24bc478652b5f$export$5f3398f8733f90e2)(children, item2.index + 1) : (0, $c5a24bc478652b5f$export$5f3398f8733f90e2)(children, item2.index - 1);
      if (prev2)
        return prev2.key;
      if (this.focusMode === "row")
        return item2.parentKey;
      return this.direction === "rtl" ? this.getLastKey(key) : this.getFirstKey(key);
    }
  }
  getFirstKey(key, global3) {
    let item2;
    if (key != null) {
      item2 = this.collection.getItem(key);
      if (!item2)
        return;
      if (this.isCell(item2) && !global3) {
        let parent = this.collection.getItem(item2.parentKey);
        return (0, $c5a24bc478652b5f$export$fbdeaa6a76694f71)((0, $c5a24bc478652b5f$export$1005530eda016c13)(parent, this.collection)).key;
      }
    }
    key = this.findNextKey();
    if (key != null && item2 && this.isCell(item2) && global3 || this.focusMode === "cell") {
      let item3 = this.collection.getItem(key);
      key = (0, $c5a24bc478652b5f$export$fbdeaa6a76694f71)((0, $c5a24bc478652b5f$export$1005530eda016c13)(item3, this.collection)).key;
    }
    return key;
  }
  getLastKey(key, global3) {
    let item2;
    if (key != null) {
      item2 = this.collection.getItem(key);
      if (!item2)
        return;
      if (this.isCell(item2) && !global3) {
        let parent = this.collection.getItem(item2.parentKey);
        let children = (0, $c5a24bc478652b5f$export$1005530eda016c13)(parent, this.collection);
        return (0, $c5a24bc478652b5f$export$7475b2c64539e4cf)(children).key;
      }
    }
    key = this.findPreviousKey();
    if (key != null && item2 && this.isCell(item2) && global3 || this.focusMode === "cell") {
      let item3 = this.collection.getItem(key);
      let children = (0, $c5a24bc478652b5f$export$1005530eda016c13)(item3, this.collection);
      key = (0, $c5a24bc478652b5f$export$7475b2c64539e4cf)(children).key;
    }
    return key;
  }
  getItem(key) {
    return this.ref.current.querySelector(`[data-key="${CSS.escape(key.toString())}"]`);
  }
  getItemRect(key) {
    var _this_layout_getLayoutInfo;
    if (this.layout)
      return (_this_layout_getLayoutInfo = this.layout.getLayoutInfo(key)) === null || _this_layout_getLayoutInfo === void 0 ? void 0 : _this_layout_getLayoutInfo.rect;
    let item2 = this.getItem(key);
    if (item2)
      return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(item2.offsetLeft, item2.offsetTop, item2.offsetWidth, item2.offsetHeight);
  }
  getPageHeight() {
    var _this_layout_virtualizer, _this_ref_current, _this_ref;
    if (this.layout)
      return (_this_layout_virtualizer = this.layout.virtualizer) === null || _this_layout_virtualizer === void 0 ? void 0 : _this_layout_virtualizer.visibleRect.height;
    return (_this_ref = this.ref) === null || _this_ref === void 0 ? void 0 : (_this_ref_current = _this_ref.current) === null || _this_ref_current === void 0 ? void 0 : _this_ref_current.offsetHeight;
  }
  getContentHeight() {
    var _this_ref_current, _this_ref;
    if (this.layout)
      return this.layout.getContentSize().height;
    return (_this_ref = this.ref) === null || _this_ref === void 0 ? void 0 : (_this_ref_current = _this_ref.current) === null || _this_ref_current === void 0 ? void 0 : _this_ref_current.scrollHeight;
  }
  getKeyPageAbove(key) {
    let itemRect = this.getItemRect(key);
    if (!itemRect)
      return null;
    let pageY = Math.max(0, itemRect.maxY - this.getPageHeight());
    while (itemRect && itemRect.y > pageY) {
      key = this.getKeyAbove(key);
      itemRect = this.getItemRect(key);
    }
    return key;
  }
  getKeyPageBelow(key) {
    let itemRect = this.getItemRect(key);
    if (!itemRect)
      return null;
    let pageHeight = this.getPageHeight();
    let pageY = Math.min(this.getContentHeight(), itemRect.y + pageHeight);
    while (itemRect && itemRect.maxY < pageY) {
      let nextKey = this.getKeyBelow(key);
      itemRect = this.getItemRect(nextKey);
      if (nextKey != null)
        key = nextKey;
    }
    return key;
  }
  getKeyForSearch(search2, fromKey) {
    if (!this.collator)
      return null;
    let collection2 = this.collection;
    let key = fromKey !== null && fromKey !== void 0 ? fromKey : this.getFirstKey();
    let startItem = collection2.getItem(key);
    if (startItem.type === "cell")
      key = startItem.parentKey;
    let hasWrapped = false;
    while (key != null) {
      let item2 = collection2.getItem(key);
      if (item2.textValue) {
        let substring = item2.textValue.slice(0, search2.length);
        if (this.collator.compare(substring, search2) === 0) {
          if (this.isRow(item2) && this.focusMode === "cell")
            return (0, $c5a24bc478652b5f$export$fbdeaa6a76694f71)((0, $c5a24bc478652b5f$export$1005530eda016c13)(item2, this.collection)).key;
          return item2.key;
        }
      }
      key = this.findNextKey(key);
      if (key == null && !hasWrapped) {
        key = this.getFirstKey();
        hasWrapped = true;
      }
    }
    return null;
  }
  constructor(options) {
    this.collection = options.collection;
    this.disabledKeys = options.disabledKeys;
    this.ref = options.ref;
    this.direction = options.direction;
    this.collator = options.collator;
    this.layout = options.layout;
    this.focusMode = options.focusMode || "row";
  }
};
var $1af922eb41e03c8f$export$e6235c0d09b995d0 = /* @__PURE__ */ new WeakMap();
var $835c96616a7cb4f9$exports = {};
$835c96616a7cb4f9$exports = {
  "ar-AE": $682989befd4f478d$exports,
  "bg-BG": $f7fca02019afd941$exports,
  "cs-CZ": $8f86f40be75387f1$exports,
  "da-DK": $db24ba43c8d652ee$exports,
  "de-DE": $f8f1e72c8b5447d6$exports,
  "el-GR": $9a73ed2983c3ab0b$exports,
  "en-US": $583de0b3587601b9$exports,
  "es-ES": $147159c978043442$exports,
  "et-EE": $5cbb62c8a19173ac$exports,
  "fi-FI": $a33d71dc804cc59e$exports,
  "fr-FR": $92d800447793d084$exports,
  "he-IL": $fe732cdb32124ea8$exports,
  "hr-HR": $e41234e934efb4f5$exports,
  "hu-HU": $1b0393182473bf9e$exports,
  "it-IT": $2eed782c1c110ce7$exports,
  "ja-JP": $8b5d459f86e9b23c$exports,
  "ko-KR": $1949c3ad17295fd4$exports,
  "lt-LT": $f5e3df4dc8aa7b54$exports,
  "lv-LV": $9dd86690a5c2b2c5$exports,
  "nb-NO": $843964c3bf9a7d24$exports,
  "nl-NL": $73f50e845f9ef3b4$exports,
  "pl-PL": $87f92a7e077514b2$exports,
  "pt-BR": $c28c98d58ee9ff6f$exports,
  "pt-PT": $b6b1503b17b2254d$exports,
  "ro-RO": $8bdaeb71e50c3e1a$exports,
  "ru-RU": $ec2b852dd7c3d1f2$exports,
  "sk-SK": $79e6d900d6a4f82d$exports,
  "sl-SI": $f4c1f0d5d4d03d80$exports,
  "sr-SP": $46252cd87269b10b$exports,
  "sv-SE": $d4d5d8dab362555c$exports,
  "tr-TR": $3d55d1f97c377e83$exports,
  "uk-UA": $5368512f1c703a3f$exports,
  "zh-CN": $f1316b1074463583$exports,
  "zh-TW": $7e60654723031b6f$exports
};
function $92599c3fd427b763$export$137e594ef3218a10(props, state) {
  let { getRowText = (key) => {
    var _state_collection_getTextValue, _state_collection, _state_collection_getItem;
    var _state_collection_getTextValue1;
    return (_state_collection_getTextValue1 = (_state_collection_getTextValue = (_state_collection = state.collection).getTextValue) === null || _state_collection_getTextValue === void 0 ? void 0 : _state_collection_getTextValue.call(_state_collection, key)) !== null && _state_collection_getTextValue1 !== void 0 ? _state_collection_getTextValue1 : (_state_collection_getItem = state.collection.getItem(key)) === null || _state_collection_getItem === void 0 ? void 0 : _state_collection_getItem.textValue;
  } } = props;
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault3($835c96616a7cb4f9$exports)), "@react-aria/grid");
  let selection = state.selectionManager.rawSelection;
  let lastSelection = (0, import_react43.useRef)(selection);
  (0, $4f58c5f72bcf79f7$export$496315a1608d9602)(() => {
    var _lastSelection_current;
    if (!state.selectionManager.isFocused) {
      lastSelection.current = selection;
      return;
    }
    let addedKeys = $92599c3fd427b763$var$diffSelection(selection, lastSelection.current);
    let removedKeys = $92599c3fd427b763$var$diffSelection(lastSelection.current, selection);
    let isReplace = state.selectionManager.selectionBehavior === "replace";
    let messages = [];
    if (state.selectionManager.selectedKeys.size === 1 && isReplace) {
      if (state.collection.getItem(state.selectionManager.selectedKeys.keys().next().value)) {
        let currentSelectionText = getRowText(state.selectionManager.selectedKeys.keys().next().value);
        if (currentSelectionText)
          messages.push(stringFormatter.format("selectedItem", {
            item: currentSelectionText
          }));
      }
    } else if (addedKeys.size === 1 && removedKeys.size === 0) {
      let addedText = getRowText(addedKeys.keys().next().value);
      if (addedText)
        messages.push(stringFormatter.format("selectedItem", {
          item: addedText
        }));
    } else if (removedKeys.size === 1 && addedKeys.size === 0) {
      if (state.collection.getItem(removedKeys.keys().next().value)) {
        let removedText = getRowText(removedKeys.keys().next().value);
        if (removedText)
          messages.push(stringFormatter.format("deselectedItem", {
            item: removedText
          }));
      }
    }
    if (state.selectionManager.selectionMode === "multiple") {
      if (messages.length === 0 || selection === "all" || selection.size > 1 || lastSelection.current === "all" || ((_lastSelection_current = lastSelection.current) === null || _lastSelection_current === void 0 ? void 0 : _lastSelection_current.size) > 1)
        messages.push(selection === "all" ? stringFormatter.format("selectedAll") : stringFormatter.format("selectedCount", {
          count: selection.size
        }));
    }
    if (messages.length > 0)
      (0, $319e236875307eab$export$a9b970dcc4ae71a9)(messages.join(" "));
    lastSelection.current = selection;
  }, [
    selection
  ]);
}
function $92599c3fd427b763$var$diffSelection(a3, b2) {
  let res = /* @__PURE__ */ new Set();
  if (a3 === "all" || b2 === "all")
    return res;
  for (let key of a3.keys())
    if (!b2.has(key))
      res.add(key);
  return res;
}
function $5b9b5b5723db6ae1$export$be42ebdab07ae4c2(props) {
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault3($835c96616a7cb4f9$exports)), "@react-aria/grid");
  let modality = (0, $507fabe10e71c6fb$export$98e20ec92f614cfe)();
  let shouldLongPress = (modality === "pointer" || modality === "virtual" || modality == null) && typeof window !== "undefined" && "ontouchstart" in window;
  let interactionDescription = (0, import_react43.useMemo)(() => {
    let selectionMode = props.selectionManager.selectionMode;
    let selectionBehavior = props.selectionManager.selectionBehavior;
    let message = void 0;
    if (shouldLongPress)
      message = stringFormatter.format("longPressToSelect");
    return selectionBehavior === "replace" && selectionMode !== "none" && props.hasItemActions ? message : void 0;
  }, [
    props.selectionManager.selectionMode,
    props.selectionManager.selectionBehavior,
    props.hasItemActions,
    stringFormatter,
    shouldLongPress
  ]);
  let descriptionProps = (0, $ef06256079686ba0$export$f8aeda7b10753fa1)(interactionDescription);
  return descriptionProps;
}
function $83c6e2eafa584c67$export$f6b86a04e5d66d90(props, state, ref) {
  let { isVirtualized, keyboardDelegate, focusMode, scrollRef, getRowText, onRowAction, onCellAction } = props;
  let { selectionManager: manager } = state;
  if (!props["aria-label"] && !props["aria-labelledby"])
    console.warn("An aria-label or aria-labelledby prop is required for accessibility.");
  let collator = (0, $325a3faab7a68acd$export$a16aca283550c30d)({
    usage: "search",
    sensitivity: "base"
  });
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let disabledBehavior = state.selectionManager.disabledBehavior;
  let delegate = (0, import_react43.useMemo)(() => keyboardDelegate || new (0, $d1c300d9c497e402$export$de9feff04fda126e)({
    collection: state.collection,
    disabledKeys: disabledBehavior === "selection" ? /* @__PURE__ */ new Set() : state.disabledKeys,
    ref,
    direction,
    collator,
    focusMode
  }), [
    keyboardDelegate,
    state.collection,
    state.disabledKeys,
    disabledBehavior,
    ref,
    direction,
    collator,
    focusMode
  ]);
  let { collectionProps } = (0, $ae20dd8cbca75726$export$d6daf82dcd84e87c)({
    ref,
    selectionManager: manager,
    keyboardDelegate: delegate,
    isVirtualized,
    scrollRef
  });
  let id2 = (0, $bdb11010cef70236$export$f680877a34711e37)(props.id);
  (0, $1af922eb41e03c8f$export$e6235c0d09b995d0).set(state, {
    keyboardDelegate: delegate,
    actions: {
      onRowAction,
      onCellAction
    }
  });
  let descriptionProps = (0, $5b9b5b5723db6ae1$export$be42ebdab07ae4c2)({
    selectionManager: manager,
    hasItemActions: !!(onRowAction || onCellAction)
  });
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let onFocus = (0, import_react43.useCallback)((e6) => {
    if (manager.isFocused) {
      if (!e6.currentTarget.contains(e6.target))
        manager.setFocused(false);
      return;
    }
    if (!e6.currentTarget.contains(e6.target))
      return;
    manager.setFocused(true);
  }, [
    manager
  ]);
  let navDisabledHandlers = (0, import_react43.useMemo)(() => ({
    onBlur: collectionProps.onBlur,
    onFocus
  }), [
    onFocus,
    collectionProps.onBlur
  ]);
  let hasTabbableChild = (0, $83013635b024ae3d$export$eac1895992b9f3d6)(ref, {
    isDisabled: state.collection.size !== 0
  });
  let gridProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(
    domProps,
    {
      role: "grid",
      id: id2,
      "aria-multiselectable": manager.selectionMode === "multiple" ? "true" : void 0
    },
    state.isKeyboardNavigationDisabled ? navDisabledHandlers : collectionProps,
    // If collection is empty, make sure the grid is tabbable unless there is a child tabbable element.
    state.collection.size === 0 && {
      tabIndex: hasTabbableChild ? -1 : 0
    },
    descriptionProps
  );
  if (isVirtualized) {
    gridProps["aria-rowcount"] = state.collection.size;
    gridProps["aria-colcount"] = state.collection.columnCount;
  }
  (0, $92599c3fd427b763$export$137e594ef3218a10)({
    getRowText
  }, state);
  return {
    gridProps
  };
}
function $e45487f8ba1cbdbf$export$d3037f5d3f3e51bf() {
  return {
    rowGroupProps: {
      role: "rowgroup"
    }
  };
}
function $4159a7a9cbb0cc18$export$96357d5a73f686fa(props, state, ref) {
  let { node: node4, isVirtualized, shouldSelectOnPressUp, onAction } = props;
  let { actions: { onRowAction } } = (0, $1af922eb41e03c8f$export$e6235c0d09b995d0).get(state);
  let { itemProps, ...states } = (0, $880e95eb8b93ba9a$export$ecf600387e221c37)({
    selectionManager: state.selectionManager,
    key: node4.key,
    ref,
    isVirtualized,
    shouldSelectOnPressUp,
    onAction: onRowAction ? () => onRowAction(node4.key) : onAction,
    isDisabled: state.collection.size === 0
  });
  let isSelected = state.selectionManager.isSelected(node4.key);
  let rowProps = {
    role: "row",
    "aria-selected": state.selectionManager.selectionMode !== "none" ? isSelected : void 0,
    "aria-disabled": states.isDisabled || void 0,
    ...itemProps
  };
  if (isVirtualized)
    rowProps["aria-rowindex"] = node4.index + 1;
  return {
    rowProps,
    ...states
  };
}
function $ab90dcbc1b5466d0$export$c7e10bfc0c59f67c(props, state, ref) {
  let { node: node4, isVirtualized, focusMode = "child", shouldSelectOnPressUp, onAction } = props;
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let { keyboardDelegate, actions: { onCellAction } } = (0, $1af922eb41e03c8f$export$e6235c0d09b995d0).get(state);
  let keyWhenFocused = (0, import_react43.useRef)(null);
  let focus = () => {
    let treeWalker = (0, $9bf71ea28793e738$export$2d6ec8fc375ceafa)(ref.current);
    if (focusMode === "child") {
      if (ref.current.contains(document.activeElement) && ref.current !== document.activeElement)
        return;
      let focusable = state.selectionManager.childFocusStrategy === "last" ? $ab90dcbc1b5466d0$var$last(treeWalker) : treeWalker.firstChild();
      if (focusable) {
        (0, $6a99195332edec8b$export$80f3e147d781571c)(focusable);
        return;
      }
    }
    if (keyWhenFocused.current != null && node4.key !== keyWhenFocused.current || !ref.current.contains(document.activeElement))
      (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
  };
  let { itemProps, isPressed } = (0, $880e95eb8b93ba9a$export$ecf600387e221c37)({
    selectionManager: state.selectionManager,
    key: node4.key,
    ref,
    isVirtualized,
    focus,
    shouldSelectOnPressUp,
    onAction: onCellAction ? () => onCellAction(node4.key) : onAction,
    isDisabled: state.collection.size === 0
  });
  let onKeyDownCapture = (e6) => {
    if (!e6.currentTarget.contains(e6.target) || state.isKeyboardNavigationDisabled)
      return;
    let walker = (0, $9bf71ea28793e738$export$2d6ec8fc375ceafa)(ref.current);
    walker.currentNode = document.activeElement;
    switch (e6.key) {
      case "ArrowLeft": {
        let focusable = direction === "rtl" ? walker.nextNode() : walker.previousNode();
        if (focusMode === "child" && focusable === ref.current)
          focusable = null;
        if (focusable) {
          e6.preventDefault();
          e6.stopPropagation();
          (0, $6a99195332edec8b$export$80f3e147d781571c)(focusable);
          (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(focusable, {
            containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref.current)
          });
        } else {
          let prev2 = keyboardDelegate.getKeyLeftOf(node4.key);
          if (prev2 !== node4.key)
            break;
          e6.preventDefault();
          e6.stopPropagation();
          if (focusMode === "cell" && direction === "rtl") {
            (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
            (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(ref.current, {
              containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref.current)
            });
          } else {
            walker.currentNode = ref.current;
            focusable = direction === "rtl" ? walker.firstChild() : $ab90dcbc1b5466d0$var$last(walker);
            if (focusable) {
              (0, $6a99195332edec8b$export$80f3e147d781571c)(focusable);
              (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(focusable, {
                containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref.current)
              });
            }
          }
        }
        break;
      }
      case "ArrowRight": {
        let focusable = direction === "rtl" ? walker.previousNode() : walker.nextNode();
        if (focusMode === "child" && focusable === ref.current)
          focusable = null;
        if (focusable) {
          e6.preventDefault();
          e6.stopPropagation();
          (0, $6a99195332edec8b$export$80f3e147d781571c)(focusable);
          (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(focusable, {
            containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref.current)
          });
        } else {
          let next2 = keyboardDelegate.getKeyRightOf(node4.key);
          if (next2 !== node4.key)
            break;
          e6.preventDefault();
          e6.stopPropagation();
          if (focusMode === "cell" && direction === "ltr") {
            (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
            (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(ref.current, {
              containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref.current)
            });
          } else {
            walker.currentNode = ref.current;
            focusable = direction === "rtl" ? $ab90dcbc1b5466d0$var$last(walker) : walker.firstChild();
            if (focusable) {
              (0, $6a99195332edec8b$export$80f3e147d781571c)(focusable);
              (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(focusable, {
                containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref.current)
              });
            }
          }
        }
        break;
      }
      case "ArrowUp":
      case "ArrowDown":
        if (!e6.altKey && ref.current.contains(e6.target)) {
          e6.stopPropagation();
          e6.preventDefault();
          ref.current.parentElement.dispatchEvent(new KeyboardEvent(e6.nativeEvent.type, e6.nativeEvent));
        }
        break;
    }
  };
  let onFocus = (e6) => {
    keyWhenFocused.current = node4.key;
    if (e6.target !== ref.current) {
      if (!(0, $507fabe10e71c6fb$export$b9b3dfddab17db27)())
        state.selectionManager.setFocusedKey(node4.key);
      return;
    }
    requestAnimationFrame(() => {
      if (focusMode === "child" && document.activeElement === ref.current)
        focus();
    });
  };
  let gridCellProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(itemProps, {
    role: "gridcell",
    onKeyDownCapture,
    onFocus
  });
  var _node_colIndex;
  if (isVirtualized)
    gridCellProps["aria-colindex"] = ((_node_colIndex = node4.colIndex) !== null && _node_colIndex !== void 0 ? _node_colIndex : node4.index) + 1;
  if (shouldSelectOnPressUp && gridCellProps.tabIndex != null && gridCellProps.onPointerDown == null)
    gridCellProps.onPointerDown = (e6) => {
      let el = e6.currentTarget;
      let tabindex = el.getAttribute("tabindex");
      el.removeAttribute("tabindex");
      requestAnimationFrame(() => {
        el.setAttribute("tabindex", tabindex);
      });
    };
  return {
    gridCellProps,
    isPressed
  };
}
function $ab90dcbc1b5466d0$var$last(walker) {
  let next2;
  let last2;
  do {
    last2 = walker.lastChild();
    if (last2)
      next2 = last2;
  } while (last2);
  return next2;
}
function $7cb39d07f245a780$export$70e2eed1a92976ad(props, state) {
  let { key } = props;
  let manager = state.selectionManager;
  let checkboxId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  let isDisabled = !state.selectionManager.canSelectItem(key);
  let isSelected = state.selectionManager.isSelected(key);
  let onChange2 = () => manager.select(key);
  const stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault3($835c96616a7cb4f9$exports)), "@react-aria/grid");
  return {
    checkboxProps: {
      id: checkboxId,
      "aria-label": stringFormatter.format("select"),
      isSelected,
      isDisabled,
      onChange: onChange2
    }
  };
}

// node_modules/@react-aria/gridlist/dist/import.mjs
var import_react44 = __toESM(require_react(), 1);
var $ce9b18daab526bbd$export$5b9bb410392e3991 = /* @__PURE__ */ new WeakMap();
function $ce9b18daab526bbd$export$f45c25170b9a99c2(state, key) {
  let { id: id2 } = $ce9b18daab526bbd$export$5b9bb410392e3991.get(state);
  if (!id2)
    throw new Error("Unknown list");
  return `${id2}-${$ce9b18daab526bbd$export$e0c709538cb8ae18(key)}`;
}
function $ce9b18daab526bbd$export$e0c709538cb8ae18(key) {
  if (typeof key === "string")
    return key.replace(/\s*/g, "");
  return "" + key;
}
function $f47efb0c3a859cf2$export$664f9155035607eb(props, state, ref) {
  let { isVirtualized, keyboardDelegate, onAction, linkBehavior = "action" } = props;
  if (!props["aria-label"] && !props["aria-labelledby"])
    console.warn("An aria-label or aria-labelledby prop is required for accessibility.");
  let { listProps } = (0, $982254629710d113$export$b95089534ab7c1fd)({
    selectionManager: state.selectionManager,
    collection: state.collection,
    disabledKeys: state.disabledKeys,
    ref,
    keyboardDelegate,
    isVirtualized,
    selectOnFocus: state.selectionManager.selectionBehavior === "replace",
    shouldFocusWrap: props.shouldFocusWrap,
    linkBehavior
  });
  let id2 = (0, $bdb11010cef70236$export$f680877a34711e37)(props.id);
  (0, $ce9b18daab526bbd$export$5b9bb410392e3991).set(state, {
    id: id2,
    onAction,
    linkBehavior
  });
  let descriptionProps = (0, $5b9b5b5723db6ae1$export$be42ebdab07ae4c2)({
    selectionManager: state.selectionManager,
    hasItemActions: !!onAction
  });
  let hasTabbableChild = (0, $83013635b024ae3d$export$eac1895992b9f3d6)(ref, {
    isDisabled: state.collection.size !== 0
  });
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let gridProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(
    domProps,
    {
      role: "grid",
      id: id2,
      "aria-multiselectable": state.selectionManager.selectionMode === "multiple" ? "true" : void 0
    },
    // If collection is empty, make sure the grid is tabbable unless there is a child tabbable element.
    state.collection.size === 0 ? {
      tabIndex: hasTabbableChild ? -1 : 0
    } : listProps,
    descriptionProps
  );
  if (isVirtualized) {
    gridProps["aria-rowcount"] = state.collection.size;
    gridProps["aria-colcount"] = 1;
  }
  (0, $92599c3fd427b763$export$137e594ef3218a10)({}, state);
  return {
    gridProps
  };
}
function $4e8b0456ef72939f$export$9610e69494fadfd2(props, state, ref) {
  let { node: node4, isVirtualized, shouldSelectOnPressUp } = props;
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let { onAction, linkBehavior } = (0, $ce9b18daab526bbd$export$5b9bb410392e3991).get(state);
  let descriptionId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)();
  let keyWhenFocused = (0, import_react44.useRef)(null);
  let focus = () => {
    if (keyWhenFocused.current != null && node4.key !== keyWhenFocused.current || !ref.current.contains(document.activeElement))
      (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
  };
  let { itemProps, ...itemStates } = (0, $880e95eb8b93ba9a$export$ecf600387e221c37)({
    selectionManager: state.selectionManager,
    key: node4.key,
    ref,
    isVirtualized,
    shouldSelectOnPressUp,
    onAction: onAction ? () => onAction(node4.key) : void 0,
    focus,
    linkBehavior
  });
  let onKeyDown = (e6) => {
    if (!e6.currentTarget.contains(e6.target))
      return;
    let walker = (0, $9bf71ea28793e738$export$2d6ec8fc375ceafa)(ref.current);
    walker.currentNode = document.activeElement;
    switch (e6.key) {
      case "ArrowLeft": {
        let focusable = direction === "rtl" ? walker.nextNode() : walker.previousNode();
        if (focusable) {
          e6.preventDefault();
          e6.stopPropagation();
          (0, $6a99195332edec8b$export$80f3e147d781571c)(focusable);
          (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(focusable, {
            containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref.current)
          });
        } else {
          e6.preventDefault();
          e6.stopPropagation();
          if (direction === "rtl") {
            (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
            (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(ref.current, {
              containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref.current)
            });
          } else {
            walker.currentNode = ref.current;
            let lastElement = $4e8b0456ef72939f$var$last(walker);
            if (lastElement) {
              (0, $6a99195332edec8b$export$80f3e147d781571c)(lastElement);
              (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(lastElement, {
                containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref.current)
              });
            }
          }
        }
        break;
      }
      case "ArrowRight": {
        let focusable = direction === "rtl" ? walker.previousNode() : walker.nextNode();
        if (focusable) {
          e6.preventDefault();
          e6.stopPropagation();
          (0, $6a99195332edec8b$export$80f3e147d781571c)(focusable);
          (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(focusable, {
            containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref.current)
          });
        } else {
          e6.preventDefault();
          e6.stopPropagation();
          if (direction === "ltr") {
            (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
            (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(ref.current, {
              containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref.current)
            });
          } else {
            walker.currentNode = ref.current;
            let lastElement = $4e8b0456ef72939f$var$last(walker);
            if (lastElement) {
              (0, $6a99195332edec8b$export$80f3e147d781571c)(lastElement);
              (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(lastElement, {
                containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref.current)
              });
            }
          }
        }
        break;
      }
      case "ArrowUp":
      case "ArrowDown":
        if (!e6.altKey && ref.current.contains(e6.target)) {
          e6.stopPropagation();
          e6.preventDefault();
          ref.current.parentElement.dispatchEvent(new KeyboardEvent(e6.nativeEvent.type, e6.nativeEvent));
        }
        break;
    }
  };
  let onFocus = (e6) => {
    keyWhenFocused.current = node4.key;
    if (e6.target !== ref.current) {
      if (!(0, $507fabe10e71c6fb$export$b9b3dfddab17db27)())
        state.selectionManager.setFocusedKey(node4.key);
      return;
    }
  };
  let linkProps = itemStates.hasAction ? (0, $ea8dcbcb9ea1b556$export$51437d503373d223)(node4.props) : {};
  let rowProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(itemProps, linkProps, {
    role: "row",
    onKeyDownCapture: onKeyDown,
    onFocus,
    "aria-label": node4.textValue || void 0,
    "aria-selected": state.selectionManager.canSelectItem(node4.key) ? state.selectionManager.isSelected(node4.key) : void 0,
    "aria-disabled": state.selectionManager.isDisabled(node4.key) || void 0,
    "aria-labelledby": descriptionId && node4.textValue ? `${(0, $ce9b18daab526bbd$export$f45c25170b9a99c2)(state, node4.key)} ${descriptionId}` : void 0,
    id: (0, $ce9b18daab526bbd$export$f45c25170b9a99c2)(state, node4.key)
  });
  if (isVirtualized)
    rowProps["aria-rowindex"] = node4.index + 1;
  let gridCellProps = {
    role: "gridcell",
    "aria-colindex": 1
  };
  return {
    rowProps,
    gridCellProps,
    descriptionProps: {
      id: descriptionId
    },
    ...itemStates
  };
}
function $4e8b0456ef72939f$var$last(walker) {
  let next2;
  let last2;
  do {
    last2 = walker.lastChild();
    if (last2)
      next2 = last2;
  } while (last2);
  return next2;
}
function $e52ffc04a4adbd52$export$e29f2573fabbf7b9(props, state) {
  let { key } = props;
  const { checkboxProps } = (0, $7cb39d07f245a780$export$70e2eed1a92976ad)(props, state);
  return {
    checkboxProps: {
      ...checkboxProps,
      "aria-labelledby": `${checkboxProps.id} ${(0, $ce9b18daab526bbd$export$f45c25170b9a99c2)(state, key)}`
    }
  };
}

// node_modules/@react-aria/virtualizer/dist/import.mjs
var import_react45 = __toESM(require_react(), 1);
var import_react_dom4 = __toESM(require_react_dom(), 1);
var $ce415dc67314b753$var$cachedRTLResult = null;
function $ce415dc67314b753$export$faf7630257ad4304(recalculate = false) {
  if ($ce415dc67314b753$var$cachedRTLResult === null || recalculate) {
    const outerDiv = document.createElement("div");
    const outerStyle = outerDiv.style;
    outerStyle.width = "50px";
    outerStyle.height = "50px";
    outerStyle.overflow = "scroll";
    outerStyle.direction = "rtl";
    const innerDiv = document.createElement("div");
    const innerStyle = innerDiv.style;
    innerStyle.width = "100px";
    innerStyle.height = "100px";
    outerDiv.appendChild(innerDiv);
    document.body.appendChild(outerDiv);
    if (outerDiv.scrollLeft > 0)
      $ce415dc67314b753$var$cachedRTLResult = "positive-descending";
    else {
      outerDiv.scrollLeft = 1;
      if (outerDiv.scrollLeft === 0)
        $ce415dc67314b753$var$cachedRTLResult = "negative";
      else
        $ce415dc67314b753$var$cachedRTLResult = "positive-ascending";
    }
    document.body.removeChild(outerDiv);
    return $ce415dc67314b753$var$cachedRTLResult;
  }
  return $ce415dc67314b753$var$cachedRTLResult;
}
function $ce415dc67314b753$export$1389d168952b34b5(node4, direction) {
  let { scrollLeft } = node4;
  if (direction === "rtl") {
    let { scrollWidth, clientWidth } = node4;
    switch ($ce415dc67314b753$export$faf7630257ad4304()) {
      case "negative":
        scrollLeft = -scrollLeft;
        break;
      case "positive-descending":
        scrollLeft = scrollWidth - clientWidth - scrollLeft;
        break;
    }
  }
  return scrollLeft;
}
function $ce415dc67314b753$export$ed5fd5ffe5ab0ac(node4, direction, scrollLeft) {
  if (direction === "rtl")
    switch ($ce415dc67314b753$export$faf7630257ad4304()) {
      case "negative":
        scrollLeft = -scrollLeft;
        break;
      case "positive-ascending":
        break;
      default: {
        const { clientWidth, scrollWidth } = node4;
        scrollLeft = scrollWidth - clientWidth - scrollLeft;
        break;
      }
    }
  node4.scrollLeft = scrollLeft;
}
var $44a6ee657928b002$var$isOldReact = (0, import_react45.default).version.startsWith("16.") || (0, import_react45.default).version.startsWith("17.");
function $44a6ee657928b002$var$ScrollView(props, ref) {
  let { contentSize, onVisibleRectChange, children, innerStyle, sizeToFit, onScrollStart, onScrollEnd, scrollDirection = "both", ...otherProps } = props;
  let defaultRef = (0, import_react45.useRef)();
  ref = ref || defaultRef;
  let state = (0, import_react45.useRef)({
    scrollTop: 0,
    scrollLeft: 0,
    scrollEndTime: 0,
    scrollTimeout: null,
    width: 0,
    height: 0,
    isScrolling: false
  }).current;
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let [isScrolling, setScrolling] = (0, import_react45.useState)(false);
  let onScroll = (0, import_react45.useCallback)((e6) => {
    if (e6.target !== e6.currentTarget)
      return;
    if (props.onScroll)
      props.onScroll(e6);
    (0, import_react_dom4.flushSync)(() => {
      let scrollTop = e6.currentTarget.scrollTop;
      let scrollLeft = (0, $ce415dc67314b753$export$1389d168952b34b5)(e6.currentTarget, direction);
      state.scrollTop = Math.max(0, Math.min(scrollTop, contentSize.height - state.height));
      state.scrollLeft = Math.max(0, Math.min(scrollLeft, contentSize.width - state.width));
      onVisibleRectChange(new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(state.scrollLeft, state.scrollTop, state.width, state.height));
      if (!state.isScrolling) {
        state.isScrolling = true;
        setScrolling(true);
        if (onScrollStart)
          onScrollStart();
      }
      let now = Date.now();
      if (state.scrollEndTime <= now + 50) {
        state.scrollEndTime = now + 300;
        clearTimeout(state.scrollTimeout);
        state.scrollTimeout = setTimeout(() => {
          state.isScrolling = false;
          setScrolling(false);
          state.scrollTimeout = null;
          if (onScrollEnd)
            onScrollEnd();
        }, 300);
      }
    });
  }, [
    props,
    direction,
    state,
    contentSize,
    onVisibleRectChange,
    onScrollStart,
    onScrollEnd
  ]);
  (0, import_react45.useEffect)(() => {
    return () => {
      clearTimeout(state.scrollTimeout);
    };
  }, []);
  let updateSize = (0, import_react45.useCallback)(() => {
    let dom = ref.current;
    if (!dom)
      return;
    let w2 = dom.clientWidth;
    let h3 = dom.clientHeight;
    if (sizeToFit && contentSize.width > 0 && contentSize.height > 0) {
      if (sizeToFit === "width")
        w2 = Math.min(w2, contentSize.width);
      else if (sizeToFit === "height")
        h3 = Math.min(h3, contentSize.height);
    }
    if (state.width !== w2 || state.height !== h3) {
      state.width = w2;
      state.height = h3;
      onVisibleRectChange(new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(state.scrollLeft, state.scrollTop, w2, h3));
    }
  }, [
    onVisibleRectChange,
    ref,
    state,
    sizeToFit,
    contentSize
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    updateSize();
  }, [
    updateSize
  ]);
  let raf = (0, import_react45.useRef)();
  let onResize = () => {
    var _raf;
    var _current;
    if ($44a6ee657928b002$var$isOldReact)
      (_current = (_raf = raf).current) !== null && _current !== void 0 ? _current : _raf.current = requestAnimationFrame(() => {
        updateSize();
        raf.current = null;
      });
    else
      updateSize();
  };
  (0, $9daab02d461809db$export$683480f191c0e3ea)({
    ref,
    onResize
  });
  (0, import_react45.useEffect)(() => {
    return () => {
      if (raf.current)
        cancelAnimationFrame(raf.current);
    };
  }, []);
  let style = {
    // Reset padding so that relative positioning works correctly. Padding will be done in JS layout.
    padding: 0,
    ...otherProps.style
  };
  if (scrollDirection === "horizontal") {
    style.overflowX = "auto";
    style.overflowY = "hidden";
  } else if (scrollDirection === "vertical" || contentSize.width === state.width) {
    style.overflowY = "auto";
    style.overflowX = "hidden";
  } else
    style.overflow = "auto";
  innerStyle = {
    width: contentSize.width,
    height: contentSize.height,
    pointerEvents: isScrolling ? "none" : "auto",
    position: "relative",
    ...innerStyle
  };
  return (0, import_react45.default).createElement("div", {
    ...otherProps,
    style,
    ref,
    onScroll
  }, (0, import_react45.default).createElement("div", {
    role: "presentation",
    style: innerStyle
  }, children));
}
var $44a6ee657928b002$export$5665e3d6be6adea = (0, import_react45.default).forwardRef($44a6ee657928b002$var$ScrollView);
function $47736c1e63ba1c6d$export$1da781778207e0a2(options) {
  let { layoutInfo, virtualizer, ref } = options;
  let updateSize = (0, import_react45.useCallback)(() => {
    let size3 = $47736c1e63ba1c6d$var$getSize(ref.current);
    virtualizer.updateItemSize(layoutInfo.key, size3);
  }, [
    virtualizer,
    layoutInfo.key,
    ref
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (layoutInfo.estimatedSize)
      updateSize();
  });
  return {
    updateSize
  };
}
function $47736c1e63ba1c6d$var$getSize(node4) {
  let height = node4.style.height;
  node4.style.height = "";
  let size3 = new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)(node4.scrollWidth, node4.scrollHeight);
  node4.style.height = height;
  return size3;
}
function $ccf8a0a04e4175ae$export$6796df8ba7398521(props) {
  let { className, layoutInfo, virtualizer, parent, children } = props;
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let ref = (0, import_react45.useRef)();
  (0, $47736c1e63ba1c6d$export$1da781778207e0a2)({
    layoutInfo,
    virtualizer,
    ref
  });
  return (0, import_react45.default).createElement("div", {
    role: "presentation",
    ref,
    className,
    style: $ccf8a0a04e4175ae$export$1481e64fbe01b8b3(layoutInfo, direction, parent)
  }, children);
}
var $ccf8a0a04e4175ae$var$cache = /* @__PURE__ */ new WeakMap();
function $ccf8a0a04e4175ae$export$1481e64fbe01b8b3(layoutInfo, dir, parent) {
  let xProperty = dir === "rtl" ? "right" : "left";
  let cached = $ccf8a0a04e4175ae$var$cache.get(layoutInfo);
  if (cached && cached[xProperty] != null) {
    if (!parent)
      return cached;
    let top = layoutInfo.rect.y - parent.rect.y;
    let x4 = layoutInfo.rect.x - parent.rect.x;
    if (cached.top === top && cached[xProperty] === x4)
      return cached;
  }
  let style = {
    position: layoutInfo.isSticky ? "sticky" : "absolute",
    // Sticky elements are positioned in normal document flow. Display inline-block so that they don't push other sticky columns onto the following rows.
    display: layoutInfo.isSticky ? "inline-block" : void 0,
    overflow: layoutInfo.allowOverflow ? "visible" : "hidden",
    top: layoutInfo.rect.y - (parent ? parent.rect.y : 0),
    [xProperty]: layoutInfo.rect.x - (parent ? parent.rect.x : 0),
    transition: "all",
    WebkitTransition: "all",
    WebkitTransitionDuration: "inherit",
    transitionDuration: "inherit",
    width: layoutInfo.rect.width,
    height: layoutInfo.rect.height,
    opacity: layoutInfo.opacity,
    zIndex: layoutInfo.zIndex,
    transform: layoutInfo.transform,
    contain: "size layout style"
  };
  $ccf8a0a04e4175ae$var$cache.set(layoutInfo, style);
  return style;
}
function $6d0a5c394373ae64$var$Virtualizer(props, ref) {
  let { children: renderView, renderWrapper, layout, collection: collection2, sizeToFit, scrollDirection, transitionDuration, isLoading, onLoadMore, focusedKey, shouldUseVirtualFocus, scrollToItem, autoFocus, ...otherProps } = props;
  let fallbackRef = (0, import_react45.useRef)();
  ref = ref || fallbackRef;
  let state = (0, $fc0b13b484ac1194$export$1505db82fe357e65)({
    transitionDuration,
    layout,
    collection: collection2,
    renderView,
    renderWrapper: renderWrapper || $6d0a5c394373ae64$var$defaultRenderWrapper,
    onVisibleRectChange(rect) {
      ref.current.scrollLeft = rect.x;
      ref.current.scrollTop = rect.y;
    }
  });
  let { virtualizerProps, scrollViewProps } = $6d0a5c394373ae64$export$dd6d526d88b5a137(props, state, ref);
  return (0, import_react45.default).createElement((0, $44a6ee657928b002$export$5665e3d6be6adea), {
    ...(0, $3ef42575df84b30b$export$9d1611c77c2fe928)(otherProps, virtualizerProps, scrollViewProps),
    ref,
    innerStyle: state.isAnimating ? {
      transition: `none ${state.virtualizer.transitionDuration}ms`
    } : void 0,
    contentSize: state.contentSize,
    onScrollStart: state.startScrolling,
    onScrollEnd: state.endScrolling,
    sizeToFit,
    scrollDirection
  }, state.visibleViews);
}
function $6d0a5c394373ae64$export$dd6d526d88b5a137(props, state, ref) {
  let { focusedKey, scrollToItem, shouldUseVirtualFocus, isLoading, onLoadMore } = props;
  let { virtualizer } = state;
  let lastFocusedKey = (0, import_react45.useRef)(null);
  let isFocusWithin = (0, import_react45.useRef)(false);
  let autoFocus = (0, import_react45.useRef)(props.autoFocus);
  (0, import_react45.useEffect)(() => {
    if (virtualizer.visibleRect.height === 0)
      return;
    let modality = (0, $507fabe10e71c6fb$export$630ff653c5ada6a9)();
    if (focusedKey !== lastFocusedKey.current && (modality !== "pointer" || autoFocus.current)) {
      autoFocus.current = false;
      if (scrollToItem)
        scrollToItem(focusedKey);
      else
        virtualizer.scrollToItem(focusedKey, {
          duration: 0
        });
    }
    lastFocusedKey.current = focusedKey;
  }, [
    focusedKey,
    virtualizer.visibleRect.height,
    virtualizer,
    lastFocusedKey,
    scrollToItem,
    ref
  ]);
  virtualizer.persistedKeys = (0, import_react45.useMemo)(() => focusedKey ? /* @__PURE__ */ new Set([
    focusedKey
  ]) : /* @__PURE__ */ new Set(), [
    focusedKey
  ]);
  let onFocus = (0, import_react45.useCallback)((e6) => {
    let modality = (0, $507fabe10e71c6fb$export$630ff653c5ada6a9)();
    if (!isFocusWithin.current && ref.current.contains(e6.target) && modality !== "pointer") {
      if (scrollToItem)
        scrollToItem(focusedKey);
      else
        virtualizer.scrollToItem(focusedKey, {
          duration: 0
        });
    }
    isFocusWithin.current = e6.target !== ref.current;
  }, [
    ref,
    virtualizer,
    focusedKey,
    scrollToItem
  ]);
  let onBlur = (0, import_react45.useCallback)((e6) => {
    isFocusWithin.current = ref.current.contains(e6.relatedTarget);
  }, [
    ref
  ]);
  let tabIndex;
  if (!shouldUseVirtualFocus) {
    tabIndex = focusedKey != null ? -1 : 0;
    if (virtualizer.collection.size === 0 && props.tabIndex != null)
      tabIndex = props.tabIndex;
  }
  let isLoadingRef = (0, import_react45.useRef)(isLoading);
  let prevProps = (0, import_react45.useRef)(props);
  let onVisibleRectChange = (0, import_react45.useCallback)((rect) => {
    state.setVisibleRect(rect);
    if (!isLoadingRef.current && onLoadMore) {
      let scrollOffset = state.virtualizer.contentSize.height - rect.height * 2;
      if (rect.y > scrollOffset) {
        isLoadingRef.current = true;
        onLoadMore();
      }
    }
  }, [
    onLoadMore,
    state
  ]);
  let lastContentSize = (0, import_react45.useRef)(0);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (state.isAnimating)
      return;
    let wasLoading = isLoadingRef.current;
    if (props !== prevProps.current) {
      isLoadingRef.current = isLoading;
      prevProps.current = props;
    }
    let shouldLoadMore = !isLoadingRef.current && onLoadMore && state.contentSize.height > 0 && state.contentSize.height <= state.virtualizer.visibleRect.height && (wasLoading || state.contentSize.height !== lastContentSize.current);
    if (shouldLoadMore) {
      isLoadingRef.current = true;
      onLoadMore();
    }
    lastContentSize.current = state.contentSize.height;
  }, [
    state.contentSize,
    state.isAnimating,
    state.virtualizer,
    isLoading,
    onLoadMore,
    props
  ]);
  return {
    virtualizerProps: {
      tabIndex,
      onFocus,
      onBlur
    },
    scrollViewProps: {
      onVisibleRectChange
    }
  };
}
var $6d0a5c394373ae64$export$89be5a243e59c4b2 = (0, import_react45.default).forwardRef($6d0a5c394373ae64$var$Virtualizer);
function $6d0a5c394373ae64$var$defaultRenderWrapper(parent, reusableView) {
  return (0, import_react45.default).createElement((0, $ccf8a0a04e4175ae$export$6796df8ba7398521), {
    key: reusableView.key,
    layoutInfo: reusableView.layoutInfo,
    virtualizer: reusableView.virtualizer,
    parent: parent === null || parent === void 0 ? void 0 : parent.layoutInfo
  }, reusableView.rendered);
}

// node_modules/@react-stately/layout/dist/import.mjs
var $61ef60fc9b1041f4$var$DEFAULT_HEIGHT = 48;
var $61ef60fc9b1041f4$export$cacbb3924155d68e = class extends (0, $c74cda7d31af1253$export$c84671f46d6a1ca) {
  getLayoutInfo(key) {
    let res = this.layoutInfos.get(key);
    if (!res && this.validRect.area < this.contentSize.area && this.lastCollection) {
      this.lastValidRect = this.validRect;
      this.validRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, 0, Infinity, Infinity);
      this.rootNodes = this.buildCollection();
      this.validRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, 0, this.contentSize.width, this.contentSize.height);
      res = this.layoutInfos.get(key);
    }
    return res;
  }
  getVisibleLayoutInfos(rect) {
    if (!this.validRect.containsRect(rect) && this.lastCollection) {
      this.lastValidRect = this.validRect;
      this.validRect = this.validRect.union(rect);
      this.rootNodes = this.buildCollection();
    }
    let res = [];
    let addNodes = (nodes) => {
      for (let node4 of nodes)
        if (this.isVisible(node4, rect)) {
          res.push(node4.layoutInfo);
          if (node4.header)
            res.push(node4.header);
          if (node4.children)
            addNodes(node4.children);
        }
    };
    addNodes(this.rootNodes);
    return res;
  }
  isVisible(node4, rect) {
    return node4.layoutInfo.rect.intersects(rect) || node4.layoutInfo.isSticky || this.virtualizer.isPersistedKey(node4.layoutInfo.key);
  }
  shouldInvalidateEverything(invalidationContext) {
    return invalidationContext.sizeChanged;
  }
  validate(invalidationContext) {
    this.collection = this.virtualizer.collection;
    this.invalidateEverything = this.shouldInvalidateEverything(invalidationContext);
    if (this.invalidateEverything) {
      this.lastValidRect = this.validRect;
      this.validRect = this.virtualizer.getVisibleRect();
    }
    this.rootNodes = this.buildCollection();
    if (this.lastCollection && this.collection !== this.lastCollection) {
      for (let key of this.lastCollection.getKeys())
        if (!this.collection.getItem(key)) {
          let layoutNode = this.layoutNodes.get(key);
          if (layoutNode) {
            var _layoutNode_header;
            this.layoutInfos.delete(layoutNode.layoutInfo.key);
            this.layoutInfos.delete((_layoutNode_header = layoutNode.header) === null || _layoutNode_header === void 0 ? void 0 : _layoutNode_header.key);
            this.layoutNodes.delete(key);
          }
        }
    }
    this.lastWidth = this.virtualizer.visibleRect.width;
    this.lastCollection = this.collection;
    this.invalidateEverything = false;
  }
  buildCollection() {
    let y4 = this.padding;
    let skipped = 0;
    let nodes = [];
    for (let node4 of this.collection) {
      var _this_rowHeight;
      let rowHeight = (_this_rowHeight = this.rowHeight) !== null && _this_rowHeight !== void 0 ? _this_rowHeight : this.estimatedRowHeight;
      if (node4.type === "item" && y4 + rowHeight < this.validRect.y && !this.isValid(node4, y4)) {
        y4 += rowHeight;
        skipped++;
        continue;
      }
      let layoutNode = this.buildChild(node4, 0, y4);
      y4 = layoutNode.layoutInfo.rect.maxY;
      nodes.push(layoutNode);
      if (node4.type === "item" && y4 > this.validRect.maxY) {
        y4 += (this.collection.size - (nodes.length + skipped)) * rowHeight;
        break;
      }
    }
    if (this.isLoading) {
      var _this_loaderHeight;
      let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, y4, this.virtualizer.visibleRect.width, (_this_loaderHeight = this.loaderHeight) !== null && _this_loaderHeight !== void 0 ? _this_loaderHeight : this.virtualizer.visibleRect.height);
      let loader = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)("loader", "loader", rect);
      this.layoutInfos.set("loader", loader);
      nodes.push({
        layoutInfo: loader
      });
      y4 = loader.rect.maxY;
    }
    if (nodes.length === 0) {
      var _this_placeholderHeight;
      let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, y4, this.virtualizer.visibleRect.width, (_this_placeholderHeight = this.placeholderHeight) !== null && _this_placeholderHeight !== void 0 ? _this_placeholderHeight : this.virtualizer.visibleRect.height);
      let placeholder = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)("placeholder", "placeholder", rect);
      this.layoutInfos.set("placeholder", placeholder);
      nodes.push({
        layoutInfo: placeholder
      });
      y4 = placeholder.rect.maxY;
    }
    this.contentSize = new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)(this.virtualizer.visibleRect.width, y4 + this.padding);
    return nodes;
  }
  isValid(node4, y4) {
    let cached = this.layoutNodes.get(node4.key);
    return !this.invalidateEverything && cached && cached.node === node4 && y4 === (cached.header || cached.layoutInfo).rect.y && cached.layoutInfo.rect.intersects(this.lastValidRect) && cached.validRect.containsRect(cached.layoutInfo.rect.intersection(this.validRect));
  }
  buildChild(node4, x4, y4) {
    if (this.isValid(node4, y4))
      return this.layoutNodes.get(node4.key);
    let layoutNode = this.buildNode(node4, x4, y4);
    layoutNode.node = node4;
    var _node_parentKey;
    layoutNode.layoutInfo.parentKey = (_node_parentKey = node4.parentKey) !== null && _node_parentKey !== void 0 ? _node_parentKey : null;
    this.layoutInfos.set(layoutNode.layoutInfo.key, layoutNode.layoutInfo);
    if (layoutNode.header)
      this.layoutInfos.set(layoutNode.header.key, layoutNode.header);
    this.layoutNodes.set(node4.key, layoutNode);
    return layoutNode;
  }
  buildNode(node4, x4, y4) {
    switch (node4.type) {
      case "section":
        return this.buildSection(node4, x4, y4);
      case "item":
        return this.buildItem(node4, x4, y4);
    }
  }
  buildSection(node4, x4, y4) {
    let width = this.virtualizer.visibleRect.width;
    let rectHeight = this.headingHeight;
    let isEstimated = false;
    if (rectHeight == null) {
      let previousLayoutNode = this.layoutNodes.get(node4.key);
      if (previousLayoutNode && previousLayoutNode.header) {
        let curNode = this.collection.getItem(node4.key);
        let lastNode = this.lastCollection ? this.lastCollection.getItem(node4.key) : null;
        rectHeight = previousLayoutNode.header.rect.height;
        isEstimated = width !== this.lastWidth || curNode !== lastNode || previousLayoutNode.header.estimatedSize;
      } else {
        rectHeight = node4.rendered ? this.estimatedHeadingHeight : 0;
        isEstimated = true;
      }
    }
    if (rectHeight == null)
      rectHeight = $61ef60fc9b1041f4$var$DEFAULT_HEIGHT;
    let headerRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, y4, width, rectHeight);
    let header = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)("header", node4.key + ":header", headerRect);
    header.estimatedSize = isEstimated;
    header.parentKey = node4.key;
    y4 += header.rect.height;
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, y4, width, 0);
    let layoutInfo = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)(node4.type, node4.key, rect);
    let startY = y4;
    let skipped = 0;
    let children = [];
    for (let child of (0, $c5a24bc478652b5f$export$1005530eda016c13)(node4, this.collection)) {
      var _this_rowHeight;
      let rowHeight = (_this_rowHeight = this.rowHeight) !== null && _this_rowHeight !== void 0 ? _this_rowHeight : this.estimatedRowHeight;
      if (y4 + rowHeight < this.validRect.y && !this.isValid(node4, y4)) {
        y4 += rowHeight;
        skipped++;
        continue;
      }
      let layoutNode = this.buildChild(child, x4, y4);
      y4 = layoutNode.layoutInfo.rect.maxY;
      children.push(layoutNode);
      if (y4 > this.validRect.maxY) {
        y4 += ([
          ...(0, $c5a24bc478652b5f$export$1005530eda016c13)(node4, this.collection)
        ].length - (children.length + skipped)) * rowHeight;
        break;
      }
    }
    rect.height = y4 - startY;
    return {
      header,
      layoutInfo,
      children,
      validRect: layoutInfo.rect.intersection(this.validRect)
    };
  }
  buildItem(node4, x4, y4) {
    let width = this.virtualizer.visibleRect.width;
    let rectHeight = this.rowHeight;
    let isEstimated = false;
    if (rectHeight == null) {
      let previousLayoutNode = this.layoutNodes.get(node4.key);
      if (previousLayoutNode) {
        rectHeight = previousLayoutNode.layoutInfo.rect.height;
        isEstimated = width !== this.lastWidth || node4 !== previousLayoutNode.node || previousLayoutNode.layoutInfo.estimatedSize;
      } else {
        rectHeight = this.estimatedRowHeight;
        isEstimated = true;
      }
    }
    if (rectHeight == null)
      rectHeight = $61ef60fc9b1041f4$var$DEFAULT_HEIGHT;
    if (typeof this.indentationForItem === "function")
      x4 += this.indentationForItem(this.collection, node4.key) || 0;
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x4, y4, width - x4, rectHeight);
    let layoutInfo = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)(node4.type, node4.key, rect);
    layoutInfo.allowOverflow = true;
    layoutInfo.estimatedSize = isEstimated;
    return {
      layoutInfo,
      validRect: layoutInfo.rect
    };
  }
  updateItemSize(key, size3) {
    let layoutInfo = this.layoutInfos.get(key);
    if (!layoutInfo)
      return false;
    layoutInfo.estimatedSize = false;
    if (layoutInfo.rect.height !== size3.height) {
      let newLayoutInfo = layoutInfo.copy();
      newLayoutInfo.rect.height = size3.height;
      this.layoutInfos.set(key, newLayoutInfo);
      this.updateLayoutNode(key, layoutInfo, newLayoutInfo);
      let node4 = this.collection.getItem(layoutInfo.parentKey);
      while (node4) {
        this.updateLayoutNode(node4.key, layoutInfo, newLayoutInfo);
        node4 = this.collection.getItem(node4.parentKey);
      }
      return true;
    }
    return false;
  }
  updateLayoutNode(key, oldLayoutInfo, newLayoutInfo) {
    let n6 = this.layoutNodes.get(key);
    if (n6) {
      n6.validRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)();
      if (n6.header === oldLayoutInfo)
        n6.header = newLayoutInfo;
      else if (n6.layoutInfo === oldLayoutInfo)
        n6.layoutInfo = newLayoutInfo;
    }
  }
  getContentSize() {
    return this.contentSize;
  }
  getKeyAbove(key) {
    let collection2 = this.collection;
    key = collection2.getKeyBefore(key);
    while (key != null) {
      let item2 = collection2.getItem(key);
      if (item2.type === "item" && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item2.key)))
        return key;
      key = collection2.getKeyBefore(key);
    }
  }
  getKeyBelow(key) {
    let collection2 = this.collection;
    key = collection2.getKeyAfter(key);
    while (key != null) {
      let item2 = collection2.getItem(key);
      if (item2.type === "item" && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item2.key)))
        return key;
      key = collection2.getKeyAfter(key);
    }
  }
  getKeyPageAbove(key) {
    let layoutInfo = this.getLayoutInfo(key);
    if (layoutInfo) {
      let pageY = Math.max(0, layoutInfo.rect.y + layoutInfo.rect.height - this.virtualizer.visibleRect.height);
      while (layoutInfo && layoutInfo.rect.y > pageY) {
        let keyAbove = this.getKeyAbove(layoutInfo.key);
        layoutInfo = this.getLayoutInfo(keyAbove);
      }
      if (layoutInfo)
        return layoutInfo.key;
    }
    return this.getFirstKey();
  }
  getKeyPageBelow(key) {
    let layoutInfo = this.getLayoutInfo(key != null ? key : this.getFirstKey());
    if (layoutInfo) {
      let pageY = Math.min(this.virtualizer.contentSize.height, layoutInfo.rect.y - layoutInfo.rect.height + this.virtualizer.visibleRect.height);
      while (layoutInfo && layoutInfo.rect.y < pageY) {
        let keyBelow = this.getKeyBelow(layoutInfo.key);
        layoutInfo = this.getLayoutInfo(keyBelow);
      }
      if (layoutInfo)
        return layoutInfo.key;
    }
    return this.getLastKey();
  }
  getFirstKey() {
    let collection2 = this.collection;
    let key = collection2.getFirstKey();
    while (key != null) {
      let item2 = collection2.getItem(key);
      if (item2.type === "item" && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item2.key)))
        return key;
      key = collection2.getKeyAfter(key);
    }
  }
  getLastKey() {
    let collection2 = this.collection;
    let key = collection2.getLastKey();
    while (key != null) {
      let item2 = collection2.getItem(key);
      if (item2.type === "item" && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item2.key)))
        return key;
      key = collection2.getKeyBefore(key);
    }
  }
  getKeyForSearch(search2, fromKey) {
    if (!this.collator)
      return null;
    let collection2 = this.collection;
    let key = fromKey || this.getFirstKey();
    while (key != null) {
      let item2 = collection2.getItem(key);
      let substring = item2.textValue.slice(0, search2.length);
      if (item2.textValue && this.collator.compare(substring, search2) === 0)
        return key;
      key = this.getKeyBelow(key);
    }
    return null;
  }
  getInitialLayoutInfo(layoutInfo) {
    layoutInfo.opacity = 0;
    layoutInfo.transform = "scale3d(0.8, 0.8, 0.8)";
    return layoutInfo;
  }
  getFinalLayoutInfo(layoutInfo) {
    layoutInfo.opacity = 0;
    layoutInfo.transform = "scale3d(0.8, 0.8, 0.8)";
    return layoutInfo;
  }
  getDropTargetFromPoint(x4, y4, isValidDropTarget) {
    x4 += this.virtualizer.visibleRect.x;
    y4 += this.virtualizer.visibleRect.y;
    let key = this.virtualizer.keyAtPoint(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x4, y4));
    if (key == null || this.collection.size === 0)
      return {
        type: "root"
      };
    let layoutInfo = this.getLayoutInfo(key);
    let rect = layoutInfo.rect;
    let target = {
      type: "item",
      key: layoutInfo.key,
      dropPosition: "on"
    };
    if (!isValidDropTarget(target)) {
      if (y4 <= rect.y + rect.height / 2 && isValidDropTarget({
        ...target,
        dropPosition: "before"
      }))
        target.dropPosition = "before";
      else if (isValidDropTarget({
        ...target,
        dropPosition: "after"
      }))
        target.dropPosition = "after";
    } else if (y4 <= rect.y + 10 && isValidDropTarget({
      ...target,
      dropPosition: "before"
    }))
      target.dropPosition = "before";
    else if (y4 >= rect.maxY - 10 && isValidDropTarget({
      ...target,
      dropPosition: "after"
    }))
      target.dropPosition = "after";
    return target;
  }
  /**
  * Creates a new ListLayout with options. See the list of properties below for a description
  * of the options that can be provided.
  */
  constructor(options = {}) {
    super();
    this.disabledKeys = /* @__PURE__ */ new Set();
    this.allowDisabledKeyFocus = false;
    this.rowHeight = options.rowHeight;
    this.estimatedRowHeight = options.estimatedRowHeight;
    this.headingHeight = options.headingHeight;
    this.estimatedHeadingHeight = options.estimatedHeadingHeight;
    this.padding = options.padding || 0;
    this.indentationForItem = options.indentationForItem;
    this.collator = options.collator;
    this.loaderHeight = options.loaderHeight;
    this.placeholderHeight = options.placeholderHeight;
    this.layoutInfos = /* @__PURE__ */ new Map();
    this.layoutNodes = /* @__PURE__ */ new Map();
    this.rootNodes = [];
    this.lastWidth = 0;
    this.lastCollection = null;
    this.allowDisabledKeyFocus = options.allowDisabledKeyFocus;
    this.lastValidRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)();
    this.validRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)();
    this.contentSize = new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)();
  }
};
var $a152112e902709bf$export$62444c3c724b1b20 = class extends (0, $61ef60fc9b1041f4$export$cacbb3924155d68e) {
  shouldInvalidateEverything(invalidationContext) {
    return super.shouldInvalidateEverything(invalidationContext) || !this.lastCollection || this.collection.columns.length !== this.lastCollection.columns.length || this.collection.columns.some((c5, i6) => c5.key !== this.lastCollection.columns[i6].key || c5.props.width !== this.lastCollection.columns[i6].props.width || c5.props.minWidth !== this.lastCollection.columns[i6].props.minWidth || c5.props.maxWidth !== this.lastCollection.columns[i6].props.maxWidth);
  }
  getResizerPosition() {
    var _this_getLayoutInfo;
    return (_this_getLayoutInfo = this.getLayoutInfo(this.resizingColumn)) === null || _this_getLayoutInfo === void 0 ? void 0 : _this_getLayoutInfo.rect.maxX;
  }
  getColumnWidth(key) {
    var _this_columnLayout_getColumnWidth;
    return (_this_columnLayout_getColumnWidth = this.columnLayout.getColumnWidth(key)) !== null && _this_columnLayout_getColumnWidth !== void 0 ? _this_columnLayout_getColumnWidth : 0;
  }
  getColumnMinWidth(key) {
    let column2 = this.collection.columns.find((col) => col.key === key);
    if (!column2)
      return 0;
    return this.columnLayout.getColumnMinWidth(key);
  }
  getColumnMaxWidth(key) {
    let column2 = this.collection.columns.find((col) => col.key === key);
    if (!column2)
      return 0;
    return this.columnLayout.getColumnMaxWidth(key);
  }
  // outside, where this is called, should call props.onColumnResizeStart...
  startResize(key) {
    this.resizingColumn = key;
  }
  // only way to call props.onColumnResize with the new size outside of Layout is to send the result back
  updateResizedColumns(key, width) {
    let newControlled = new Map(Array.from(this.controlledColumns).map(([key2, entry]) => [
      key2,
      entry.props.width
    ]));
    let newSizes = this.columnLayout.resizeColumnWidth(this.virtualizer.visibleRect.width, this.collection, newControlled, this.uncontrolledWidths, key, width);
    let map4 = new Map(Array.from(this.uncontrolledColumns).map(([key2]) => [
      key2,
      newSizes.get(key2)
    ]));
    map4.set(key, width);
    this.uncontrolledWidths = map4;
    if (this.uncontrolledWidths.size > 0)
      this.virtualizer.relayoutNow({
        sizeChanged: true
      });
    return newSizes;
  }
  endResize() {
    this.resizingColumn = null;
  }
  buildCollection() {
    let loadingState = this.collection.body.props.loadingState;
    this.wasLoading = this.isLoading;
    this.isLoading = loadingState === "loading" || loadingState === "loadingMore";
    this.stickyColumnIndices = [];
    for (let column2 of this.collection.columns)
      if (column2.props.isDragButtonCell || column2.props.isSelectionCell || this.collection.rowHeaderColumnKeys.has(column2.key))
        this.stickyColumnIndices.push(column2.index);
    let [controlledColumns, uncontrolledColumns] = this.columnLayout.splitColumnsIntoControlledAndUncontrolled(this.collection.columns);
    this.controlledColumns = controlledColumns;
    this.uncontrolledColumns = uncontrolledColumns;
    let colWidths = this.columnLayout.recombineColumns(this.collection.columns, this.uncontrolledWidths, uncontrolledColumns, controlledColumns);
    this.columnWidths = this.columnLayout.buildColumnWidths(this.virtualizer.visibleRect.width, this.collection, colWidths);
    let header = this.buildHeader();
    let body = this.buildBody(0);
    this.lastPersistedKeys = null;
    body.layoutInfo.rect.width = Math.max(header.layoutInfo.rect.width, body.layoutInfo.rect.width);
    this.contentSize = new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)(body.layoutInfo.rect.width, body.layoutInfo.rect.maxY);
    return [
      header,
      body
    ];
  }
  buildHeader() {
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, 0, 0, 0);
    let layoutInfo = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)("header", "header", rect);
    let y4 = 0;
    let width = 0;
    let children = [];
    for (let headerRow of this.collection.headerRows) {
      let layoutNode = this.buildChild(headerRow, 0, y4);
      layoutNode.layoutInfo.parentKey = "header";
      y4 = layoutNode.layoutInfo.rect.maxY;
      width = Math.max(width, layoutNode.layoutInfo.rect.width);
      layoutNode.index = children.length;
      children.push(layoutNode);
    }
    rect.width = width;
    rect.height = y4;
    this.layoutInfos.set("header", layoutInfo);
    return {
      layoutInfo,
      children,
      validRect: layoutInfo.rect
    };
  }
  buildHeaderRow(headerRow, x4, y4) {
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, y4, 0, 0);
    let row = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)("headerrow", headerRow.key, rect);
    let height = 0;
    let columns = [];
    for (let cell2 of (0, $c5a24bc478652b5f$export$1005530eda016c13)(headerRow, this.collection)) {
      let layoutNode = this.buildChild(cell2, x4, y4);
      layoutNode.layoutInfo.parentKey = row.key;
      x4 = layoutNode.layoutInfo.rect.maxX;
      height = Math.max(height, layoutNode.layoutInfo.rect.height);
      layoutNode.index = columns.length;
      columns.push(layoutNode);
    }
    for (let [i6, layout] of columns.entries())
      layout.layoutInfo.zIndex = columns.length - i6 + 1;
    this.setChildHeights(columns, height);
    rect.height = height;
    rect.width = x4;
    return {
      layoutInfo: row,
      children: columns,
      validRect: rect
    };
  }
  setChildHeights(children, height) {
    for (let child of children)
      if (child.layoutInfo.rect.height !== height) {
        child.layoutInfo = child.layoutInfo.copy();
        this.layoutInfos.set(child.layoutInfo.key, child.layoutInfo);
        child.layoutInfo.rect.height = height;
      }
  }
  // used to get the column widths when rendering to the DOM
  getRenderedColumnWidth(node4) {
    var _node_colspan;
    let colspan = (_node_colspan = node4.colspan) !== null && _node_colspan !== void 0 ? _node_colspan : 1;
    var _node_colIndex;
    let colIndex = (_node_colIndex = node4.colIndex) !== null && _node_colIndex !== void 0 ? _node_colIndex : node4.index;
    let width = 0;
    for (let i6 = colIndex; i6 < colIndex + colspan; i6++) {
      let column2 = this.collection.columns[i6];
      if ((column2 === null || column2 === void 0 ? void 0 : column2.key) != null)
        width += this.columnWidths.get(column2.key);
    }
    return width;
  }
  getEstimatedHeight(node4, width, height, estimatedHeight) {
    let isEstimated = false;
    if (height == null) {
      let previousLayoutNode = this.layoutNodes.get(node4.key);
      if (previousLayoutNode) {
        height = previousLayoutNode.layoutInfo.rect.height;
        isEstimated = node4 !== previousLayoutNode.node || width !== previousLayoutNode.layoutInfo.rect.width || previousLayoutNode.layoutInfo.estimatedSize;
      } else {
        height = estimatedHeight;
        isEstimated = true;
      }
    }
    return {
      height,
      isEstimated
    };
  }
  buildColumn(node4, x4, y4) {
    var _node_props, _node_props1;
    let width = this.getRenderedColumnWidth(node4);
    let { height, isEstimated } = this.getEstimatedHeight(node4, width, this.headingHeight, this.estimatedHeadingHeight);
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x4, y4, width, height);
    let layoutInfo = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)(node4.type, node4.key, rect);
    layoutInfo.isSticky = !this.disableSticky && (((_node_props = node4.props) === null || _node_props === void 0 ? void 0 : _node_props.isDragButtonCell) || ((_node_props1 = node4.props) === null || _node_props1 === void 0 ? void 0 : _node_props1.isSelectionCell));
    layoutInfo.zIndex = layoutInfo.isSticky ? 2 : 1;
    layoutInfo.estimatedSize = isEstimated;
    return {
      layoutInfo,
      validRect: layoutInfo.rect
    };
  }
  buildBody(y4) {
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, y4, 0, 0);
    let layoutInfo = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)("rowgroup", "body", rect);
    let startY = y4;
    let skipped = 0;
    let width = 0;
    let children = [];
    for (let [i6, node4] of [
      ...this.collection
    ].entries()) {
      var _this_rowHeight;
      let rowHeight = ((_this_rowHeight = this.rowHeight) !== null && _this_rowHeight !== void 0 ? _this_rowHeight : this.estimatedRowHeight) + 1;
      if (y4 + rowHeight < this.validRect.y && !this.isValid(node4, y4)) {
        y4 += rowHeight;
        skipped++;
        continue;
      }
      let layoutNode = this.buildChild(node4, 0, y4);
      layoutNode.layoutInfo.parentKey = "body";
      layoutNode.index = i6;
      y4 = layoutNode.layoutInfo.rect.maxY;
      width = Math.max(width, layoutNode.layoutInfo.rect.width);
      children.push(layoutNode);
      if (y4 > this.validRect.maxY) {
        y4 += (this.collection.size - (skipped + children.length)) * rowHeight;
        break;
      }
    }
    if (this.isLoading) {
      let rect2 = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(40, Math.max(y4, 40), (width || this.virtualizer.visibleRect.width) - 80, children.length === 0 ? this.virtualizer.visibleRect.height - 80 : 60);
      let loader = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)("loader", "loader", rect2);
      loader.parentKey = "body";
      loader.isSticky = !this.disableSticky && children.length === 0;
      this.layoutInfos.set("loader", loader);
      children.push({
        layoutInfo: loader,
        validRect: loader.rect
      });
      y4 = loader.rect.maxY;
      width = Math.max(width, rect2.width);
    } else if (children.length === 0) {
      let rect2 = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(40, Math.max(y4, 40), this.virtualizer.visibleRect.width - 80, this.virtualizer.visibleRect.height - 80);
      let empty3 = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)("empty", "empty", rect2);
      empty3.parentKey = "body";
      empty3.isSticky = !this.disableSticky;
      this.layoutInfos.set("empty", empty3);
      children.push({
        layoutInfo: empty3,
        validRect: empty3.rect
      });
      y4 = empty3.rect.maxY;
      width = Math.max(width, rect2.width);
    }
    rect.width = width;
    rect.height = y4 - startY;
    this.layoutInfos.set("body", layoutInfo);
    return {
      layoutInfo,
      children,
      validRect: layoutInfo.rect.intersection(this.validRect)
    };
  }
  buildNode(node4, x4, y4) {
    switch (node4.type) {
      case "headerrow":
        return this.buildHeaderRow(node4, x4, y4);
      case "item":
        return this.buildRow(node4, x4, y4);
      case "column":
      case "placeholder":
        return this.buildColumn(node4, x4, y4);
      case "cell":
        return this.buildCell(node4, x4, y4);
      default:
        throw new Error("Unknown node type " + node4.type);
    }
  }
  buildRow(node4, x4, y4) {
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x4, y4, 0, 0);
    let layoutInfo = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)("row", node4.key, rect);
    let children = [];
    let height = 0;
    for (let [i6, child] of [
      ...(0, $c5a24bc478652b5f$export$1005530eda016c13)(node4, this.collection)
    ].entries())
      if (child.type === "cell") {
        if (x4 > this.validRect.maxX) {
          let layoutNode = this.layoutNodes.get(child.key);
          if (layoutNode) {
            layoutNode.layoutInfo.rect.x = x4;
            x4 += layoutNode.layoutInfo.rect.width;
          }
        } else {
          let layoutNode = this.buildChild(child, x4, y4);
          x4 = layoutNode.layoutInfo.rect.maxX;
          height = Math.max(height, layoutNode.layoutInfo.rect.height);
          layoutNode.index = i6;
          children.push(layoutNode);
        }
      }
    this.setChildHeights(children, height);
    rect.width = this.layoutInfos.get("header").rect.width;
    rect.height = height + 1;
    return {
      layoutInfo,
      children,
      validRect: rect.intersection(this.validRect)
    };
  }
  buildCell(node4, x4, y4) {
    var _node_props, _node_props1;
    let width = this.getRenderedColumnWidth(node4);
    let { height, isEstimated } = this.getEstimatedHeight(node4, width, this.rowHeight, this.estimatedRowHeight);
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x4, y4, width, height);
    let layoutInfo = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)(node4.type, node4.key, rect);
    layoutInfo.isSticky = !this.disableSticky && (((_node_props = node4.props) === null || _node_props === void 0 ? void 0 : _node_props.isDragButtonCell) || ((_node_props1 = node4.props) === null || _node_props1 === void 0 ? void 0 : _node_props1.isSelectionCell));
    layoutInfo.zIndex = layoutInfo.isSticky ? 2 : 1;
    layoutInfo.estimatedSize = isEstimated;
    return {
      layoutInfo,
      validRect: rect
    };
  }
  getVisibleLayoutInfos(rect) {
    if (!this.validRect.containsRect(rect) && this.lastCollection) {
      this.lastValidRect = this.validRect;
      this.validRect = this.validRect.union(rect);
      this.rootNodes = this.buildCollection();
    }
    let res = [];
    this.buildPersistedIndices();
    for (let node4 of this.rootNodes) {
      res.push(node4.layoutInfo);
      this.addVisibleLayoutInfos(res, node4, rect);
    }
    return res;
  }
  addVisibleLayoutInfos(res, node4, rect) {
    if (!node4.children || node4.children.length === 0)
      return;
    switch (node4.layoutInfo.type) {
      case "header":
        for (let child of node4.children) {
          res.push(child.layoutInfo);
          this.addVisibleLayoutInfos(res, child, rect);
        }
        break;
      case "rowgroup": {
        let firstVisibleRow = this.binarySearch(node4.children, rect.topLeft, "y");
        let lastVisibleRow = this.binarySearch(node4.children, rect.bottomRight, "y");
        let persistedRowIndices = this.persistedIndices.get(node4.layoutInfo.key);
        let persistIndex = 0;
        while (persistedRowIndices && persistIndex < persistedRowIndices.length && persistedRowIndices[persistIndex] < firstVisibleRow) {
          let idx = persistedRowIndices[persistIndex];
          if (idx < node4.children.length) {
            res.push(node4.children[idx].layoutInfo);
            this.addVisibleLayoutInfos(res, node4.children[idx], rect);
          }
          persistIndex++;
        }
        for (let i6 = firstVisibleRow; i6 <= lastVisibleRow; i6++) {
          while (persistedRowIndices && persistIndex < persistedRowIndices.length && persistedRowIndices[persistIndex] < i6)
            persistIndex++;
          res.push(node4.children[i6].layoutInfo);
          this.addVisibleLayoutInfos(res, node4.children[i6], rect);
        }
        while (persistedRowIndices && persistIndex < persistedRowIndices.length) {
          let idx = persistedRowIndices[persistIndex++];
          if (idx < node4.children.length)
            res.push(node4.children[idx].layoutInfo);
        }
        break;
      }
      case "headerrow":
      case "row": {
        let firstVisibleCell = this.binarySearch(node4.children, rect.topLeft, "x");
        let lastVisibleCell = this.binarySearch(node4.children, rect.topRight, "x");
        let stickyIndex = 0;
        let persistedCellIndices = this.persistedIndices.get(node4.layoutInfo.key) || this.stickyColumnIndices;
        while (stickyIndex < persistedCellIndices.length && persistedCellIndices[stickyIndex] < firstVisibleCell) {
          let idx = persistedCellIndices[stickyIndex];
          if (idx < node4.children.length)
            res.push(node4.children[idx].layoutInfo);
          stickyIndex++;
        }
        for (let i6 = firstVisibleCell; i6 <= lastVisibleCell; i6++) {
          while (stickyIndex < persistedCellIndices.length && persistedCellIndices[stickyIndex] < i6)
            stickyIndex++;
          res.push(node4.children[i6].layoutInfo);
        }
        while (stickyIndex < persistedCellIndices.length) {
          let idx = persistedCellIndices[stickyIndex++];
          if (idx < node4.children.length)
            res.push(node4.children[idx].layoutInfo);
        }
        break;
      }
      default:
        throw new Error("Unknown node type " + node4.layoutInfo.type);
    }
  }
  binarySearch(items, point3, axis) {
    let low = 0;
    let high = items.length - 1;
    while (low <= high) {
      let mid = low + high >> 1;
      let item2 = items[mid];
      if (axis === "x" && item2.layoutInfo.rect.maxX < point3.x || axis === "y" && item2.layoutInfo.rect.maxY < point3.y)
        low = mid + 1;
      else if (axis === "x" && item2.layoutInfo.rect.x > point3.x || axis === "y" && item2.layoutInfo.rect.y > point3.y)
        high = mid - 1;
      else
        return mid;
    }
    return Math.max(0, Math.min(items.length - 1, low));
  }
  buildPersistedIndices() {
    if (this.virtualizer.persistedKeys === this.lastPersistedKeys)
      return;
    this.lastPersistedKeys = this.virtualizer.persistedKeys;
    this.persistedIndices.clear();
    for (let key of this.virtualizer.persistedKeys) {
      let layoutInfo = this.layoutInfos.get(key);
      while (layoutInfo && layoutInfo.parentKey) {
        let collectionNode = this.collection.getItem(layoutInfo.key);
        let indices = this.persistedIndices.get(layoutInfo.parentKey);
        if (!indices) {
          indices = collectionNode.type === "cell" || collectionNode.type === "column" ? [
            ...this.stickyColumnIndices
          ] : [];
          this.persistedIndices.set(layoutInfo.parentKey, indices);
        }
        let index3 = this.layoutNodes.get(layoutInfo.key).index;
        if (!indices.includes(index3))
          indices.push(index3);
        layoutInfo = this.layoutInfos.get(layoutInfo.parentKey);
      }
    }
    for (let indices of this.persistedIndices.values())
      indices.sort((a3, b2) => a3 - b2);
  }
  getInitialLayoutInfo(layoutInfo) {
    let res = super.getInitialLayoutInfo(layoutInfo);
    res.transform = null;
    return res;
  }
  getFinalLayoutInfo(layoutInfo) {
    let res = super.getFinalLayoutInfo(layoutInfo);
    res.transform = null;
    return res;
  }
  // Checks if Chrome version is 105 or greater
  checkChrome105() {
    var _window_navigator_userAgentData;
    if (typeof window === "undefined" || window.navigator == null)
      return false;
    let isChrome105;
    if (window.navigator["userAgentData"])
      isChrome105 = (_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((b2) => b2.brand === "Chromium" && Number(b2.version) === 105);
    else {
      let regex = /Chrome\/(\d+)/;
      let matches = regex.exec(window.navigator.userAgent);
      isChrome105 = matches && matches.length >= 2 && Number(matches[1]) === 105;
    }
    return isChrome105;
  }
  getDropTargetFromPoint(x4, y4, isValidDropTarget) {
    var _this_virtualizer_layout_getVisibleLayoutInfos_find;
    x4 += this.virtualizer.visibleRect.x;
    y4 += this.virtualizer.visibleRect.y;
    y4 -= (_this_virtualizer_layout_getVisibleLayoutInfos_find = this.virtualizer.layout.getVisibleLayoutInfos(new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x4, y4, 1, 1)).find((info) => info.type === "headerrow")) === null || _this_virtualizer_layout_getVisibleLayoutInfos_find === void 0 ? void 0 : _this_virtualizer_layout_getVisibleLayoutInfos_find.rect.height;
    let key;
    let point3 = new (0, $3041db3296945e6e$export$baf26146a414f24a)(x4, y4);
    let rectAtPoint = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(point3.x, point3.y, 1, 1);
    let layoutInfos = this.virtualizer.layout.getVisibleLayoutInfos(rectAtPoint).filter((info) => info.type === "row");
    for (let layoutInfo2 of layoutInfos)
      if (layoutInfo2.rect.intersects(rectAtPoint))
        key = layoutInfo2.key;
    if (key == null || this.collection.size === 0)
      return {
        type: "root"
      };
    let layoutInfo = this.getLayoutInfo(key);
    let rect = layoutInfo.rect;
    let target = {
      type: "item",
      key: layoutInfo.key,
      dropPosition: "on"
    };
    if (!isValidDropTarget(target)) {
      if (y4 <= rect.y + rect.height / 2 && isValidDropTarget({
        ...target,
        dropPosition: "before"
      }))
        target.dropPosition = "before";
      else if (isValidDropTarget({
        ...target,
        dropPosition: "after"
      }))
        target.dropPosition = "after";
    } else if (y4 <= rect.y + 10 && isValidDropTarget({
      ...target,
      dropPosition: "before"
    }))
      target.dropPosition = "before";
    else if (y4 >= rect.maxY - 10 && isValidDropTarget({
      ...target,
      dropPosition: "after"
    }))
      target.dropPosition = "after";
    return target;
  }
  constructor(options) {
    super(options);
    this.columnWidths = /* @__PURE__ */ new Map();
    this.wasLoading = false;
    this.isLoading = false;
    this.lastPersistedKeys = null;
    this.persistedIndices = /* @__PURE__ */ new Map();
    this.collection = options.initialCollection;
    this.stickyColumnIndices = [];
    this.disableSticky = this.checkChrome105();
    this.columnLayout = options.columnLayout;
    let [controlledColumns, uncontrolledColumns] = this.columnLayout.splitColumnsIntoControlledAndUncontrolled(this.collection.columns);
    this.controlledColumns = controlledColumns;
    this.uncontrolledColumns = uncontrolledColumns;
    this.uncontrolledWidths = this.columnLayout.getInitialUncontrolledWidths(uncontrolledColumns);
  }
};

// node_modules/@keystar/ui/dist/keystar-ui-list-view.js
var import_react46 = __toESM(require_react());
var import_jsx_runtime25 = __toESM(require_jsx_runtime());

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-chevronLeftIcon.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime());
var chevronLeftIcon = (0, import_jsx_runtime22.jsx)("path", {
  d: "m15 18-6-6 6-6"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-chevronRightIcon.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime());
var chevronRightIcon = (0, import_jsx_runtime23.jsx)("path", {
  d: "m9 18 6-6-6-6"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-gripVerticalIcon.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime());
var gripVerticalIcon = (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, {
  children: [(0, import_jsx_runtime24.jsx)("circle", {
    cx: 9,
    cy: 12,
    r: 1
  }), (0, import_jsx_runtime24.jsx)("circle", {
    cx: 9,
    cy: 5,
    r: 1
  }), (0, import_jsx_runtime24.jsx)("circle", {
    cx: 9,
    cy: 19,
    r: 1
  }), (0, import_jsx_runtime24.jsx)("circle", {
    cx: 15,
    cy: 12,
    r: 1
  }), (0, import_jsx_runtime24.jsx)("circle", {
    cx: 15,
    cy: 5,
    r: 1
  }), (0, import_jsx_runtime24.jsx)("circle", {
    cx: 15,
    cy: 19,
    r: 1
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-list-view.js
var listViewClassList = new ClassList("ListView", ["centered-wrapper"]);
var listViewItemClassList = new ClassList("ListViewItem", ["actionmenu", "actions", "badge", "checkbox", "content", "description", "draghandle", "grid", "parent-indicator", "row", "thumbnail"]);
var ListViewContext = (
  // @ts-expect-error
  (0, import_react46.createContext)(null)
);
var ListViewProvider = ListViewContext.Provider;
function useListViewContext() {
  let context = (0, import_react46.useContext)(ListViewContext);
  if (!context) {
    throw new Error("Attempt to access `ListViewContext` outside of its provided.");
  }
  return context;
}
var localizedMessages4 = {
  "ar-AE": {
    loading: "جارٍ التحميل...",
    loadingMore: "جارٍ تحميل المزيد..."
  },
  "bg-BG": {
    loading: "Зареждане...",
    loadingMore: "Зареждане на още..."
  },
  "cs-CZ": {
    loading: "Načítání...",
    loadingMore: "Načítání dalších..."
  },
  "da-DK": {
    loading: "Indlæser...",
    loadingMore: "Indlæser flere..."
  },
  "de-DE": {
    loading: "Laden...",
    loadingMore: "Mehr laden ..."
  },
  "el-GR": {
    loading: "Φόρτωση...",
    loadingMore: "Φόρτωση περισσότερων..."
  },
  "en-US": {
    loading: "Loading…",
    loadingMore: "Loading more…"
  },
  "es-ES": {
    loading: "Cargando…",
    loadingMore: "Cargando más…"
  },
  "et-EE": {
    loading: "Laadimine...",
    loadingMore: "Laadi rohkem..."
  },
  "fi-FI": {
    loading: "Ladataan…",
    loadingMore: "Ladataan lisää…"
  },
  "fr-FR": {
    loading: "Chargement...",
    loadingMore: "Chargement supplémentaire..."
  },
  "he-IL": {
    loading: "טוען...",
    loadingMore: "טוען עוד..."
  },
  "hr-HR": {
    loading: "Učitavam...",
    loadingMore: "Učitavam još..."
  },
  "hu-HU": {
    loading: "Betöltés folyamatban…",
    loadingMore: "Továbbiak betöltése folyamatban…"
  },
  "it-IT": {
    loading: "Caricamento...",
    loadingMore: "Caricamento altri..."
  },
  "ja-JP": {
    loading: "読み込み中...",
    loadingMore: "さらに読み込み中..."
  },
  "ko-KR": {
    loading: "로드 중…",
    loadingMore: "추가 로드 중…"
  },
  "lt-LT": {
    loading: "Įkeliama...",
    loadingMore: "Įkeliama daugiau..."
  },
  "lv-LV": {
    loading: "Notiek ielāde...",
    loadingMore: "Tiek ielādēts vēl..."
  },
  "nb-NO": {
    loading: "Laster inn ...",
    loadingMore: "Laster inn flere ..."
  },
  "nl-NL": {
    loading: "Laden...",
    loadingMore: "Meer laden..."
  },
  "pl-PL": {
    loading: "Ładowanie...",
    loadingMore: "Wczytywanie większej liczby..."
  },
  "pt-BR": {
    loading: "Carregando...",
    loadingMore: "Carregando mais..."
  },
  "pt-PT": {
    loading: "A carregar...",
    loadingMore: "A carregar mais..."
  },
  "ro-RO": {
    loading: "Se încarcă...",
    loadingMore: "Se încarcă mai multe..."
  },
  "ru-RU": {
    loading: "Загрузка...",
    loadingMore: "Дополнительная загрузка..."
  },
  "sk-SK": {
    loading: "Načítava sa...",
    loadingMore: "Načítava sa viac..."
  },
  "sl-SI": {
    loading: "Nalaganje ...",
    loadingMore: "Nalaganje več vsebine ..."
  },
  "sr-SP": {
    loading: "Učitavam...",
    loadingMore: "Učitavam još..."
  },
  "sv-SE": {
    loading: "Läser in...",
    loadingMore: "Läser in mer..."
  },
  "tr-TR": {
    loading: "Yükleniyor...",
    loadingMore: "Daha fazla yükleniyor..."
  },
  "uk-UA": {
    loading: "Завантаження…",
    loadingMore: "Завантаження інших об’єктів..."
  },
  "zh-CN": {
    loading: "正在加载...",
    loadingMore: "正在加载更多..."
  },
  "zh-T": {
    loading: "載入中…",
    loadingMore: "正在載入更多…"
  }
};
function DragPreview(props) {
  let {
    item: item2,
    itemCount,
    itemHeight,
    density
  } = props;
  let isDraggingMultiple = itemCount > 1;
  return (0, import_jsx_runtime25.jsx)("div", {
    ...toDataAttributes({
      density,
      multi: isDraggingMultiple
    }),
    style: {
      height: itemHeight
    },
    className: classNames(css({
      display: "grid",
      backgroundColor: tokenSchema.color.background.canvas,
      border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.alias.borderSelected}`,
      borderRadius: tokenSchema.size.radius.small,
      paddingInline: tokenSchema.size.space.medium,
      position: "relative",
      outline: 0,
      width: tokenSchema.size.alias.singleLineWidth,
      // Density
      minHeight: tokenSchema.size.element.medium,
      paddingBlock: tokenSchema.size.space.medium,
      '&[data-density="compact"]': {
        minHeight: tokenSchema.size.element.regular,
        paddingBlock: tokenSchema.size.space.regular
      },
      '&[data-density="spacious"]': {
        minHeight: tokenSchema.size.element.large,
        paddingBlock: tokenSchema.size.space.large
      },
      // indicate that multiple items are being dragged by implying a stack
      "&[data-multi=true]::after": {
        backgroundColor: "inherit",
        border: "inherit",
        borderRadius: "inherit",
        content: '" "',
        display: "block",
        height: "100%",
        insetInlineStart: 4,
        position: "absolute",
        top: 4,
        width: "100%",
        zIndex: -1
      }
    })),
    children: (0, import_jsx_runtime25.jsx)(Grid, {
      UNSAFE_className: listViewItemClassList.element("grid"),
      columns: "auto auto 1fr auto",
      rows: "1fr auto",
      areas: ["thumbnail content     . badge", "thumbnail description . badge"],
      alignItems: "center",
      children: (0, import_jsx_runtime25.jsxs)(SlotProvider, {
        slots: {
          text: {
            gridArea: "content",
            flexGrow: 1,
            truncate: true,
            weight: "medium",
            UNSAFE_className: listViewItemClassList.element("content")
          },
          description: {
            color: "neutralSecondary",
            size: "small",
            gridArea: "description",
            flexGrow: 1,
            marginTop: "small",
            truncate: true,
            UNSAFE_className: listViewItemClassList.element("description")
          },
          image: {
            borderRadius: "xsmall",
            gridArea: "thumbnail",
            marginEnd: "regular",
            overflow: "hidden",
            height: density === "compact" ? "element.small" : "element.regular",
            UNSAFE_className: listViewItemClassList.element("thumbnail")
          },
          button: {
            isHidden: true,
            UNSAFE_className: listViewItemClassList.element("actions")
          },
          actionGroup: {
            isHidden: true,
            UNSAFE_className: listViewItemClassList.element("actions")
          },
          actionMenu: {
            isHidden: true,
            UNSAFE_className: listViewItemClassList.element("actionmenu")
          }
        },
        children: [isReactText(item2.rendered) ? (0, import_jsx_runtime25.jsx)(Text2, {
          children: item2.rendered
        }) : item2.rendered, isDraggingMultiple && (0, import_jsx_runtime25.jsx)(Flex, {
          alignItems: "center",
          backgroundColor: "accentEmphasis",
          borderRadius: "small",
          gridArea: "badge",
          minWidth: "element.small",
          padding: "small",
          UNSAFE_className: listViewItemClassList.element("badge"),
          children: (0, import_jsx_runtime25.jsx)(Text2, {
            align: "center",
            color: "inverse",
            size: "small",
            weight: "medium",
            children: itemCount
          })
        })]
      })
    })
  });
}
function InsertionIndicator(props) {
  let {
    dropState,
    dragAndDropHooks
  } = useListViewContext();
  const {
    target,
    isPresentationOnly
  } = props;
  assert(!!dragAndDropHooks.useDropIndicator, "dragAndDropHooks.useDropIndicator is not defined.");
  let ref = (0, import_react46.useRef)(null);
  let {
    dropIndicatorProps
  } = dragAndDropHooks.useDropIndicator(props, dropState, ref);
  let {
    visuallyHiddenProps
  } = $5c3e21d68f1c4674$export$a966af930f325cab();
  let isDropTarget = dropState.isDropTarget(target);
  if (!isDropTarget && dropIndicatorProps["aria-hidden"]) {
    return null;
  }
  let maskColor = tokenSchema.color.background.canvas;
  let borderColor = tokenSchema.color.background.accentEmphasis;
  let borderSize = tokenSchema.size.border.medium;
  let circleSize = tokenSchema.size.space.regular;
  return (0, import_jsx_runtime25.jsx)("div", {
    role: "row",
    "aria-hidden": dropIndicatorProps["aria-hidden"],
    children: (0, import_jsx_runtime25.jsx)("div", {
      role: "gridcell",
      "aria-selected": "false",
      ...toDataAttributes({
        dropTarget: isDropTarget
      }),
      className: classNames(css({
        insetInlineStart: circleSize,
        outline: "none",
        position: "absolute",
        width: `calc(100% - (2 * ${circleSize}))`,
        "&[data-drop-target=true]": {
          borderBottom: `${borderSize} solid ${borderColor}`,
          "&::before": {
            left: `calc(${circleSize} * -1)`
          },
          "&::after": {
            right: `calc(${circleSize} * -1)`
          },
          "&::before, &::after": {
            backgroundColor: maskColor,
            border: `${borderSize} solid ${borderColor}`,
            borderRadius: "50%",
            content: '" "',
            height: circleSize,
            position: "absolute",
            top: `calc(${circleSize} / -2 - ${borderSize} / 2)`,
            width: circleSize,
            zIndex: 5
          }
        }
      })),
      children: !isPresentationOnly && (0, import_jsx_runtime25.jsx)("div", {
        ...visuallyHiddenProps,
        role: "button",
        ...dropIndicatorProps,
        ref
      })
    })
  });
}
function ListViewItem(props) {
  var _draggableItem, _draggableItem2, _dropIndicator, _dropIndicator2;
  let {
    item: item2
  } = props;
  let {
    density,
    dragAndDropHooks,
    dragState,
    dropState,
    isListDraggable,
    isListDroppable,
    layout,
    loadingState,
    overflowMode,
    state
  } = useListViewContext();
  let {
    direction
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let rowRef = (0, import_react46.useRef)(null);
  let {
    isFocusVisible: isFocusVisibleWithin,
    focusProps: focusWithinProps
  } = $f7dceffc5ad7768b$export$4e328f61c538687f({
    within: true
  });
  let {
    isFocusVisible,
    focusProps
  } = $f7dceffc5ad7768b$export$4e328f61c538687f();
  let {
    rowProps,
    gridCellProps,
    isPressed,
    descriptionProps,
    isDisabled,
    allowsSelection,
    hasAction
  } = $4e8b0456ef72939f$export$9610e69494fadfd2({
    node: item2,
    isVirtualized: true,
    shouldSelectOnPressUp: isListDraggable
  }, state, rowRef);
  let isDroppable = isListDroppable && !isDisabled;
  let {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    isDisabled: !allowsSelection && !hasAction
  });
  let {
    checkboxProps
  } = $e52ffc04a4adbd52$export$e29f2573fabbf7b9({
    key: item2.key
  }, state);
  let draggableItem;
  if (isListDraggable) {
    assert(!!(dragAndDropHooks && dragAndDropHooks.useDraggableItem), "useDraggableItem is missing from dragAndDropHooks");
    draggableItem = dragAndDropHooks.useDraggableItem({
      key: item2.key,
      hasDragButton: true
    }, dragState);
    if (isDisabled) {
      draggableItem = null;
    }
  }
  let isDropTarget;
  let dropIndicator;
  let dropIndicatorRef = (0, import_react46.useRef)(null);
  if (isListDroppable) {
    let target = {
      type: "item",
      key: item2.key,
      dropPosition: "on"
    };
    isDropTarget = dropState.isDropTarget(target);
    assert(!!(dragAndDropHooks && dragAndDropHooks.useDropIndicator), "useDropIndicator is missing from dragAndDropHooks");
    dropIndicator = dragAndDropHooks.useDropIndicator({
      target
    }, dropState, dropIndicatorRef);
  }
  let dragButtonRef = (0, import_react46.useRef)(null);
  let {
    buttonProps
  } = $701a24aa0da5b062$export$ea18c227d4417cc3({
    // @ts-expect-error
    ...(_draggableItem = draggableItem) === null || _draggableItem === void 0 ? void 0 : _draggableItem.dragButtonProps,
    elementType: "div"
  }, dragButtonRef);
  let chevron = (0, import_jsx_runtime25.jsx)(Icon, {
    ...toDataAttributes({
      disabled: !hasAction,
      visible: item2.props.hasChildItems
    }),
    color: "neutral",
    src: direction === "ltr" ? chevronRightIcon : chevronLeftIcon,
    "aria-hidden": "true",
    UNSAFE_className: classNames(listViewItemClassList.element("parent-indicator"), css({
      display: "none",
      gridArea: "chevron",
      marginInlineStart: tokenSchema.size.space.regular,
      [`${listViewItemClassList.selector("root")}[data-child-nodes=true] &`]: {
        display: "inline-block",
        visibility: "hidden"
      },
      "&[data-visible=true]": {
        visibility: "visible"
      },
      "&[data-disabled=true]": {
        stroke: tokenSchema.color.alias.foregroundDisabled
      }
    }))
  });
  let showCheckbox = state.selectionManager.selectionMode !== "none" && state.selectionManager.selectionBehavior === "toggle";
  let {
    visuallyHiddenProps
  } = $5c3e21d68f1c4674$export$a966af930f325cab();
  let dropProps = isDroppable ? (
    // @ts-expect-error
    void 0
  ) : (
    // @ts-expect-error
    {
      "aria-hidden": void 0
    }
  );
  const mergedProps = $3ef42575df84b30b$export$9d1611c77c2fe928(
    rowProps,
    // @ts-expect-error
    (_draggableItem2 = draggableItem) === null || _draggableItem2 === void 0 ? void 0 : _draggableItem2.dragProps,
    dropProps,
    hoverProps,
    focusWithinProps,
    focusProps,
    // Remove tab index from list row if performing a screenreader drag. This prevents TalkBack from focusing the row,
    // allowing for single swipe navigation between row drop indicator
    // @ts-expect-error
    (dragAndDropHooks === null || dragAndDropHooks === void 0 ? void 0 : dragAndDropHooks.isVirtualDragging()) && {
      tabIndex: null
    }
  );
  let isFirstRow = item2.prevKey == null;
  let isLastRow = item2.nextKey == null;
  let isFlushWithContainerBottom = false;
  if (isLastRow && loadingState !== "loadingMore") {
    var _layout$getContentSiz, _layout$virtualizer;
    if (((_layout$getContentSiz = layout.getContentSize()) === null || _layout$getContentSiz === void 0 ? void 0 : _layout$getContentSiz.height) >= ((_layout$virtualizer = layout.virtualizer) === null || _layout$virtualizer === void 0 ? void 0 : _layout$virtualizer.getVisibleRect().height)) {
      isFlushWithContainerBottom = true;
    }
  }
  let content3 = isReactText(item2.rendered) ? (0, import_jsx_runtime25.jsx)(Text2, {
    children: item2.rendered
  }) : item2.rendered;
  if (isDisabled) {
    content3 = (0, import_jsx_runtime25.jsx)(KeystarProvider, {
      isDisabled: true,
      children: content3
    });
  }
  return (0, import_jsx_runtime25.jsx)("div", {
    ...mergedProps,
    ...toDataAttributes({
      "flush-last": isFlushWithContainerBottom
    }),
    className: classNames(listViewItemClassList.element("row"), css({
      cursor: "default",
      outline: 0,
      position: "relative",
      /* box shadow for bottom border */
      "&:not([data-flush-last=true])::after": {
        boxShadow: `inset 0 -1px 0 0 ${tokenSchema.color.border.neutral}`,
        content: '" "',
        display: "block",
        insetBlockEnd: 0,
        insetBlockStart: 0,
        insetInlineEnd: 0,
        insetInlineStart: 0,
        pointerEvents: "none",
        position: "absolute",
        zIndex: 3
      }
    })),
    ref: rowRef,
    children: (0, import_jsx_runtime25.jsx)("div", {
      ...toDataAttributes({
        first: isFirstRow || void 0,
        last: isLastRow || void 0,
        // @ts-expect-error
        droppable: isDropTarget || void 0,
        draggable: isListDraggable || void 0,
        focus: isFocusVisible ? "visible" : isFocusVisibleWithin ? "within" : void 0,
        interaction: isPressed ? "press" : isHovered ? "hover" : void 0
      }),
      className: classNames(listViewItemClassList.element("root"), css({
        display: "grid",
        paddingInline: tokenSchema.size.space.medium,
        position: "relative",
        outline: 0,
        // density
        minHeight: tokenSchema.size.element.medium,
        paddingBlock: tokenSchema.size.space.medium,
        [`${listViewClassList.selector("root")}[data-density="compact"] &`]: {
          minHeight: tokenSchema.size.element.regular,
          paddingBlock: tokenSchema.size.space.regular
        },
        [`${listViewClassList.selector("root")}[data-density="spacious"] &`]: {
          minHeight: tokenSchema.size.element.large,
          paddingBlock: tokenSchema.size.space.large
        },
        // variants
        "&[data-draggable=true]": {
          paddingInlineStart: tokenSchema.size.space.small
        },
        // interactions
        '&[data-interaction="hover"]': {
          backgroundColor: tokenSchema.color.alias.backgroundHovered
        },
        '&[data-interaction="press"]': {
          backgroundColor: tokenSchema.color.alias.backgroundPressed
        },
        // focus indicator
        '&[data-focus="visible"]': {
          "&::before": {
            backgroundColor: tokenSchema.color.background.accentEmphasis,
            borderRadius: tokenSchema.size.space.small,
            content: '""',
            insetBlock: 0,
            insetInlineStart: tokenSchema.size.space.xsmall,
            marginBlock: tokenSchema.size.space.xsmall,
            marginInlineEnd: `calc(${tokenSchema.size.space.small} * -1)`,
            position: "absolute",
            width: tokenSchema.size.space.small
          }
        },
        // selected
        [`${listViewItemClassList.selector("row")}[aria-selected="true"] &`]: {
          backgroundColor: tokenSchema.color.alias.backgroundSelected,
          // boxShadow: `0 0 0 ${tokenSchema.size.border.regular} ${tokenSchema.color.alias.focusRing}`,
          '&[data-interaction="hover"], &[data-focus="visible"]': {
            backgroundColor: tokenSchema.color.alias.backgroundSelectedHovered
          }
        }
      })),
      ...gridCellProps,
      children: (0, import_jsx_runtime25.jsxs)(Grid, {
        UNSAFE_className: listViewItemClassList.element("grid"),
        columns: "auto auto auto 1fr minmax(0px, auto) auto auto",
        rows: "1fr auto",
        areas: ["draghandle checkbox thumbnail content actions actionmenu chevron", "draghandle checkbox thumbnail description actions actionmenu chevron"],
        alignItems: "center",
        children: [isListDraggable && (0, import_jsx_runtime25.jsx)("div", {
          className: classNames(css({
            gridArea: "draghandle",
            display: "flex",
            justifyContent: "center",
            width: tokenSchema.size.element.small
          })),
          children: !isDisabled && (0, import_jsx_runtime25.jsx)(FocusRing, {
            children: (0, import_jsx_runtime25.jsx)("div", {
              ...buttonProps,
              className: classNames(listViewItemClassList.element("draghandle"), css({
                outline: 0,
                position: "relative",
                // focus ring
                "::after": {
                  borderRadius: tokenSchema.size.radius.small,
                  content: '""',
                  inset: 0,
                  margin: 0,
                  position: "absolute",
                  transition: transition(["box-shadow", "margin"], {
                    easing: "easeOut"
                  })
                },
                "&[data-focus=visible]::after": {
                  boxShadow: `0 0 0 ${tokenSchema.size.alias.focusRing} ${tokenSchema.color.alias.focusRing}`,
                  margin: `calc(${tokenSchema.size.alias.focusRingGap} * -1)`
                }
              })),
              ref: dragButtonRef,
              draggable: "true",
              children: (0, import_jsx_runtime25.jsx)(Icon, {
                src: gripVerticalIcon,
                color: "neutral"
              })
            })
          })
        }), isListDroppable && !((_dropIndicator = dropIndicator) !== null && _dropIndicator !== void 0 && _dropIndicator.isHidden) && (0, import_jsx_runtime25.jsx)("div", {
          role: "button",
          ...visuallyHiddenProps,
          ...(_dropIndicator2 = dropIndicator) === null || _dropIndicator2 === void 0 ? void 0 : _dropIndicator2.dropIndicatorProps,
          ref: dropIndicatorRef
        }), showCheckbox && (0, import_jsx_runtime25.jsx)(Flex, {
          gridArea: "checkbox",
          alignItems: "center",
          justifyContent: "center",
          children: (0, import_jsx_runtime25.jsx)(Checkbox, {
            ...checkboxProps,
            UNSAFE_className: classNames(listViewItemClassList.element("checkbox"), css({
              paddingInlineEnd: tokenSchema.size.space.regular
            }))
          })
        }), (0, import_jsx_runtime25.jsxs)(SlotProvider, {
          slots: {
            text: {
              color: isDisabled ? "color.alias.foregroundDisabled" : void 0,
              gridArea: "content",
              flexGrow: 1,
              truncate: overflowMode === "truncate",
              weight: "medium",
              UNSAFE_className: listViewItemClassList.element("content")
            },
            description: {
              color: isDisabled ? "color.alias.foregroundDisabled" : "neutralSecondary",
              size: "small",
              gridArea: "description",
              flexGrow: 1,
              marginTop: "regular",
              truncate: overflowMode === "truncate",
              UNSAFE_className: listViewItemClassList.element("description"),
              ...descriptionProps
            },
            image: {
              borderRadius: "xsmall",
              gridArea: "thumbnail",
              marginEnd: "regular",
              overflow: "hidden",
              height: density === "compact" ? "element.small" : "element.regular",
              UNSAFE_className: listViewItemClassList.element("thumbnail")
            },
            button: {
              UNSAFE_className: listViewItemClassList.element("actions"),
              prominence: "low",
              gridArea: "actions"
            },
            actionGroup: {
              UNSAFE_className: listViewItemClassList.element("actions"),
              prominence: "low",
              gridArea: "actions",
              density: "compact"
            },
            actionMenu: {
              UNSAFE_className: listViewItemClassList.element("actionmenu"),
              prominence: "low",
              gridArea: "actionmenu"
            }
          },
          children: [content3, (0, import_jsx_runtime25.jsx)(ClearSlots, {
            children: chevron
          })]
        })]
      })
    })
  });
}
function RootDropIndicator() {
  let {
    dropState,
    dragAndDropHooks
  } = useListViewContext();
  let ref = (0, import_react46.useRef)(null);
  assert(!!dragAndDropHooks.useDropIndicator, "dragAndDropHooks.useDropIndicator is not defined.");
  let {
    dropIndicatorProps
  } = dragAndDropHooks.useDropIndicator({
    target: {
      type: "root"
    }
  }, dropState, ref);
  let isDropTarget = dropState.isDropTarget({
    type: "root"
  });
  let {
    visuallyHiddenProps
  } = $5c3e21d68f1c4674$export$a966af930f325cab();
  if (!isDropTarget && dropIndicatorProps["aria-hidden"]) {
    return null;
  }
  return (0, import_jsx_runtime25.jsx)("div", {
    role: "row",
    "aria-hidden": dropIndicatorProps["aria-hidden"],
    children: (0, import_jsx_runtime25.jsx)("div", {
      role: "gridcell",
      "aria-selected": "false",
      children: (0, import_jsx_runtime25.jsx)("div", {
        role: "button",
        ...visuallyHiddenProps,
        ...dropIndicatorProps,
        ref
      })
    })
  });
}
var ROW_HEIGHTS = {
  compact: {
    medium: 32,
    large: 40
  },
  regular: {
    medium: 40,
    large: 50
  },
  spacious: {
    medium: 48,
    large: 60
  }
};
function useListLayout(state, density, overflowMode) {
  let {
    scale
  } = useProvider();
  let collator = $325a3faab7a68acd$export$a16aca283550c30d({
    usage: "search",
    sensitivity: "base"
  });
  let isEmpty2 = state.collection.size === 0;
  let layout = (0, import_react46.useMemo)(
    () => new $61ef60fc9b1041f4$export$cacbb3924155d68e({
      estimatedRowHeight: ROW_HEIGHTS[density][scale],
      padding: 0,
      collator,
      loaderHeight: isEmpty2 ? void 0 : ROW_HEIGHTS[density][scale]
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [collator, scale, density, isEmpty2, overflowMode]
  );
  layout.collection = state.collection;
  layout.disabledKeys = state.disabledKeys;
  return layout;
}
function ListView(props, ref) {
  var _dropState, _droppableCollection;
  let {
    density = "regular",
    loadingState,
    onLoadMore,
    isQuiet,
    overflowMode = "truncate",
    onAction,
    dragAndDropHooks,
    ...otherProps
  } = props;
  let isListDraggable = !!(dragAndDropHooks !== null && dragAndDropHooks !== void 0 && dragAndDropHooks.useDraggableCollectionState);
  let isListDroppable = !!(dragAndDropHooks !== null && dragAndDropHooks !== void 0 && dragAndDropHooks.useDroppableCollectionState);
  let dragHooksProvided = (0, import_react46.useRef)(isListDraggable);
  let dropHooksProvided = (0, import_react46.useRef)(isListDroppable);
  (0, import_react46.useEffect)(() => {
    if (dragHooksProvided.current !== isListDraggable) {
      console.warn("Drag hooks were provided during one render, but not another. This should be avoided as it may produce unexpected behavior.");
    }
    if (dropHooksProvided.current !== isListDroppable) {
      console.warn("Drop hooks were provided during one render, but not another. This should be avoided as it may produce unexpected behavior.");
    }
  }, [isListDraggable, isListDroppable]);
  let domRef = $df56164dff5785e2$export$4338b53315abf666(ref);
  let state = $e72dd72e1c76a225$export$2f645645f7bca764({
    ...props,
    selectionBehavior: props.selectionStyle === "highlight" ? "replace" : "toggle"
  });
  let {
    collection: collection2,
    selectionManager
  } = state;
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages4);
  let isLoading = loadingState === "loading" || loadingState === "loadingMore";
  let styleProps = useStyleProps(props);
  let preview = (0, import_react46.useRef)(null);
  let dragState = (() => {
    if (dragAndDropHooks != null && dragAndDropHooks.useDraggableCollectionState && dragAndDropHooks.useDraggableCollection) {
      let state2 = dragAndDropHooks.useDraggableCollectionState({
        collection: collection2,
        selectionManager,
        preview
      });
      dragAndDropHooks.useDraggableCollection({}, state2, domRef);
      return state2;
    }
  })();
  let layout = useListLayout(state, props.density || "regular", overflowMode);
  layout.allowDisabledKeyFocus = state.selectionManager.disabledBehavior === "selection" || !!(dragState !== null && dragState !== void 0 && dragState.draggingKeys.size);
  let DragPreview$1 = dragAndDropHooks === null || dragAndDropHooks === void 0 ? void 0 : dragAndDropHooks.DragPreview;
  let dropState;
  let droppableCollection;
  let isRootDropTarget;
  if (dragAndDropHooks && dragAndDropHooks.useDroppableCollectionState && dragAndDropHooks.useDroppableCollection) {
    dropState = dragAndDropHooks.useDroppableCollectionState({
      collection: collection2,
      selectionManager
    });
    droppableCollection = dragAndDropHooks.useDroppableCollection({
      keyboardDelegate: layout,
      dropTargetDelegate: layout
    }, dropState, domRef);
    isRootDropTarget = dropState.isDropTarget({
      type: "root"
    });
  }
  let {
    gridProps
  } = $f47efb0c3a859cf2$export$664f9155035607eb({
    ...props,
    isVirtualized: true,
    keyboardDelegate: layout,
    onAction
  }, state, domRef);
  layout.isLoading = isLoading;
  let focusedKey = selectionManager.focusedKey;
  if (((_dropState = dropState) === null || _dropState === void 0 || (_dropState = _dropState.target) === null || _dropState === void 0 ? void 0 : _dropState.type) === "item") {
    focusedKey = dropState.target.key;
  }
  let hasAnyChildren = (0, import_react46.useMemo)(() => [...collection2].some((item2) => item2.hasChildNodes), [collection2]);
  return (0, import_jsx_runtime25.jsxs)(ListViewProvider, {
    value: {
      density,
      // @ts-expect-error
      dragAndDropHooks,
      // @ts-expect-error
      dragState,
      // @ts-expect-error
      dropState,
      isListDraggable,
      isListDroppable,
      // @ts-expect-error
      layout,
      // @ts-expect-error
      loadingState,
      // @ts-expect-error
      onAction,
      overflowMode,
      state
    },
    children: [(0, import_jsx_runtime25.jsx)($9bf71ea28793e738$export$20e40289641fbbb6, {
      children: (0, import_jsx_runtime25.jsx)(FocusRing, {
        children: (0, import_jsx_runtime25.jsx)($6d0a5c394373ae64$export$89be5a243e59c4b2, {
          ...$3ef42575df84b30b$export$9d1611c77c2fe928(
            // @ts-expect-error
            isListDroppable ? (_droppableCollection = droppableCollection) === null || _droppableCollection === void 0 ? void 0 : _droppableCollection.collectionProps : {},
            gridProps
          ),
          ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
          ...gridProps,
          ...styleProps,
          ...toDataAttributes({
            childNodes: hasAnyChildren,
            density,
            draggable: isListDraggable,
            // @ts-expect-error
            dropTarget: isRootDropTarget,
            overflowMode
          }),
          isLoading,
          onLoadMore,
          ref: domRef,
          focusedKey,
          scrollDirection: "vertical",
          className: classNames(listViewClassList.element("root"), css({
            backgroundColor: tokenSchema.color.background.canvas,
            border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.neutral}`,
            borderRadius: tokenSchema.size.radius.medium,
            boxSizing: "content-box",
            // resolves measurement/scroll issues related to border
            outline: 0,
            overflow: "auto",
            position: "relative",
            transform: "translate3d(0, 0, 0)",
            userSelect: "none",
            "&[data-drop-target=true]": {
              borderColor: tokenSchema.color.alias.focusRing,
              backgroundColor: tokenSchema.color.alias.backgroundSelected,
              boxShadow: `inset 0 0 0 1px ${tokenSchema.color.alias.focusRing}`
            },
            "&[data-focus=visible]": {
              borderColor: tokenSchema.color.alias.focusRing,
              boxShadow: `inset 0 0 0 1px ${tokenSchema.color.alias.focusRing}`
            }
          }), styleProps.className),
          layout,
          collection: collection2,
          transitionDuration: isLoading ? 160 : 220,
          children: (type2, item2) => {
            if (type2 === "item") {
              return (0, import_jsx_runtime25.jsxs)(import_jsx_runtime25.Fragment, {
                children: [isListDroppable && collection2.getKeyBefore(item2.key) == null && (0, import_jsx_runtime25.jsx)(RootDropIndicator, {}, "root"), isListDroppable && (0, import_jsx_runtime25.jsx)(InsertionIndicator, {
                  target: {
                    key: item2.key,
                    type: "item",
                    dropPosition: "before"
                  }
                }, `${item2.key}-before`), (0, import_jsx_runtime25.jsx)(ListViewItem, {
                  item: item2,
                  isEmphasized: true,
                  hasActions: !!onAction
                }), isListDroppable && (0, import_jsx_runtime25.jsx)(InsertionIndicator, {
                  target: {
                    key: item2.key,
                    type: "item",
                    dropPosition: "after"
                  },
                  isPresentationOnly: collection2.getKeyAfter(item2.key) != null
                }, `${item2.key}-after`)]
              });
            } else if (type2 === "loader") {
              return (0, import_jsx_runtime25.jsx)(CenteredWrapper, {
                children: (0, import_jsx_runtime25.jsx)(ProgressCircle, {
                  isIndeterminate: true,
                  size: density === "compact" ? "small" : void 0,
                  "aria-label": collection2.size > 0 ? stringFormatter.format("loadingMore") : stringFormatter.format("loading")
                })
              });
            } else if (type2 === "placeholder") {
              let emptyState = props.renderEmptyState ? props.renderEmptyState() : null;
              if (emptyState == null) {
                return null;
              }
              return (0, import_jsx_runtime25.jsx)(CenteredWrapper, {
                children: emptyState
              });
            }
          }
        })
      })
    }), DragPreview$1 && isListDraggable && (0, import_jsx_runtime25.jsx)(DragPreview$1, {
      ref: preview,
      children: () => {
        let item2 = state.collection.getItem(dragState.draggedKey);
        assert(item2 != null, "Dragged item must exist in collection.");
        let itemCount = dragState.draggingKeys.size;
        let itemHeight = layout.getLayoutInfo(dragState.draggedKey).rect.height;
        return (0, import_jsx_runtime25.jsx)(DragPreview, {
          item: item2,
          itemCount,
          itemHeight,
          density
        });
      }
    })]
  });
}
function CenteredWrapper({
  children
}) {
  let {
    state
  } = useListViewContext();
  return (0, import_jsx_runtime25.jsx)("div", {
    role: "row",
    "aria-rowindex": state.collection.size + 1,
    "data-has-items": state.collection.size > 0,
    className: classNames(listViewClassList.element("centered-wrapper"), css({
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      height: "100%",
      width: "100%",
      // if there's items it must be loading—add a gutter between the items
      // and the loading indicator
      "&[data-has-items=true]": {
        paddingTop: tokenSchema.size.space.regular
      }
    })),
    children: (0, import_jsx_runtime25.jsx)("div", {
      role: "gridcell",
      children
    })
  });
}
var _ListView = import_react46.default.forwardRef(ListView);

// node_modules/@react-aria/tooltip/dist/import.mjs
var import_react47 = __toESM(require_react(), 1);
function $326e436e94273fe1$export$1c4b08e0eca38426(props, state) {
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let { hoverProps } = (0, $6179b936705e76d3$export$ae780daf29e6d456)({
    onHoverStart: () => state === null || state === void 0 ? void 0 : state.open(true),
    onHoverEnd: () => state === null || state === void 0 ? void 0 : state.close()
  });
  return {
    tooltipProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, hoverProps, {
      role: "tooltip"
    })
  };
}
function $4e1b34546679e357$export$a6da6c504e4bba8b(props, state, ref) {
  let { isDisabled, trigger: trigger2 } = props;
  let tooltipId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  let isHovered = (0, import_react47.useRef)(false);
  let isFocused = (0, import_react47.useRef)(false);
  let handleShow = () => {
    if (isHovered.current || isFocused.current)
      state.open(isFocused.current);
  };
  let handleHide = (immediate) => {
    if (!isHovered.current && !isFocused.current)
      state.close(immediate);
  };
  (0, import_react47.useEffect)(() => {
    let onKeyDown = (e6) => {
      if (ref && ref.current) {
        if (e6.key === "Escape") {
          e6.stopPropagation();
          state.close(true);
        }
      }
    };
    if (state.isOpen) {
      document.addEventListener("keydown", onKeyDown, true);
      return () => {
        document.removeEventListener("keydown", onKeyDown, true);
      };
    }
  }, [
    ref,
    state
  ]);
  let onHoverStart = () => {
    if (trigger2 === "focus")
      return;
    if ((0, $507fabe10e71c6fb$export$630ff653c5ada6a9)() === "pointer")
      isHovered.current = true;
    else
      isHovered.current = false;
    handleShow();
  };
  let onHoverEnd = () => {
    if (trigger2 === "focus")
      return;
    isFocused.current = false;
    isHovered.current = false;
    handleHide();
  };
  let onPressStart = () => {
    isFocused.current = false;
    isHovered.current = false;
    handleHide(true);
  };
  let onFocus = () => {
    let isVisible2 = (0, $507fabe10e71c6fb$export$b9b3dfddab17db27)();
    if (isVisible2) {
      isFocused.current = true;
      handleShow();
    }
  };
  let onBlur = () => {
    isFocused.current = false;
    isHovered.current = false;
    handleHide(true);
  };
  let { hoverProps } = (0, $6179b936705e76d3$export$ae780daf29e6d456)({
    isDisabled,
    onHoverStart,
    onHoverEnd
  });
  let { focusableProps } = (0, $e6afbd83fe6ebbd2$export$4c014de7c8940b4c)({
    isDisabled,
    onFocus,
    onBlur
  }, ref);
  return {
    triggerProps: {
      "aria-describedby": state.isOpen ? tooltipId : void 0,
      ...(0, $3ef42575df84b30b$export$9d1611c77c2fe928)(focusableProps, hoverProps, {
        onPointerDown: onPressStart,
        onKeyDown: onPressStart
      })
    },
    tooltipProps: {
      id: tooltipId
    }
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-tooltip.js
var import_react49 = __toESM(require_react());
var import_jsx_runtime26 = __toESM(require_jsx_runtime());

// node_modules/@react-stately/tooltip/dist/import.mjs
var import_react48 = __toESM(require_react(), 1);
var $8796f90736e175cb$var$TOOLTIP_DELAY = 1500;
var $8796f90736e175cb$var$TOOLTIP_COOLDOWN = 500;
var $8796f90736e175cb$var$tooltips = {};
var $8796f90736e175cb$var$tooltipId = 0;
var $8796f90736e175cb$var$globalWarmedUp = false;
var $8796f90736e175cb$var$globalWarmUpTimeout = null;
var $8796f90736e175cb$var$globalCooldownTimeout = null;
function $8796f90736e175cb$export$4d40659c25ecb50b(props = {}) {
  let { delay = $8796f90736e175cb$var$TOOLTIP_DELAY, closeDelay = $8796f90736e175cb$var$TOOLTIP_COOLDOWN } = props;
  let { isOpen, open, close } = (0, $fc909762b330b746$export$61c6a8c84e605fb6)(props);
  let id2 = (0, import_react48.useMemo)(() => `${++$8796f90736e175cb$var$tooltipId}`, []);
  let closeTimeout = (0, import_react48.useRef)();
  let ensureTooltipEntry = () => {
    $8796f90736e175cb$var$tooltips[id2] = hideTooltip;
  };
  let closeOpenTooltips = () => {
    for (let hideTooltipId in $8796f90736e175cb$var$tooltips)
      if (hideTooltipId !== id2) {
        $8796f90736e175cb$var$tooltips[hideTooltipId](true);
        delete $8796f90736e175cb$var$tooltips[hideTooltipId];
      }
  };
  let showTooltip = () => {
    clearTimeout(closeTimeout.current);
    closeTimeout.current = null;
    closeOpenTooltips();
    ensureTooltipEntry();
    $8796f90736e175cb$var$globalWarmedUp = true;
    open();
    if ($8796f90736e175cb$var$globalWarmUpTimeout) {
      clearTimeout($8796f90736e175cb$var$globalWarmUpTimeout);
      $8796f90736e175cb$var$globalWarmUpTimeout = null;
    }
    if ($8796f90736e175cb$var$globalCooldownTimeout) {
      clearTimeout($8796f90736e175cb$var$globalCooldownTimeout);
      $8796f90736e175cb$var$globalCooldownTimeout = null;
    }
  };
  let hideTooltip = (immediate) => {
    if (immediate || closeDelay <= 0) {
      clearTimeout(closeTimeout.current);
      closeTimeout.current = null;
      close();
    } else if (!closeTimeout.current)
      closeTimeout.current = setTimeout(() => {
        closeTimeout.current = null;
        close();
      }, closeDelay);
    if ($8796f90736e175cb$var$globalWarmUpTimeout) {
      clearTimeout($8796f90736e175cb$var$globalWarmUpTimeout);
      $8796f90736e175cb$var$globalWarmUpTimeout = null;
    }
    if ($8796f90736e175cb$var$globalWarmedUp) {
      if ($8796f90736e175cb$var$globalCooldownTimeout)
        clearTimeout($8796f90736e175cb$var$globalCooldownTimeout);
      $8796f90736e175cb$var$globalCooldownTimeout = setTimeout(() => {
        delete $8796f90736e175cb$var$tooltips[id2];
        $8796f90736e175cb$var$globalCooldownTimeout = null;
        $8796f90736e175cb$var$globalWarmedUp = false;
      }, Math.max($8796f90736e175cb$var$TOOLTIP_COOLDOWN, closeDelay));
    }
  };
  let warmupTooltip = () => {
    closeOpenTooltips();
    ensureTooltipEntry();
    if (!isOpen && !$8796f90736e175cb$var$globalWarmUpTimeout && !$8796f90736e175cb$var$globalWarmedUp)
      $8796f90736e175cb$var$globalWarmUpTimeout = setTimeout(() => {
        $8796f90736e175cb$var$globalWarmUpTimeout = null;
        $8796f90736e175cb$var$globalWarmedUp = true;
        showTooltip();
      }, delay);
    else if (!isOpen)
      showTooltip();
  };
  (0, import_react48.useEffect)(() => {
    return () => {
      clearTimeout(closeTimeout.current);
      let tooltip = $8796f90736e175cb$var$tooltips[id2];
      if (tooltip)
        delete $8796f90736e175cb$var$tooltips[id2];
    };
  }, [
    id2
  ]);
  return {
    isOpen,
    open: (immediate) => {
      if (!immediate && delay > 0 && !closeTimeout.current)
        warmupTooltip();
      else
        showTooltip();
    },
    close: hideTooltip
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-tooltip.js
var TooltipContext = import_react49.default.createContext({});
var Tooltip = (0, import_react49.forwardRef)(function Tooltip2(props, forwardedRef) {
  let {
    state,
    targetRef: triggerRef,
    overlayRef: tooltipRef,
    crossOffset,
    offset,
    ...contextualProps
  } = (0, import_react49.useContext)(TooltipContext);
  props = $3ef42575df84b30b$export$9d1611c77c2fe928(props, contextualProps);
  let {
    isOpen,
    tone,
    ...otherProps
  } = props;
  let targetGapToken = tokenSchema.size.space.regular;
  let {
    tooltipProps
  } = $326e436e94273fe1$export$1c4b08e0eca38426(contextualProps, state);
  let styleProps = useStyleProps(otherProps);
  let ref = (0, import_react49.useRef)(null);
  let overlayRef = $df56164dff5785e2$export$4338b53315abf666(tooltipRef ? $5dc95899b306f630$export$c9058316764c140e(tooltipRef, forwardedRef) : forwardedRef);
  let targetRef = triggerRef !== null && triggerRef !== void 0 ? triggerRef : ref;
  let slots = (0, import_react49.useMemo)(() => ({
    icon: {
      size: "small",
      color: "inherit"
    },
    text: {
      size: "small",
      color: "inherit"
    },
    kbd: {
      size: "small",
      color: "inherit"
    }
  }), []);
  let preferredPlacement = contextualProps.placement || "top";
  let {
    overlayProps,
    arrowProps,
    placement: resolvedPlacement
  } = $2a41e45df1593e64$export$d39e1813b3bdd0e1({
    ...contextualProps,
    placement: preferredPlacement,
    isOpen: state === null || state === void 0 ? void 0 : state.isOpen,
    overlayRef,
    targetRef
  });
  let placement = (resolvedPlacement || preferredPlacement).split(" ")[0];
  return (0, import_jsx_runtime26.jsxs)("div", {
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(overlayProps, tooltipProps),
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
    ...toDataAttributes({
      placement,
      tone,
      open: isOpen || void 0
    }),
    ref: overlayRef,
    className: classNames(css({
      backgroundColor: tokenSchema.color.background.inverse,
      color: tokenSchema.color.foreground.inverse,
      borderRadius: tokenSchema.size.radius.small,
      maxWidth: tokenSchema.size.alias.singleLineWidth,
      minHeight: tokenSchema.size.element.small,
      paddingBlock: tokenSchema.size.space.regular,
      paddingInline: tokenSchema.size.space.regular,
      opacity: 0,
      pointerEvents: "none",
      transition: transition(["opacity", "transform"]),
      userSelect: "none",
      '&[data-tone="accent"]': {
        backgroundColor: tokenSchema.color.background.accentEmphasis,
        color: tokenSchema.color.foreground.onEmphasis
      },
      '&[data-tone="critical"]': {
        backgroundColor: tokenSchema.color.background.criticalEmphasis,
        color: tokenSchema.color.foreground.onEmphasis
      },
      '&[data-tone="positive"]': {
        backgroundColor: tokenSchema.color.background.positiveEmphasis,
        color: tokenSchema.color.foreground.onEmphasis
      },
      // animate towards placement, away from the trigger
      '&[data-placement="top"]': {
        marginBottom: targetGapToken,
        transform: `translateY(calc(${targetGapToken} * 0.5))`
      },
      '&[data-placement="bottom"]': {
        marginTop: targetGapToken,
        transform: `translateY(calc(${targetGapToken} * -0.5))`
      },
      '&[data-placement="left"], [dir=ltr] &[data-placement="start"], [dir=rtl] &[data-placement="end"]': {
        marginRight: targetGapToken,
        transform: `translateX(calc(${targetGapToken} * 0.5))`
      },
      '&[data-placement="right"], [dir=ltr] &[data-placement="end"], [dir=rtl] &[data-placement="start"]': {
        marginLeft: targetGapToken,
        transform: `translateX(calc(${targetGapToken} * -0.5))`
      },
      '&[data-open="true"]': {
        opacity: 1,
        transform: `translate(0)`
      }
    }), styleProps.className),
    style: {
      ...overlayProps.style,
      ...tooltipProps.style,
      ...styleProps.style
    },
    children: [(0, import_jsx_runtime26.jsx)("div", {
      className: css({
        alignItems: "center",
        boxSizing: "border-box",
        display: "flex",
        gap: tokenSchema.size.space.small
      }),
      children: (0, import_jsx_runtime26.jsx)(SlotProvider, {
        slots,
        children: props.children && (isReactText(props.children) ? (0, import_jsx_runtime26.jsx)(Text2, {
          children: props.children
        }) : props.children)
      })
    }), (0, import_jsx_runtime26.jsx)(DirectionIndicator, {
      ...arrowProps,
      fill: toneToFill[tone !== null && tone !== void 0 ? tone : "neutral"],
      placement,
      size: "xsmall"
    })]
  });
});
var toneToFill = {
  accent: "accent",
  critical: "critical",
  neutral: "inverse",
  positive: "positive"
};
var MOUSE_REST_TIMEOUT = 600;
function TooltipTrigger(props) {
  let {
    children,
    isDisabled,
    trigger: triggerMode,
    ...otherProps
  } = props;
  let targetRef = (0, import_react49.useRef)(null);
  let overlayRef = (0, import_react49.useRef)(null);
  let state = $8796f90736e175cb$export$4d40659c25ecb50b({
    isDisabled,
    delay: MOUSE_REST_TIMEOUT,
    trigger: triggerMode,
    ...props
  });
  let {
    triggerProps,
    tooltipProps
  } = $4e1b34546679e357$export$a6da6c504e4bba8b({
    isDisabled,
    trigger: triggerMode
  }, state, targetRef);
  let [triggerElement, tooltipElement] = import_react49.default.Children.toArray(children);
  return (0, import_jsx_runtime26.jsxs)($e6afbd83fe6ebbd2$export$13f3202a3e5ddd5, {
    ...triggerProps,
    ref: targetRef,
    children: [triggerElement, (0, import_jsx_runtime26.jsx)(TooltipContext.Provider, {
      value: {
        overlayRef,
        targetRef,
        state,
        ...otherProps,
        ...tooltipProps
      },
      children: (0, import_jsx_runtime26.jsx)(Overlay, {
        isOpen: state.isOpen,
        nodeRef: overlayRef,
        children: tooltipElement
      })
    })]
  });
}
TooltipTrigger.getCollectionNode = function* (props) {
  let childArray = [];
  import_react49.default.Children.forEach(props.children, (child) => {
    if (import_react49.default.isValidElement(child)) {
      childArray.push(child);
    }
  });
  let [trigger2, tooltip] = childArray;
  yield {
    element: trigger2,
    wrapper: (element4) => (0, import_jsx_runtime26.jsxs)(TooltipTrigger, {
      ...props,
      children: [element4, tooltip]
    }, element4.key)
  };
};
var _TooltipTrigger = TooltipTrigger;

// node_modules/slate-react/dist/index.es.js
var import_direction = __toESM(require_direction());
var import_debounce = __toESM(require_debounce());
var import_throttle = __toESM(require_throttle());
var import_react50 = __toESM(require_react());

// node_modules/slate-react/node_modules/compute-scroll-into-view/dist/index.mjs
function t2(t5) {
  return "object" == typeof t5 && null != t5 && 1 === t5.nodeType;
}
function e(t5, e6) {
  return (!e6 || "hidden" !== t5) && "visible" !== t5 && "clip" !== t5;
}
function n2(t5, n6) {
  if (t5.clientHeight < t5.scrollHeight || t5.clientWidth < t5.scrollWidth) {
    var r7 = getComputedStyle(t5, null);
    return e(r7.overflowY, n6) || e(r7.overflowX, n6) || function(t6) {
      var e6 = function(t7) {
        if (!t7.ownerDocument || !t7.ownerDocument.defaultView)
          return null;
        try {
          return t7.ownerDocument.defaultView.frameElement;
        } catch (t8) {
          return null;
        }
      }(t6);
      return !!e6 && (e6.clientHeight < t6.scrollHeight || e6.clientWidth < t6.scrollWidth);
    }(t5);
  }
  return false;
}
function r3(t5, e6, n6, r7, i6, o5, l7, d5) {
  return o5 < t5 && l7 > e6 || o5 > t5 && l7 < e6 ? 0 : o5 <= t5 && d5 <= n6 || l7 >= e6 && d5 >= n6 ? o5 - t5 - r7 : l7 > e6 && d5 < n6 || o5 < t5 && d5 > n6 ? l7 - e6 + i6 : 0;
}
var i2 = function(e6, i6) {
  var o5 = window, l7 = i6.scrollMode, d5 = i6.block, f6 = i6.inline, h3 = i6.boundary, u4 = i6.skipOverflowHiddenElements, s4 = "function" == typeof h3 ? h3 : function(t5) {
    return t5 !== h3;
  };
  if (!t2(e6))
    throw new TypeError("Invalid target");
  for (var a3, c5, g4 = document.scrollingElement || document.documentElement, p5 = [], m3 = e6; t2(m3) && s4(m3); ) {
    if ((m3 = null == (c5 = (a3 = m3).parentElement) ? a3.getRootNode().host || null : c5) === g4) {
      p5.push(m3);
      break;
    }
    null != m3 && m3 === document.body && n2(m3) && !n2(document.documentElement) || null != m3 && n2(m3, u4) && p5.push(m3);
  }
  for (var w2 = o5.visualViewport ? o5.visualViewport.width : innerWidth, v6 = o5.visualViewport ? o5.visualViewport.height : innerHeight, W3 = window.scrollX || pageXOffset, H2 = window.scrollY || pageYOffset, b2 = e6.getBoundingClientRect(), y4 = b2.height, E3 = b2.width, M2 = b2.top, V = b2.right, x4 = b2.bottom, I3 = b2.left, C3 = "start" === d5 || "nearest" === d5 ? M2 : "end" === d5 ? x4 : M2 + y4 / 2, R2 = "center" === f6 ? I3 + E3 / 2 : "end" === f6 ? V : I3, T2 = [], k2 = 0; k2 < p5.length; k2++) {
    var B3 = p5[k2], D2 = B3.getBoundingClientRect(), O2 = D2.height, X2 = D2.width, Y2 = D2.top, L2 = D2.right, S2 = D2.bottom, j4 = D2.left;
    if ("if-needed" === l7 && M2 >= 0 && I3 >= 0 && x4 <= v6 && V <= w2 && M2 >= Y2 && x4 <= S2 && I3 >= j4 && V <= L2)
      return T2;
    var N2 = getComputedStyle(B3), q2 = parseInt(N2.borderLeftWidth, 10), z3 = parseInt(N2.borderTopWidth, 10), A3 = parseInt(N2.borderRightWidth, 10), F = parseInt(N2.borderBottomWidth, 10), G2 = 0, J = 0, K = "offsetWidth" in B3 ? B3.offsetWidth - B3.clientWidth - q2 - A3 : 0, P3 = "offsetHeight" in B3 ? B3.offsetHeight - B3.clientHeight - z3 - F : 0, Q2 = "offsetWidth" in B3 ? 0 === B3.offsetWidth ? 0 : X2 / B3.offsetWidth : 0, U2 = "offsetHeight" in B3 ? 0 === B3.offsetHeight ? 0 : O2 / B3.offsetHeight : 0;
    if (g4 === B3)
      G2 = "start" === d5 ? C3 : "end" === d5 ? C3 - v6 : "nearest" === d5 ? r3(H2, H2 + v6, v6, z3, F, H2 + C3, H2 + C3 + y4, y4) : C3 - v6 / 2, J = "start" === f6 ? R2 : "center" === f6 ? R2 - w2 / 2 : "end" === f6 ? R2 - w2 : r3(W3, W3 + w2, w2, q2, A3, W3 + R2, W3 + R2 + E3, E3), G2 = Math.max(0, G2 + H2), J = Math.max(0, J + W3);
    else {
      G2 = "start" === d5 ? C3 - Y2 - z3 : "end" === d5 ? C3 - S2 + F + P3 : "nearest" === d5 ? r3(Y2, S2, O2, z3, F + P3, C3, C3 + y4, y4) : C3 - (Y2 + O2 / 2) + P3 / 2, J = "start" === f6 ? R2 - j4 - q2 : "center" === f6 ? R2 - (j4 + X2 / 2) + K / 2 : "end" === f6 ? R2 - L2 + A3 + K : r3(j4, L2, X2, q2, A3 + K, R2, R2 + E3, E3);
      var Z2 = B3.scrollLeft, $ = B3.scrollTop;
      C3 += $ - (G2 = Math.max(0, Math.min($ + G2 / U2, B3.scrollHeight - O2 / U2 + P3))), R2 += Z2 - (J = Math.max(0, Math.min(Z2 + J / Q2, B3.scrollWidth - X2 / Q2 + K)));
    }
    T2.push({ el: B3, top: G2, left: J });
  }
  return T2;
};

// node_modules/slate-react/node_modules/scroll-into-view-if-needed/es/index.js
function isOptionsObject(options) {
  return options === Object(options) && Object.keys(options).length !== 0;
}
function defaultBehavior(actions, behavior) {
  if (behavior === void 0) {
    behavior = "auto";
  }
  var canSmoothScroll = "scrollBehavior" in document.body.style;
  actions.forEach(function(_ref) {
    var el = _ref.el, top = _ref.top, left = _ref.left;
    if (el.scroll && canSmoothScroll) {
      el.scroll({
        top,
        left,
        behavior
      });
    } else {
      el.scrollTop = top;
      el.scrollLeft = left;
    }
  });
}
function getOptions(options) {
  if (options === false) {
    return {
      block: "end",
      inline: "nearest"
    };
  }
  if (isOptionsObject(options)) {
    return options;
  }
  return {
    block: "start",
    inline: "nearest"
  };
}
function scrollIntoView(target, options) {
  var isTargetAttached = target.isConnected || target.ownerDocument.documentElement.contains(target);
  if (isOptionsObject(options) && typeof options.behavior === "function") {
    return options.behavior(isTargetAttached ? i2(target, options) : []);
  }
  if (!isTargetAttached) {
    return;
  }
  var computeOptions = getOptions(options);
  return defaultBehavior(i2(target, computeOptions), computeOptions.behavior);
}
var es_default = scrollIntoView;

// node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js
var resizeObservers = [];

// node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js
var hasActiveObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.activeTargets.length > 0;
  });
};

// node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js
var hasSkippedObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.skippedTargets.length > 0;
  });
};

// node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js
var msg = "ResizeObserver loop completed with undelivered notifications.";
var deliverResizeLoopError = function() {
  var event;
  if (typeof ErrorEvent === "function") {
    event = new ErrorEvent("error", {
      message: msg
    });
  } else {
    event = document.createEvent("Event");
    event.initEvent("error", false, false);
    event.message = msg;
  }
  window.dispatchEvent(event);
};

// node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js
var ResizeObserverBoxOptions;
(function(ResizeObserverBoxOptions2) {
  ResizeObserverBoxOptions2["BORDER_BOX"] = "border-box";
  ResizeObserverBoxOptions2["CONTENT_BOX"] = "content-box";
  ResizeObserverBoxOptions2["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));

// node_modules/@juggle/resize-observer/lib/utils/freeze.js
var freeze = function(obj) {
  return Object.freeze(obj);
};

// node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js
var ResizeObserverSize = /* @__PURE__ */ function() {
  function ResizeObserverSize2(inlineSize, blockSize) {
    this.inlineSize = inlineSize;
    this.blockSize = blockSize;
    freeze(this);
  }
  return ResizeObserverSize2;
}();

// node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js
var DOMRectReadOnly = function() {
  function DOMRectReadOnly2(x4, y4, width, height) {
    this.x = x4;
    this.y = y4;
    this.width = width;
    this.height = height;
    this.top = this.y;
    this.left = this.x;
    this.bottom = this.top + this.height;
    this.right = this.left + this.width;
    return freeze(this);
  }
  DOMRectReadOnly2.prototype.toJSON = function() {
    var _a3 = this, x4 = _a3.x, y4 = _a3.y, top = _a3.top, right = _a3.right, bottom = _a3.bottom, left = _a3.left, width = _a3.width, height = _a3.height;
    return { x: x4, y: y4, top, right, bottom, left, width, height };
  };
  DOMRectReadOnly2.fromRect = function(rectangle) {
    return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
  };
  return DOMRectReadOnly2;
}();

// node_modules/@juggle/resize-observer/lib/utils/element.js
var isSVG = function(target) {
  return target instanceof SVGElement && "getBBox" in target;
};
var isHidden = function(target) {
  if (isSVG(target)) {
    var _a3 = target.getBBox(), width = _a3.width, height = _a3.height;
    return !width && !height;
  }
  var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
  return !(offsetWidth || offsetHeight || target.getClientRects().length);
};
var isElement2 = function(obj) {
  var _a3;
  if (obj instanceof Element) {
    return true;
  }
  var scope = (_a3 = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a3 === void 0 ? void 0 : _a3.defaultView;
  return !!(scope && obj instanceof scope.Element);
};
var isReplacedElement = function(target) {
  switch (target.tagName) {
    case "INPUT":
      if (target.type !== "image") {
        break;
      }
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return true;
  }
  return false;
};

// node_modules/@juggle/resize-observer/lib/utils/global.js
var global2 = typeof window !== "undefined" ? window : {};

// node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js
var cache2 = /* @__PURE__ */ new WeakMap();
var scrollRegexp = /auto|scroll/;
var verticalRegexp = /^tb|vertical/;
var IE = /msie|trident/i.test(global2.navigator && global2.navigator.userAgent);
var parseDimension = function(pixel) {
  return parseFloat(pixel || "0");
};
var size2 = function(inlineSize, blockSize, switchSizes) {
  if (inlineSize === void 0) {
    inlineSize = 0;
  }
  if (blockSize === void 0) {
    blockSize = 0;
  }
  if (switchSizes === void 0) {
    switchSizes = false;
  }
  return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
};
var zeroBoxes = freeze({
  devicePixelContentBoxSize: size2(),
  borderBoxSize: size2(),
  contentBoxSize: size2(),
  contentRect: new DOMRectReadOnly(0, 0, 0, 0)
});
var calculateBoxSizes = function(target, forceRecalculation) {
  if (forceRecalculation === void 0) {
    forceRecalculation = false;
  }
  if (cache2.has(target) && !forceRecalculation) {
    return cache2.get(target);
  }
  if (isHidden(target)) {
    cache2.set(target, zeroBoxes);
    return zeroBoxes;
  }
  var cs = getComputedStyle(target);
  var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
  var removePadding = !IE && cs.boxSizing === "border-box";
  var switchSizes = verticalRegexp.test(cs.writingMode || "");
  var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || "");
  var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || "");
  var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
  var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
  var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
  var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
  var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
  var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
  var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
  var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
  var horizontalPadding = paddingLeft + paddingRight;
  var verticalPadding = paddingTop + paddingBottom;
  var horizontalBorderArea = borderLeft + borderRight;
  var verticalBorderArea = borderTop + borderBottom;
  var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
  var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
  var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
  var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
  var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
  var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
  var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
  var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
  var boxes = freeze({
    devicePixelContentBoxSize: size2(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
    borderBoxSize: size2(borderBoxWidth, borderBoxHeight, switchSizes),
    contentBoxSize: size2(contentWidth, contentHeight, switchSizes),
    contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
  });
  cache2.set(target, boxes);
  return boxes;
};
var calculateBoxSize = function(target, observedBox, forceRecalculation) {
  var _a3 = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a3.borderBoxSize, contentBoxSize = _a3.contentBoxSize, devicePixelContentBoxSize = _a3.devicePixelContentBoxSize;
  switch (observedBox) {
    case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
      return devicePixelContentBoxSize;
    case ResizeObserverBoxOptions.BORDER_BOX:
      return borderBoxSize;
    default:
      return contentBoxSize;
  }
};

// node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js
var ResizeObserverEntry = /* @__PURE__ */ function() {
  function ResizeObserverEntry2(target) {
    var boxes = calculateBoxSizes(target);
    this.target = target;
    this.contentRect = boxes.contentRect;
    this.borderBoxSize = freeze([boxes.borderBoxSize]);
    this.contentBoxSize = freeze([boxes.contentBoxSize]);
    this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
  }
  return ResizeObserverEntry2;
}();

// node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js
var calculateDepthForNode = function(node4) {
  if (isHidden(node4)) {
    return Infinity;
  }
  var depth = 0;
  var parent = node4.parentNode;
  while (parent) {
    depth += 1;
    parent = parent.parentNode;
  }
  return depth;
};

// node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js
var broadcastActiveObservations = function() {
  var shallowestDepth = Infinity;
  var callbacks2 = [];
  resizeObservers.forEach(function processObserver(ro) {
    if (ro.activeTargets.length === 0) {
      return;
    }
    var entries2 = [];
    ro.activeTargets.forEach(function processTarget(ot) {
      var entry = new ResizeObserverEntry(ot.target);
      var targetDepth = calculateDepthForNode(ot.target);
      entries2.push(entry);
      ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
      if (targetDepth < shallowestDepth) {
        shallowestDepth = targetDepth;
      }
    });
    callbacks2.push(function resizeObserverCallback() {
      ro.callback.call(ro.observer, entries2, ro.observer);
    });
    ro.activeTargets.splice(0, ro.activeTargets.length);
  });
  for (var _i = 0, callbacks_1 = callbacks2; _i < callbacks_1.length; _i++) {
    var callback = callbacks_1[_i];
    callback();
  }
  return shallowestDepth;
};

// node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js
var gatherActiveObservationsAtDepth = function(depth) {
  resizeObservers.forEach(function processObserver(ro) {
    ro.activeTargets.splice(0, ro.activeTargets.length);
    ro.skippedTargets.splice(0, ro.skippedTargets.length);
    ro.observationTargets.forEach(function processTarget(ot) {
      if (ot.isActive()) {
        if (calculateDepthForNode(ot.target) > depth) {
          ro.activeTargets.push(ot);
        } else {
          ro.skippedTargets.push(ot);
        }
      }
    });
  });
};

// node_modules/@juggle/resize-observer/lib/utils/process.js
var process2 = function() {
  var depth = 0;
  gatherActiveObservationsAtDepth(depth);
  while (hasActiveObservations()) {
    depth = broadcastActiveObservations();
    gatherActiveObservationsAtDepth(depth);
  }
  if (hasSkippedObservations()) {
    deliverResizeLoopError();
  }
  return depth > 0;
};

// node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js
var trigger;
var callbacks = [];
var notify = function() {
  return callbacks.splice(0).forEach(function(cb) {
    return cb();
  });
};
var queueMicroTask = function(callback) {
  if (!trigger) {
    var toggle_1 = 0;
    var el_1 = document.createTextNode("");
    var config3 = { characterData: true };
    new MutationObserver(function() {
      return notify();
    }).observe(el_1, config3);
    trigger = function() {
      el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
    };
  }
  callbacks.push(callback);
  trigger();
};

// node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js
var queueResizeObserver = function(cb) {
  queueMicroTask(function ResizeObserver2() {
    requestAnimationFrame(cb);
  });
};

// node_modules/@juggle/resize-observer/lib/utils/scheduler.js
var watching = 0;
var isWatching = function() {
  return !!watching;
};
var CATCH_PERIOD = 250;
var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
var events = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
];
var time = function(timeout) {
  if (timeout === void 0) {
    timeout = 0;
  }
  return Date.now() + timeout;
};
var scheduled = false;
var Scheduler = function() {
  function Scheduler2() {
    var _this = this;
    this.stopped = true;
    this.listener = function() {
      return _this.schedule();
    };
  }
  Scheduler2.prototype.run = function(timeout) {
    var _this = this;
    if (timeout === void 0) {
      timeout = CATCH_PERIOD;
    }
    if (scheduled) {
      return;
    }
    scheduled = true;
    var until = time(timeout);
    queueResizeObserver(function() {
      var elementsHaveResized = false;
      try {
        elementsHaveResized = process2();
      } finally {
        scheduled = false;
        timeout = until - time();
        if (!isWatching()) {
          return;
        }
        if (elementsHaveResized) {
          _this.run(1e3);
        } else if (timeout > 0) {
          _this.run(timeout);
        } else {
          _this.start();
        }
      }
    });
  };
  Scheduler2.prototype.schedule = function() {
    this.stop();
    this.run();
  };
  Scheduler2.prototype.observe = function() {
    var _this = this;
    var cb = function() {
      return _this.observer && _this.observer.observe(document.body, observerConfig);
    };
    document.body ? cb() : global2.addEventListener("DOMContentLoaded", cb);
  };
  Scheduler2.prototype.start = function() {
    var _this = this;
    if (this.stopped) {
      this.stopped = false;
      this.observer = new MutationObserver(this.listener);
      this.observe();
      events.forEach(function(name2) {
        return global2.addEventListener(name2, _this.listener, true);
      });
    }
  };
  Scheduler2.prototype.stop = function() {
    var _this = this;
    if (!this.stopped) {
      this.observer && this.observer.disconnect();
      events.forEach(function(name2) {
        return global2.removeEventListener(name2, _this.listener, true);
      });
      this.stopped = true;
    }
  };
  return Scheduler2;
}();
var scheduler = new Scheduler();
var updateCount = function(n6) {
  !watching && n6 > 0 && scheduler.start();
  watching += n6;
  !watching && scheduler.stop();
};

// node_modules/@juggle/resize-observer/lib/ResizeObservation.js
var skipNotifyOnElement = function(target) {
  return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
};
var ResizeObservation = function() {
  function ResizeObservation2(target, observedBox) {
    this.target = target;
    this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
    this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  ResizeObservation2.prototype.isActive = function() {
    var size3 = calculateBoxSize(this.target, this.observedBox, true);
    if (skipNotifyOnElement(this.target)) {
      this.lastReportedSize = size3;
    }
    if (this.lastReportedSize.inlineSize !== size3.inlineSize || this.lastReportedSize.blockSize !== size3.blockSize) {
      return true;
    }
    return false;
  };
  return ResizeObservation2;
}();

// node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js
var ResizeObserverDetail = /* @__PURE__ */ function() {
  function ResizeObserverDetail2(resizeObserver, callback) {
    this.activeTargets = [];
    this.skippedTargets = [];
    this.observationTargets = [];
    this.observer = resizeObserver;
    this.callback = callback;
  }
  return ResizeObserverDetail2;
}();

// node_modules/@juggle/resize-observer/lib/ResizeObserverController.js
var observerMap = /* @__PURE__ */ new WeakMap();
var getObservationIndex = function(observationTargets, target) {
  for (var i6 = 0; i6 < observationTargets.length; i6 += 1) {
    if (observationTargets[i6].target === target) {
      return i6;
    }
  }
  return -1;
};
var ResizeObserverController = function() {
  function ResizeObserverController2() {
  }
  ResizeObserverController2.connect = function(resizeObserver, callback) {
    var detail = new ResizeObserverDetail(resizeObserver, callback);
    observerMap.set(resizeObserver, detail);
  };
  ResizeObserverController2.observe = function(resizeObserver, target, options) {
    var detail = observerMap.get(resizeObserver);
    var firstObservation = detail.observationTargets.length === 0;
    if (getObservationIndex(detail.observationTargets, target) < 0) {
      firstObservation && resizeObservers.push(detail);
      detail.observationTargets.push(new ResizeObservation(target, options && options.box));
      updateCount(1);
      scheduler.schedule();
    }
  };
  ResizeObserverController2.unobserve = function(resizeObserver, target) {
    var detail = observerMap.get(resizeObserver);
    var index3 = getObservationIndex(detail.observationTargets, target);
    var lastObservation = detail.observationTargets.length === 1;
    if (index3 >= 0) {
      lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
      detail.observationTargets.splice(index3, 1);
      updateCount(-1);
    }
  };
  ResizeObserverController2.disconnect = function(resizeObserver) {
    var _this = this;
    var detail = observerMap.get(resizeObserver);
    detail.observationTargets.slice().forEach(function(ot) {
      return _this.unobserve(resizeObserver, ot.target);
    });
    detail.activeTargets.splice(0, detail.activeTargets.length);
  };
  return ResizeObserverController2;
}();

// node_modules/@juggle/resize-observer/lib/ResizeObserver.js
var ResizeObserver = function() {
  function ResizeObserver2(callback) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (typeof callback !== "function") {
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    }
    ResizeObserverController.connect(this, callback);
  }
  ResizeObserver2.prototype.observe = function(target, options) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement2(target)) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.observe(this, target, options);
  };
  ResizeObserver2.prototype.unobserve = function(target) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement2(target)) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.unobserve(this, target);
  };
  ResizeObserver2.prototype.disconnect = function() {
    ResizeObserverController.disconnect(this);
  };
  ResizeObserver2.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  };
  return ResizeObserver2;
}();

// node_modules/slate-react/dist/index.es.js
var import_is_hotkey = __toESM(require_lib2());
var import_react_dom5 = __toESM(require_react_dom());
function _defineProperty2(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i6;
  for (i6 = 0; i6 < sourceKeys.length; i6++) {
    key = sourceKeys[i6];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties2(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose2(source, excluded);
  var key, i6;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i6 = 0; i6 < sourceSymbolKeys.length; i6++) {
      key = sourceSymbolKeys[i6];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
var n3 = 0;
var Key = class {
  constructor() {
    this.id = "".concat(n3++);
  }
};
var NODE_TO_INDEX = /* @__PURE__ */ new WeakMap();
var NODE_TO_PARENT = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_WINDOW = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_ELEMENT = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_PLACEHOLDER_ELEMENT = /* @__PURE__ */ new WeakMap();
var ELEMENT_TO_NODE = /* @__PURE__ */ new WeakMap();
var NODE_TO_ELEMENT = /* @__PURE__ */ new WeakMap();
var NODE_TO_KEY = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_KEY_TO_ELEMENT = /* @__PURE__ */ new WeakMap();
var IS_READ_ONLY = /* @__PURE__ */ new WeakMap();
var IS_FOCUSED = /* @__PURE__ */ new WeakMap();
var IS_COMPOSING = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_USER_SELECTION = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_ON_CHANGE = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_SCHEDULE_FLUSH = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_PENDING_INSERTION_MARKS = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_USER_MARKS = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_PENDING_DIFFS = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_PENDING_ACTION = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_PENDING_SELECTION = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_FORCE_RENDER = /* @__PURE__ */ new WeakMap();
var PLACEHOLDER_SYMBOL = Symbol("placeholder");
var MARK_PLACEHOLDER_SYMBOL = Symbol("mark-placeholder");
var DOMText = globalThis.Text;
var getDefaultView = (value2) => {
  return value2 && value2.ownerDocument && value2.ownerDocument.defaultView || null;
};
var isDOMComment = (value2) => {
  return isDOMNode(value2) && value2.nodeType === 8;
};
var isDOMElement = (value2) => {
  return isDOMNode(value2) && value2.nodeType === 1;
};
var isDOMNode = (value2) => {
  var window2 = getDefaultView(value2);
  return !!window2 && value2 instanceof window2.Node;
};
var isDOMSelection = (value2) => {
  var window2 = value2 && value2.anchorNode && getDefaultView(value2.anchorNode);
  return !!window2 && value2 instanceof window2.Selection;
};
var isDOMText = (value2) => {
  return isDOMNode(value2) && value2.nodeType === 3;
};
var isPlainTextOnlyPaste = (event) => {
  return event.clipboardData && event.clipboardData.getData("text/plain") !== "" && event.clipboardData.types.length === 1;
};
var normalizeDOMPoint = (domPoint) => {
  var [node4, offset] = domPoint;
  if (isDOMElement(node4) && node4.childNodes.length) {
    var isLast = offset === node4.childNodes.length;
    var index3 = isLast ? offset - 1 : offset;
    [node4, index3] = getEditableChildAndIndex(node4, index3, isLast ? "backward" : "forward");
    isLast = index3 < offset;
    while (isDOMElement(node4) && node4.childNodes.length) {
      var i6 = isLast ? node4.childNodes.length - 1 : 0;
      node4 = getEditableChild(node4, i6, isLast ? "backward" : "forward");
    }
    offset = isLast && node4.textContent != null ? node4.textContent.length : 0;
  }
  return [node4, offset];
};
var hasShadowRoot = (node4) => {
  var parent = node4 && node4.parentNode;
  while (parent) {
    if (parent.toString() === "[object ShadowRoot]") {
      return true;
    }
    parent = parent.parentNode;
  }
  return false;
};
var getEditableChildAndIndex = (parent, index3, direction) => {
  var {
    childNodes
  } = parent;
  var child = childNodes[index3];
  var i6 = index3;
  var triedForward = false;
  var triedBackward = false;
  while (isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute("contenteditable") === "false") {
    if (triedForward && triedBackward) {
      break;
    }
    if (i6 >= childNodes.length) {
      triedForward = true;
      i6 = index3 - 1;
      direction = "backward";
      continue;
    }
    if (i6 < 0) {
      triedBackward = true;
      i6 = index3 + 1;
      direction = "forward";
      continue;
    }
    child = childNodes[i6];
    index3 = i6;
    i6 += direction === "forward" ? 1 : -1;
  }
  return [child, index3];
};
var getEditableChild = (parent, index3, direction) => {
  var [child] = getEditableChildAndIndex(parent, index3, direction);
  return child;
};
var getPlainText = (domNode) => {
  var text7 = "";
  if (isDOMText(domNode) && domNode.nodeValue) {
    return domNode.nodeValue;
  }
  if (isDOMElement(domNode)) {
    for (var childNode of Array.from(domNode.childNodes)) {
      text7 += getPlainText(childNode);
    }
    var display = getComputedStyle(domNode).getPropertyValue("display");
    if (display === "block" || display === "list" || domNode.tagName === "BR") {
      text7 += "\n";
    }
  }
  return text7;
};
var catchSlateFragment = /data-slate-fragment="(.+?)"/m;
var getSlateFragmentAttribute = (dataTransfer) => {
  var htmlData = dataTransfer.getData("text/html");
  var [, fragment] = htmlData.match(catchSlateFragment) || [];
  return fragment;
};
var isTrackedMutation = (editor, mutation, batch) => {
  var {
    target
  } = mutation;
  if (isDOMElement(target) && target.matches('[contentEditable="false"]')) {
    return false;
  }
  var {
    document: document5
  } = ReactEditor.getWindow(editor);
  if (document5.contains(target)) {
    return ReactEditor.hasDOMNode(editor, target, {
      editable: true
    });
  }
  var parentMutation = batch.find((_ref) => {
    var {
      addedNodes,
      removedNodes
    } = _ref;
    for (var node4 of addedNodes) {
      if (node4 === target || node4.contains(target)) {
        return true;
      }
    }
    for (var _node of removedNodes) {
      if (_node === target || _node.contains(target)) {
        return true;
      }
    }
  });
  if (!parentMutation || parentMutation === mutation) {
    return false;
  }
  return isTrackedMutation(editor, parentMutation, batch);
};
var IS_REACT_VERSION_17_OR_ABOVE = parseInt(import_react50.default.version.split(".")[0], 10) >= 17;
var IS_IOS = typeof navigator !== "undefined" && typeof window !== "undefined" && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
var IS_APPLE = typeof navigator !== "undefined" && /Mac OS X/.test(navigator.userAgent);
var IS_ANDROID = typeof navigator !== "undefined" && /Android/.test(navigator.userAgent);
var IS_FIREFOX = typeof navigator !== "undefined" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
var IS_SAFARI = typeof navigator !== "undefined" && /Version\/[\d\.]+.*Safari/.test(navigator.userAgent);
var IS_EDGE_LEGACY = typeof navigator !== "undefined" && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])(?:\.)/i.test(navigator.userAgent);
var IS_CHROME = typeof navigator !== "undefined" && /Chrome/i.test(navigator.userAgent);
var IS_CHROME_LEGACY = typeof navigator !== "undefined" && /Chrome?\/(?:[0-7][0-5]|[0-6][0-9])(?:\.)/i.test(navigator.userAgent);
var IS_ANDROID_CHROME_LEGACY = IS_ANDROID && typeof navigator !== "undefined" && /Chrome?\/(?:[0-5]?\d)(?:\.)/i.test(navigator.userAgent);
var IS_FIREFOX_LEGACY = typeof navigator !== "undefined" && /^(?!.*Seamonkey)(?=.*Firefox\/(?:[0-7][0-9]|[0-8][0-6])(?:\.)).*/i.test(navigator.userAgent);
var IS_UC_MOBILE = typeof navigator !== "undefined" && /.*UCBrowser/.test(navigator.userAgent);
var IS_WECHATBROWSER = typeof navigator !== "undefined" && /.*Wechat/.test(navigator.userAgent);
var CAN_USE_DOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
var HAS_BEFORE_INPUT_SUPPORT = (!IS_CHROME_LEGACY || !IS_ANDROID_CHROME_LEGACY) && !IS_EDGE_LEGACY && // globalThis is undefined in older browsers
typeof globalThis !== "undefined" && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.
typeof globalThis.InputEvent.prototype.getTargetRanges === "function";
var ReactEditor = {
  /**
   * Check if the user is currently composing inside the editor.
   */
  isComposing(editor) {
    return !!IS_COMPOSING.get(editor);
  },
  /**
   * Return the host window of the current editor.
   */
  getWindow(editor) {
    var window2 = EDITOR_TO_WINDOW.get(editor);
    if (!window2) {
      throw new Error("Unable to find a host window element for this editor");
    }
    return window2;
  },
  /**
   * Find a key for a Slate node.
   */
  findKey(editor, node4) {
    var key = NODE_TO_KEY.get(node4);
    if (!key) {
      key = new Key();
      NODE_TO_KEY.set(node4, key);
    }
    return key;
  },
  /**
   * Find the path of Slate node.
   */
  findPath(editor, node4) {
    var path3 = [];
    var child = node4;
    while (true) {
      var parent = NODE_TO_PARENT.get(child);
      if (parent == null) {
        if (Editor.isEditor(child)) {
          return path3;
        } else {
          break;
        }
      }
      var i6 = NODE_TO_INDEX.get(child);
      if (i6 == null) {
        break;
      }
      path3.unshift(i6);
      child = parent;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Scrubber.stringify(node4)));
  },
  /**
   * Find the DOM node that implements DocumentOrShadowRoot for the editor.
   */
  findDocumentOrShadowRoot(editor) {
    var el = ReactEditor.toDOMNode(editor, editor);
    var root = el.getRootNode();
    if ((root instanceof Document || root instanceof ShadowRoot) && root.getSelection != null) {
      return root;
    }
    return el.ownerDocument;
  },
  /**
   * Check if the editor is focused.
   */
  isFocused(editor) {
    return !!IS_FOCUSED.get(editor);
  },
  /**
   * Check if the editor is in read-only mode.
   */
  isReadOnly(editor) {
    return !!IS_READ_ONLY.get(editor);
  },
  /**
   * Blur the editor.
   */
  blur(editor) {
    var el = ReactEditor.toDOMNode(editor, editor);
    var root = ReactEditor.findDocumentOrShadowRoot(editor);
    IS_FOCUSED.set(editor, false);
    if (root.activeElement === el) {
      el.blur();
    }
  },
  /**
   * Focus the editor.
   */
  focus(editor) {
    var el = ReactEditor.toDOMNode(editor, editor);
    var root = ReactEditor.findDocumentOrShadowRoot(editor);
    IS_FOCUSED.set(editor, true);
    if (root.activeElement !== el) {
      el.focus({
        preventScroll: true
      });
    }
  },
  /**
   * Deselect the editor.
   */
  deselect(editor) {
    var {
      selection
    } = editor;
    var root = ReactEditor.findDocumentOrShadowRoot(editor);
    var domSelection = root.getSelection();
    if (domSelection && domSelection.rangeCount > 0) {
      domSelection.removeAllRanges();
    }
    if (selection) {
      Transforms.deselect(editor);
    }
  },
  /**
   * Check if a DOM node is within the editor.
   */
  hasDOMNode(editor, target) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      editable = false
    } = options;
    var editorEl = ReactEditor.toDOMNode(editor, editor);
    var targetEl;
    try {
      targetEl = isDOMElement(target) ? target : target.parentElement;
    } catch (err) {
      if (!err.message.includes('Permission denied to access property "nodeType"')) {
        throw err;
      }
    }
    if (!targetEl) {
      return false;
    }
    return targetEl.closest("[data-slate-editor]") === editorEl && (!editable || targetEl.isContentEditable ? true : typeof targetEl.isContentEditable === "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    targetEl.closest('[contenteditable="false"]') === editorEl || !!targetEl.getAttribute("data-slate-zero-width"));
  },
  /**
   * Insert data from a `DataTransfer` into the editor.
   */
  insertData(editor, data) {
    editor.insertData(data);
  },
  /**
   * Insert fragment data from a `DataTransfer` into the editor.
   */
  insertFragmentData(editor, data) {
    return editor.insertFragmentData(data);
  },
  /**
   * Insert text data from a `DataTransfer` into the editor.
   */
  insertTextData(editor, data) {
    return editor.insertTextData(data);
  },
  /**
   * Sets data from the currently selected fragment on a `DataTransfer`.
   */
  setFragmentData(editor, data, originEvent) {
    editor.setFragmentData(data, originEvent);
  },
  /**
   * Find the native DOM element from a Slate node.
   */
  toDOMNode(editor, node4) {
    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);
    var domNode = Editor.isEditor(node4) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.get(ReactEditor.findKey(editor, node4));
    if (!domNode) {
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Scrubber.stringify(node4)));
    }
    return domNode;
  },
  /**
   * Find a native DOM selection point from a Slate point.
   */
  toDOMPoint(editor, point3) {
    var [node4] = Editor.node(editor, point3.path);
    var el = ReactEditor.toDOMNode(editor, node4);
    var domPoint;
    if (Editor.void(editor, {
      at: point3
    })) {
      point3 = {
        path: point3.path,
        offset: 0
      };
    }
    var selector = "[data-slate-string], [data-slate-zero-width]";
    var texts = Array.from(el.querySelectorAll(selector));
    var start2 = 0;
    for (var i6 = 0; i6 < texts.length; i6++) {
      var text7 = texts[i6];
      var domNode = text7.childNodes[0];
      if (domNode == null || domNode.textContent == null) {
        continue;
      }
      var {
        length: length4
      } = domNode.textContent;
      var attr = text7.getAttribute("data-slate-length");
      var trueLength = attr == null ? length4 : parseInt(attr, 10);
      var end = start2 + trueLength;
      var nextText = texts[i6 + 1];
      if (point3.offset === end && nextText !== null && nextText !== void 0 && nextText.hasAttribute("data-slate-mark-placeholder")) {
        var _nextText$textContent;
        var domText = nextText.childNodes[0];
        domPoint = [
          // COMPAT: If we don't explicity set the dom point to be on the actual
          // dom text element, chrome will put the selection behind the actual dom
          // text element, causing domRange.getBoundingClientRect() calls on a collapsed
          // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
          // which will cause issues when scrolling to it.
          domText instanceof DOMText ? domText : nextText,
          (_nextText$textContent = nextText.textContent) !== null && _nextText$textContent !== void 0 && _nextText$textContent.startsWith("\uFEFF") ? 1 : 0
        ];
        break;
      }
      if (point3.offset <= end) {
        var offset = Math.min(length4, Math.max(0, point3.offset - start2));
        domPoint = [domNode, offset];
        break;
      }
      start2 = end;
    }
    if (!domPoint) {
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Scrubber.stringify(point3)));
    }
    return domPoint;
  },
  /**
   * Find a native DOM range from a Slate `range`.
   *
   * Notice: the returned range will always be ordinal regardless of the direction of Slate `range` due to DOM API limit.
   *
   * there is no way to create a reverse DOM Range using Range.setStart/setEnd
   * according to https://dom.spec.whatwg.org/#concept-range-bp-set.
   */
  toDOMRange(editor, range) {
    var {
      anchor,
      focus
    } = range;
    var isBackward = Range.isBackward(range);
    var domAnchor = ReactEditor.toDOMPoint(editor, anchor);
    var domFocus = Range.isCollapsed(range) ? domAnchor : ReactEditor.toDOMPoint(editor, focus);
    var window2 = ReactEditor.getWindow(editor);
    var domRange = window2.document.createRange();
    var [startNode, startOffset] = isBackward ? domFocus : domAnchor;
    var [endNode, endOffset] = isBackward ? domAnchor : domFocus;
    var startEl = isDOMElement(startNode) ? startNode : startNode.parentElement;
    var isStartAtZeroWidth = !!startEl.getAttribute("data-slate-zero-width");
    var endEl = isDOMElement(endNode) ? endNode : endNode.parentElement;
    var isEndAtZeroWidth = !!endEl.getAttribute("data-slate-zero-width");
    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset);
    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset);
    return domRange;
  },
  /**
   * Find a Slate node from a native DOM `element`.
   */
  toSlateNode(editor, domNode) {
    var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;
    if (domEl && !domEl.hasAttribute("data-slate-node")) {
      domEl = domEl.closest("[data-slate-node]");
    }
    var node4 = domEl ? ELEMENT_TO_NODE.get(domEl) : null;
    if (!node4) {
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(domEl));
    }
    return node4;
  },
  /**
   * Get the target range from a DOM `event`.
   */
  findEventRange(editor, event) {
    if ("nativeEvent" in event) {
      event = event.nativeEvent;
    }
    var {
      clientX: x4,
      clientY: y4,
      target
    } = event;
    if (x4 == null || y4 == null) {
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(event));
    }
    var node4 = ReactEditor.toSlateNode(editor, event.target);
    var path3 = ReactEditor.findPath(editor, node4);
    if (Element2.isElement(node4) && Editor.isVoid(editor, node4)) {
      var rect = target.getBoundingClientRect();
      var isPrev = editor.isInline(node4) ? x4 - rect.left < rect.left + rect.width - x4 : y4 - rect.top < rect.top + rect.height - y4;
      var edge = Editor.point(editor, path3, {
        edge: isPrev ? "start" : "end"
      });
      var point3 = isPrev ? Editor.before(editor, edge) : Editor.after(editor, edge);
      if (point3) {
        var _range = Editor.range(editor, point3);
        return _range;
      }
    }
    var domRange;
    var {
      document: document5
    } = ReactEditor.getWindow(editor);
    if (document5.caretRangeFromPoint) {
      domRange = document5.caretRangeFromPoint(x4, y4);
    } else {
      var position3 = document5.caretPositionFromPoint(x4, y4);
      if (position3) {
        domRange = document5.createRange();
        domRange.setStart(position3.offsetNode, position3.offset);
        domRange.setEnd(position3.offsetNode, position3.offset);
      }
    }
    if (!domRange) {
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(event));
    }
    var range = ReactEditor.toSlateRange(editor, domRange, {
      exactMatch: false,
      suppressThrow: false
    });
    return range;
  },
  /**
   * Find a Slate point from a DOM selection's `domNode` and `domOffset`.
   */
  toSlatePoint(editor, domPoint, options) {
    var {
      exactMatch,
      suppressThrow
    } = options;
    var [nearestNode, nearestOffset] = exactMatch ? domPoint : normalizeDOMPoint(domPoint);
    var parentNode = nearestNode.parentNode;
    var textNode = null;
    var offset = 0;
    if (parentNode) {
      var _domNode$textContent, _domNode$textContent2;
      var editorEl = ReactEditor.toDOMNode(editor, editor);
      var potentialVoidNode = parentNode.closest('[data-slate-void="true"]');
      var voidNode = potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null;
      var leafNode = parentNode.closest("[data-slate-leaf]");
      var domNode = null;
      if (leafNode) {
        textNode = leafNode.closest('[data-slate-node="text"]');
        if (textNode) {
          var window2 = ReactEditor.getWindow(editor);
          var range = window2.document.createRange();
          range.setStart(textNode, 0);
          range.setEnd(nearestNode, nearestOffset);
          var contents = range.cloneContents();
          var removals = [...Array.prototype.slice.call(contents.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(contents.querySelectorAll("[contenteditable=false]"))];
          removals.forEach((el) => {
            if (IS_ANDROID && !exactMatch && el.hasAttribute("data-slate-zero-width") && el.textContent.length > 0 && el.textContext !== "\uFEFF") {
              if (el.textContent.startsWith("\uFEFF")) {
                el.textContent = el.textContent.slice(1);
              }
              return;
            }
            el.parentNode.removeChild(el);
          });
          offset = contents.textContent.length;
          domNode = textNode;
        }
      } else if (voidNode) {
        var leafNodes = voidNode.querySelectorAll("[data-slate-leaf]");
        for (var index3 = 0; index3 < leafNodes.length; index3++) {
          var current = leafNodes[index3];
          if (ReactEditor.hasDOMNode(editor, current)) {
            leafNode = current;
            break;
          }
        }
        if (!leafNode) {
          offset = 1;
        } else {
          textNode = leafNode.closest('[data-slate-node="text"]');
          domNode = leafNode;
          offset = domNode.textContent.length;
          domNode.querySelectorAll("[data-slate-zero-width]").forEach((el) => {
            offset -= el.textContent.length;
          });
        }
      }
      if (domNode && offset === domNode.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      IS_ANDROID && domNode.getAttribute("data-slate-zero-width") === "z" && (_domNode$textContent = domNode.textContent) !== null && _domNode$textContent !== void 0 && _domNode$textContent.startsWith("\uFEFF") && (parentNode.hasAttribute("data-slate-zero-width") || IS_FIREFOX && (_domNode$textContent2 = domNode.textContent) !== null && _domNode$textContent2 !== void 0 && _domNode$textContent2.endsWith("\n\n"))) {
        offset--;
      }
    }
    if (IS_ANDROID && !textNode && !exactMatch) {
      var node4 = parentNode.hasAttribute("data-slate-node") ? parentNode : parentNode.closest("[data-slate-node]");
      if (node4 && ReactEditor.hasDOMNode(editor, node4, {
        editable: true
      })) {
        var _slateNode = ReactEditor.toSlateNode(editor, node4);
        var {
          path: _path,
          offset: _offset
        } = Editor.start(editor, ReactEditor.findPath(editor, _slateNode));
        if (!node4.querySelector("[data-slate-leaf]")) {
          _offset = nearestOffset;
        }
        return {
          path: _path,
          offset: _offset
        };
      }
    }
    if (!textNode) {
      if (suppressThrow) {
        return null;
      }
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(domPoint));
    }
    var slateNode = ReactEditor.toSlateNode(editor, textNode);
    var path3 = ReactEditor.findPath(editor, slateNode);
    return {
      path: path3,
      offset
    };
  },
  /**
   * Find a Slate range from a DOM range or selection.
   */
  toSlateRange(editor, domRange, options) {
    var {
      exactMatch,
      suppressThrow
    } = options;
    var el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer;
    var anchorNode;
    var anchorOffset;
    var focusNode;
    var focusOffset;
    var isCollapsed;
    if (el) {
      if (isDOMSelection(domRange)) {
        anchorNode = domRange.anchorNode;
        anchorOffset = domRange.anchorOffset;
        focusNode = domRange.focusNode;
        focusOffset = domRange.focusOffset;
        if (IS_CHROME && hasShadowRoot(anchorNode)) {
          isCollapsed = domRange.anchorNode === domRange.focusNode && domRange.anchorOffset === domRange.focusOffset;
        } else {
          isCollapsed = domRange.isCollapsed;
        }
      } else {
        anchorNode = domRange.startContainer;
        anchorOffset = domRange.startOffset;
        focusNode = domRange.endContainer;
        focusOffset = domRange.endOffset;
        isCollapsed = domRange.collapsed;
      }
    }
    if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(domRange));
    }
    if ("getAttribute" in focusNode && focusNode.getAttribute("contenteditable") === "false") {
      var _anchorNode$textConte;
      focusNode = anchorNode;
      focusOffset = ((_anchorNode$textConte = anchorNode.textContent) === null || _anchorNode$textConte === void 0 ? void 0 : _anchorNode$textConte.length) || 0;
    }
    var anchor = ReactEditor.toSlatePoint(editor, [anchorNode, anchorOffset], {
      exactMatch,
      suppressThrow
    });
    if (!anchor) {
      return null;
    }
    var focus = isCollapsed ? anchor : ReactEditor.toSlatePoint(editor, [focusNode, focusOffset], {
      exactMatch,
      suppressThrow
    });
    if (!focus) {
      return null;
    }
    if (IS_FIREFOX && !isCollapsed && anchorNode !== focusNode) {
      var isEnd = Editor.isEnd(editor, anchor, anchor.path);
      var isStart = Editor.isStart(editor, focus, focus.path);
      if (isEnd) {
        var after = Editor.after(editor, anchor);
        anchor = after || anchor;
      }
      if (isStart) {
        var before = Editor.before(editor, focus);
        focus = before || focus;
      }
    }
    var range = {
      anchor,
      focus
    };
    if (Range.isExpanded(range) && Range.isForward(range) && isDOMElement(focusNode) && Editor.void(editor, {
      at: range.focus,
      mode: "highest"
    })) {
      range = Editor.unhangRange(editor, range, {
        voids: true
      });
    }
    return range;
  },
  hasRange(editor, range) {
    var {
      anchor,
      focus
    } = range;
    return Editor.hasPath(editor, anchor.path) && Editor.hasPath(editor, focus.path);
  },
  /**
   * Check if the target is in the editor.
   */
  hasTarget(editor, target) {
    return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target);
  },
  /**
   * Check if the target is editable and in the editor.
   */
  hasEditableTarget(editor, target) {
    return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target, {
      editable: true
    });
  },
  /**
   * Check if the target can be selectable
   */
  hasSelectableTarget(editor, target) {
    return ReactEditor.hasEditableTarget(editor, target) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, target);
  },
  /**
   * Check if the target is inside void and in an non-readonly editor.
   */
  isTargetInsideNonReadonlyVoid(editor, target) {
    if (IS_READ_ONLY.get(editor))
      return false;
    var slateNode = ReactEditor.hasTarget(editor, target) && ReactEditor.toSlateNode(editor, target);
    return Element2.isElement(slateNode) && Editor.isVoid(editor, slateNode);
  },
  /**
   * Experimental and android specific: Flush all pending diffs and cancel composition at the next possible time.
   */
  androidScheduleFlush(editor) {
    var _EDITOR_TO_SCHEDULE_F;
    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(editor)) === null || _EDITOR_TO_SCHEDULE_F === void 0 ? void 0 : _EDITOR_TO_SCHEDULE_F();
  },
  /**
   * Experimental and android specific: Get pending diffs
   */
  androidPendingDiffs(editor) {
    return EDITOR_TO_PENDING_DIFFS.get(editor);
  }
};
var _excluded$32 = ["anchor", "focus"];
var _excluded2$12 = ["anchor", "focus"];
var shallowCompare = (obj1, obj2) => Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every((key) => obj2.hasOwnProperty(key) && obj1[key] === obj2[key]);
var isDecorationFlagsEqual = (range, other) => {
  var rangeOwnProps = _objectWithoutProperties2(range, _excluded$32);
  var otherOwnProps = _objectWithoutProperties2(other, _excluded2$12);
  return range[PLACEHOLDER_SYMBOL] === other[PLACEHOLDER_SYMBOL] && shallowCompare(rangeOwnProps, otherOwnProps);
};
var isElementDecorationsEqual = (list3, another) => {
  if (list3.length !== another.length) {
    return false;
  }
  for (var i6 = 0; i6 < list3.length; i6++) {
    var range = list3[i6];
    var other = another[i6];
    if (!Range.equals(range, other) || !isDecorationFlagsEqual(range, other)) {
      return false;
    }
  }
  return true;
};
var isTextDecorationsEqual = (list3, another) => {
  if (list3.length !== another.length) {
    return false;
  }
  for (var i6 = 0; i6 < list3.length; i6++) {
    var range = list3[i6];
    var other = another[i6];
    if (range.anchor.offset !== other.anchor.offset || range.focus.offset !== other.focus.offset || !isDecorationFlagsEqual(range, other)) {
      return false;
    }
  }
  return true;
};
var useIsomorphicLayoutEffect = CAN_USE_DOM ? import_react50.useLayoutEffect : import_react50.useEffect;
var String2 = (props) => {
  var {
    isLast,
    leaf,
    parent,
    text: text7
  } = props;
  var editor = useSlateStatic();
  var path3 = ReactEditor.findPath(editor, text7);
  var parentPath = Path.parent(path3);
  var isMarkPlaceholder = leaf[MARK_PLACEHOLDER_SYMBOL] === true;
  if (editor.isVoid(parent)) {
    return import_react50.default.createElement(ZeroWidthString, {
      length: Node3.string(parent).length
    });
  }
  if (leaf.text === "" && parent.children[parent.children.length - 1] === text7 && !editor.isInline(parent) && Editor.string(editor, parentPath) === "") {
    return import_react50.default.createElement(ZeroWidthString, {
      isLineBreak: true,
      isMarkPlaceholder
    });
  }
  if (leaf.text === "") {
    return import_react50.default.createElement(ZeroWidthString, {
      isMarkPlaceholder
    });
  }
  if (isLast && leaf.text.slice(-1) === "\n") {
    return import_react50.default.createElement(TextString, {
      isTrailing: true,
      text: leaf.text
    });
  }
  return import_react50.default.createElement(TextString, {
    text: leaf.text
  });
};
var TextString = (props) => {
  var {
    text: text7,
    isTrailing = false
  } = props;
  var ref = (0, import_react50.useRef)(null);
  var getTextContent = () => {
    return "".concat(text7 !== null && text7 !== void 0 ? text7 : "").concat(isTrailing ? "\n" : "");
  };
  var [initialText] = (0, import_react50.useState)(getTextContent);
  useIsomorphicLayoutEffect(() => {
    var textWithTrailing = getTextContent();
    if (ref.current && ref.current.textContent !== textWithTrailing) {
      ref.current.textContent = textWithTrailing;
    }
  });
  return import_react50.default.createElement(MemoizedText$1, {
    ref
  }, initialText);
};
var MemoizedText$1 = (0, import_react50.memo)((0, import_react50.forwardRef)((props, ref) => {
  return import_react50.default.createElement("span", {
    "data-slate-string": true,
    ref
  }, props.children);
}));
var ZeroWidthString = (props) => {
  var {
    length: length4 = 0,
    isLineBreak = false,
    isMarkPlaceholder = false
  } = props;
  var attributes = {
    "data-slate-zero-width": isLineBreak ? "n" : "z",
    "data-slate-length": length4
  };
  if (isMarkPlaceholder) {
    attributes["data-slate-mark-placeholder"] = true;
  }
  return import_react50.default.createElement("span", Object.assign({}, attributes), !IS_ANDROID || !isLineBreak ? "\uFEFF" : null, isLineBreak ? import_react50.default.createElement("br", null) : null);
};
var EditorContext = (0, import_react50.createContext)(null);
var useSlateStatic = () => {
  var editor = (0, import_react50.useContext)(EditorContext);
  if (!editor) {
    throw new Error("The `useSlateStatic` hook must be used inside the <Slate> component's context.");
  }
  return editor;
};
var Leaf = (props) => {
  var {
    leaf,
    isLast,
    text: text7,
    parent,
    renderPlaceholder,
    renderLeaf: renderLeaf2 = (props2) => import_react50.default.createElement(DefaultLeaf, Object.assign({}, props2))
  } = props;
  var lastPlaceholderRef = (0, import_react50.useRef)(null);
  var placeholderRef = (0, import_react50.useRef)(null);
  var editor = useSlateStatic();
  var placeholderResizeObserver = (0, import_react50.useRef)(null);
  (0, import_react50.useEffect)(() => {
    return () => {
      if (placeholderResizeObserver.current) {
        placeholderResizeObserver.current.disconnect();
      }
    };
  }, []);
  (0, import_react50.useEffect)(() => {
    var placeholderEl = placeholderRef === null || placeholderRef === void 0 ? void 0 : placeholderRef.current;
    if (placeholderEl) {
      EDITOR_TO_PLACEHOLDER_ELEMENT.set(editor, placeholderEl);
    } else {
      EDITOR_TO_PLACEHOLDER_ELEMENT.delete(editor);
    }
    if (placeholderResizeObserver.current) {
      placeholderResizeObserver.current.disconnect();
      if (placeholderEl)
        placeholderResizeObserver.current.observe(placeholderEl);
    } else if (placeholderEl) {
      var ResizeObserver$1 = window.ResizeObserver || ResizeObserver;
      placeholderResizeObserver.current = new ResizeObserver$1(() => {
        var forceRender2 = EDITOR_TO_FORCE_RENDER.get(editor);
        forceRender2 === null || forceRender2 === void 0 ? void 0 : forceRender2();
      });
      placeholderResizeObserver.current.observe(placeholderEl);
    }
    if (!placeholderEl && lastPlaceholderRef.current) {
      var forceRender = EDITOR_TO_FORCE_RENDER.get(editor);
      forceRender === null || forceRender === void 0 ? void 0 : forceRender();
    }
    lastPlaceholderRef.current = placeholderRef.current;
    return () => {
      EDITOR_TO_PLACEHOLDER_ELEMENT.delete(editor);
    };
  }, [placeholderRef, leaf]);
  var children = import_react50.default.createElement(String2, {
    isLast,
    leaf,
    parent,
    text: text7
  });
  if (leaf[PLACEHOLDER_SYMBOL]) {
    var placeholderProps = {
      children: leaf.placeholder,
      attributes: {
        "data-slate-placeholder": true,
        style: {
          position: "absolute",
          pointerEvents: "none",
          width: "100%",
          maxWidth: "100%",
          display: "block",
          opacity: "0.333",
          userSelect: "none",
          textDecoration: "none"
        },
        contentEditable: false,
        ref: placeholderRef
      }
    };
    children = import_react50.default.createElement(import_react50.default.Fragment, null, renderPlaceholder(placeholderProps), children);
  }
  var attributes = {
    "data-slate-leaf": true
  };
  return renderLeaf2({
    attributes,
    children,
    leaf,
    text: text7
  });
};
var MemoizedLeaf = import_react50.default.memo(Leaf, (prev2, next2) => {
  return next2.parent === prev2.parent && next2.isLast === prev2.isLast && next2.renderLeaf === prev2.renderLeaf && next2.renderPlaceholder === prev2.renderPlaceholder && next2.text === prev2.text && Text.equals(next2.leaf, prev2.leaf) && next2.leaf[PLACEHOLDER_SYMBOL] === prev2.leaf[PLACEHOLDER_SYMBOL];
});
var DefaultLeaf = (props) => {
  var {
    attributes,
    children
  } = props;
  return import_react50.default.createElement("span", Object.assign({}, attributes), children);
};
var Text3 = (props) => {
  var {
    decorations,
    isLast,
    parent,
    renderPlaceholder,
    renderLeaf: renderLeaf2,
    text: text7
  } = props;
  var editor = useSlateStatic();
  var ref = (0, import_react50.useRef)(null);
  var leaves = Text.decorations(text7, decorations);
  var key = ReactEditor.findKey(editor, text7);
  var children = [];
  for (var i6 = 0; i6 < leaves.length; i6++) {
    var leaf = leaves[i6];
    children.push(import_react50.default.createElement(MemoizedLeaf, {
      isLast: isLast && i6 === leaves.length - 1,
      key: "".concat(key.id, "-").concat(i6),
      renderPlaceholder,
      leaf,
      text: text7,
      parent,
      renderLeaf: renderLeaf2
    }));
  }
  var callbackRef = (0, import_react50.useCallback)((span) => {
    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);
    if (span) {
      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, span);
      NODE_TO_ELEMENT.set(text7, span);
      ELEMENT_TO_NODE.set(span, text7);
    } else {
      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.delete(key);
      NODE_TO_ELEMENT.delete(text7);
      if (ref.current) {
        ELEMENT_TO_NODE.delete(ref.current);
      }
    }
    ref.current = span;
  }, [ref, editor, key, text7]);
  return import_react50.default.createElement("span", {
    "data-slate-node": "text",
    ref: callbackRef
  }, children);
};
var MemoizedText = import_react50.default.memo(Text3, (prev2, next2) => {
  return next2.parent === prev2.parent && next2.isLast === prev2.isLast && next2.renderLeaf === prev2.renderLeaf && next2.renderPlaceholder === prev2.renderPlaceholder && next2.text === prev2.text && isTextDecorationsEqual(next2.decorations, prev2.decorations);
});
var Element3 = (props) => {
  var {
    decorations,
    element: element4,
    renderElement: renderElement2 = (p5) => import_react50.default.createElement(DefaultElement, Object.assign({}, p5)),
    renderPlaceholder,
    renderLeaf: renderLeaf2,
    selection
  } = props;
  var editor = useSlateStatic();
  var readOnly = useReadOnly();
  var isInline = editor.isInline(element4);
  var key = ReactEditor.findKey(editor, element4);
  var ref = (0, import_react50.useCallback)((ref2) => {
    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);
    if (ref2) {
      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, ref2);
      NODE_TO_ELEMENT.set(element4, ref2);
      ELEMENT_TO_NODE.set(ref2, element4);
    } else {
      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.delete(key);
      NODE_TO_ELEMENT.delete(element4);
    }
  }, [editor, key, element4]);
  var children = useChildren({
    decorations,
    node: element4,
    renderElement: renderElement2,
    renderPlaceholder,
    renderLeaf: renderLeaf2,
    selection
  });
  var attributes = {
    "data-slate-node": "element",
    ref
  };
  if (isInline) {
    attributes["data-slate-inline"] = true;
  }
  if (!isInline && Editor.hasInlines(editor, element4)) {
    var text7 = Node3.string(element4);
    var dir = (0, import_direction.default)(text7);
    if (dir === "rtl") {
      attributes.dir = dir;
    }
  }
  if (Editor.isVoid(editor, element4)) {
    attributes["data-slate-void"] = true;
    if (!readOnly && isInline) {
      attributes.contentEditable = false;
    }
    var Tag2 = isInline ? "span" : "div";
    var [[_text]] = Node3.texts(element4);
    children = import_react50.default.createElement(Tag2, {
      "data-slate-spacer": true,
      style: {
        height: "0",
        color: "transparent",
        outline: "none",
        position: "absolute"
      }
    }, import_react50.default.createElement(MemoizedText, {
      renderPlaceholder,
      decorations: [],
      isLast: false,
      parent: element4,
      text: _text
    }));
    NODE_TO_INDEX.set(_text, 0);
    NODE_TO_PARENT.set(_text, element4);
  }
  return renderElement2({
    attributes,
    children,
    element: element4
  });
};
var MemoizedElement = import_react50.default.memo(Element3, (prev2, next2) => {
  return prev2.element === next2.element && prev2.renderElement === next2.renderElement && prev2.renderLeaf === next2.renderLeaf && prev2.renderPlaceholder === next2.renderPlaceholder && isElementDecorationsEqual(prev2.decorations, next2.decorations) && (prev2.selection === next2.selection || !!prev2.selection && !!next2.selection && Range.equals(prev2.selection, next2.selection));
});
var DefaultElement = (props) => {
  var {
    attributes,
    children,
    element: element4
  } = props;
  var editor = useSlateStatic();
  var Tag2 = editor.isInline(element4) ? "span" : "div";
  return import_react50.default.createElement(Tag2, Object.assign({}, attributes, {
    style: {
      position: "relative"
    }
  }), children);
};
var DecorateContext = (0, import_react50.createContext)(() => []);
var useDecorate = () => {
  return (0, import_react50.useContext)(DecorateContext);
};
var SelectedContext = (0, import_react50.createContext)(false);
var useSelected = () => {
  return (0, import_react50.useContext)(SelectedContext);
};
var useChildren = (props) => {
  var {
    decorations,
    node: node4,
    renderElement: renderElement2,
    renderPlaceholder,
    renderLeaf: renderLeaf2,
    selection
  } = props;
  var decorate = useDecorate();
  var editor = useSlateStatic();
  var path3 = ReactEditor.findPath(editor, node4);
  var children = [];
  var isLeafBlock = Element2.isElement(node4) && !editor.isInline(node4) && Editor.hasInlines(editor, node4);
  for (var i6 = 0; i6 < node4.children.length; i6++) {
    var p5 = path3.concat(i6);
    var n6 = node4.children[i6];
    var key = ReactEditor.findKey(editor, n6);
    var range = Editor.range(editor, p5);
    var sel = selection && Range.intersection(range, selection);
    var ds = decorate([n6, p5]);
    for (var dec of decorations) {
      var d5 = Range.intersection(dec, range);
      if (d5) {
        ds.push(d5);
      }
    }
    if (Element2.isElement(n6)) {
      children.push(import_react50.default.createElement(SelectedContext.Provider, {
        key: "provider-".concat(key.id),
        value: !!sel
      }, import_react50.default.createElement(MemoizedElement, {
        decorations: ds,
        element: n6,
        key: key.id,
        renderElement: renderElement2,
        renderPlaceholder,
        renderLeaf: renderLeaf2,
        selection: sel
      })));
    } else {
      children.push(import_react50.default.createElement(MemoizedText, {
        decorations: ds,
        key: key.id,
        isLast: isLeafBlock && i6 === node4.children.length - 1,
        parent: node4,
        renderPlaceholder,
        renderLeaf: renderLeaf2,
        text: n6
      }));
    }
    NODE_TO_INDEX.set(n6, i6);
    NODE_TO_PARENT.set(n6, node4);
  }
  return children;
};
var ReadOnlyContext = (0, import_react50.createContext)(false);
var useReadOnly = () => {
  return (0, import_react50.useContext)(ReadOnlyContext);
};
var SlateContext = (0, import_react50.createContext)(null);
var useSlate = () => {
  var context = (0, import_react50.useContext)(SlateContext);
  if (!context) {
    throw new Error("The `useSlate` hook must be used inside the <Slate> component's context.");
  }
  var {
    editor
  } = context;
  return editor;
};
var TRIPLE_CLICK = 3;
var HOTKEYS = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
};
var APPLE_HOTKEYS = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
};
var WINDOWS_HOTKEYS = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
};
var create8 = (key) => {
  var generic = HOTKEYS[key];
  var apple = APPLE_HOTKEYS[key];
  var windows = WINDOWS_HOTKEYS[key];
  var isGeneric = generic && (0, import_is_hotkey.isKeyHotkey)(generic);
  var isApple = apple && (0, import_is_hotkey.isKeyHotkey)(apple);
  var isWindows = windows && (0, import_is_hotkey.isKeyHotkey)(windows);
  return (event) => {
    if (isGeneric && isGeneric(event))
      return true;
    if (IS_APPLE && isApple && isApple(event))
      return true;
    if (!IS_APPLE && isWindows && isWindows(event))
      return true;
    return false;
  };
};
var Hotkeys = {
  isBold: create8("bold"),
  isCompose: create8("compose"),
  isMoveBackward: create8("moveBackward"),
  isMoveForward: create8("moveForward"),
  isDeleteBackward: create8("deleteBackward"),
  isDeleteForward: create8("deleteForward"),
  isDeleteLineBackward: create8("deleteLineBackward"),
  isDeleteLineForward: create8("deleteLineForward"),
  isDeleteWordBackward: create8("deleteWordBackward"),
  isDeleteWordForward: create8("deleteWordForward"),
  isExtendBackward: create8("extendBackward"),
  isExtendForward: create8("extendForward"),
  isExtendLineBackward: create8("extendLineBackward"),
  isExtendLineForward: create8("extendLineForward"),
  isItalic: create8("italic"),
  isMoveLineBackward: create8("moveLineBackward"),
  isMoveLineForward: create8("moveLineForward"),
  isMoveWordBackward: create8("moveWordBackward"),
  isMoveWordForward: create8("moveWordForward"),
  isRedo: create8("redo"),
  isSoftBreak: create8("insertSoftBreak"),
  isSplitBlock: create8("splitBlock"),
  isTransposeCharacter: create8("transposeCharacter"),
  isUndo: create8("undo")
};
var createRestoreDomManager = (editor, receivedUserInput) => {
  var bufferedMutations = [];
  var clear2 = () => {
    bufferedMutations = [];
  };
  var registerMutations = (mutations) => {
    if (!receivedUserInput.current) {
      return;
    }
    var trackedMutations = mutations.filter((mutation) => isTrackedMutation(editor, mutation, mutations));
    bufferedMutations.push(...trackedMutations);
  };
  function restoreDOM() {
    if (bufferedMutations.length > 0) {
      bufferedMutations.reverse().forEach((mutation) => {
        if (mutation.type === "characterData") {
          return;
        }
        mutation.removedNodes.forEach((node4) => {
          mutation.target.insertBefore(node4, mutation.nextSibling);
        });
        mutation.addedNodes.forEach((node4) => {
          mutation.target.removeChild(node4);
        });
      });
      clear2();
    }
  }
  return {
    registerMutations,
    restoreDOM,
    clear: clear2
  };
};
var MUTATION_OBSERVER_CONFIG$1 = {
  subtree: true,
  childList: true,
  characterData: true,
  characterDataOldValue: true
};
var RestoreDOMComponent = class extends import_react50.Component {
  constructor() {
    super(...arguments);
    this.context = null;
    this.manager = null;
    this.mutationObserver = null;
  }
  observe() {
    var _this$mutationObserve;
    var {
      node: node4
    } = this.props;
    if (!node4.current) {
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    }
    (_this$mutationObserve = this.mutationObserver) === null || _this$mutationObserve === void 0 ? void 0 : _this$mutationObserve.observe(node4.current, MUTATION_OBSERVER_CONFIG$1);
  }
  componentDidMount() {
    var {
      receivedUserInput
    } = this.props;
    var editor = this.context;
    this.manager = createRestoreDomManager(editor, receivedUserInput);
    this.mutationObserver = new MutationObserver(this.manager.registerMutations);
    this.observe();
  }
  getSnapshotBeforeUpdate() {
    var _this$mutationObserve2, _this$mutationObserve3, _this$manager2;
    var pendingMutations = (_this$mutationObserve2 = this.mutationObserver) === null || _this$mutationObserve2 === void 0 ? void 0 : _this$mutationObserve2.takeRecords();
    if (pendingMutations !== null && pendingMutations !== void 0 && pendingMutations.length) {
      var _this$manager;
      (_this$manager = this.manager) === null || _this$manager === void 0 ? void 0 : _this$manager.registerMutations(pendingMutations);
    }
    (_this$mutationObserve3 = this.mutationObserver) === null || _this$mutationObserve3 === void 0 ? void 0 : _this$mutationObserve3.disconnect();
    (_this$manager2 = this.manager) === null || _this$manager2 === void 0 ? void 0 : _this$manager2.restoreDOM();
    return null;
  }
  componentDidUpdate() {
    var _this$manager3;
    (_this$manager3 = this.manager) === null || _this$manager3 === void 0 ? void 0 : _this$manager3.clear();
    this.observe();
  }
  componentWillUnmount() {
    var _this$mutationObserve4;
    (_this$mutationObserve4 = this.mutationObserver) === null || _this$mutationObserve4 === void 0 ? void 0 : _this$mutationObserve4.disconnect();
  }
  render() {
    return this.props.children;
  }
};
RestoreDOMComponent.contextType = EditorContext;
var RestoreDOM = IS_ANDROID ? RestoreDOMComponent : (_ref) => {
  var {
    children
  } = _ref;
  return import_react50.default.createElement(import_react50.default.Fragment, null, children);
};
function verifyDiffState(editor, textDiff) {
  var {
    path: path3,
    diff
  } = textDiff;
  if (!Editor.hasPath(editor, path3)) {
    return false;
  }
  var node4 = Node3.get(editor, path3);
  if (!Text.isText(node4)) {
    return false;
  }
  if (diff.start !== node4.text.length || diff.text.length === 0) {
    return node4.text.slice(diff.start, diff.start + diff.text.length) === diff.text;
  }
  var nextPath = Path.next(path3);
  if (!Editor.hasPath(editor, nextPath)) {
    return false;
  }
  var nextNode = Node3.get(editor, nextPath);
  return Text.isText(nextNode) && nextNode.text.startsWith(diff.text);
}
function applyStringDiff(text7) {
  for (var _len = arguments.length, diffs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    diffs[_key - 1] = arguments[_key];
  }
  return diffs.reduce((text8, diff) => text8.slice(0, diff.start) + diff.text + text8.slice(diff.end), text7);
}
function longestCommonPrefixLength(str, another) {
  var length4 = Math.min(str.length, another.length);
  for (var i6 = 0; i6 < length4; i6++) {
    if (str.charAt(i6) !== another.charAt(i6)) {
      return i6;
    }
  }
  return length4;
}
function longestCommonSuffixLength(str, another, max4) {
  var length4 = Math.min(str.length, another.length, max4);
  for (var i6 = 0; i6 < length4; i6++) {
    if (str.charAt(str.length - i6 - 1) !== another.charAt(another.length - i6 - 1)) {
      return i6;
    }
  }
  return length4;
}
function normalizeStringDiff(targetText, diff) {
  var {
    start: start2,
    end,
    text: text7
  } = diff;
  var removedText = targetText.slice(start2, end);
  var prefixLength = longestCommonPrefixLength(removedText, text7);
  var max4 = Math.min(removedText.length - prefixLength, text7.length - prefixLength);
  var suffixLength = longestCommonSuffixLength(removedText, text7, max4);
  var normalized = {
    start: start2 + prefixLength,
    end: end - suffixLength,
    text: text7.slice(prefixLength, text7.length - suffixLength)
  };
  if (normalized.start === normalized.end && normalized.text.length === 0) {
    return null;
  }
  return normalized;
}
function mergeStringDiffs(targetText, a3, b2) {
  var start2 = Math.min(a3.start, b2.start);
  var overlap = Math.max(0, Math.min(a3.start + a3.text.length, b2.end) - b2.start);
  var applied = applyStringDiff(targetText, a3, b2);
  var sliceEnd = Math.max(b2.start + b2.text.length, a3.start + a3.text.length + (a3.start + a3.text.length > b2.start ? b2.text.length : 0) - overlap);
  var text7 = applied.slice(start2, sliceEnd);
  var end = Math.max(a3.end, b2.end - a3.text.length + (a3.end - a3.start));
  return normalizeStringDiff(targetText, {
    start: start2,
    end,
    text: text7
  });
}
function targetRange(textDiff) {
  var {
    path: path3,
    diff
  } = textDiff;
  return {
    anchor: {
      path: path3,
      offset: diff.start
    },
    focus: {
      path: path3,
      offset: diff.end
    }
  };
}
function normalizePoint(editor, point3) {
  var {
    path: path3,
    offset
  } = point3;
  if (!Editor.hasPath(editor, path3)) {
    return null;
  }
  var leaf = Node3.get(editor, path3);
  if (!Text.isText(leaf)) {
    return null;
  }
  var parentBlock = Editor.above(editor, {
    match: (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6),
    at: path3
  });
  if (!parentBlock) {
    return null;
  }
  while (offset > leaf.text.length) {
    var entry = Editor.next(editor, {
      at: path3,
      match: Text.isText
    });
    if (!entry || !Path.isDescendant(entry[1], parentBlock[1])) {
      return null;
    }
    offset -= leaf.text.length;
    leaf = entry[0];
    path3 = entry[1];
  }
  return {
    path: path3,
    offset
  };
}
function normalizeRange(editor, range) {
  var anchor = normalizePoint(editor, range.anchor);
  if (!anchor) {
    return null;
  }
  if (Range.isCollapsed(range)) {
    return {
      anchor,
      focus: anchor
    };
  }
  var focus = normalizePoint(editor, range.focus);
  if (!focus) {
    return null;
  }
  return {
    anchor,
    focus
  };
}
function transformPendingPoint(editor, point3, op) {
  var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);
  var textDiff = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find((_ref) => {
    var {
      path: path3
    } = _ref;
    return Path.equals(path3, point3.path);
  });
  if (!textDiff || point3.offset <= textDiff.diff.start) {
    return Point.transform(point3, op, {
      affinity: "backward"
    });
  }
  var {
    diff
  } = textDiff;
  if (point3.offset <= diff.start + diff.text.length) {
    var _anchor = {
      path: point3.path,
      offset: diff.start
    };
    var _transformed = Point.transform(_anchor, op, {
      affinity: "backward"
    });
    if (!_transformed) {
      return null;
    }
    return {
      path: _transformed.path,
      offset: _transformed.offset + point3.offset - diff.start
    };
  }
  var anchor = {
    path: point3.path,
    offset: point3.offset - diff.text.length + diff.end - diff.start
  };
  var transformed = Point.transform(anchor, op, {
    affinity: "backward"
  });
  if (!transformed) {
    return null;
  }
  if (op.type === "split_node" && Path.equals(op.path, point3.path) && anchor.offset < op.position && diff.start < op.position) {
    return transformed;
  }
  return {
    path: transformed.path,
    offset: transformed.offset + diff.text.length - diff.end + diff.start
  };
}
function transformPendingRange(editor, range, op) {
  var anchor = transformPendingPoint(editor, range.anchor, op);
  if (!anchor) {
    return null;
  }
  if (Range.isCollapsed(range)) {
    return {
      anchor,
      focus: anchor
    };
  }
  var focus = transformPendingPoint(editor, range.focus, op);
  if (!focus) {
    return null;
  }
  return {
    anchor,
    focus
  };
}
function transformTextDiff(textDiff, op) {
  var {
    path: path3,
    diff,
    id: id2
  } = textDiff;
  switch (op.type) {
    case "insert_text": {
      if (!Path.equals(op.path, path3) || op.offset >= diff.end) {
        return textDiff;
      }
      if (op.offset <= diff.start) {
        return {
          diff: {
            start: op.text.length + diff.start,
            end: op.text.length + diff.end,
            text: diff.text
          },
          id: id2,
          path: path3
        };
      }
      return {
        diff: {
          start: diff.start,
          end: diff.end + op.text.length,
          text: diff.text
        },
        id: id2,
        path: path3
      };
    }
    case "remove_text": {
      if (!Path.equals(op.path, path3) || op.offset >= diff.end) {
        return textDiff;
      }
      if (op.offset + op.text.length <= diff.start) {
        return {
          diff: {
            start: diff.start - op.text.length,
            end: diff.end - op.text.length,
            text: diff.text
          },
          id: id2,
          path: path3
        };
      }
      return {
        diff: {
          start: diff.start,
          end: diff.end - op.text.length,
          text: diff.text
        },
        id: id2,
        path: path3
      };
    }
    case "split_node": {
      if (!Path.equals(op.path, path3) || op.position >= diff.end) {
        return {
          diff,
          id: id2,
          path: Path.transform(path3, op, {
            affinity: "backward"
          })
        };
      }
      if (op.position > diff.start) {
        return {
          diff: {
            start: diff.start,
            end: Math.min(op.position, diff.end),
            text: diff.text
          },
          id: id2,
          path: path3
        };
      }
      return {
        diff: {
          start: diff.start - op.position,
          end: diff.end - op.position,
          text: diff.text
        },
        id: id2,
        path: Path.transform(path3, op, {
          affinity: "forward"
        })
      };
    }
    case "merge_node": {
      if (!Path.equals(op.path, path3)) {
        return {
          diff,
          id: id2,
          path: Path.transform(path3, op)
        };
      }
      return {
        diff: {
          start: diff.start + op.position,
          end: diff.end + op.position,
          text: diff.text
        },
        id: id2,
        path: Path.transform(path3, op)
      };
    }
  }
  var newPath = Path.transform(path3, op);
  if (!newPath) {
    return null;
  }
  return {
    diff,
    path: newPath,
    id: id2
  };
}
function ownKeys$32(object2, enumerableOnly) {
  var keys3 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$32(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6] != null ? arguments[i6] : {};
    if (i6 % 2) {
      ownKeys$32(Object(source), true).forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$32(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var RESOLVE_DELAY = 25;
var FLUSH_DELAY = 200;
var debug2 = function debug3() {
};
var isDataTransfer = (value2) => (value2 === null || value2 === void 0 ? void 0 : value2.constructor.name) === "DataTransfer";
function createAndroidInputManager(_ref) {
  var {
    editor,
    scheduleOnDOMSelectionChange,
    onDOMSelectionChange
  } = _ref;
  var flushing = false;
  var compositionEndTimeoutId = null;
  var flushTimeoutId = null;
  var actionTimeoutId = null;
  var idCounter = 0;
  var insertPositionHint = false;
  var applyPendingSelection = () => {
    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(editor);
    EDITOR_TO_PENDING_SELECTION.delete(editor);
    if (pendingSelection) {
      var {
        selection
      } = editor;
      var normalized = normalizeRange(editor, pendingSelection);
      if (normalized && (!selection || !Range.equals(normalized, selection))) {
        Transforms.select(editor, normalized);
      }
    }
  };
  var performAction = () => {
    var action = EDITOR_TO_PENDING_ACTION.get(editor);
    EDITOR_TO_PENDING_ACTION.delete(editor);
    if (!action) {
      return;
    }
    if (action.at) {
      var target = Point.isPoint(action.at) ? normalizePoint(editor, action.at) : normalizeRange(editor, action.at);
      if (!target) {
        return;
      }
      var _targetRange = Editor.range(editor, target);
      if (!editor.selection || !Range.equals(editor.selection, _targetRange)) {
        Transforms.select(editor, target);
      }
    }
    action.run();
  };
  var flush2 = () => {
    if (flushTimeoutId) {
      clearTimeout(flushTimeoutId);
      flushTimeoutId = null;
    }
    if (actionTimeoutId) {
      clearTimeout(actionTimeoutId);
      actionTimeoutId = null;
    }
    if (!hasPendingDiffs() && !hasPendingAction()) {
      applyPendingSelection();
      return;
    }
    if (!flushing) {
      flushing = true;
      setTimeout(() => flushing = false);
    }
    if (hasPendingAction()) {
      flushing = "action";
    }
    var selectionRef = editor.selection && Editor.rangeRef(editor, editor.selection, {
      affinity: "forward"
    });
    EDITOR_TO_USER_MARKS.set(editor, editor.marks);
    debug2("flush", EDITOR_TO_PENDING_ACTION.get(editor), EDITOR_TO_PENDING_DIFFS.get(editor));
    var scheduleSelectionChange = hasPendingDiffs();
    var diff;
    while (diff = (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI === void 0 ? void 0 : _EDITOR_TO_PENDING_DI[0]) {
      var _EDITOR_TO_PENDING_DI, _EDITOR_TO_PENDING_DI2;
      var pendingMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);
      if (pendingMarks !== void 0) {
        EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);
        editor.marks = pendingMarks;
      }
      if (pendingMarks && insertPositionHint === false) {
        insertPositionHint = null;
      }
      var range = targetRange(diff);
      if (!editor.selection || !Range.equals(editor.selection, range)) {
        Transforms.select(editor, range);
      }
      if (diff.diff.text) {
        Editor.insertText(editor, diff.diff.text);
      } else {
        Editor.deleteFragment(editor);
      }
      EDITOR_TO_PENDING_DIFFS.set(editor, (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI2 === void 0 ? void 0 : _EDITOR_TO_PENDING_DI2.filter((_ref2) => {
        var {
          id: id2
        } = _ref2;
        return id2 !== diff.id;
      }));
      if (!verifyDiffState(editor, diff)) {
        scheduleSelectionChange = false;
        EDITOR_TO_PENDING_ACTION.delete(editor);
        EDITOR_TO_USER_MARKS.delete(editor);
        flushing = "action";
        EDITOR_TO_PENDING_SELECTION.delete(editor);
        scheduleOnDOMSelectionChange.cancel();
        onDOMSelectionChange.cancel();
        selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();
      }
    }
    var selection = selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();
    if (selection && !EDITOR_TO_PENDING_SELECTION.get(editor) && (!editor.selection || !Range.equals(selection, editor.selection))) {
      Transforms.select(editor, selection);
    }
    if (hasPendingAction()) {
      performAction();
      return;
    }
    if (scheduleSelectionChange) {
      scheduleOnDOMSelectionChange();
    }
    scheduleOnDOMSelectionChange.flush();
    onDOMSelectionChange.flush();
    applyPendingSelection();
    var userMarks = EDITOR_TO_USER_MARKS.get(editor);
    EDITOR_TO_USER_MARKS.delete(editor);
    if (userMarks !== void 0) {
      editor.marks = userMarks;
      editor.onChange();
    }
  };
  var handleCompositionEnd = (_event) => {
    if (compositionEndTimeoutId) {
      clearTimeout(compositionEndTimeoutId);
    }
    compositionEndTimeoutId = setTimeout(() => {
      IS_COMPOSING.set(editor, false);
      flush2();
    }, RESOLVE_DELAY);
  };
  var handleCompositionStart = (_event) => {
    IS_COMPOSING.set(editor, true);
    if (compositionEndTimeoutId) {
      clearTimeout(compositionEndTimeoutId);
      compositionEndTimeoutId = null;
    }
  };
  var updatePlaceholderVisibility = function updatePlaceholderVisibility2() {
    var forceHide = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var placeholderElement = EDITOR_TO_PLACEHOLDER_ELEMENT.get(editor);
    if (!placeholderElement) {
      return;
    }
    if (hasPendingDiffs() || forceHide) {
      placeholderElement.style.display = "none";
      return;
    }
    placeholderElement.style.removeProperty("display");
  };
  var storeDiff = (path3, diff) => {
    var _EDITOR_TO_PENDING_DI3;
    var pendingDiffs = (_EDITOR_TO_PENDING_DI3 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI3 !== void 0 ? _EDITOR_TO_PENDING_DI3 : [];
    EDITOR_TO_PENDING_DIFFS.set(editor, pendingDiffs);
    var target = Node3.leaf(editor, path3);
    var idx = pendingDiffs.findIndex((change) => Path.equals(change.path, path3));
    if (idx < 0) {
      var normalized = normalizeStringDiff(target.text, diff);
      if (normalized) {
        pendingDiffs.push({
          path: path3,
          diff,
          id: idCounter++
        });
      }
      updatePlaceholderVisibility();
      return;
    }
    var merged = mergeStringDiffs(target.text, pendingDiffs[idx].diff, diff);
    if (!merged) {
      pendingDiffs.splice(idx, 1);
      updatePlaceholderVisibility();
      return;
    }
    pendingDiffs[idx] = _objectSpread$32(_objectSpread$32({}, pendingDiffs[idx]), {}, {
      diff: merged
    });
  };
  var scheduleAction = function scheduleAction2(run) {
    var {
      at
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    insertPositionHint = false;
    EDITOR_TO_PENDING_SELECTION.delete(editor);
    scheduleOnDOMSelectionChange.cancel();
    onDOMSelectionChange.cancel();
    if (hasPendingAction()) {
      flush2();
    }
    EDITOR_TO_PENDING_ACTION.set(editor, {
      at,
      run
    });
    actionTimeoutId = setTimeout(flush2);
  };
  var handleDOMBeforeInput = (event) => {
    var _targetRange2;
    if (flushTimeoutId) {
      clearTimeout(flushTimeoutId);
      flushTimeoutId = null;
    }
    var {
      inputType: type2
    } = event;
    var targetRange2 = null;
    var data = event.dataTransfer || event.data || void 0;
    if (insertPositionHint !== false && type2 !== "insertText" && type2 !== "insertCompositionText") {
      insertPositionHint = false;
    }
    var [nativeTargetRange] = event.getTargetRanges();
    if (nativeTargetRange) {
      targetRange2 = ReactEditor.toSlateRange(editor, nativeTargetRange, {
        exactMatch: false,
        suppressThrow: true
      });
    }
    var window2 = ReactEditor.getWindow(editor);
    var domSelection = window2.getSelection();
    if (!targetRange2 && domSelection) {
      nativeTargetRange = domSelection;
      targetRange2 = ReactEditor.toSlateRange(editor, domSelection, {
        exactMatch: false,
        suppressThrow: true
      });
    }
    targetRange2 = (_targetRange2 = targetRange2) !== null && _targetRange2 !== void 0 ? _targetRange2 : editor.selection;
    if (!targetRange2) {
      return;
    }
    var canStoreDiff = true;
    if (type2.startsWith("delete")) {
      if (Range.isExpanded(targetRange2)) {
        var [_start, _end] = Range.edges(targetRange2);
        var _leaf = Node3.leaf(editor, _start.path);
        if (_leaf.text.length === _start.offset && _end.offset === 0) {
          var next2 = Editor.next(editor, {
            at: _start.path,
            match: Text.isText
          });
          if (next2 && Path.equals(next2[1], _end.path)) {
            targetRange2 = {
              anchor: _end,
              focus: _end
            };
          }
        }
      }
      var direction = type2.endsWith("Backward") ? "backward" : "forward";
      var [start2, end] = Range.edges(targetRange2);
      var [leaf, path3] = Editor.leaf(editor, start2.path);
      var diff = {
        text: "",
        start: start2.offset,
        end: end.offset
      };
      var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);
      var relevantPendingDiffs = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find((change) => Path.equals(change.path, path3));
      var diffs = relevantPendingDiffs ? [relevantPendingDiffs.diff, diff] : [diff];
      var text7 = applyStringDiff(leaf.text, ...diffs);
      if (text7.length === 0) {
        canStoreDiff = false;
      }
      if (Range.isExpanded(targetRange2)) {
        if (canStoreDiff && Path.equals(targetRange2.anchor.path, targetRange2.focus.path)) {
          var point3 = {
            path: targetRange2.anchor.path,
            offset: start2.offset
          };
          var range = Editor.range(editor, point3, point3);
          handleUserSelect(range);
          return storeDiff(targetRange2.anchor.path, {
            text: "",
            end: end.offset,
            start: start2.offset
          });
        }
        return scheduleAction(() => Editor.deleteFragment(editor, {
          direction
        }), {
          at: targetRange2
        });
      }
    }
    switch (type2) {
      case "deleteByComposition":
      case "deleteByCut":
      case "deleteByDrag": {
        return scheduleAction(() => Editor.deleteFragment(editor), {
          at: targetRange2
        });
      }
      case "deleteContent":
      case "deleteContentForward": {
        var {
          anchor
        } = targetRange2;
        if (canStoreDiff && Range.isCollapsed(targetRange2)) {
          var targetNode = Node3.leaf(editor, anchor.path);
          if (anchor.offset < targetNode.text.length) {
            return storeDiff(anchor.path, {
              text: "",
              start: anchor.offset,
              end: anchor.offset + 1
            });
          }
        }
        return scheduleAction(() => Editor.deleteForward(editor), {
          at: targetRange2
        });
      }
      case "deleteContentBackward": {
        var _nativeTargetRange;
        var {
          anchor: _anchor
        } = targetRange2;
        var nativeCollapsed = isDOMSelection(nativeTargetRange) ? nativeTargetRange.isCollapsed : !!((_nativeTargetRange = nativeTargetRange) !== null && _nativeTargetRange !== void 0 && _nativeTargetRange.collapsed);
        if (canStoreDiff && nativeCollapsed && Range.isCollapsed(targetRange2) && _anchor.offset > 0) {
          return storeDiff(_anchor.path, {
            text: "",
            start: _anchor.offset - 1,
            end: _anchor.offset
          });
        }
        return scheduleAction(() => Editor.deleteBackward(editor), {
          at: targetRange2
        });
      }
      case "deleteEntireSoftLine": {
        return scheduleAction(() => {
          Editor.deleteBackward(editor, {
            unit: "line"
          });
          Editor.deleteForward(editor, {
            unit: "line"
          });
        }, {
          at: targetRange2
        });
      }
      case "deleteHardLineBackward": {
        return scheduleAction(() => Editor.deleteBackward(editor, {
          unit: "block"
        }), {
          at: targetRange2
        });
      }
      case "deleteSoftLineBackward": {
        return scheduleAction(() => Editor.deleteBackward(editor, {
          unit: "line"
        }), {
          at: targetRange2
        });
      }
      case "deleteHardLineForward": {
        return scheduleAction(() => Editor.deleteForward(editor, {
          unit: "block"
        }), {
          at: targetRange2
        });
      }
      case "deleteSoftLineForward": {
        return scheduleAction(() => Editor.deleteForward(editor, {
          unit: "line"
        }), {
          at: targetRange2
        });
      }
      case "deleteWordBackward": {
        return scheduleAction(() => Editor.deleteBackward(editor, {
          unit: "word"
        }), {
          at: targetRange2
        });
      }
      case "deleteWordForward": {
        return scheduleAction(() => Editor.deleteForward(editor, {
          unit: "word"
        }), {
          at: targetRange2
        });
      }
      case "insertLineBreak": {
        return scheduleAction(() => Editor.insertSoftBreak(editor), {
          at: targetRange2
        });
      }
      case "insertParagraph": {
        return scheduleAction(() => Editor.insertBreak(editor), {
          at: targetRange2
        });
      }
      case "insertCompositionText":
      case "deleteCompositionText":
      case "insertFromComposition":
      case "insertFromDrop":
      case "insertFromPaste":
      case "insertFromYank":
      case "insertReplacementText":
      case "insertText": {
        if (isDataTransfer(data)) {
          return scheduleAction(() => ReactEditor.insertData(editor, data), {
            at: targetRange2
          });
        }
        var _text = data !== null && data !== void 0 ? data : "";
        if (EDITOR_TO_PENDING_INSERTION_MARKS.get(editor)) {
          _text = _text.replace("\uFEFF", "");
        }
        if (type2 === "insertText" && /.*\n.*\n$/.test(_text)) {
          _text = _text.slice(0, -1);
        }
        if (_text.includes("\n")) {
          return scheduleAction(() => {
            var parts = _text.split("\n");
            parts.forEach((line2, i6) => {
              if (line2) {
                Editor.insertText(editor, line2);
              }
              if (i6 !== parts.length - 1) {
                Editor.insertSoftBreak(editor);
              }
            });
          }, {
            at: targetRange2
          });
        }
        if (Path.equals(targetRange2.anchor.path, targetRange2.focus.path)) {
          var [_start2, _end2] = Range.edges(targetRange2);
          var _diff = {
            start: _start2.offset,
            end: _end2.offset,
            text: _text
          };
          if (_text && insertPositionHint && type2 === "insertCompositionText") {
            var hintPosition = insertPositionHint.start + insertPositionHint.text.search(/\S|$/);
            var diffPosition = _diff.start + _diff.text.search(/\S|$/);
            if (diffPosition === hintPosition + 1 && _diff.end === insertPositionHint.start + insertPositionHint.text.length) {
              _diff.start -= 1;
              insertPositionHint = null;
              scheduleFlush();
            } else {
              insertPositionHint = false;
            }
          } else if (type2 === "insertText") {
            if (insertPositionHint === null) {
              insertPositionHint = _diff;
            } else if (insertPositionHint && Range.isCollapsed(targetRange2) && insertPositionHint.end + insertPositionHint.text.length === _start2.offset) {
              insertPositionHint = _objectSpread$32(_objectSpread$32({}, insertPositionHint), {}, {
                text: insertPositionHint.text + _text
              });
            } else {
              insertPositionHint = false;
            }
          } else {
            insertPositionHint = false;
          }
          if (canStoreDiff) {
            storeDiff(_start2.path, _diff);
            return;
          }
        }
        return scheduleAction(() => Editor.insertText(editor, _text), {
          at: targetRange2
        });
      }
    }
  };
  var hasPendingAction = () => {
    return !!EDITOR_TO_PENDING_ACTION.get(editor);
  };
  var hasPendingDiffs = () => {
    var _EDITOR_TO_PENDING_DI4;
    return !!((_EDITOR_TO_PENDING_DI4 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI4 !== void 0 && _EDITOR_TO_PENDING_DI4.length);
  };
  var hasPendingChanges = () => {
    return hasPendingAction() || hasPendingDiffs();
  };
  var isFlushing = () => {
    return flushing;
  };
  var handleUserSelect = (range) => {
    EDITOR_TO_PENDING_SELECTION.set(editor, range);
    if (flushTimeoutId) {
      clearTimeout(flushTimeoutId);
      flushTimeoutId = null;
    }
    var {
      selection
    } = editor;
    if (!range) {
      return;
    }
    var pathChanged = !selection || !Path.equals(selection.anchor.path, range.anchor.path);
    var parentPathChanged = !selection || !Path.equals(selection.anchor.path.slice(0, -1), range.anchor.path.slice(0, -1));
    if (pathChanged && insertPositionHint || parentPathChanged) {
      insertPositionHint = false;
    }
    if (pathChanged || hasPendingDiffs()) {
      flushTimeoutId = setTimeout(flush2, FLUSH_DELAY);
    }
  };
  var handleInput = () => {
    if (hasPendingAction() || !hasPendingDiffs()) {
      flush2();
    }
  };
  var handleKeyDown = (_2) => {
    if (!hasPendingDiffs()) {
      updatePlaceholderVisibility(true);
      setTimeout(updatePlaceholderVisibility);
    }
  };
  var scheduleFlush = () => {
    if (!hasPendingAction()) {
      actionTimeoutId = setTimeout(flush2);
    }
  };
  var handleDomMutations = (mutations) => {
    if (hasPendingDiffs() || hasPendingAction()) {
      return;
    }
    if (mutations.some((mutation) => isTrackedMutation(editor, mutation, mutations))) {
      var _EDITOR_TO_FORCE_REND;
      (_EDITOR_TO_FORCE_REND = EDITOR_TO_FORCE_RENDER.get(editor)) === null || _EDITOR_TO_FORCE_REND === void 0 ? void 0 : _EDITOR_TO_FORCE_REND();
    }
  };
  return {
    flush: flush2,
    scheduleFlush,
    hasPendingDiffs,
    hasPendingAction,
    hasPendingChanges,
    isFlushing,
    handleUserSelect,
    handleCompositionEnd,
    handleCompositionStart,
    handleDOMBeforeInput,
    handleKeyDown,
    handleDomMutations,
    handleInput
  };
}
function useIsMounted2() {
  var isMountedRef = (0, import_react50.useRef)(false);
  (0, import_react50.useEffect)(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  return isMountedRef.current;
}
function useMutationObserver(node4, callback, options) {
  var [mutationObserver] = (0, import_react50.useState)(() => new MutationObserver(callback));
  useIsomorphicLayoutEffect(() => {
    mutationObserver.takeRecords();
  });
  (0, import_react50.useEffect)(() => {
    if (!node4.current) {
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    }
    mutationObserver.observe(node4.current, options);
    return () => mutationObserver.disconnect();
  }, []);
}
var _excluded$22 = ["node"];
function ownKeys$22(object2, enumerableOnly) {
  var keys3 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$22(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6] != null ? arguments[i6] : {};
    if (i6 % 2) {
      ownKeys$22(Object(source), true).forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$22(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var MUTATION_OBSERVER_CONFIG = {
  subtree: true,
  childList: true,
  characterData: true
};
function useAndroidInputManager(_ref) {
  var {
    node: node4
  } = _ref, options = _objectWithoutProperties2(_ref, _excluded$22);
  if (!IS_ANDROID) {
    return null;
  }
  var editor = useSlateStatic();
  var isMounted = useIsMounted2();
  var [inputManager] = (0, import_react50.useState)(() => createAndroidInputManager(_objectSpread$22({
    editor
  }, options)));
  useMutationObserver(node4, inputManager.handleDomMutations, MUTATION_OBSERVER_CONFIG);
  EDITOR_TO_SCHEDULE_FLUSH.set(editor, inputManager.scheduleFlush);
  if (isMounted) {
    inputManager.flush();
  }
  return inputManager;
}
function useTrackUserInput() {
  var editor = useSlateStatic();
  var receivedUserInput = (0, import_react50.useRef)(false);
  var animationFrameIdRef = (0, import_react50.useRef)(0);
  var onUserInput = (0, import_react50.useCallback)(() => {
    if (receivedUserInput.current) {
      return;
    }
    receivedUserInput.current = true;
    var window2 = ReactEditor.getWindow(editor);
    window2.cancelAnimationFrame(animationFrameIdRef.current);
    animationFrameIdRef.current = window2.requestAnimationFrame(() => {
      receivedUserInput.current = false;
    });
  }, []);
  (0, import_react50.useEffect)(() => () => cancelAnimationFrame(animationFrameIdRef.current), []);
  return {
    receivedUserInput,
    onUserInput
  };
}
var _excluded$12 = ["autoFocus", "decorate", "onDOMBeforeInput", "placeholder", "readOnly", "renderElement", "renderLeaf", "renderPlaceholder", "scrollSelectionIntoView", "style", "as", "disableDefaultStyles"];
var _excluded22 = ["text"];
function ownKeys$12(object2, enumerableOnly) {
  var keys3 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$12(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6] != null ? arguments[i6] : {};
    if (i6 % 2) {
      ownKeys$12(Object(source), true).forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$12(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Children3 = (props) => import_react50.default.createElement(import_react50.default.Fragment, null, useChildren(props));
var Editable = (props) => {
  var _EDITOR_TO_PLACEHOLDE, _EDITOR_TO_PLACEHOLDE2;
  var defaultRenderPlaceholder = (0, import_react50.useCallback)((props2) => import_react50.default.createElement(DefaultPlaceholder, Object.assign({}, props2)), []);
  var {
    autoFocus,
    decorate = defaultDecorate,
    onDOMBeforeInput: propsOnDOMBeforeInput,
    placeholder,
    readOnly = false,
    renderElement: renderElement2,
    renderLeaf: renderLeaf2,
    renderPlaceholder = defaultRenderPlaceholder,
    scrollSelectionIntoView = defaultScrollSelectionIntoView,
    style: userStyle = {},
    as: Component2 = "div",
    disableDefaultStyles = false
  } = props, attributes = _objectWithoutProperties2(props, _excluded$12);
  var editor = useSlate();
  var [isComposing, setIsComposing] = (0, import_react50.useState)(false);
  var ref = (0, import_react50.useRef)(null);
  var deferredOperations = (0, import_react50.useRef)([]);
  var {
    onUserInput,
    receivedUserInput
  } = useTrackUserInput();
  var [, forceRender] = (0, import_react50.useReducer)((s4) => s4 + 1, 0);
  EDITOR_TO_FORCE_RENDER.set(editor, forceRender);
  IS_READ_ONLY.set(editor, readOnly);
  var state = (0, import_react50.useMemo)(() => ({
    isDraggingInternally: false,
    isUpdatingSelection: false,
    latestElement: null,
    hasMarkPlaceholder: false
  }), []);
  (0, import_react50.useEffect)(() => {
    if (ref.current && autoFocus) {
      ref.current.focus();
    }
  }, [autoFocus]);
  var onDOMSelectionChange = (0, import_react50.useCallback)((0, import_throttle.default)(() => {
    if ((IS_ANDROID || !ReactEditor.isComposing(editor)) && (!state.isUpdatingSelection || androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing()) && !state.isDraggingInternally) {
      var root = ReactEditor.findDocumentOrShadowRoot(editor);
      var {
        activeElement
      } = root;
      var el = ReactEditor.toDOMNode(editor, editor);
      var domSelection = root.getSelection();
      if (activeElement === el) {
        state.latestElement = activeElement;
        IS_FOCUSED.set(editor, true);
      } else {
        IS_FOCUSED.delete(editor);
      }
      if (!domSelection) {
        return Transforms.deselect(editor);
      }
      var {
        anchorNode,
        focusNode
      } = domSelection;
      var anchorNodeSelectable = ReactEditor.hasEditableTarget(editor, anchorNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, anchorNode);
      var focusNodeSelectable = ReactEditor.hasEditableTarget(editor, focusNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, focusNode);
      if (anchorNodeSelectable && focusNodeSelectable) {
        var range = ReactEditor.toSlateRange(editor, domSelection, {
          exactMatch: false,
          suppressThrow: true
        });
        if (range) {
          if (!ReactEditor.isComposing(editor) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.hasPendingChanges()) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing())) {
            Transforms.select(editor, range);
          } else {
            androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleUserSelect(range);
          }
        }
      }
      if (readOnly && (!anchorNodeSelectable || !focusNodeSelectable)) {
        Transforms.deselect(editor);
      }
    }
  }, 100), [readOnly]);
  var scheduleOnDOMSelectionChange = (0, import_react50.useMemo)(() => (0, import_debounce.default)(onDOMSelectionChange, 0), [onDOMSelectionChange]);
  var androidInputManager = useAndroidInputManager({
    node: ref,
    onDOMSelectionChange,
    scheduleOnDOMSelectionChange
  });
  useIsomorphicLayoutEffect(() => {
    var window2;
    if (ref.current && (window2 = getDefaultView(ref.current))) {
      EDITOR_TO_WINDOW.set(editor, window2);
      EDITOR_TO_ELEMENT.set(editor, ref.current);
      NODE_TO_ELEMENT.set(editor, ref.current);
      ELEMENT_TO_NODE.set(ref.current, editor);
    } else {
      NODE_TO_ELEMENT.delete(editor);
    }
    var {
      selection
    } = editor;
    var root = ReactEditor.findDocumentOrShadowRoot(editor);
    var domSelection = root.getSelection();
    if (!domSelection || !ReactEditor.isFocused(editor) || androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.hasPendingAction()) {
      return;
    }
    var setDomSelection = (forceChange) => {
      var hasDomSelection = domSelection.type !== "None";
      if (!selection && !hasDomSelection) {
        return;
      }
      var editorElement = EDITOR_TO_ELEMENT.get(editor);
      var hasDomSelectionInEditor = false;
      if (editorElement.contains(domSelection.anchorNode) && editorElement.contains(domSelection.focusNode)) {
        hasDomSelectionInEditor = true;
      }
      if (hasDomSelection && hasDomSelectionInEditor && selection && !forceChange) {
        var slateRange = ReactEditor.toSlateRange(editor, domSelection, {
          exactMatch: true,
          // domSelection is not necessarily a valid Slate range
          // (e.g. when clicking on contentEditable:false element)
          suppressThrow: true
        });
        if (slateRange && Range.equals(slateRange, selection)) {
          var _anchorNode$parentEle;
          if (!state.hasMarkPlaceholder) {
            return;
          }
          var {
            anchorNode
          } = domSelection;
          if (anchorNode !== null && anchorNode !== void 0 && (_anchorNode$parentEle = anchorNode.parentElement) !== null && _anchorNode$parentEle !== void 0 && _anchorNode$parentEle.hasAttribute("data-slate-mark-placeholder")) {
            return;
          }
        }
      }
      if (selection && !ReactEditor.hasRange(editor, selection)) {
        editor.selection = ReactEditor.toSlateRange(editor, domSelection, {
          exactMatch: false,
          suppressThrow: true
        });
        return;
      }
      state.isUpdatingSelection = true;
      var newDomRange2 = selection && ReactEditor.toDOMRange(editor, selection);
      if (newDomRange2) {
        if (Range.isBackward(selection)) {
          domSelection.setBaseAndExtent(newDomRange2.endContainer, newDomRange2.endOffset, newDomRange2.startContainer, newDomRange2.startOffset);
        } else {
          domSelection.setBaseAndExtent(newDomRange2.startContainer, newDomRange2.startOffset, newDomRange2.endContainer, newDomRange2.endOffset);
        }
        scrollSelectionIntoView(editor, newDomRange2);
      } else {
        domSelection.removeAllRanges();
      }
      return newDomRange2;
    };
    var newDomRange = setDomSelection();
    var ensureSelection = (androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.isFlushing()) === "action";
    if (!IS_ANDROID || !ensureSelection) {
      setTimeout(() => {
        if (newDomRange && IS_FIREFOX) {
          var el = ReactEditor.toDOMNode(editor, editor);
          el.focus();
        }
        state.isUpdatingSelection = false;
      });
      return;
    }
    var timeoutId = null;
    var animationFrameId = requestAnimationFrame(() => {
      if (ensureSelection) {
        var ensureDomSelection = (forceChange) => {
          try {
            var el = ReactEditor.toDOMNode(editor, editor);
            el.focus();
            setDomSelection(forceChange);
          } catch (e6) {
          }
        };
        ensureDomSelection();
        timeoutId = setTimeout(() => {
          ensureDomSelection(true);
          state.isUpdatingSelection = false;
        });
      }
    });
    return () => {
      cancelAnimationFrame(animationFrameId);
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    };
  });
  var onDOMBeforeInput = (0, import_react50.useCallback)((event) => {
    onUserInput();
    if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isDOMEventHandled(event, propsOnDOMBeforeInput)) {
      var _EDITOR_TO_USER_SELEC;
      if (androidInputManager) {
        return androidInputManager.handleDOMBeforeInput(event);
      }
      scheduleOnDOMSelectionChange.flush();
      onDOMSelectionChange.flush();
      var {
        selection
      } = editor;
      var {
        inputType: type2
      } = event;
      var data = event.dataTransfer || event.data || void 0;
      var isCompositionChange = type2 === "insertCompositionText" || type2 === "deleteCompositionText";
      if (isCompositionChange && ReactEditor.isComposing(editor)) {
        return;
      }
      var native = false;
      if (type2 === "insertText" && selection && Range.isCollapsed(selection) && // Only use native character insertion for single characters a-z or space for now.
      // Long-press events (hold a + press 4 = ä) to choose a special character otherwise
      // causes duplicate inserts.
      event.data && event.data.length === 1 && /[a-z ]/i.test(event.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405
      // When there is an inline element, e.g. a link, and you select
      // right after it (the start of the next node).
      selection.anchor.offset !== 0) {
        var _node$parentElement, _window$getComputedSt;
        native = true;
        if (editor.marks) {
          native = false;
        }
        var {
          anchor: anchor2
        } = selection;
        var [node4, offset] = ReactEditor.toDOMPoint(editor, anchor2);
        var anchorNode = (_node$parentElement = node4.parentElement) === null || _node$parentElement === void 0 ? void 0 : _node$parentElement.closest("a");
        var window2 = ReactEditor.getWindow(editor);
        if (native && anchorNode && ReactEditor.hasDOMNode(editor, anchorNode)) {
          var _lastText$textContent;
          var lastText = window2 === null || window2 === void 0 ? void 0 : window2.document.createTreeWalker(anchorNode, NodeFilter.SHOW_TEXT).lastChild();
          if (lastText === node4 && ((_lastText$textContent = lastText.textContent) === null || _lastText$textContent === void 0 ? void 0 : _lastText$textContent.length) === offset) {
            native = false;
          }
        }
        if (native && node4.parentElement && (window2 === null || window2 === void 0 ? void 0 : (_window$getComputedSt = window2.getComputedStyle(node4.parentElement)) === null || _window$getComputedSt === void 0 ? void 0 : _window$getComputedSt.whiteSpace) === "pre") {
          var block5 = Editor.above(editor, {
            at: anchor2.path,
            match: (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6)
          });
          if (block5 && Node3.string(block5[0]).includes("	")) {
            native = false;
          }
        }
      }
      if (!type2.startsWith("delete") || type2.startsWith("deleteBy")) {
        var [targetRange2] = event.getTargetRanges();
        if (targetRange2) {
          var range = ReactEditor.toSlateRange(editor, targetRange2, {
            exactMatch: false,
            suppressThrow: false
          });
          if (!selection || !Range.equals(selection, range)) {
            native = false;
            var selectionRef = !isCompositionChange && editor.selection && Editor.rangeRef(editor, editor.selection);
            Transforms.select(editor, range);
            if (selectionRef) {
              EDITOR_TO_USER_SELECTION.set(editor, selectionRef);
            }
          }
        }
      }
      if (isCompositionChange) {
        return;
      }
      if (!native) {
        event.preventDefault();
      }
      if (selection && Range.isExpanded(selection) && type2.startsWith("delete")) {
        var direction = type2.endsWith("Backward") ? "backward" : "forward";
        Editor.deleteFragment(editor, {
          direction
        });
        return;
      }
      switch (type2) {
        case "deleteByComposition":
        case "deleteByCut":
        case "deleteByDrag": {
          Editor.deleteFragment(editor);
          break;
        }
        case "deleteContent":
        case "deleteContentForward": {
          Editor.deleteForward(editor);
          break;
        }
        case "deleteContentBackward": {
          Editor.deleteBackward(editor);
          break;
        }
        case "deleteEntireSoftLine": {
          Editor.deleteBackward(editor, {
            unit: "line"
          });
          Editor.deleteForward(editor, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineBackward": {
          Editor.deleteBackward(editor, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineBackward": {
          Editor.deleteBackward(editor, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineForward": {
          Editor.deleteForward(editor, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineForward": {
          Editor.deleteForward(editor, {
            unit: "line"
          });
          break;
        }
        case "deleteWordBackward": {
          Editor.deleteBackward(editor, {
            unit: "word"
          });
          break;
        }
        case "deleteWordForward": {
          Editor.deleteForward(editor, {
            unit: "word"
          });
          break;
        }
        case "insertLineBreak":
          Editor.insertSoftBreak(editor);
          break;
        case "insertParagraph": {
          Editor.insertBreak(editor);
          break;
        }
        case "insertFromComposition":
        case "insertFromDrop":
        case "insertFromPaste":
        case "insertFromYank":
        case "insertReplacementText":
        case "insertText": {
          if (type2 === "insertFromComposition") {
            if (ReactEditor.isComposing(editor)) {
              setIsComposing(false);
              IS_COMPOSING.set(editor, false);
            }
          }
          if ((data === null || data === void 0 ? void 0 : data.constructor.name) === "DataTransfer") {
            ReactEditor.insertData(editor, data);
          } else if (typeof data === "string") {
            if (native) {
              deferredOperations.current.push(() => Editor.insertText(editor, data));
            } else {
              Editor.insertText(editor, data);
            }
          }
          break;
        }
      }
      var toRestore = (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(editor)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();
      EDITOR_TO_USER_SELECTION.delete(editor);
      if (toRestore && (!editor.selection || !Range.equals(editor.selection, toRestore))) {
        Transforms.select(editor, toRestore);
      }
    }
  }, [readOnly, propsOnDOMBeforeInput]);
  var callbackRef = (0, import_react50.useCallback)((node4) => {
    if (node4 == null) {
      onDOMSelectionChange.cancel();
      scheduleOnDOMSelectionChange.cancel();
      EDITOR_TO_ELEMENT.delete(editor);
      NODE_TO_ELEMENT.delete(editor);
      if (ref.current && HAS_BEFORE_INPUT_SUPPORT) {
        ref.current.removeEventListener("beforeinput", onDOMBeforeInput);
      }
    } else {
      if (HAS_BEFORE_INPUT_SUPPORT) {
        node4.addEventListener("beforeinput", onDOMBeforeInput);
      }
    }
    ref.current = node4;
  }, [ref, onDOMBeforeInput, onDOMSelectionChange, scheduleOnDOMSelectionChange]);
  useIsomorphicLayoutEffect(() => {
    var window2 = ReactEditor.getWindow(editor);
    window2.document.addEventListener("selectionchange", scheduleOnDOMSelectionChange);
    return () => {
      window2.document.removeEventListener("selectionchange", scheduleOnDOMSelectionChange);
    };
  }, [scheduleOnDOMSelectionChange]);
  var decorations = decorate([editor, []]);
  if (placeholder && editor.children.length === 1 && Array.from(Node3.texts(editor)).length === 1 && Node3.string(editor) === "" && !isComposing) {
    var start2 = Editor.start(editor, []);
    decorations.push({
      [PLACEHOLDER_SYMBOL]: true,
      placeholder,
      anchor: start2,
      focus: start2
    });
  }
  var {
    marks
  } = editor;
  state.hasMarkPlaceholder = false;
  if (editor.selection && Range.isCollapsed(editor.selection) && marks) {
    var {
      anchor
    } = editor.selection;
    var leaf = Node3.leaf(editor, anchor.path);
    var rest = _objectWithoutProperties2(leaf, _excluded22);
    if (!Text.equals(leaf, marks, {
      loose: true
    })) {
      state.hasMarkPlaceholder = true;
      var unset = Object.fromEntries(Object.keys(rest).map((mark) => [mark, null]));
      decorations.push(_objectSpread$12(_objectSpread$12(_objectSpread$12({
        [MARK_PLACEHOLDER_SYMBOL]: true
      }, unset), marks), {}, {
        anchor,
        focus: anchor
      }));
    }
  }
  (0, import_react50.useEffect)(() => {
    setTimeout(() => {
      var {
        selection
      } = editor;
      if (selection) {
        var {
          anchor: _anchor
        } = selection;
        var _text = Node3.leaf(editor, _anchor.path);
        if (marks && !Text.equals(_text, marks, {
          loose: true
        })) {
          EDITOR_TO_PENDING_INSERTION_MARKS.set(editor, marks);
          return;
        }
      }
      EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);
    });
  });
  var placeholderHeight = (_EDITOR_TO_PLACEHOLDE = EDITOR_TO_PLACEHOLDER_ELEMENT.get(editor)) === null || _EDITOR_TO_PLACEHOLDE === void 0 ? void 0 : (_EDITOR_TO_PLACEHOLDE2 = _EDITOR_TO_PLACEHOLDE.getBoundingClientRect()) === null || _EDITOR_TO_PLACEHOLDE2 === void 0 ? void 0 : _EDITOR_TO_PLACEHOLDE2.height;
  return import_react50.default.createElement(ReadOnlyContext.Provider, {
    value: readOnly
  }, import_react50.default.createElement(DecorateContext.Provider, {
    value: decorate
  }, import_react50.default.createElement(RestoreDOM, {
    node: ref,
    receivedUserInput
  }, import_react50.default.createElement(Component2, Object.assign({
    role: readOnly ? void 0 : "textbox",
    "aria-multiline": readOnly ? void 0 : true
  }, attributes, {
    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd
    // have to use hacks to make these replacement-based features work.
    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop
    // mismatch warning app moves to browser. Pass-through consumer props when
    // not CAN_USE_DOM (SSR) and default to falsy value
    spellCheck: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.spellCheck : false,
    autoCorrect: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCorrect : "false",
    autoCapitalize: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCapitalize : "false",
    "data-slate-editor": true,
    "data-slate-node": "value",
    // explicitly set this
    contentEditable: !readOnly,
    // in some cases, a decoration needs access to the range / selection to decorate a text node,
    // then you will select the whole text node when you select part the of text
    // this magic zIndex="-1" will fix it
    zindex: -1,
    suppressContentEditableWarning: true,
    ref: callbackRef,
    style: _objectSpread$12(_objectSpread$12({}, disableDefaultStyles ? {} : _objectSpread$12({
      // Allow positioning relative to the editable element.
      position: "relative",
      // Prevent the default outline styles.
      outline: "none",
      // Preserve adjacent whitespace and new lines.
      whiteSpace: "pre-wrap",
      // Allow words to break if they are too long.
      wordWrap: "break-word"
    }, placeholderHeight ? {
      minHeight: placeholderHeight
    } : {})), userStyle),
    onBeforeInput: (0, import_react50.useCallback)((event) => {
      if (!HAS_BEFORE_INPUT_SUPPORT && !readOnly && !isEventHandled(event, attributes.onBeforeInput) && ReactEditor.hasSelectableTarget(editor, event.target)) {
        event.preventDefault();
        if (!ReactEditor.isComposing(editor)) {
          var _text2 = event.data;
          Editor.insertText(editor, _text2);
        }
      }
    }, [readOnly]),
    onInput: (0, import_react50.useCallback)((event) => {
      if (isEventHandled(event, attributes.onInput)) {
        return;
      }
      if (androidInputManager) {
        androidInputManager.handleInput();
        return;
      }
      for (var op of deferredOperations.current) {
        op();
      }
      deferredOperations.current = [];
    }, []),
    onBlur: (0, import_react50.useCallback)((event) => {
      if (readOnly || state.isUpdatingSelection || !ReactEditor.hasSelectableTarget(editor, event.target) || isEventHandled(event, attributes.onBlur)) {
        return;
      }
      var root = ReactEditor.findDocumentOrShadowRoot(editor);
      if (state.latestElement === root.activeElement) {
        return;
      }
      var {
        relatedTarget
      } = event;
      var el = ReactEditor.toDOMNode(editor, editor);
      if (relatedTarget === el) {
        return;
      }
      if (isDOMElement(relatedTarget) && relatedTarget.hasAttribute("data-slate-spacer")) {
        return;
      }
      if (relatedTarget != null && isDOMNode(relatedTarget) && ReactEditor.hasDOMNode(editor, relatedTarget)) {
        var node4 = ReactEditor.toSlateNode(editor, relatedTarget);
        if (Element2.isElement(node4) && !editor.isVoid(node4)) {
          return;
        }
      }
      if (IS_SAFARI) {
        var domSelection = root.getSelection();
        domSelection === null || domSelection === void 0 ? void 0 : domSelection.removeAllRanges();
      }
      IS_FOCUSED.delete(editor);
    }, [readOnly, attributes.onBlur]),
    onClick: (0, import_react50.useCallback)((event) => {
      if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onClick) && isDOMNode(event.target)) {
        var node4 = ReactEditor.toSlateNode(editor, event.target);
        var path3 = ReactEditor.findPath(editor, node4);
        if (!Editor.hasPath(editor, path3) || Node3.get(editor, path3) !== node4) {
          return;
        }
        if (event.detail === TRIPLE_CLICK && path3.length >= 1) {
          var blockPath = path3;
          if (!(Element2.isElement(node4) && Editor.isBlock(editor, node4))) {
            var _block$;
            var block5 = Editor.above(editor, {
              match: (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6),
              at: path3
            });
            blockPath = (_block$ = block5 === null || block5 === void 0 ? void 0 : block5[1]) !== null && _block$ !== void 0 ? _block$ : path3.slice(0, 1);
          }
          var range = Editor.range(editor, blockPath);
          Transforms.select(editor, range);
          return;
        }
        if (readOnly) {
          return;
        }
        var _start = Editor.start(editor, path3);
        var end = Editor.end(editor, path3);
        var startVoid = Editor.void(editor, {
          at: _start
        });
        var endVoid = Editor.void(editor, {
          at: end
        });
        if (startVoid && endVoid && Path.equals(startVoid[1], endVoid[1])) {
          var _range = Editor.range(editor, _start);
          Transforms.select(editor, _range);
        }
      }
    }, [readOnly, attributes.onClick]),
    onCompositionEnd: (0, import_react50.useCallback)((event) => {
      if (ReactEditor.hasSelectableTarget(editor, event.target)) {
        if (ReactEditor.isComposing(editor)) {
          setIsComposing(false);
          IS_COMPOSING.set(editor, false);
        }
        androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleCompositionEnd(event);
        if (isEventHandled(event, attributes.onCompositionEnd) || IS_ANDROID) {
          return;
        }
        if (!IS_SAFARI && !IS_FIREFOX_LEGACY && !IS_IOS && !IS_WECHATBROWSER && !IS_UC_MOBILE && event.data) {
          var placeholderMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);
          EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);
          if (placeholderMarks !== void 0) {
            EDITOR_TO_USER_MARKS.set(editor, editor.marks);
            editor.marks = placeholderMarks;
          }
          Editor.insertText(editor, event.data);
          var userMarks = EDITOR_TO_USER_MARKS.get(editor);
          EDITOR_TO_USER_MARKS.delete(editor);
          if (userMarks !== void 0) {
            editor.marks = userMarks;
          }
        }
      }
    }, [attributes.onCompositionEnd]),
    onCompositionUpdate: (0, import_react50.useCallback)((event) => {
      if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionUpdate)) {
        if (!ReactEditor.isComposing(editor)) {
          setIsComposing(true);
          IS_COMPOSING.set(editor, true);
        }
      }
    }, [attributes.onCompositionUpdate]),
    onCompositionStart: (0, import_react50.useCallback)((event) => {
      if (ReactEditor.hasSelectableTarget(editor, event.target)) {
        androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleCompositionStart(event);
        if (isEventHandled(event, attributes.onCompositionStart) || IS_ANDROID) {
          return;
        }
        setIsComposing(true);
        var {
          selection
        } = editor;
        if (selection) {
          if (Range.isExpanded(selection)) {
            Editor.deleteFragment(editor);
            return;
          }
          var inline4 = Editor.above(editor, {
            match: (n6) => Element2.isElement(n6) && Editor.isInline(editor, n6),
            mode: "highest"
          });
          if (inline4) {
            var [, inlinePath] = inline4;
            if (Editor.isEnd(editor, selection.anchor, inlinePath)) {
              var point3 = Editor.after(editor, inlinePath);
              Transforms.setSelection(editor, {
                anchor: point3,
                focus: point3
              });
            }
          }
        }
      }
    }, [attributes.onCompositionStart]),
    onCopy: (0, import_react50.useCallback)((event) => {
      if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCopy)) {
        event.preventDefault();
        ReactEditor.setFragmentData(editor, event.clipboardData, "copy");
      }
    }, [attributes.onCopy]),
    onCut: (0, import_react50.useCallback)((event) => {
      if (!readOnly && ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCut)) {
        event.preventDefault();
        ReactEditor.setFragmentData(editor, event.clipboardData, "cut");
        var {
          selection
        } = editor;
        if (selection) {
          if (Range.isExpanded(selection)) {
            Editor.deleteFragment(editor);
          } else {
            var node4 = Node3.parent(editor, selection.anchor.path);
            if (Editor.isVoid(editor, node4)) {
              Transforms.delete(editor);
            }
          }
        }
      }
    }, [readOnly, attributes.onCut]),
    onDragOver: (0, import_react50.useCallback)((event) => {
      if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragOver)) {
        var node4 = ReactEditor.toSlateNode(editor, event.target);
        if (Element2.isElement(node4) && Editor.isVoid(editor, node4)) {
          event.preventDefault();
        }
      }
    }, [attributes.onDragOver]),
    onDragStart: (0, import_react50.useCallback)((event) => {
      if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragStart)) {
        var node4 = ReactEditor.toSlateNode(editor, event.target);
        var path3 = ReactEditor.findPath(editor, node4);
        var voidMatch = Element2.isElement(node4) && Editor.isVoid(editor, node4) || Editor.void(editor, {
          at: path3,
          voids: true
        });
        if (voidMatch) {
          var range = Editor.range(editor, path3);
          Transforms.select(editor, range);
        }
        state.isDraggingInternally = true;
        ReactEditor.setFragmentData(editor, event.dataTransfer, "drag");
      }
    }, [readOnly, attributes.onDragStart]),
    onDrop: (0, import_react50.useCallback)((event) => {
      if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDrop)) {
        event.preventDefault();
        var draggedRange = editor.selection;
        var range = ReactEditor.findEventRange(editor, event);
        var data = event.dataTransfer;
        Transforms.select(editor, range);
        if (state.isDraggingInternally) {
          if (draggedRange && !Range.equals(draggedRange, range) && !Editor.void(editor, {
            at: range,
            voids: true
          })) {
            Transforms.delete(editor, {
              at: draggedRange
            });
          }
        }
        ReactEditor.insertData(editor, data);
        if (!ReactEditor.isFocused(editor)) {
          ReactEditor.focus(editor);
        }
      }
      state.isDraggingInternally = false;
    }, [readOnly, attributes.onDrop]),
    onDragEnd: (0, import_react50.useCallback)((event) => {
      if (!readOnly && state.isDraggingInternally && attributes.onDragEnd && ReactEditor.hasTarget(editor, event.target)) {
        attributes.onDragEnd(event);
      }
      state.isDraggingInternally = false;
    }, [readOnly, attributes.onDragEnd]),
    onFocus: (0, import_react50.useCallback)((event) => {
      if (!readOnly && !state.isUpdatingSelection && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onFocus)) {
        var el = ReactEditor.toDOMNode(editor, editor);
        var root = ReactEditor.findDocumentOrShadowRoot(editor);
        state.latestElement = root.activeElement;
        if (IS_FIREFOX && event.target !== el) {
          el.focus();
          return;
        }
        IS_FOCUSED.set(editor, true);
      }
    }, [readOnly, attributes.onFocus]),
    onKeyDown: (0, import_react50.useCallback)((event) => {
      if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target)) {
        androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleKeyDown(event);
        var {
          nativeEvent
        } = event;
        if (ReactEditor.isComposing(editor) && nativeEvent.isComposing === false) {
          IS_COMPOSING.set(editor, false);
          setIsComposing(false);
        }
        if (isEventHandled(event, attributes.onKeyDown) || ReactEditor.isComposing(editor)) {
          return;
        }
        var {
          selection
        } = editor;
        var element4 = editor.children[selection !== null ? selection.focus.path[0] : 0];
        var isRTL = (0, import_direction.default)(Node3.string(element4)) === "rtl";
        if (Hotkeys.isRedo(nativeEvent)) {
          event.preventDefault();
          var maybeHistoryEditor = editor;
          if (typeof maybeHistoryEditor.redo === "function") {
            maybeHistoryEditor.redo();
          }
          return;
        }
        if (Hotkeys.isUndo(nativeEvent)) {
          event.preventDefault();
          var _maybeHistoryEditor = editor;
          if (typeof _maybeHistoryEditor.undo === "function") {
            _maybeHistoryEditor.undo();
          }
          return;
        }
        if (Hotkeys.isMoveLineBackward(nativeEvent)) {
          event.preventDefault();
          Transforms.move(editor, {
            unit: "line",
            reverse: true
          });
          return;
        }
        if (Hotkeys.isMoveLineForward(nativeEvent)) {
          event.preventDefault();
          Transforms.move(editor, {
            unit: "line"
          });
          return;
        }
        if (Hotkeys.isExtendLineBackward(nativeEvent)) {
          event.preventDefault();
          Transforms.move(editor, {
            unit: "line",
            edge: "focus",
            reverse: true
          });
          return;
        }
        if (Hotkeys.isExtendLineForward(nativeEvent)) {
          event.preventDefault();
          Transforms.move(editor, {
            unit: "line",
            edge: "focus"
          });
          return;
        }
        if (Hotkeys.isMoveBackward(nativeEvent)) {
          event.preventDefault();
          if (selection && Range.isCollapsed(selection)) {
            Transforms.move(editor, {
              reverse: !isRTL
            });
          } else {
            Transforms.collapse(editor, {
              edge: "start"
            });
          }
          return;
        }
        if (Hotkeys.isMoveForward(nativeEvent)) {
          event.preventDefault();
          if (selection && Range.isCollapsed(selection)) {
            Transforms.move(editor, {
              reverse: isRTL
            });
          } else {
            Transforms.collapse(editor, {
              edge: "end"
            });
          }
          return;
        }
        if (Hotkeys.isMoveWordBackward(nativeEvent)) {
          event.preventDefault();
          if (selection && Range.isExpanded(selection)) {
            Transforms.collapse(editor, {
              edge: "focus"
            });
          }
          Transforms.move(editor, {
            unit: "word",
            reverse: !isRTL
          });
          return;
        }
        if (Hotkeys.isMoveWordForward(nativeEvent)) {
          event.preventDefault();
          if (selection && Range.isExpanded(selection)) {
            Transforms.collapse(editor, {
              edge: "focus"
            });
          }
          Transforms.move(editor, {
            unit: "word",
            reverse: isRTL
          });
          return;
        }
        if (!HAS_BEFORE_INPUT_SUPPORT) {
          if (Hotkeys.isBold(nativeEvent) || Hotkeys.isItalic(nativeEvent) || Hotkeys.isTransposeCharacter(nativeEvent)) {
            event.preventDefault();
            return;
          }
          if (Hotkeys.isSoftBreak(nativeEvent)) {
            event.preventDefault();
            Editor.insertSoftBreak(editor);
            return;
          }
          if (Hotkeys.isSplitBlock(nativeEvent)) {
            event.preventDefault();
            Editor.insertBreak(editor);
            return;
          }
          if (Hotkeys.isDeleteBackward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "backward"
              });
            } else {
              Editor.deleteBackward(editor);
            }
            return;
          }
          if (Hotkeys.isDeleteForward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "forward"
              });
            } else {
              Editor.deleteForward(editor);
            }
            return;
          }
          if (Hotkeys.isDeleteLineBackward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "backward"
              });
            } else {
              Editor.deleteBackward(editor, {
                unit: "line"
              });
            }
            return;
          }
          if (Hotkeys.isDeleteLineForward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "forward"
              });
            } else {
              Editor.deleteForward(editor, {
                unit: "line"
              });
            }
            return;
          }
          if (Hotkeys.isDeleteWordBackward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "backward"
              });
            } else {
              Editor.deleteBackward(editor, {
                unit: "word"
              });
            }
            return;
          }
          if (Hotkeys.isDeleteWordForward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "forward"
              });
            } else {
              Editor.deleteForward(editor, {
                unit: "word"
              });
            }
            return;
          }
        } else {
          if (IS_CHROME || IS_SAFARI) {
            if (selection && (Hotkeys.isDeleteBackward(nativeEvent) || Hotkeys.isDeleteForward(nativeEvent)) && Range.isCollapsed(selection)) {
              var currentNode = Node3.parent(editor, selection.anchor.path);
              if (Element2.isElement(currentNode) && Editor.isVoid(editor, currentNode) && (Editor.isInline(editor, currentNode) || Editor.isBlock(editor, currentNode))) {
                event.preventDefault();
                Editor.deleteBackward(editor, {
                  unit: "block"
                });
                return;
              }
            }
          }
        }
      }
    }, [readOnly, attributes.onKeyDown]),
    onPaste: (0, import_react50.useCallback)((event) => {
      if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onPaste)) {
        if (!HAS_BEFORE_INPUT_SUPPORT || isPlainTextOnlyPaste(event.nativeEvent) || IS_SAFARI) {
          event.preventDefault();
          ReactEditor.insertData(editor, event.clipboardData);
        }
      }
    }, [readOnly, attributes.onPaste])
  }), import_react50.default.createElement(Children3, {
    decorations,
    node: editor,
    renderElement: renderElement2,
    renderPlaceholder,
    renderLeaf: renderLeaf2,
    selection: editor.selection
  })))));
};
var DefaultPlaceholder = (_ref) => {
  var {
    attributes,
    children
  } = _ref;
  return (
    // COMPAT: Artificially add a line-break to the end on the placeholder element
    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter
    import_react50.default.createElement("span", Object.assign({}, attributes), children, IS_ANDROID && import_react50.default.createElement("br", null))
  );
};
var defaultDecorate = () => [];
var defaultScrollSelectionIntoView = (editor, domRange) => {
  if (domRange.getBoundingClientRect && (!editor.selection || editor.selection && Range.isCollapsed(editor.selection))) {
    var leafEl = domRange.startContainer.parentElement;
    leafEl.getBoundingClientRect = domRange.getBoundingClientRect.bind(domRange);
    es_default(leafEl, {
      scrollMode: "if-needed"
    });
    delete leafEl.getBoundingClientRect;
  }
};
var isEventHandled = (event, handler) => {
  if (!handler) {
    return false;
  }
  var shouldTreatEventAsHandled = handler(event);
  if (shouldTreatEventAsHandled != null) {
    return shouldTreatEventAsHandled;
  }
  return event.isDefaultPrevented() || event.isPropagationStopped();
};
var isDOMEventHandled = (event, handler) => {
  if (!handler) {
    return false;
  }
  var shouldTreatEventAsHandled = handler(event);
  if (shouldTreatEventAsHandled != null) {
    return shouldTreatEventAsHandled;
  }
  return event.defaultPrevented;
};
var FocusedContext = (0, import_react50.createContext)(false);
var SlateSelectorContext = (0, import_react50.createContext)({});
function getSelectorContext(editor) {
  var eventListeners = (0, import_react50.useRef)([]).current;
  var slateRef = (0, import_react50.useRef)({
    editor
  }).current;
  var onChange2 = (0, import_react50.useCallback)((editor2) => {
    slateRef.editor = editor2;
    eventListeners.forEach((listener) => listener(editor2));
  }, []);
  var selectorContext = (0, import_react50.useMemo)(() => {
    return {
      getSlate: () => slateRef.editor,
      addEventListener: (callback) => {
        eventListeners.push(callback);
        return () => {
          eventListeners.splice(eventListeners.indexOf(callback), 1);
        };
      }
    };
  }, [eventListeners, slateRef]);
  return {
    selectorContext,
    onChange: onChange2
  };
}
var _excluded3 = ["editor", "children", "onChange", "value"];
var Slate = (props) => {
  var {
    editor,
    children,
    onChange: onChange2,
    value: value2
  } = props, rest = _objectWithoutProperties2(props, _excluded3);
  var unmountRef = (0, import_react50.useRef)(false);
  var [context, setContext] = import_react50.default.useState(() => {
    if (!Node3.isNodeList(value2)) {
      throw new Error("[Slate] value is invalid! Expected a list of elements but got: ".concat(Scrubber.stringify(value2)));
    }
    if (!Editor.isEditor(editor)) {
      throw new Error("[Slate] editor is invalid! You passed: ".concat(Scrubber.stringify(editor)));
    }
    editor.children = value2;
    Object.assign(editor, rest);
    return {
      v: 0,
      editor
    };
  });
  var {
    selectorContext,
    onChange: handleSelectorChange
  } = getSelectorContext(editor);
  var onContextChange = (0, import_react50.useCallback)(() => {
    if (onChange2) {
      onChange2(editor.children);
    }
    setContext((prevContext) => ({
      v: prevContext.v + 1,
      editor
    }));
    handleSelectorChange(editor);
  }, [onChange2]);
  (0, import_react50.useEffect)(() => {
    EDITOR_TO_ON_CHANGE.set(editor, onContextChange);
    return () => {
      EDITOR_TO_ON_CHANGE.set(editor, () => {
      });
      unmountRef.current = true;
    };
  }, [onContextChange]);
  var [isFocused, setIsFocused] = (0, import_react50.useState)(ReactEditor.isFocused(editor));
  (0, import_react50.useEffect)(() => {
    setIsFocused(ReactEditor.isFocused(editor));
  });
  useIsomorphicLayoutEffect(() => {
    var fn2 = () => setIsFocused(ReactEditor.isFocused(editor));
    if (IS_REACT_VERSION_17_OR_ABOVE) {
      document.addEventListener("focusin", fn2);
      document.addEventListener("focusout", fn2);
      return () => {
        document.removeEventListener("focusin", fn2);
        document.removeEventListener("focusout", fn2);
      };
    } else {
      document.addEventListener("focus", fn2, true);
      document.addEventListener("blur", fn2, true);
      return () => {
        document.removeEventListener("focus", fn2, true);
        document.removeEventListener("blur", fn2, true);
      };
    }
  }, []);
  return import_react50.default.createElement(SlateSelectorContext.Provider, {
    value: selectorContext
  }, import_react50.default.createElement(SlateContext.Provider, {
    value: context
  }, import_react50.default.createElement(EditorContext.Provider, {
    value: context.editor
  }, import_react50.default.createElement(FocusedContext.Provider, {
    value: isFocused
  }, children))));
};
var doRectsIntersect = (rect, compareRect) => {
  var middle = (compareRect.top + compareRect.bottom) / 2;
  return rect.top <= middle && rect.bottom >= middle;
};
var areRangesSameLine = (editor, range1, range2) => {
  var rect1 = ReactEditor.toDOMRange(editor, range1).getBoundingClientRect();
  var rect2 = ReactEditor.toDOMRange(editor, range2).getBoundingClientRect();
  return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1);
};
var findCurrentLineRange = (editor, parentRange) => {
  var parentRangeBoundary = Editor.range(editor, Range.end(parentRange));
  var positions = Array.from(Editor.positions(editor, {
    at: parentRange
  }));
  var left = 0;
  var right = positions.length;
  var middle = Math.floor(right / 2);
  if (areRangesSameLine(editor, Editor.range(editor, positions[left]), parentRangeBoundary)) {
    return Editor.range(editor, positions[left], parentRangeBoundary);
  }
  if (positions.length < 2) {
    return Editor.range(editor, positions[positions.length - 1], parentRangeBoundary);
  }
  while (middle !== positions.length && middle !== left) {
    if (areRangesSameLine(editor, Editor.range(editor, positions[middle]), parentRangeBoundary)) {
      right = middle;
    } else {
      left = middle;
    }
    middle = Math.floor((left + right) / 2);
  }
  return Editor.range(editor, positions[right], parentRangeBoundary);
};
function ownKeys2(object2, enumerableOnly) {
  var keys3 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread2(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6] != null ? arguments[i6] : {};
    if (i6 % 2) {
      ownKeys2(Object(source), true).forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var withReact = function withReact2(editor) {
  var clipboardFormatKey2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x-slate-fragment";
  var e6 = editor;
  var {
    apply,
    onChange: onChange2,
    deleteBackward,
    addMark,
    removeMark
  } = e6;
  EDITOR_TO_KEY_TO_ELEMENT.set(e6, /* @__PURE__ */ new WeakMap());
  e6.addMark = (key, value2) => {
    var _EDITOR_TO_SCHEDULE_F, _EDITOR_TO_PENDING_DI;
    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(e6)) === null || _EDITOR_TO_SCHEDULE_F === void 0 ? void 0 : _EDITOR_TO_SCHEDULE_F();
    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e6) && (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(e6)) !== null && _EDITOR_TO_PENDING_DI !== void 0 && _EDITOR_TO_PENDING_DI.length) {
      EDITOR_TO_PENDING_INSERTION_MARKS.set(e6, null);
    }
    EDITOR_TO_USER_MARKS.delete(e6);
    addMark(key, value2);
  };
  e6.removeMark = (key) => {
    var _EDITOR_TO_PENDING_DI2;
    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e6) && (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(e6)) !== null && _EDITOR_TO_PENDING_DI2 !== void 0 && _EDITOR_TO_PENDING_DI2.length) {
      EDITOR_TO_PENDING_INSERTION_MARKS.set(e6, null);
    }
    EDITOR_TO_USER_MARKS.delete(e6);
    removeMark(key);
  };
  e6.deleteBackward = (unit) => {
    if (unit !== "line") {
      return deleteBackward(unit);
    }
    if (e6.selection && Range.isCollapsed(e6.selection)) {
      var parentBlockEntry = Editor.above(e6, {
        match: (n6) => Element2.isElement(n6) && Editor.isBlock(e6, n6),
        at: e6.selection
      });
      if (parentBlockEntry) {
        var [, parentBlockPath] = parentBlockEntry;
        var parentElementRange = Editor.range(e6, parentBlockPath, e6.selection.anchor);
        var currentLineRange = findCurrentLineRange(e6, parentElementRange);
        if (!Range.isCollapsed(currentLineRange)) {
          Transforms.delete(e6, {
            at: currentLineRange
          });
        }
      }
    }
  };
  e6.apply = (op) => {
    var matches = [];
    var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(e6);
    if (pendingDiffs !== null && pendingDiffs !== void 0 && pendingDiffs.length) {
      var transformed = pendingDiffs.map((textDiff) => transformTextDiff(textDiff, op)).filter(Boolean);
      EDITOR_TO_PENDING_DIFFS.set(e6, transformed);
    }
    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(e6);
    if (pendingSelection) {
      EDITOR_TO_PENDING_SELECTION.set(e6, transformPendingRange(e6, pendingSelection, op));
    }
    var pendingAction = EDITOR_TO_PENDING_ACTION.get(e6);
    if (pendingAction !== null && pendingAction !== void 0 && pendingAction.at) {
      var at = Point.isPoint(pendingAction === null || pendingAction === void 0 ? void 0 : pendingAction.at) ? transformPendingPoint(e6, pendingAction.at, op) : transformPendingRange(e6, pendingAction.at, op);
      EDITOR_TO_PENDING_ACTION.set(e6, at ? _objectSpread2(_objectSpread2({}, pendingAction), {}, {
        at
      }) : null);
    }
    switch (op.type) {
      case "insert_text":
      case "remove_text":
      case "set_node":
      case "split_node": {
        matches.push(...getMatches(e6, op.path));
        break;
      }
      case "set_selection": {
        var _EDITOR_TO_USER_SELEC;
        (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(e6)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();
        EDITOR_TO_USER_SELECTION.delete(e6);
        break;
      }
      case "insert_node":
      case "remove_node": {
        matches.push(...getMatches(e6, Path.parent(op.path)));
        break;
      }
      case "merge_node": {
        var prevPath = Path.previous(op.path);
        matches.push(...getMatches(e6, prevPath));
        break;
      }
      case "move_node": {
        var commonPath = Path.common(Path.parent(op.path), Path.parent(op.newPath));
        matches.push(...getMatches(e6, commonPath));
        break;
      }
    }
    apply(op);
    for (var [path3, key] of matches) {
      var [node4] = Editor.node(e6, path3);
      NODE_TO_KEY.set(node4, key);
    }
  };
  e6.setFragmentData = (data) => {
    var {
      selection
    } = e6;
    if (!selection) {
      return;
    }
    var [start2, end] = Range.edges(selection);
    var startVoid = Editor.void(e6, {
      at: start2.path
    });
    var endVoid = Editor.void(e6, {
      at: end.path
    });
    if (Range.isCollapsed(selection) && !startVoid) {
      return;
    }
    var domRange = ReactEditor.toDOMRange(e6, selection);
    var contents = domRange.cloneContents();
    var attach = contents.childNodes[0];
    contents.childNodes.forEach((node4) => {
      if (node4.textContent && node4.textContent.trim() !== "") {
        attach = node4;
      }
    });
    if (endVoid) {
      var [voidNode] = endVoid;
      var r7 = domRange.cloneRange();
      var domNode = ReactEditor.toDOMNode(e6, voidNode);
      r7.setEndAfter(domNode);
      contents = r7.cloneContents();
    }
    if (startVoid) {
      attach = contents.querySelector("[data-slate-spacer]");
    }
    Array.from(contents.querySelectorAll("[data-slate-zero-width]")).forEach((zw) => {
      var isNewline = zw.getAttribute("data-slate-zero-width") === "n";
      zw.textContent = isNewline ? "\n" : "";
    });
    if (isDOMText(attach)) {
      var span = attach.ownerDocument.createElement("span");
      span.style.whiteSpace = "pre";
      span.appendChild(attach);
      contents.appendChild(span);
      attach = span;
    }
    var fragment = e6.getFragment();
    var string3 = JSON.stringify(fragment);
    var encoded = window.btoa(encodeURIComponent(string3));
    attach.setAttribute("data-slate-fragment", encoded);
    data.setData("application/".concat(clipboardFormatKey2), encoded);
    var div2 = contents.ownerDocument.createElement("div");
    div2.appendChild(contents);
    div2.setAttribute("hidden", "true");
    contents.ownerDocument.body.appendChild(div2);
    data.setData("text/html", div2.innerHTML);
    data.setData("text/plain", getPlainText(div2));
    contents.ownerDocument.body.removeChild(div2);
    return data;
  };
  e6.insertData = (data) => {
    if (!e6.insertFragmentData(data)) {
      e6.insertTextData(data);
    }
  };
  e6.insertFragmentData = (data) => {
    var fragment = data.getData("application/".concat(clipboardFormatKey2)) || getSlateFragmentAttribute(data);
    if (fragment) {
      var decoded = decodeURIComponent(window.atob(fragment));
      var parsed = JSON.parse(decoded);
      e6.insertFragment(parsed);
      return true;
    }
    return false;
  };
  e6.insertTextData = (data) => {
    var text7 = data.getData("text/plain");
    if (text7) {
      var lines = text7.split(/\r\n|\r|\n/);
      var split2 = false;
      for (var line2 of lines) {
        if (split2) {
          Transforms.splitNodes(e6, {
            always: true
          });
        }
        e6.insertText(line2);
        split2 = true;
      }
      return true;
    }
    return false;
  };
  e6.onChange = (options) => {
    import_react_dom5.default.unstable_batchedUpdates(() => {
      var onContextChange = EDITOR_TO_ON_CHANGE.get(e6);
      if (onContextChange) {
        onContextChange();
      }
      onChange2(options);
    });
  };
  return e6;
};
var getMatches = (e6, path3) => {
  var matches = [];
  for (var [n6, p5] of Editor.levels(e6, {
    at: path3
  })) {
    var key = ReactEditor.findKey(e6, n6);
    matches.push([p5, key]);
  }
  return matches;
};

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-editIcon.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime());
var editIcon = (0, import_jsx_runtime27.jsxs)(import_jsx_runtime27.Fragment, {
  children: [(0, import_jsx_runtime27.jsx)("path", {
    d: "M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"
  }), (0, import_jsx_runtime27.jsx)("path", {
    d: "M18.375 2.625a2.121 2.121 0 1 1 3 3L12 15l-4 1 1-4Z"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-externalLinkIcon.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime());
var externalLinkIcon = (0, import_jsx_runtime28.jsx)("path", {
  d: "M15 3h6v6M10 14 21 3M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-linkIcon.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime());
var linkIcon = (0, import_jsx_runtime29.jsxs)(import_jsx_runtime29.Fragment, {
  children: [(0, import_jsx_runtime29.jsx)("path", {
    d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"
  }), (0, import_jsx_runtime29.jsx)("path", {
    d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-unlinkIcon.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime());
var unlinkIcon = (0, import_jsx_runtime30.jsx)("path", {
  d: "m18.84 12.25 1.72-1.71h-.02a5.004 5.004 0 0 0-.12-7.07 5.006 5.006 0 0 0-6.95 0l-1.72 1.71M5.17 11.75l-1.71 1.71a5.004 5.004 0 0 0 .12 7.07 5.006 5.006 0 0 0 6.95 0l1.71-1.71M8 2v3M2 8h3M16 19v3M19 16h3"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-chevronDownIcon.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime());
var chevronDownIcon = (0, import_jsx_runtime31.jsx)("path", {
  d: "m6 9 6 6 6-6"
});

// node_modules/@keystar/ui/dist/keystar-ui-listbox.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime());
var import_react51 = __toESM(require_react());

// node_modules/@react-aria/listbox/dist/import.mjs
var $b1f0cad8af73213b$export$3585ede4d035bf14 = /* @__PURE__ */ new WeakMap();
function $b1f0cad8af73213b$var$normalizeKey(key) {
  if (typeof key === "string")
    return key.replace(/\s*/g, "");
  return "" + key;
}
function $b1f0cad8af73213b$export$9145995848b05025(state, itemKey) {
  let data = $b1f0cad8af73213b$export$3585ede4d035bf14.get(state);
  if (!data)
    throw new Error("Unknown list");
  return `${data.id}-option-${$b1f0cad8af73213b$var$normalizeKey(itemKey)}`;
}
function $c132121280ec012d$export$50eacbbf140a3141(props, state, ref) {
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let selectionBehavior = props.selectionBehavior || "toggle";
  let linkBehavior = props.linkBehavior || (selectionBehavior === "replace" ? "action" : "override");
  if (selectionBehavior === "toggle" && linkBehavior === "action")
    linkBehavior = "override";
  let { listProps } = (0, $982254629710d113$export$b95089534ab7c1fd)({
    ...props,
    ref,
    selectionManager: state.selectionManager,
    collection: state.collection,
    disabledKeys: state.disabledKeys,
    linkBehavior
  });
  let { focusWithinProps } = (0, $9ab94262bd0047c7$export$420e68273165f4ec)({
    onFocusWithin: props.onFocus,
    onBlurWithin: props.onBlur,
    onFocusWithinChange: props.onFocusChange
  });
  let id2 = (0, $bdb11010cef70236$export$f680877a34711e37)(props.id);
  (0, $b1f0cad8af73213b$export$3585ede4d035bf14).set(state, {
    id: id2,
    shouldUseVirtualFocus: props.shouldUseVirtualFocus,
    shouldSelectOnPressUp: props.shouldSelectOnPressUp,
    shouldFocusOnHover: props.shouldFocusOnHover,
    isVirtualized: props.isVirtualized,
    onAction: props.onAction,
    linkBehavior
  });
  let { labelProps, fieldProps } = (0, $d191a55c9702f145$export$8467354a121f1b9f)({
    ...props,
    id: id2,
    // listbox is not an HTML input element so it
    // shouldn't be labeled by a <label> element.
    labelElementType: "span"
  });
  return {
    labelProps,
    listBoxProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, focusWithinProps, state.selectionManager.selectionMode === "multiple" ? {
      "aria-multiselectable": "true"
    } : {}, {
      role: "listbox",
      ...(0, $3ef42575df84b30b$export$9d1611c77c2fe928)(fieldProps, listProps)
    })
  };
}
function $293f70390ea03370$export$497855f14858aa34(props, state, ref) {
  var _item_props;
  let { key } = props;
  let data = (0, $b1f0cad8af73213b$export$3585ede4d035bf14).get(state);
  var _props_isDisabled;
  let isDisabled = (_props_isDisabled = props.isDisabled) !== null && _props_isDisabled !== void 0 ? _props_isDisabled : state.disabledKeys.has(key);
  var _props_isSelected;
  let isSelected = (_props_isSelected = props.isSelected) !== null && _props_isSelected !== void 0 ? _props_isSelected : state.selectionManager.isSelected(key);
  var _props_shouldSelectOnPressUp;
  let shouldSelectOnPressUp = (_props_shouldSelectOnPressUp = props.shouldSelectOnPressUp) !== null && _props_shouldSelectOnPressUp !== void 0 ? _props_shouldSelectOnPressUp : data === null || data === void 0 ? void 0 : data.shouldSelectOnPressUp;
  var _props_shouldFocusOnHover;
  let shouldFocusOnHover = (_props_shouldFocusOnHover = props.shouldFocusOnHover) !== null && _props_shouldFocusOnHover !== void 0 ? _props_shouldFocusOnHover : data === null || data === void 0 ? void 0 : data.shouldFocusOnHover;
  var _props_shouldUseVirtualFocus;
  let shouldUseVirtualFocus = (_props_shouldUseVirtualFocus = props.shouldUseVirtualFocus) !== null && _props_shouldUseVirtualFocus !== void 0 ? _props_shouldUseVirtualFocus : data === null || data === void 0 ? void 0 : data.shouldUseVirtualFocus;
  var _props_isVirtualized;
  let isVirtualized = (_props_isVirtualized = props.isVirtualized) !== null && _props_isVirtualized !== void 0 ? _props_isVirtualized : data === null || data === void 0 ? void 0 : data.isVirtualized;
  let labelId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)();
  let descriptionId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)();
  let optionProps = {
    role: "option",
    "aria-disabled": isDisabled || void 0,
    "aria-selected": state.selectionManager.selectionMode !== "none" ? isSelected : void 0
  };
  if (!((0, $c87311424ea30a05$export$9ac100e40613ea10)() && (0, $c87311424ea30a05$export$78551043582a6a98)())) {
    optionProps["aria-label"] = props["aria-label"];
    optionProps["aria-labelledby"] = labelId;
    optionProps["aria-describedby"] = descriptionId;
  }
  let item2 = state.collection.getItem(key);
  if (isVirtualized) {
    let index3 = Number(item2 === null || item2 === void 0 ? void 0 : item2.index);
    optionProps["aria-posinset"] = Number.isNaN(index3) ? void 0 : index3 + 1;
    optionProps["aria-setsize"] = (0, $453cc9f0df89c0a5$export$77d5aafae4e095b2)(state.collection);
  }
  let { itemProps, isPressed, isFocused, hasAction, allowsSelection } = (0, $880e95eb8b93ba9a$export$ecf600387e221c37)({
    selectionManager: state.selectionManager,
    key,
    ref,
    shouldSelectOnPressUp,
    allowsDifferentPressOrigin: shouldSelectOnPressUp && shouldFocusOnHover,
    isVirtualized,
    shouldUseVirtualFocus,
    isDisabled,
    onAction: (data === null || data === void 0 ? void 0 : data.onAction) ? () => {
      var _data_onAction;
      return data === null || data === void 0 ? void 0 : (_data_onAction = data.onAction) === null || _data_onAction === void 0 ? void 0 : _data_onAction.call(data, key);
    } : void 0,
    linkBehavior: data === null || data === void 0 ? void 0 : data.linkBehavior
  });
  let { hoverProps } = (0, $6179b936705e76d3$export$ae780daf29e6d456)({
    isDisabled: isDisabled || !shouldFocusOnHover,
    onHoverStart() {
      if (!(0, $507fabe10e71c6fb$export$b9b3dfddab17db27)()) {
        state.selectionManager.setFocused(true);
        state.selectionManager.setFocusedKey(key);
      }
    }
  });
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(item2 === null || item2 === void 0 ? void 0 : item2.props, {
    isLink: !!(item2 === null || item2 === void 0 ? void 0 : (_item_props = item2.props) === null || _item_props === void 0 ? void 0 : _item_props.href)
  });
  delete domProps.id;
  return {
    optionProps: {
      ...optionProps,
      ...(0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, itemProps, hoverProps),
      id: (0, $b1f0cad8af73213b$export$9145995848b05025)(state, key)
    },
    labelProps: {
      id: labelId
    },
    descriptionProps: {
      id: descriptionId
    },
    isFocused,
    isFocusVisible: isFocused && (0, $507fabe10e71c6fb$export$b9b3dfddab17db27)(),
    isSelected,
    isDisabled,
    isPressed,
    allowsSelection,
    hasAction
  };
}
function $af383d3bef1cfdc9$export$c3f9f39876e4bc7(props) {
  let { heading: heading2, "aria-label": ariaLabel } = props;
  let headingId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  return {
    itemProps: {
      role: "presentation"
    },
    headingProps: heading2 ? {
      // Techincally, listbox cannot contain headings according to ARIA.
      // We hide the heading from assistive technology, using role="presentation",
      // and only use it as a visual label for the nested group.
      id: headingId,
      role: "presentation"
    } : {},
    groupProps: {
      role: "group",
      "aria-label": ariaLabel,
      "aria-labelledby": heading2 ? headingId : void 0
    }
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-listbox.js
var ListItem = forwardRefWithAs(function ListItem2(props, forwardedRef) {
  let {
    children,
    elementType: ElementType = "div",
    descriptionProps,
    keyboardShortcutProps,
    labelProps,
    isFocused,
    isHovered,
    isPressed,
    isSelected,
    ...otherProps
  } = props;
  let gridGutter = tokenSchema.size.space.regular;
  let contentGutter = tokenSchema.size.space.medium;
  let focusIndicatorWidth = tokenSchema.size.space.xsmall;
  let gridClassname = css({
    display: "grid",
    // listboxes (options) have selection indicators at the end, whilst menus have them at the start
    gridTemplateAreas: '". icon text . kbd checkmark ." ". icon description . kbd checkmark ."',
    gridTemplateColumns: `${gridGutter} auto 1fr ${contentGutter} auto ${tokenSchema.size.icon.regular} ${gridGutter}`,
    gridTemplateRows: "1fr auto",
    borderRadius: tokenSchema.size.radius.small,
    paddingBlock: tokenSchema.size.space.regular
  });
  let rootClassname = css({
    cursor: "default",
    color: tokenSchema.color.alias.foregroundIdle,
    display: "block",
    outline: 0,
    position: "relative",
    paddingInline: tokenSchema.size.space.small,
    // indicate when external link? e.g. `&[href^=http]`
    "a&": {
      cursor: "pointer"
    },
    "& .list-item-text": {
      marginBlock: `calc((${tokenSchema.size.icon.regular} - ${tokenSchema.typography.text.regular.capheight}) / 2)`
    },
    [`&:not([aria-disabled=true])`]: {
      "& .list-item-checkmark": {
        stroke: tokenSchema.color.alias.foregroundSelected
      },
      "& .list-item-text": {
        color: tokenSchema.color.foreground.neutralEmphasis
      },
      "& .list-item-icon": {
        color: tokenSchema.color.foreground.neutralSecondary
      }
    },
    // standard menu items: no selection indicator
    [`&[role=menuitem] .${gridClassname}`]: {
      gridTemplateAreas: '". icon text . kbd ." ". icon description . kbd ."',
      gridTemplateColumns: `${gridGutter} auto 1fr ${contentGutter} auto ${gridGutter}`
    },
    [[
      // selectable menu items: selection indicator at the start
      `&[role=menuitemcheckbox] .${gridClassname}, &[role=menuitemradio] .${gridClassname}`,
      // menus with _any_ selectable items must make space for the selection indicator
      `[data-selection=single] &[role=menuitem] .${gridClassname}, [data-selection=multiple] &[role=menuitem] .${gridClassname}`
    ].join(", ")]: {
      gridTemplateAreas: '". checkmark icon text . kbd ." ". checkmark icon description . kbd ."',
      gridTemplateColumns: `${tokenSchema.size.space.small} ${tokenSchema.size.icon.medium} auto 1fr ${contentGutter} auto ${gridGutter}`
    },
    // hover
    [`&[aria-disabled=false]:hover .${gridClassname}, &[data-hovered] .${gridClassname}`]: {
      backgroundColor: tokenSchema.color.alias.backgroundHovered,
      color: tokenSchema.color.alias.foregroundHovered
    },
    // focus
    [`&[aria-disabled=false]:focus .${gridClassname}, &[data-focused] .${gridClassname}`]: {
      backgroundColor: tokenSchema.color.alias.backgroundHovered,
      color: tokenSchema.color.alias.foregroundHovered
    },
    // emphasise `kbd` during interaction
    "&[aria-disabled=false]:hover kbd, &[data-hovered] kbd, &[aria-disabled=false]:focus kbd, &[data-focused] kbd": {
      color: tokenSchema.color.alias.foregroundIdle
    },
    // press
    [`&[aria-disabled=false]:active .${gridClassname}, &[data-pressed] .${gridClassname}`]: {
      backgroundColor: tokenSchema.color.alias.backgroundPressed,
      color: tokenSchema.color.alias.foregroundPressed
    },
    // focus indicator
    "&[data-focused]": {
      // [`& .${gridClassname}`]: {
      //   backgroundColor: tokenSchema.color.alias.backgroundSelected,
      // },
      "&::before": {
        backgroundColor: tokenSchema.color.background.accentEmphasis,
        borderRadius: focusIndicatorWidth,
        content: '""',
        insetBlock: tokenSchema.size.space.xsmall,
        insetInlineStart: 0,
        position: "absolute",
        width: focusIndicatorWidth
      }
    },
    // disabled
    "&[aria-disabled=true]": {
      color: tokenSchema.color.alias.foregroundDisabled,
      "& kbd": {
        color: "currentColor"
      },
      "& .list-item-checkmark": {
        stroke: "currentColor"
      }
    }
  });
  const slots = {
    text: {
      ...labelProps,
      color: "inherit",
      gridArea: "text",
      weight: "medium",
      UNSAFE_className: "list-item-text"
    },
    icon: {
      gridArea: "icon",
      marginEnd: "regular",
      UNSAFE_className: "list-item-icon"
    },
    description: {
      color: "neutralSecondary",
      gridArea: "description",
      marginY: "small",
      size: "small",
      ...descriptionProps
    },
    kbd: {
      UNSAFE_className: css({
        alignItems: "center",
        color: tokenSchema.color.foreground.neutralTertiary,
        display: "flex",
        gridArea: "kbd",
        height: tokenSchema.size.icon.regular
      }),
      ...keyboardShortcutProps
    }
  };
  return (0, import_jsx_runtime32.jsx)(
    ElementType,
    {
      ...toDataAttributes({
        focused: isFocused || void 0,
        hovered: isHovered || void 0,
        pressed: isPressed || void 0
      }),
      ...otherProps,
      ref: forwardedRef,
      className: classNames(rootClassname),
      children: (0, import_jsx_runtime32.jsx)("div", {
        className: gridClassname,
        children: (0, import_jsx_runtime32.jsx)(ClearSlots, {
          children: (0, import_jsx_runtime32.jsxs)(SlotProvider, {
            slots,
            children: [children, isSelected && (0, import_jsx_runtime32.jsx)(Icon, {
              src: checkIcon,
              slot: "checkmark",
              strokeScaling: false,
              gridArea: "checkmark",
              UNSAFE_className: "list-item-checkmark"
            })]
          })
        })
      })
    }
  );
});
var localizedMessages5 = {
  "ar-AE": {
    loading: "جارٍ التحميل...",
    loadingMore: "جارٍ تحميل المزيد..."
  },
  "bg-BG": {
    loading: "Зареждане...",
    loadingMore: "Зареждане на още..."
  },
  "cs-CZ": {
    loading: "Načítání...",
    loadingMore: "Načítání dalších..."
  },
  "da-DK": {
    loading: "Indlæser ...",
    loadingMore: "Indlæser flere ..."
  },
  "de-DE": {
    loading: "Laden...",
    loadingMore: "Mehr laden ..."
  },
  "el-GR": {
    loading: "Φόρτωση...",
    loadingMore: "Φόρτωση περισσότερων..."
  },
  "en-US": {
    loading: "Loading…",
    loadingMore: "Loading more…"
  },
  "es-ES": {
    loading: "Cargando…",
    loadingMore: "Cargando más…"
  },
  "et-EE": {
    loading: "Laadimine...",
    loadingMore: "Laadi rohkem..."
  },
  "fi-FI": {
    loading: "Ladataan…",
    loadingMore: "Ladataan lisää…"
  },
  "fr-FR": {
    loading: "Chargement...",
    loadingMore: "Chargement supplémentaire..."
  },
  "he-IL": {
    loading: "טוען...",
    loadingMore: "טוען עוד..."
  },
  "hr-HR": {
    loading: "Učitavam...",
    loadingMore: "Učitavam još..."
  },
  "hu-HU": {
    loading: "Betöltés folyamatban…",
    loadingMore: "Továbbiak betöltése folyamatban…"
  },
  "it-IT": {
    loading: "Caricamento...",
    loadingMore: "Caricamento altri..."
  },
  "ja-JP": {
    loading: "読み込み中...",
    loadingMore: "さらに読み込み中..."
  },
  "ko-KR": {
    loading: "로드 중",
    loadingMore: "추가 로드 중"
  },
  "lt-LT": {
    loading: "Įkeliama...",
    loadingMore: "Įkeliama daugiau..."
  },
  "lv-LV": {
    loading: "Notiek ielāde...",
    loadingMore: "Tiek ielādēts vēl..."
  },
  "nb-NO": {
    loading: "Laster inn ...",
    loadingMore: "Laster inn flere ..."
  },
  "nl-NL": {
    loading: "Laden...",
    loadingMore: "Meer laden..."
  },
  "pl-PL": {
    loading: "Ładowanie...",
    loadingMore: "Wczytywanie większej liczby..."
  },
  "pt-BR": {
    loading: "Carregando...",
    loadingMore: "Carregando mais..."
  },
  "pt-PT": {
    loading: "A carregar...",
    loadingMore: "A carregar mais..."
  },
  "ro-RO": {
    loading: "Se încarcă...",
    loadingMore: "Se încarcă mai multe..."
  },
  "ru-RU": {
    loading: "Загрузка...",
    loadingMore: "Дополнительная загрузка..."
  },
  "sk-SK": {
    loading: "Načítava sa...",
    loadingMore: "Načítava sa viac..."
  },
  "sl-SI": {
    loading: "Nalaganje...",
    loadingMore: "Nalaganje več vsebine..."
  },
  "sr-SP": {
    loading: "Učitavam...",
    loadingMore: "Učitavam još..."
  },
  "sv-SE": {
    loading: "Läser in...",
    loadingMore: "Läser in mer..."
  },
  "tr-TR": {
    loading: "Yükleniyor...",
    loadingMore: "Daha fazla yükleniyor..."
  },
  "uk-UA": {
    loading: "Завантаження…",
    loadingMore: "Завантаження інших об’єктів..."
  },
  "zh-CN": {
    loading: "正在加载...",
    loadingMore: "正在加载更多..."
  },
  "zh-T": {
    loading: "正在載入",
    loadingMore: "正在載入更多…"
  }
};
var ListBoxContext = (0, import_react51.createContext)(null);
function useListBoxContext() {
  let context = (0, import_react51.useContext)(ListBoxContext);
  assert(!!context, "ListBoxContext is missing");
  return context;
}
function ListBoxOption(props) {
  let {
    item: item2,
    shouldSelectOnPressUp,
    shouldFocusOnHover,
    shouldUseVirtualFocus
  } = props;
  let {
    rendered,
    key
  } = item2;
  let state = useListBoxContext();
  let ref = (0, import_react51.useRef)(null);
  let {
    optionProps,
    labelProps,
    descriptionProps,
    isSelected,
    isDisabled,
    isFocused,
    isPressed
  } = $293f70390ea03370$export$497855f14858aa34({
    "aria-label": item2["aria-label"],
    key,
    shouldSelectOnPressUp,
    shouldFocusOnHover,
    isVirtualized: true,
    shouldUseVirtualFocus
  }, state, ref);
  let {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    ...props,
    isDisabled
  });
  let {
    isFocusVisible: isFocusVisible$1,
    focusProps
  } = $f7dceffc5ad7768b$export$4e328f61c538687f();
  let contents = isReactText(rendered) ? (0, import_jsx_runtime32.jsx)(Text2, {
    children: rendered
  }) : rendered;
  let isKeyboardModality = $507fabe10e71c6fb$export$b9b3dfddab17db27();
  return (0, import_jsx_runtime32.jsx)(ListItem, {
    descriptionProps,
    labelProps,
    isFocused: shouldUseVirtualFocus ? isFocused && isKeyboardModality : isFocusVisible$1,
    isHovered: isHovered && !shouldFocusOnHover || isFocused && !isKeyboardModality,
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(optionProps, focusProps, shouldFocusOnHover ? {} : hoverProps),
    isPressed,
    isSelected,
    ref,
    children: contents
  });
}
function ListBoxSection(props) {
  let {
    children,
    layoutInfo,
    headerLayoutInfo,
    virtualizer,
    item: item2
  } = props;
  let {
    headingProps,
    groupProps
  } = $af383d3bef1cfdc9$export$c3f9f39876e4bc7({
    heading: item2.rendered,
    "aria-label": item2["aria-label"]
  });
  let headerRef = (0, import_react51.useRef)(null);
  $47736c1e63ba1c6d$export$1da781778207e0a2({
    layoutInfo: headerLayoutInfo,
    virtualizer,
    ref: headerRef
  });
  let {
    direction
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let state = useListBoxContext();
  return (0, import_jsx_runtime32.jsxs)(import_react51.Fragment, {
    children: [(0, import_jsx_runtime32.jsxs)("div", {
      role: "presentation",
      ref: headerRef,
      style: $ccf8a0a04e4175ae$export$1481e64fbe01b8b3(headerLayoutInfo, direction),
      children: [item2.key !== state.collection.getFirstKey() && (0, import_jsx_runtime32.jsx)(Divider, {
        role: "presentation",
        elementType: "div",
        size: "medium",
        UNSAFE_className: css({
          margin: tokenSchema.size.space.medium
        })
      }), item2.rendered && (0, import_jsx_runtime32.jsx)(Text2, {
        ...headingProps,
        casing: "uppercase",
        color: "neutralSecondary",
        size: "small",
        weight: "medium",
        UNSAFE_className: css({
          padding: tokenSchema.size.space.medium
        }),
        children: item2.rendered
      })]
    }), (0, import_jsx_runtime32.jsx)("div", {
      ...groupProps,
      style: $ccf8a0a04e4175ae$export$1481e64fbe01b8b3(layoutInfo, direction),
      className: classNames(css({}), "ListBoxSection"),
      children
    })]
  });
}
function useListBoxLayout(state) {
  let {
    scale
  } = useProvider();
  let collator = $325a3faab7a68acd$export$a16aca283550c30d({
    usage: "search",
    sensitivity: "base"
  });
  let layout = (0, import_react51.useMemo)(() => new $61ef60fc9b1041f4$export$cacbb3924155d68e({
    estimatedRowHeight: scale === "large" ? 48 : 32,
    estimatedHeadingHeight: scale === "large" ? 33 : 26,
    padding: scale === "large" ? 5 : 4,
    loaderHeight: 40,
    placeholderHeight: scale === "large" ? 48 : 32,
    collator
  }), [collator, scale]);
  layout.collection = state.collection;
  layout.disabledKeys = state.disabledKeys;
  return layout;
}
function ListBoxBase(props, forwardedRef) {
  let {
    layout,
    state,
    shouldSelectOnPressUp,
    focusOnPointerEnter,
    shouldUseVirtualFocus,
    domProps = {},
    transitionDuration = 0,
    onScroll
  } = props;
  let {
    listBoxProps
  } = $c132121280ec012d$export$50eacbbf140a3141({
    ...props,
    keyboardDelegate: layout,
    isVirtualized: true
  }, state, forwardedRef);
  let styleProps = useStyleProps(props);
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages5);
  layout.isLoading = !!props.isLoading;
  let renderWrapper = (parent, reusableView, children, renderChildren) => {
    if (reusableView.viewType === "section") {
      var _children$find;
      return (0, import_jsx_runtime32.jsx)(ListBoxSection, {
        item: reusableView.content,
        layoutInfo: reusableView.layoutInfo,
        virtualizer: reusableView.virtualizer,
        headerLayoutInfo: (_children$find = children.find((c5) => c5.viewType === "header")) === null || _children$find === void 0 ? void 0 : _children$find.layoutInfo,
        children: renderChildren(children.filter((c5) => c5.viewType === "item"))
      }, reusableView.key);
    }
    return (0, import_jsx_runtime32.jsx)($ccf8a0a04e4175ae$export$6796df8ba7398521, {
      layoutInfo: reusableView.layoutInfo,
      virtualizer: reusableView.virtualizer,
      parent: parent === null || parent === void 0 ? void 0 : parent.layoutInfo,
      children: reusableView.rendered
    }, reusableView.key);
  };
  return (0, import_jsx_runtime32.jsx)(ListBoxContext.Provider, {
    value: state,
    children: (0, import_jsx_runtime32.jsx)($9bf71ea28793e738$export$20e40289641fbbb6, {
      children: (0, import_jsx_runtime32.jsx)($6d0a5c394373ae64$export$89be5a243e59c4b2, {
        ...styleProps,
        ...$3ef42575df84b30b$export$9d1611c77c2fe928(listBoxProps, domProps),
        ref: forwardedRef,
        focusedKey: state.selectionManager.focusedKey,
        autoFocus: !!props.autoFocus,
        sizeToFit: "height",
        scrollDirection: "vertical",
        layout,
        collection: state.collection,
        renderWrapper,
        transitionDuration,
        isLoading: props.isLoading,
        onLoadMore: props.onLoadMore,
        shouldUseVirtualFocus,
        onScroll,
        children: (type2, item2) => {
          if (type2 === "item") {
            return (0, import_jsx_runtime32.jsx)(ListBoxOption, {
              item: item2,
              shouldSelectOnPressUp,
              shouldFocusOnHover: focusOnPointerEnter,
              shouldUseVirtualFocus
            });
          } else if (type2 === "loader") {
            return (0, import_jsx_runtime32.jsx)("div", {
              role: "option",
              style: {
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                height: "100%"
              },
              children: (0, import_jsx_runtime32.jsx)(ProgressCircle, {
                isIndeterminate: true,
                size: "small",
                "aria-label": state.collection.size > 0 ? stringFormatter.format("loadingMore") : stringFormatter.format("loading")
              })
            });
          } else if (type2 === "placeholder") {
            let emptyState = props.renderEmptyState ? props.renderEmptyState() : null;
            if (emptyState == null) {
              return null;
            }
            return (0, import_jsx_runtime32.jsx)("div", {
              role: "option",
              children: emptyState
            });
          }
        }
      })
    })
  });
}
var _ListBoxBase = (0, import_react51.forwardRef)(ListBoxBase);
function ListBox(props, forwardedRef) {
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let state = $e72dd72e1c76a225$export$2f645645f7bca764(props);
  let layout = useListBoxLayout(state);
  return (0, import_jsx_runtime32.jsx)(_ListBoxBase, {
    ...props,
    ref: domRef,
    state,
    layout
  });
}
var _ListBox = (0, import_react51.forwardRef)(ListBox);
var listStyles = css({
  borderRadius: "inherit",
  maxHeight: "inherit",
  // maxWidth: tokenSchema.size.dialog.small,
  outline: 0,
  overflowY: "auto",
  paddingBlock: tokenSchema.size.space.small,
  userSelect: "none"
});

// node_modules/@keystar/ui/dist/keystar-ui-menu.js
var import_react55 = __toESM(require_react());

// node_modules/@react-aria/menu/dist/ar-AE.mjs
var $c0398ad35c3639b7$exports = {};
$c0398ad35c3639b7$exports = {
  "longPressMessage": `اضغط مطولاً أو اضغط على Alt + السهم لأسفل لفتح القائمة`
};

// node_modules/@react-aria/menu/dist/bg-BG.mjs
var $7af657c4165927c3$exports = {};
$7af657c4165927c3$exports = {
  "longPressMessage": `Натиснете продължително или натиснете Alt+ стрелка надолу, за да отворите менюто`
};

// node_modules/@react-aria/menu/dist/cs-CZ.mjs
var $d95d4da6d531ab81$exports = {};
$d95d4da6d531ab81$exports = {
  "longPressMessage": `Dlouhým stiskem nebo stisknutím kláves Alt + šipka dolů otevřete nabídku`
};

// node_modules/@react-aria/menu/dist/da-DK.mjs
var $24ebda9c775dca17$exports = {};
$24ebda9c775dca17$exports = {
  "longPressMessage": `Langt tryk eller tryk på Alt + pil ned for at åbne menuen`
};

// node_modules/@react-aria/menu/dist/de-DE.mjs
var $743e0dfca6cab1e9$exports = {};
$743e0dfca6cab1e9$exports = {
  "longPressMessage": `Drücken Sie lange oder drücken Sie Alt + Nach-unten, um das Menü zu öffnen`
};

// node_modules/@react-aria/menu/dist/el-GR.mjs
var $a2f41026e05f1c84$exports = {};
$a2f41026e05f1c84$exports = {
  "longPressMessage": `Πιέστε παρατεταμένα ή πατήστε Alt + κάτω βέλος για να ανοίξετε το μενού`
};

// node_modules/@react-aria/menu/dist/en-US.mjs
var $43b800e97c901737$exports = {};
$43b800e97c901737$exports = {
  "longPressMessage": `Long press or press Alt + ArrowDown to open menu`
};

// node_modules/@react-aria/menu/dist/es-ES.mjs
var $442f5f6ac211e29f$exports = {};
$442f5f6ac211e29f$exports = {
  "longPressMessage": `Mantenga pulsado o pulse Alt + flecha abajo para abrir el menú`
};

// node_modules/@react-aria/menu/dist/et-EE.mjs
var $dff280acfeb2d8ac$exports = {};
$dff280acfeb2d8ac$exports = {
  "longPressMessage": `Menüü avamiseks vajutage pikalt või vajutage klahve Alt + allanool`
};

// node_modules/@react-aria/menu/dist/fi-FI.mjs
var $51608325613944d7$exports = {};
$51608325613944d7$exports = {
  "longPressMessage": `Avaa valikko painamalla pohjassa tai näppäinyhdistelmällä Alt + Alanuoli`
};

// node_modules/@react-aria/menu/dist/fr-FR.mjs
var $c4a1b1eabeaa87be$exports = {};
$c4a1b1eabeaa87be$exports = {
  "longPressMessage": `Appuyez de manière prolongée ou appuyez sur Alt + Flèche vers le bas pour ouvrir le menu.`
};

// node_modules/@react-aria/menu/dist/he-IL.mjs
var $8c74815cdee18d1b$exports = {};
$8c74815cdee18d1b$exports = {
  "longPressMessage": `לחץ לחיצה ארוכה או הקש Alt + ArrowDown כדי לפתוח את התפריט`
};

// node_modules/@react-aria/menu/dist/hr-HR.mjs
var $fd0e9ef6a7fe0ec9$exports = {};
$fd0e9ef6a7fe0ec9$exports = {
  "longPressMessage": `Dugo pritisnite ili pritisnite Alt + strelicu prema dolje za otvaranje izbornika`
};

// node_modules/@react-aria/menu/dist/hu-HU.mjs
var $a89a74a39eba465a$exports = {};
$a89a74a39eba465a$exports = {
  "longPressMessage": `Nyomja meg hosszan, vagy nyomja meg az Alt + lefele nyíl gombot a menü megnyitásához`
};

// node_modules/@react-aria/menu/dist/it-IT.mjs
var $edc7c66594a0ae8a$exports = {};
$edc7c66594a0ae8a$exports = {
  "longPressMessage": `Premere a lungo o premere Alt + Freccia giù per aprire il menu`
};

// node_modules/@react-aria/menu/dist/ja-JP.mjs
var $f1ab51510712db52$exports = {};
$f1ab51510712db52$exports = {
  "longPressMessage": `長押しまたは Alt+下矢印キーでメニューを開く`
};

// node_modules/@react-aria/menu/dist/ko-KR.mjs
var $f9b672d9b82fa3d6$exports = {};
$f9b672d9b82fa3d6$exports = {
  "longPressMessage": `길게 누르거나 Alt + 아래쪽 화살표를 눌러 메뉴 열기`
};

// node_modules/@react-aria/menu/dist/lt-LT.mjs
var $a385f3910feda499$exports = {};
$a385f3910feda499$exports = {
  "longPressMessage": `Norėdami atidaryti meniu, nuspaudę palaikykite arba paspauskite „Alt + ArrowDown“.`
};

// node_modules/@react-aria/menu/dist/lv-LV.mjs
var $4f1bde932c441789$exports = {};
$4f1bde932c441789$exports = {
  "longPressMessage": `Lai atvērtu izvēlni, turiet nospiestu vai nospiediet taustiņu kombināciju Alt + lejupvērstā bultiņa`
};

// node_modules/@react-aria/menu/dist/nb-NO.mjs
var $914a51a8a594d5be$exports = {};
$914a51a8a594d5be$exports = {
  "longPressMessage": `Langt trykk eller trykk Alt + PilNed for å åpne menyen`
};

// node_modules/@react-aria/menu/dist/nl-NL.mjs
var $89aaf803103bb500$exports = {};
$89aaf803103bb500$exports = {
  "longPressMessage": `Druk lang op Alt + pijl-omlaag of druk op Alt om het menu te openen`
};

// node_modules/@react-aria/menu/dist/pl-PL.mjs
var $c685891476dbaaca$exports = {};
$c685891476dbaaca$exports = {
  "longPressMessage": `Naciśnij i przytrzymaj lub naciśnij klawisze Alt + Strzałka w dół, aby otworzyć menu`
};

// node_modules/@react-aria/menu/dist/pt-BR.mjs
var $885879b9b10c2959$exports = {};
$885879b9b10c2959$exports = {
  "longPressMessage": `Pressione e segure ou pressione Alt + Seta para baixo para abrir o menu`
};

// node_modules/@react-aria/menu/dist/pt-PT.mjs
var $6b39616688a51692$exports = {};
$6b39616688a51692$exports = {
  "longPressMessage": `Prima continuamente ou prima Alt + Seta Para Baixo para abrir o menu`
};

// node_modules/@react-aria/menu/dist/ro-RO.mjs
var $f26362aed63f47e2$exports = {};
$f26362aed63f47e2$exports = {
  "longPressMessage": `Apăsați lung sau apăsați pe Alt + săgeată în jos pentru a deschide meniul`
};

// node_modules/@react-aria/menu/dist/ru-RU.mjs
var $06cbade644558bf0$exports = {};
$06cbade644558bf0$exports = {
  "longPressMessage": `Нажмите и удерживайте или нажмите Alt + Стрелка вниз, чтобы открыть меню`
};

// node_modules/@react-aria/menu/dist/sk-SK.mjs
var $0a391ff68f9d59b1$exports = {};
$0a391ff68f9d59b1$exports = {
  "longPressMessage": `Ponuku otvoríte dlhým stlačením alebo stlačením klávesu Alt + klávesu so šípkou nadol`
};

// node_modules/@react-aria/menu/dist/sl-SI.mjs
var $8193cf0e649c7928$exports = {};
$8193cf0e649c7928$exports = {
  "longPressMessage": `Za odprtje menija pritisnite in držite gumb ali pritisnite Alt+puščica navzdol`
};

// node_modules/@react-aria/menu/dist/sr-SP.mjs
var $f398debcce5a5c55$exports = {};
$f398debcce5a5c55$exports = {
  "longPressMessage": `Dugo pritisnite ili pritisnite Alt + strelicu prema dole da otvorite meni`
};

// node_modules/@react-aria/menu/dist/sv-SE.mjs
var $9e9fef000aa4c013$exports = {};
$9e9fef000aa4c013$exports = {
  "longPressMessage": `Håll nedtryckt eller tryck på Alt + pil nedåt för att öppna menyn`
};

// node_modules/@react-aria/menu/dist/tr-TR.mjs
var $c016c8183bbe3d68$exports = {};
$c016c8183bbe3d68$exports = {
  "longPressMessage": `Menüyü açmak için uzun basın veya Alt + Aşağı Ok tuşuna basın`
};

// node_modules/@react-aria/menu/dist/uk-UA.mjs
var $ca4f6c8462244e62$exports = {};
$ca4f6c8462244e62$exports = {
  "longPressMessage": `Довго або звичайно натисніть комбінацію клавіш Alt і стрілка вниз, щоб відкрити меню`
};

// node_modules/@react-aria/menu/dist/zh-CN.mjs
var $2d9960c02ccac927$exports = {};
$2d9960c02ccac927$exports = {
  "longPressMessage": `长按或按 Alt + 向下方向键以打开菜单`
};

// node_modules/@react-aria/menu/dist/zh-TW.mjs
var $f1b682a4c8c5631c$exports = {};
$f1b682a4c8c5631c$exports = {
  "longPressMessage": `長按或按 Alt+向下鍵以開啟功能表`
};

// node_modules/@react-aria/menu/dist/import.mjs
var import_react52 = __toESM(require_react(), 1);
function $parcel$interopDefault4(a3) {
  return a3 && a3.__esModule ? a3.default : a3;
}
var $2cbb7ca666678a14$exports = {};
$2cbb7ca666678a14$exports = {
  "ar-AE": $c0398ad35c3639b7$exports,
  "bg-BG": $7af657c4165927c3$exports,
  "cs-CZ": $d95d4da6d531ab81$exports,
  "da-DK": $24ebda9c775dca17$exports,
  "de-DE": $743e0dfca6cab1e9$exports,
  "el-GR": $a2f41026e05f1c84$exports,
  "en-US": $43b800e97c901737$exports,
  "es-ES": $442f5f6ac211e29f$exports,
  "et-EE": $dff280acfeb2d8ac$exports,
  "fi-FI": $51608325613944d7$exports,
  "fr-FR": $c4a1b1eabeaa87be$exports,
  "he-IL": $8c74815cdee18d1b$exports,
  "hr-HR": $fd0e9ef6a7fe0ec9$exports,
  "hu-HU": $a89a74a39eba465a$exports,
  "it-IT": $edc7c66594a0ae8a$exports,
  "ja-JP": $f1ab51510712db52$exports,
  "ko-KR": $f9b672d9b82fa3d6$exports,
  "lt-LT": $a385f3910feda499$exports,
  "lv-LV": $4f1bde932c441789$exports,
  "nb-NO": $914a51a8a594d5be$exports,
  "nl-NL": $89aaf803103bb500$exports,
  "pl-PL": $c685891476dbaaca$exports,
  "pt-BR": $885879b9b10c2959$exports,
  "pt-PT": $6b39616688a51692$exports,
  "ro-RO": $f26362aed63f47e2$exports,
  "ru-RU": $06cbade644558bf0$exports,
  "sk-SK": $0a391ff68f9d59b1$exports,
  "sl-SI": $8193cf0e649c7928$exports,
  "sr-SP": $f398debcce5a5c55$exports,
  "sv-SE": $9e9fef000aa4c013$exports,
  "tr-TR": $c016c8183bbe3d68$exports,
  "uk-UA": $ca4f6c8462244e62$exports,
  "zh-CN": $2d9960c02ccac927$exports,
  "zh-TW": $f1b682a4c8c5631c$exports
};
function $168583247155ddda$export$dc9c12ed27dd1b49(props, state, ref) {
  let { type: type2 = "menu", isDisabled, trigger: trigger2 = "press" } = props;
  let menuTriggerId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  let { triggerProps, overlayProps } = (0, $628037886ba31236$export$f9d5c8beee7d008d)({
    type: type2
  }, state, ref);
  let onKeyDown = (e6) => {
    if (isDisabled)
      return;
    if (trigger2 === "longPress" && !e6.altKey)
      return;
    if (ref && ref.current)
      switch (e6.key) {
        case "Enter":
        case " ":
          if (trigger2 === "longPress")
            return;
        case "ArrowDown":
          if (!("continuePropagation" in e6))
            e6.stopPropagation();
          e6.preventDefault();
          state.toggle("first");
          break;
        case "ArrowUp":
          if (!("continuePropagation" in e6))
            e6.stopPropagation();
          e6.preventDefault();
          state.toggle("last");
          break;
        default:
          if ("continuePropagation" in e6)
            e6.continuePropagation();
      }
  };
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault4($2cbb7ca666678a14$exports)), "@react-aria/menu");
  let { longPressProps } = (0, $8a26561d2877236e$export$c24ed0104d07eab9)({
    isDisabled: isDisabled || trigger2 !== "longPress",
    accessibilityDescription: stringFormatter.format("longPressMessage"),
    onLongPressStart() {
      state.close();
    },
    onLongPress() {
      state.open("first");
    }
  });
  let pressProps = {
    onPressStart(e6) {
      if (e6.pointerType !== "touch" && e6.pointerType !== "keyboard" && !isDisabled)
        state.toggle(e6.pointerType === "virtual" ? "first" : null);
    },
    onPress(e6) {
      if (e6.pointerType === "touch" && !isDisabled)
        state.toggle();
    }
  };
  delete triggerProps.onPress;
  return {
    menuTriggerProps: {
      ...triggerProps,
      ...trigger2 === "press" ? pressProps : longPressProps,
      id: menuTriggerId,
      onKeyDown
    },
    menuProps: {
      ...overlayProps,
      "aria-labelledby": menuTriggerId,
      autoFocus: state.focusStrategy || true,
      onClose: state.close
    }
  };
}
var $d5336fe17ce95402$export$6f49b4016bfc8d56 = /* @__PURE__ */ new WeakMap();
function $d5336fe17ce95402$export$38eaa17faae8f579(props, state, ref) {
  let { shouldFocusWrap = true, onKeyDown, onKeyUp, ...otherProps } = props;
  if (!props["aria-label"] && !props["aria-labelledby"])
    console.warn("An aria-label or aria-labelledby prop is required for accessibility.");
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let { listProps } = (0, $982254629710d113$export$b95089534ab7c1fd)({
    ...otherProps,
    ref,
    selectionManager: state.selectionManager,
    collection: state.collection,
    disabledKeys: state.disabledKeys,
    shouldFocusWrap,
    linkBehavior: "override"
  });
  $d5336fe17ce95402$export$6f49b4016bfc8d56.set(state, {
    onClose: props.onClose,
    onAction: props.onAction
  });
  return {
    menuProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, {
      onKeyDown,
      onKeyUp
    }, {
      role: "menu",
      ...listProps,
      onKeyDown: (e6) => {
        if (e6.key !== "Escape")
          listProps.onKeyDown(e6);
      }
    })
  };
}
function $a2e5df62f93c7633$export$9d32628fc2aea7da(props, state, ref) {
  var _item_props;
  let { key, closeOnSelect, isVirtualized, "aria-haspopup": hasPopup, onPressStart: pressStartProp, onPressUp: pressUpProp, onPress, onPressChange, onPressEnd, onHoverStart: hoverStartProp, onHoverChange, onHoverEnd, onKeyDown, onKeyUp, onFocus, onFocusChange, onBlur } = props;
  let isTrigger = !!hasPopup;
  var _props_isDisabled;
  let isDisabled = (_props_isDisabled = props.isDisabled) !== null && _props_isDisabled !== void 0 ? _props_isDisabled : state.disabledKeys.has(key);
  var _props_isSelected;
  let isSelected = (_props_isSelected = props.isSelected) !== null && _props_isSelected !== void 0 ? _props_isSelected : state.selectionManager.isSelected(key);
  let data = (0, $d5336fe17ce95402$export$6f49b4016bfc8d56).get(state);
  let onClose = props.onClose || data.onClose;
  let onAction = isTrigger ? () => {
  } : props.onAction || data.onAction;
  let router = (0, $ea8dcbcb9ea1b556$export$9a302a45f65d0572)();
  let performAction = (e6) => {
    if (onAction)
      onAction(key);
    if (e6.target instanceof HTMLAnchorElement)
      router.open(e6.target, e6);
  };
  let role = "menuitem";
  if (!isTrigger) {
    if (state.selectionManager.selectionMode === "single")
      role = "menuitemradio";
    else if (state.selectionManager.selectionMode === "multiple")
      role = "menuitemcheckbox";
  }
  let labelId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)();
  let descriptionId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)();
  let keyboardId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)();
  let ariaProps = {
    "aria-disabled": isDisabled || void 0,
    role,
    "aria-label": props["aria-label"],
    "aria-labelledby": labelId,
    "aria-describedby": [
      descriptionId,
      keyboardId
    ].filter(Boolean).join(" ") || void 0,
    "aria-controls": props["aria-controls"],
    "aria-haspopup": hasPopup,
    "aria-expanded": props["aria-expanded"]
  };
  if (state.selectionManager.selectionMode !== "none" && !isTrigger)
    ariaProps["aria-checked"] = isSelected;
  let item2 = state.collection.getItem(key);
  if (isVirtualized) {
    ariaProps["aria-posinset"] = item2 === null || item2 === void 0 ? void 0 : item2.index;
    ariaProps["aria-setsize"] = (0, $453cc9f0df89c0a5$export$77d5aafae4e095b2)(state.collection);
  }
  let onPressStart = (e6) => {
    if (e6.pointerType === "keyboard")
      performAction(e6);
    pressStartProp === null || pressStartProp === void 0 ? void 0 : pressStartProp(e6);
  };
  let onPressUp = (e6) => {
    if (e6.pointerType !== "keyboard") {
      performAction(e6);
      if (!isTrigger && onClose && (closeOnSelect !== null && closeOnSelect !== void 0 ? closeOnSelect : state.selectionManager.selectionMode !== "multiple" || state.selectionManager.isLink(key)))
        onClose();
    }
    pressUpProp === null || pressUpProp === void 0 ? void 0 : pressUpProp(e6);
  };
  let { itemProps, isFocused } = (0, $880e95eb8b93ba9a$export$ecf600387e221c37)({
    selectionManager: state.selectionManager,
    key,
    ref,
    shouldSelectOnPressUp: true,
    allowsDifferentPressOrigin: true,
    // Disable all handling of links in useSelectable item
    // because we handle it ourselves. The behavior of menus
    // is slightly different from other collections because
    // actions are performed on key down rather than key up.
    linkBehavior: "none"
  });
  let { pressProps, isPressed } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    onPressStart,
    onPress,
    onPressUp,
    onPressChange,
    onPressEnd,
    isDisabled
  });
  let { hoverProps } = (0, $6179b936705e76d3$export$ae780daf29e6d456)({
    isDisabled,
    onHoverStart(e6) {
      if (!(0, $507fabe10e71c6fb$export$b9b3dfddab17db27)()) {
        state.selectionManager.setFocused(true);
        state.selectionManager.setFocusedKey(key);
      }
      hoverStartProp === null || hoverStartProp === void 0 ? void 0 : hoverStartProp(e6);
    },
    onHoverChange,
    onHoverEnd
  });
  let { keyboardProps } = (0, $46d819fcbaf35654$export$8f71654801c2f7cd)({
    onKeyDown: (e6) => {
      if (e6.repeat) {
        e6.continuePropagation();
        return;
      }
      switch (e6.key) {
        case " ":
          if (!isDisabled && state.selectionManager.selectionMode === "none" && !isTrigger && closeOnSelect !== false && onClose)
            onClose();
          break;
        case "Enter":
          if (!isDisabled && closeOnSelect !== false && !isTrigger && onClose)
            onClose();
          break;
        default:
          if (!isTrigger)
            e6.continuePropagation();
          onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(e6);
          break;
      }
    },
    onKeyUp
  });
  let { focusProps } = (0, $a1ea59d68270f0dd$export$f8168d8dd8fd66e6)({
    onBlur,
    onFocus,
    onFocusChange
  });
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(item2.props, {
    isLink: !!(item2 === null || item2 === void 0 ? void 0 : (_item_props = item2.props) === null || _item_props === void 0 ? void 0 : _item_props.href)
  });
  delete domProps.id;
  return {
    menuItemProps: {
      ...ariaProps,
      ...(0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, isTrigger ? {
        onFocus: itemProps.onFocus
      } : itemProps, pressProps, hoverProps, keyboardProps, focusProps),
      tabIndex: itemProps.tabIndex != null ? -1 : void 0
    },
    labelProps: {
      id: labelId
    },
    descriptionProps: {
      id: descriptionId
    },
    keyboardShortcutProps: {
      id: keyboardId
    },
    isFocused,
    isSelected,
    isPressed,
    isDisabled
  };
}
function $3e5eb2498db5b506$export$73f7a44322579622(props) {
  let { heading: heading2, "aria-label": ariaLabel } = props;
  let headingId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  return {
    itemProps: {
      role: "presentation"
    },
    headingProps: heading2 ? {
      // Techincally, menus cannot contain headings according to ARIA.
      // We hide the heading from assistive technology, using role="presentation",
      // and only use it as a label for the nested group.
      id: headingId,
      role: "presentation"
    } : {},
    groupProps: {
      role: "group",
      "aria-label": ariaLabel,
      "aria-labelledby": heading2 ? headingId : void 0
    }
  };
}
var $d275435c250248f8$var$ANGLE_PADDING = Math.PI / 12;

// node_modules/@react-stately/tree/dist/import.mjs
var import_react53 = __toESM(require_react(), 1);
var $05ca4cd7c4a5a999$export$863faf230ee2118a = class {
  *[Symbol.iterator]() {
    yield* this.iterable;
  }
  get size() {
    return this.keyMap.size;
  }
  getKeys() {
    return this.keyMap.keys();
  }
  getKeyBefore(key) {
    let node4 = this.keyMap.get(key);
    return node4 ? node4.prevKey : null;
  }
  getKeyAfter(key) {
    let node4 = this.keyMap.get(key);
    return node4 ? node4.nextKey : null;
  }
  getFirstKey() {
    return this.firstKey;
  }
  getLastKey() {
    return this.lastKey;
  }
  getItem(key) {
    return this.keyMap.get(key);
  }
  at(idx) {
    const keys3 = [
      ...this.getKeys()
    ];
    return this.getItem(keys3[idx]);
  }
  constructor(nodes, { expandedKeys } = {}) {
    this.keyMap = /* @__PURE__ */ new Map();
    this.iterable = nodes;
    expandedKeys = expandedKeys || /* @__PURE__ */ new Set();
    let visit2 = (node4) => {
      this.keyMap.set(node4.key, node4);
      if (node4.childNodes && (node4.type === "section" || expandedKeys.has(node4.key)))
        for (let child of node4.childNodes)
          visit2(child);
    };
    for (let node4 of nodes)
      visit2(node4);
    let last2;
    let index3 = 0;
    for (let [key, node4] of this.keyMap) {
      if (last2) {
        last2.nextKey = key;
        node4.prevKey = last2.key;
      } else {
        this.firstKey = key;
        node4.prevKey = void 0;
      }
      if (node4.type === "item")
        node4.index = index3++;
      last2 = node4;
      last2.nextKey = void 0;
    }
    this.lastKey = last2 === null || last2 === void 0 ? void 0 : last2.key;
  }
};
function $875d6693e12af071$export$728d6ba534403756(props) {
  let [expandedKeys, setExpandedKeys] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(props.expandedKeys ? new Set(props.expandedKeys) : void 0, props.defaultExpandedKeys ? new Set(props.defaultExpandedKeys) : /* @__PURE__ */ new Set(), props.onExpandedChange);
  let selectionState = (0, $7af3f5b51489e0b5$export$253fe78d46329472)(props);
  let disabledKeys = (0, import_react53.useMemo)(() => props.disabledKeys ? new Set(props.disabledKeys) : /* @__PURE__ */ new Set(), [
    props.disabledKeys
  ]);
  let tree2 = (0, $7613b1592d41b092$export$6cd28814d92fa9c9)(props, (0, import_react53.useCallback)((nodes) => new (0, $05ca4cd7c4a5a999$export$863faf230ee2118a)(nodes, {
    expandedKeys
  }), [
    expandedKeys
  ]), null);
  (0, import_react53.useEffect)(() => {
    if (selectionState.focusedKey != null && !tree2.getItem(selectionState.focusedKey))
      selectionState.setFocusedKey(null);
  }, [
    tree2,
    selectionState.focusedKey
  ]);
  let onToggle = (key) => {
    setExpandedKeys($875d6693e12af071$var$toggleKey(expandedKeys, key));
  };
  return {
    collection: tree2,
    expandedKeys,
    disabledKeys,
    toggleKey: onToggle,
    setExpandedKeys,
    selectionManager: new (0, $d496c0a20b6e58ec$export$6c8a5aaad13c9852)(tree2, selectionState)
  };
}
function $875d6693e12af071$var$toggleKey(set2, key) {
  let res = new Set(set2);
  if (res.has(key))
    res.delete(key);
  else
    res.add(key);
  return res;
}

// node_modules/@keystar/ui/dist/keystar-ui-menu.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime());

// node_modules/@react-stately/menu/dist/import.mjs
var import_react54 = __toESM(require_react(), 1);
function $a28c903ee9ad8dc5$export$79fefeb1c2091ac3(props) {
  let overlayTriggerState = (0, $fc909762b330b746$export$61c6a8c84e605fb6)(props);
  let [focusStrategy, setFocusStrategy] = (0, import_react54.useState)(null);
  let [expandedKeysStack, setExpandedKeysStack] = (0, import_react54.useState)([]);
  let closeAll = () => {
    setExpandedKeysStack([]);
    overlayTriggerState.close();
  };
  let openSubmenu = (triggerKey, level) => {
    setExpandedKeysStack((oldStack) => {
      if (level > oldStack.length)
        return oldStack;
      return [
        ...oldStack.slice(0, level),
        triggerKey
      ];
    });
  };
  let closeSubmenu = (triggerKey, level) => {
    setExpandedKeysStack((oldStack) => {
      let key = oldStack[level];
      if (key === triggerKey)
        return oldStack.slice(0, level);
      else
        return oldStack;
    });
  };
  return {
    focusStrategy,
    ...overlayTriggerState,
    open(focusStrategy2 = null) {
      setFocusStrategy(focusStrategy2);
      overlayTriggerState.open();
    },
    toggle(focusStrategy2 = null) {
      setFocusStrategy(focusStrategy2);
      overlayTriggerState.toggle();
    },
    close() {
      closeAll();
    },
    UNSTABLE_expandedKeysStack: expandedKeysStack,
    UNSTABLE_openSubmenu: openSubmenu,
    UNSTABLE_closeSubmenu: closeSubmenu
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-moreHorizontalIcon.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime());
var moreHorizontalIcon = (0, import_jsx_runtime33.jsxs)(import_jsx_runtime33.Fragment, {
  children: [(0, import_jsx_runtime33.jsx)("circle", {
    cx: 12,
    cy: 12,
    r: 1
  }), (0, import_jsx_runtime33.jsx)("circle", {
    cx: 19,
    cy: 12,
    r: 1
  }), (0, import_jsx_runtime33.jsx)("circle", {
    cx: 5,
    cy: 12,
    r: 1
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-menu.js
var localizedMessages6 = {
  "ar-AE": {
    moreActions: "المزيد من الإجراءات"
  },
  "bg-BG": {
    moreActions: "Повече действия"
  },
  "cs-CZ": {
    moreActions: "Další akce"
  },
  "da-DK": {
    moreActions: "Flere handlinger"
  },
  "de-DE": {
    moreActions: "Mehr Aktionen"
  },
  "el-GR": {
    moreActions: "Περισσότερες ενέργειες"
  },
  "en-US": {
    moreActions: "More actions"
  },
  "es-ES": {
    moreActions: "Más acciones"
  },
  "et-EE": {
    moreActions: "Veel toiminguid"
  },
  "fi-FI": {
    moreActions: "Lisää toimintoja"
  },
  "fr-FR": {
    moreActions: "Autres actions"
  },
  "he-IL": {
    moreActions: "פעולות נוספות"
  },
  "hr-HR": {
    moreActions: "Dodatne radnje"
  },
  "hu-HU": {
    moreActions: "További lehetőségek"
  },
  "it-IT": {
    moreActions: "Altre azioni"
  },
  "ja-JP": {
    moreActions: "その他のアクション"
  },
  "ko-KR": {
    moreActions: "기타 작업"
  },
  "lt-LT": {
    moreActions: "Daugiau veiksmų"
  },
  "lv-LV": {
    moreActions: "Citas darbības"
  },
  "nb-NO": {
    moreActions: "Flere handlinger"
  },
  "nl-NL": {
    moreActions: "Meer handelingen"
  },
  "pl-PL": {
    moreActions: "Więcej akcji"
  },
  "pt-BR": {
    moreActions: "Mais ações"
  },
  "pt-PT": {
    moreActions: "Mais ações"
  },
  "ro-RO": {
    moreActions: "Mai multe acțiuni"
  },
  "ru-RU": {
    moreActions: "Дополнительные действия"
  },
  "sk-SK": {
    moreActions: "Ďalšie akcie"
  },
  "sl-SI": {
    moreActions: "Več možnosti"
  },
  "sr-SP": {
    moreActions: "Dodatne radnje"
  },
  "sv-SE": {
    moreActions: "Fler åtgärder"
  },
  "tr-TR": {
    moreActions: "Daha fazla eylem"
  },
  "uk-UA": {
    moreActions: "Більше дій"
  },
  "zh-CN": {
    moreActions: "更多操作"
  },
  "zh-TW": {
    moreActions: "更多動作"
  }
};
var MenuContext = import_react55.default.createContext({});
function useMenuContext() {
  return (0, import_react55.useContext)(MenuContext);
}
function MenuItem(props) {
  let {
    item: item2,
    state,
    isVirtualized,
    onAction
  } = props;
  let {
    onClose,
    closeOnSelect
  } = useMenuContext();
  let {
    rendered,
    key
  } = item2;
  let isSelected = state.selectionManager.isSelected(key);
  let isDisabled = state.selectionManager.isDisabled(key);
  let ref = (0, import_react55.useRef)(null);
  let {
    menuItemProps,
    labelProps,
    descriptionProps,
    keyboardShortcutProps
  } = $a2e5df62f93c7633$export$9d32628fc2aea7da({
    isSelected,
    isDisabled,
    "aria-label": item2["aria-label"],
    key,
    onClose,
    closeOnSelect,
    isVirtualized,
    onAction
  }, state, ref);
  let {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    isDisabled
  });
  let {
    focusProps,
    isFocusVisible
  } = $f7dceffc5ad7768b$export$4e328f61c538687f();
  let contents = isReactText(rendered) ? (0, import_jsx_runtime34.jsx)(Text2, {
    children: rendered
  }) : rendered;
  let role = state.selectionManager.disabledBehavior === "selection" && state.disabledKeys.has(key) ? "menuitem" : void 0;
  return (0, import_jsx_runtime34.jsx)(ListItem, {
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(menuItemProps, {
      role
    }, hoverProps, focusProps),
    elementType: item2.props.href ? "a" : "div",
    descriptionProps,
    keyboardShortcutProps,
    labelProps,
    isHovered,
    isFocused: isFocusVisible,
    isSelected,
    ref,
    children: contents
  });
}
function MenuSection(props) {
  let {
    item: item2,
    state,
    onAction
  } = props;
  let {
    itemProps,
    headingProps,
    groupProps
  } = $3e5eb2498db5b506$export$73f7a44322579622({
    heading: item2.rendered,
    "aria-label": item2["aria-label"]
  });
  let {
    separatorProps
  } = $f4b273590fab9f93$export$52210f68a14655d0({});
  return (0, import_jsx_runtime34.jsxs)(import_react55.Fragment, {
    children: [item2.key !== state.collection.getFirstKey() && (0, import_jsx_runtime34.jsx)(Divider, {
      ...separatorProps,
      marginY: "small"
    }), (0, import_jsx_runtime34.jsxs)("div", {
      ...itemProps,
      children: [item2.rendered && (0, import_jsx_runtime34.jsx)(Text2, {
        casing: "uppercase",
        size: "small",
        color: "neutralSecondary",
        weight: "medium",
        UNSAFE_className: css({
          paddingBlock: tokenSchema.size.space.regular,
          paddingInline: tokenSchema.size.space.medium
        }),
        ...headingProps,
        children: item2.rendered
      }), (0, import_jsx_runtime34.jsx)("div", {
        ...groupProps,
        children: [...$c5a24bc478652b5f$export$1005530eda016c13(item2, state.collection)].map((node4) => {
          let item3 = (0, import_jsx_runtime34.jsx)(MenuItem, {
            item: node4,
            state,
            onAction
          }, node4.key);
          if (node4.wrapper) {
            item3 = node4.wrapper(item3);
          }
          return item3;
        })
      })]
    })]
  });
}
function Menu(props, forwardedRef) {
  let contextProps = (0, import_react55.useContext)(MenuContext);
  let completeProps = {
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(contextProps, props)
  };
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let state = $875d6693e12af071$export$728d6ba534403756(completeProps);
  let {
    menuProps
  } = $d5336fe17ce95402$export$38eaa17faae8f579(completeProps, state, domRef);
  let styleProps = useStyleProps(completeProps);
  $e7801be82b4b2a53$export$4debdb1a3f0fa79e(contextProps, domRef);
  return (0, import_jsx_runtime34.jsx)("div", {
    ...menuProps,
    ...styleProps,
    ref: domRef,
    className: classNames(listStyles, styleProps.className),
    "data-selection": state.selectionManager.selectionMode,
    children: [...state.collection].map((item2) => {
      if (item2.type === "section") {
        return (0, import_jsx_runtime34.jsx)(MenuSection, {
          item: item2,
          state,
          onAction: completeProps.onAction
        }, item2.key);
      }
      let menuItem = (0, import_jsx_runtime34.jsx)(MenuItem, {
        item: item2,
        state,
        onAction: completeProps.onAction
      }, item2.key);
      if (item2.wrapper) {
        menuItem = item2.wrapper(menuItem);
      }
      return menuItem;
    })
  });
}
var _Menu = import_react55.default.forwardRef(Menu);
var MenuTrigger = (0, import_react55.forwardRef)(function MenuTrigger2(props, forwardedRef) {
  let triggerRef = (0, import_react55.useRef)(null);
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let menuTriggerRef = domRef || triggerRef;
  let menuRef = (0, import_react55.useRef)(null);
  let {
    children,
    align = "start",
    shouldFlip = true,
    direction = "bottom",
    closeOnSelect,
    trigger: trigger2 = "press"
  } = props;
  let [menuTrigger, menu] = import_react55.default.Children.toArray(children);
  let state = $a28c903ee9ad8dc5$export$79fefeb1c2091ac3(props);
  let {
    menuTriggerProps,
    menuProps
  } = $168583247155ddda$export$dc9c12ed27dd1b49({
    trigger: trigger2
  }, state, menuTriggerRef);
  let initialPlacement;
  switch (direction) {
    case "left":
    case "right":
    case "start":
    case "end":
      initialPlacement = `${direction} ${align === "end" ? "bottom" : "top"}`;
      break;
    case "bottom":
    case "top":
    default:
      initialPlacement = `${direction} ${align}`;
  }
  let isMobile = useIsMobileDevice();
  let menuContext = {
    ...menuProps,
    ref: menuRef,
    onClose: state.close,
    closeOnSelect,
    autoFocus: state.focusStrategy || true,
    UNSAFE_style: isMobile ? {
      width: "100%",
      maxHeight: "inherit"
    } : {
      maxWidth: tokenSchema.size.dialog.xsmall
    }
  };
  let overlay;
  if (isMobile) {
    overlay = (0, import_jsx_runtime34.jsx)(Tray, {
      state,
      children: menu
    });
  } else {
    overlay = (0, import_jsx_runtime34.jsx)(Popover, {
      state,
      triggerRef: menuTriggerRef,
      scrollRef: menuRef,
      placement: initialPlacement,
      hideArrow: true,
      shouldFlip,
      children: menu
    });
  }
  return (0, import_jsx_runtime34.jsxs)(import_react55.Fragment, {
    children: [(0, import_jsx_runtime34.jsx)(SlotProvider, {
      slots: {
        actionButton: {
          holdAffordance: trigger2 === "longPress"
        }
      },
      children: (0, import_jsx_runtime34.jsx)($f1ab8c75478c6f73$export$3351871ee4b288b8, {
        ...menuTriggerProps,
        ref: menuTriggerRef,
        isPressed: state.isOpen,
        children: menuTrigger
      })
    }), (0, import_jsx_runtime34.jsx)(MenuContext.Provider, {
      // TODO: Fix this type error
      // @ts-expect-error
      value: menuContext,
      children: overlay
    })]
  });
});
function ActionMenu(props, ref) {
  props = useSlotProps(props, "actionMenu");
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages6);
  let buttonProps = $65484d02dcb7eb3e$export$457c3d6518dd4c6f(props, {
    labelable: true
  });
  if (buttonProps["aria-label"] === void 0) {
    buttonProps["aria-label"] = stringFormatter.format("moreActions");
  }
  return (0, import_jsx_runtime34.jsxs)(MenuTrigger, {
    isOpen: props.isOpen,
    defaultOpen: props.defaultOpen,
    onOpenChange: props.onOpenChange,
    align: props.align,
    direction: props.direction,
    shouldFlip: props.shouldFlip,
    children: [(0, import_jsx_runtime34.jsx)(ActionButton, {
      ref,
      ...props,
      ...buttonProps,
      children: (0, import_jsx_runtime34.jsx)(Icon, {
        src: moreHorizontalIcon
      })
    }), (0, import_jsx_runtime34.jsx)(_Menu, {
      children: props.children,
      items: props.items,
      disabledKeys: props.disabledKeys,
      onAction: props.onAction
    })]
  });
}
var _ActionMenu = (0, import_react55.forwardRef)(ActionMenu);

// node_modules/@react-aria/actiongroup/dist/import.mjs
var import_react56 = __toESM(require_react(), 1);
var $304ac34015d4535d$var$BUTTON_GROUP_ROLES = {
  "none": "toolbar",
  "single": "radiogroup",
  "multiple": "toolbar"
};
function $304ac34015d4535d$export$f4bf8d43c16de704(props, state, ref) {
  let { isDisabled, orientation = "horizontal" } = props;
  let [isInToolbar, setInToolbar] = (0, import_react56.useState)(false);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    var _ref_current_parentElement;
    setInToolbar(!!(ref.current && ((_ref_current_parentElement = ref.current.parentElement) === null || _ref_current_parentElement === void 0 ? void 0 : _ref_current_parentElement.closest('[role="toolbar"]'))));
  }, [
    ref
  ]);
  let allKeys = [
    ...state.collection.getKeys()
  ];
  if (!allKeys.some((key) => !state.disabledKeys.has(key)))
    isDisabled = true;
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let focusManager = (0, $9bf71ea28793e738$export$c5251b9e124bf29)(ref);
  let flipDirection = direction === "rtl" && orientation === "horizontal";
  let onKeyDown = (e6) => {
    if (!e6.currentTarget.contains(e6.target))
      return;
    switch (e6.key) {
      case "ArrowRight":
      case "ArrowDown":
        e6.preventDefault();
        e6.stopPropagation();
        if (e6.key === "ArrowRight" && flipDirection)
          focusManager.focusPrevious({
            wrap: true
          });
        else
          focusManager.focusNext({
            wrap: true
          });
        break;
      case "ArrowLeft":
      case "ArrowUp":
        e6.preventDefault();
        e6.stopPropagation();
        if (e6.key === "ArrowLeft" && flipDirection)
          focusManager.focusNext({
            wrap: true
          });
        else
          focusManager.focusPrevious({
            wrap: true
          });
        break;
    }
  };
  let role = $304ac34015d4535d$var$BUTTON_GROUP_ROLES[state.selectionManager.selectionMode];
  if (isInToolbar && role === "toolbar")
    role = "group";
  return {
    actionGroupProps: {
      ...(0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
        labelable: true
      }),
      role,
      "aria-orientation": role === "toolbar" ? orientation : void 0,
      "aria-disabled": isDisabled,
      onKeyDown
    }
  };
}
var $f0ac0fb73c3ec062$var$BUTTON_ROLES = {
  "none": void 0,
  "single": "radio",
  "multiple": "checkbox"
};
function $f0ac0fb73c3ec062$export$9597202bd3099a29(props, state, ref) {
  let selectionMode = state.selectionManager.selectionMode;
  let buttonProps = {
    role: $f0ac0fb73c3ec062$var$BUTTON_ROLES[selectionMode]
  };
  if (selectionMode !== "none") {
    let isSelected = state.selectionManager.isSelected(props.key);
    buttonProps["aria-checked"] = isSelected;
  }
  let isFocused = props.key === state.selectionManager.focusedKey;
  let onRemovedWithFocus = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(() => {
    if (isFocused)
      state.selectionManager.setFocusedKey(null);
  });
  (0, import_react56.useEffect)(() => {
    return () => {
      onRemovedWithFocus();
    };
  }, [
    onRemovedWithFocus
  ]);
  return {
    buttonProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(buttonProps, {
      tabIndex: isFocused || state.selectionManager.focusedKey == null ? 0 : -1,
      onFocus() {
        state.selectionManager.setFocusedKey(props.key);
      },
      onPress() {
        state.selectionManager.select(props.key);
      }
    })
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-action-group.js
var import_react57 = __toESM(require_react());
var import_jsx_runtime35 = __toESM(require_jsx_runtime());
function ActionGroup(props, forwardedRef) {
  props = useProviderProps(props);
  props = useSlotProps(props, "actionGroup");
  let {
    density,
    prominence,
    isJustified,
    isDisabled,
    orientation = "horizontal",
    overflowMode,
    onAction,
    buttonLabelBehavior,
    summaryIcon,
    ...otherProps
  } = props;
  prominence = prominence === "low" ? "low" : "default";
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let wrapperRef = (0, import_react57.useRef)(null);
  let state = $e72dd72e1c76a225$export$2f645645f7bca764({
    ...props,
    suppressTextValueWarning: true
  });
  let {
    actionGroupProps
  } = $304ac34015d4535d$export$f4bf8d43c16de704(props, state, domRef);
  let providerProps = {
    isDisabled
  };
  let styleProps = useStyleProps(props);
  let isIconCollapsible = (0, import_react57.useMemo)(() => [...state.collection].every((item2) => typeof item2.rendered !== "string"), [state.collection]);
  let [{
    visibleItems,
    hideButtonText,
    isMeasuring
  }, setVisibleItems] = $1dbecbe27a04f9af$export$14d238f342723f25({
    visibleItems: state.collection.size,
    hideButtonText: buttonLabelBehavior === "hide" && isIconCollapsible,
    isMeasuring: false
  });
  let selectionMode = state.selectionManager.selectionMode;
  let updateOverflow = (0, import_react57.useCallback)(() => {
    if (overflowMode !== "collapse") {
      return;
    }
    if (orientation === "vertical" && selectionMode !== "none") {
      return;
    }
    let computeVisibleItems = (visibleItems2) => {
      if (domRef.current && wrapperRef.current) {
        let listItems = Array.from(domRef.current.children);
        let containerSize = orientation === "horizontal" ? wrapperRef.current.offsetWidth : wrapperRef.current.offsetHeight;
        let isShowingMenu = visibleItems2 < state.collection.size;
        let calculatedSize = 0;
        let newVisibleItems = 0;
        if (isShowingMenu) {
          let item2 = listItems.pop();
          if (item2) {
            calculatedSize += orientation === "horizontal" ? outerWidth(item2, false, true) : outerHeight(item2, false, true);
          }
        }
        for (let [i6, item2] of listItems.entries()) {
          calculatedSize += orientation === "horizontal" ? outerWidth(item2, i6 === 0, i6 === listItems.length - 1) : outerHeight(item2, i6 === 0, i6 === listItems.length - 1);
          if (calculatedSize <= containerSize) {
            newVisibleItems++;
          } else {
            break;
          }
        }
        if (selectionMode === "single" && newVisibleItems < state.collection.size) {
          return 0;
        }
        return newVisibleItems;
      }
      return visibleItems2;
    };
    setVisibleItems(function* () {
      let hideButtonText2 = buttonLabelBehavior === "hide" && isIconCollapsible;
      yield {
        visibleItems: state.collection.size,
        hideButtonText: hideButtonText2,
        isMeasuring: true
      };
      let newVisibleItems = computeVisibleItems(state.collection.size);
      let isMeasuring2 = newVisibleItems < state.collection.size && newVisibleItems > 0;
      if (newVisibleItems < state.collection.size && buttonLabelBehavior === "collapse" && isIconCollapsible) {
        yield {
          visibleItems: state.collection.size,
          hideButtonText: true,
          isMeasuring: true
        };
        newVisibleItems = computeVisibleItems(state.collection.size);
        isMeasuring2 = newVisibleItems < state.collection.size && newVisibleItems > 0;
        hideButtonText2 = true;
      }
      yield {
        visibleItems: newVisibleItems,
        hideButtonText: hideButtonText2,
        isMeasuring: isMeasuring2
      };
      if (isMeasuring2) {
        yield {
          visibleItems: computeVisibleItems(newVisibleItems),
          hideButtonText: hideButtonText2,
          isMeasuring: false
        };
      }
    });
  }, [domRef, state.collection, setVisibleItems, overflowMode, selectionMode, buttonLabelBehavior, isIconCollapsible, orientation]);
  let parentRef = (0, import_react57.useMemo)(() => ({
    get current() {
      var _wrapperRef$current;
      return (_wrapperRef$current = wrapperRef.current) === null || _wrapperRef$current === void 0 ? void 0 : _wrapperRef$current.parentElement;
    }
  }), [wrapperRef]);
  $9daab02d461809db$export$683480f191c0e3ea({
    ref: overflowMode !== "wrap" ? parentRef : void 0,
    onResize: updateOverflow
  });
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(updateOverflow, [updateOverflow, state.collection]);
  let children = [...state.collection];
  let menuItem = null;
  let menuProps = {};
  if (overflowMode === "collapse" && visibleItems === 0) {
    menuProps = $65484d02dcb7eb3e$export$457c3d6518dd4c6f(props, {
      labelable: true
    });
    actionGroupProps = {};
  }
  if (overflowMode === "collapse" && visibleItems < state.collection.size) {
    let menuChildren = children.slice(visibleItems);
    children = children.slice(0, visibleItems);
    menuItem = (0, import_jsx_runtime35.jsx)(ActionGroupMenu, {
      ...menuProps,
      items: menuChildren,
      prominence,
      onAction,
      isDisabled,
      state,
      summaryIcon,
      hideButtonText,
      isOnlyItem: visibleItems === 0,
      orientation
    });
  }
  let style = {
    ...styleProps.style,
    // While measuring, take up as much space as possible.
    flexBasis: isMeasuring ? "100%" : void 0
  };
  return (0, import_jsx_runtime35.jsx)($9bf71ea28793e738$export$20e40289641fbbb6, {
    children: (0, import_jsx_runtime35.jsx)("div", {
      ...styleProps,
      style,
      className: classNames(css({
        display: "flex",
        maxWidth: "100%"
      }), styleProps.className),
      ref: wrapperRef,
      children: (0, import_jsx_runtime35.jsx)("div", {
        ...actionGroupProps,
        ...toDataAttributes({
          overflow: overflowMode,
          prominence,
          justified: isJustified && !isMeasuring || void 0,
          compact: density === "compact" || void 0,
          vertical: orientation === "vertical" || void 0
        }),
        ref: domRef,
        className: classNames(css({
          display: "flex",
          // gap: tokenSchema.size.space.regular,
          // NOTE: `gap` seems to break the measurement/collapse logic, so we use margin instead.
          width: "calc(100% + var(--action-item-gap) + 1px)",
          margin: `calc(var(--action-item-gap) / -2)`,
          "--action-item-gap": tokenSchema.size.space.regular,
          [actionButtonClassList.selector("root", "child")]: {
            margin: `calc(var(--action-item-gap) / 2)`
          },
          // wrap
          "&[data-overflow=wrap]": {
            flexWrap: "wrap"
          },
          // justified
          "&[data-justified]": {
            [actionButtonClassList.selector("root", "child")]: {
              flexGrow: 1
            }
          },
          // compact
          "&[data-compact]:not([data-prominence=low])": {
            "--action-item-gap": 0,
            // gap: 0,
            [actionButtonClassList.selector("root", "child")]: {
              borderRadius: 0,
              "&:first-of-type": {
                borderTopLeftRadius: tokenSchema.size.radius.regular,
                borderBottomLeftRadius: tokenSchema.size.radius.regular
              },
              "&:last-of-type": {
                borderTopRightRadius: tokenSchema.size.radius.regular,
                borderBottomRightRadius: tokenSchema.size.radius.regular
              },
              "&:not(:last-of-type)": {
                marginRight: `calc(${tokenSchema.size.border.regular} * -1)`
              },
              "&.is-hovered, &.is-focused, &.is-pressed": {
                zIndex: 1
              },
              "&.is-selected": {
                zIndex: 2
              }
            }
          },
          "&[data-compact][data-prominence=low]": {
            "--action-item-gap": tokenSchema.size.space.small
          }
        }), otherProps.UNSAFE_className),
        children: (0, import_jsx_runtime35.jsxs)(KeystarProvider, {
          ...providerProps,
          children: [children.map((item2) => (0, import_jsx_runtime35.jsx)(ActionGroupItem, {
            onAction,
            prominence,
            isDisabled,
            item: item2,
            state,
            hideButtonText,
            orientation
          }, item2.key)), menuItem]
        })
      })
    })
  });
}
var _ActionGroup = (0, import_react57.forwardRef)(ActionGroup);
function ActionGroupItem({
  item: item2,
  state,
  isDisabled,
  onAction,
  hideButtonText,
  orientation,
  prominence
}) {
  let ref = (0, import_react57.useRef)(null);
  let {
    buttonProps
  } = $f0ac0fb73c3ec062$export$9597202bd3099a29({
    key: item2.key
  }, state);
  isDisabled = isDisabled || state.disabledKeys.has(item2.key);
  let isSelected = state.selectionManager.isSelected(item2.key);
  let domProps = $65484d02dcb7eb3e$export$457c3d6518dd4c6f(item2.props);
  if (onAction && !isDisabled) {
    buttonProps = $3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, {
      onPress: () => onAction(item2.key)
    });
  }
  let textId = $bdb11010cef70236$export$f680877a34711e37();
  let kbdId = $bdb11010cef70236$export$f680877a34711e37();
  let [textContent, setTextContent] = (0, import_react57.useState)("");
  let [kbdContent, setKbdContent] = (0, import_react57.useState)("");
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    if (hideButtonText) {
      var _document$getElementB, _document$getElementB2;
      setTextContent((_document$getElementB = document.getElementById(textId)) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.textContent);
      setKbdContent((_document$getElementB2 = document.getElementById(kbdId)) === null || _document$getElementB2 === void 0 ? void 0 : _document$getElementB2.textContent);
    }
  }, [hideButtonText, item2.rendered, textId, kbdId]);
  let button = (
    // Use a PressResponder to send DOM props through.
    // Button doesn't allow overriding the role by default.
    (0, import_jsx_runtime35.jsx)($f1ab8c75478c6f73$export$3351871ee4b288b8, {
      ...$3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, domProps),
      children: (0, import_jsx_runtime35.jsx)(ClearSlots, {
        children: (0, import_jsx_runtime35.jsx)(SlotProvider, {
          slots: {
            kbd: {
              id: hideButtonText ? kbdId : void 0,
              isHidden: true
              // always hide kbd in buttons
            },
            text: {
              id: hideButtonText ? textId : void 0,
              isHidden: hideButtonText
            }
          },
          children: (0, import_jsx_runtime35.jsx)(ActionButton, {
            ...item2.props,
            prominence,
            ref,
            UNSAFE_className: classNames(css({
              flexShrink: 0
            })),
            isSelected,
            isDisabled,
            "aria-label": item2["aria-label"],
            "aria-labelledby": item2["aria-label"] == null && hideButtonText ? textId : void 0,
            children: item2.rendered
          })
        })
      })
    })
  );
  if (hideButtonText && textContent) {
    button = (0, import_jsx_runtime35.jsxs)(_TooltipTrigger, {
      placement: orientation === "vertical" ? "end" : "top",
      children: [button, (0, import_jsx_runtime35.jsx)(Tooltip, {
        children: kbdContent ? (0, import_jsx_runtime35.jsxs)(import_jsx_runtime35.Fragment, {
          children: [(0, import_jsx_runtime35.jsx)(Text2, {
            children: textContent
          }), (0, import_jsx_runtime35.jsx)(Kbd, {
            children: kbdContent
          })]
        }) : textContent
      })]
    });
  }
  if (item2.wrapper) {
    button = item2.wrapper(button);
  }
  return button;
}
function ActionGroupMenu({
  hideButtonText,
  isDisabled,
  isOnlyItem,
  items,
  onAction,
  orientation,
  prominence,
  state,
  staticColor,
  summaryIcon,
  ...otherProps
}) {
  let key = items[0].key;
  let {
    buttonProps
  } = $f0ac0fb73c3ec062$export$9597202bd3099a29({
    key
  }, state);
  delete buttonProps.onPress;
  delete buttonProps.role;
  delete buttonProps["aria-checked"];
  let ariaLabel = otherProps["aria-label"] || (otherProps["aria-labelledby"] ? void 0 : "…");
  let ariaLabelledby = otherProps["aria-labelledby"];
  let textId = $bdb11010cef70236$export$f680877a34711e37();
  let id2 = $bdb11010cef70236$export$f680877a34711e37();
  if (state.selectionManager.selectionMode === "none") {
    summaryIcon = null;
  }
  let isSelected = state.selectionManager.selectionMode !== "none" && items.some((i6) => state.selectionManager.isSelected(i6.key));
  if (!summaryIcon && state.selectionManager.selectionMode === "single" && state.selectionManager.disallowEmptySelection && state.selectionManager.firstSelectedKey != null) {
    let selectedItem = state.collection.getItem(state.selectionManager.firstSelectedKey);
    if (selectedItem) {
      var _ariaLabelledby;
      summaryIcon = selectedItem.rendered;
      if (isReactText(summaryIcon)) {
        summaryIcon = (0, import_jsx_runtime35.jsx)(Text2, {
          children: summaryIcon
        });
      }
      ariaLabelledby = `${(_ariaLabelledby = ariaLabelledby) !== null && _ariaLabelledby !== void 0 ? _ariaLabelledby : id2} ${textId}`;
    }
  }
  if (summaryIcon) {
    summaryIcon = (0, import_jsx_runtime35.jsxs)(import_jsx_runtime35.Fragment, {
      children: [summaryIcon, (0, import_jsx_runtime35.jsx)(Icon, {
        src: chevronDownIcon
      })]
    });
  }
  return (
    // Use a PressResponder to send DOM props through.
    (0, import_jsx_runtime35.jsxs)(MenuTrigger, {
      align: isOnlyItem ? "start" : "end",
      direction: orientation === "vertical" ? "end" : "bottom",
      children: [(0, import_jsx_runtime35.jsx)(SlotProvider, {
        slots: {
          text: {
            id: hideButtonText ? textId : void 0,
            isHidden: hideButtonText
          }
        },
        children: (0, import_jsx_runtime35.jsx)($f1ab8c75478c6f73$export$3351871ee4b288b8, {
          ...buttonProps,
          children: (0, import_jsx_runtime35.jsx)(ActionButton, {
            ...otherProps,
            id: id2,
            prominence,
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledby,
            isDisabled,
            isSelected,
            children: summaryIcon || (0, import_jsx_runtime35.jsx)(Icon, {
              src: moreHorizontalIcon
            })
          })
        })
      }), (0, import_jsx_runtime35.jsx)(_Menu, {
        items,
        disabledKeys: state.disabledKeys,
        selectionMode: state.selectionManager.selectionMode,
        selectedKeys: state.selectionManager.selectedKeys,
        disallowEmptySelection: state.selectionManager.disallowEmptySelection,
        onSelectionChange: (keys3) => state.selectionManager.setSelectedKeys(keys3),
        onAction,
        children: (node4) => (0, import_jsx_runtime35.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
          ...node4.props,
          textValue: node4.textValue,
          children: node4.rendered
        })
      })]
    })
  );
}
function outerWidth(element4, ignoreLeftMargin, ignoreRightMargin) {
  let style = window.getComputedStyle(element4);
  return element4.offsetWidth + (ignoreLeftMargin ? 0 : toNumber(style.marginLeft)) + (ignoreRightMargin ? 0 : toNumber(style.marginRight));
}
function outerHeight(element4, ignoreTopMargin, ignoreBottomMargin) {
  let style = window.getComputedStyle(element4);
  return element4.offsetHeight + (ignoreTopMargin ? 0 : toNumber(style.marginTop)) + (ignoreBottomMargin ? 0 : toNumber(style.marginBottom));
}
function toNumber(value2) {
  let parsed = parseInt(value2, 10);
  return isNaN(parsed) ? 0 : parsed;
}

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-boldIcon.js
var import_jsx_runtime36 = __toESM(require_jsx_runtime());
var boldIcon = (0, import_jsx_runtime36.jsx)("path", {
  d: "M14 12a4 4 0 0 0 0-8H6v8M15 20a4 4 0 0 0 0-8H6v8Z"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-codeIcon.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime());
var codeIcon = (0, import_jsx_runtime37.jsx)("path", {
  d: "m16 18 6-6-6-6M8 6l-6 6 6 6"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-italicIcon.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime());
var italicIcon = (0, import_jsx_runtime38.jsx)("path", {
  d: "M19 4h-9M14 20H5M15 4 9 20"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-maximizeIcon.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime());
var maximizeIcon = (0, import_jsx_runtime39.jsx)("path", {
  d: "M8 3H5a2 2 0 0 0-2 2v3M21 8V5a2 2 0 0 0-2-2h-3M3 16v3a2 2 0 0 0 2 2h3M16 21h3a2 2 0 0 0 2-2v-3"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-minimizeIcon.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime());
var minimizeIcon = (0, import_jsx_runtime40.jsx)("path", {
  d: "M8 3v3a2 2 0 0 1-2 2H3M21 8h-3a2 2 0 0 1-2-2V3M3 16h3a2 2 0 0 1 2 2v3M16 21v-3a2 2 0 0 1 2-2h3"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-plusIcon.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime());
var plusIcon = (0, import_jsx_runtime41.jsx)("path", {
  d: "M5 12h14M12 5v14"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-removeFormattingIcon.js
var import_jsx_runtime42 = __toESM(require_jsx_runtime());
var removeFormattingIcon = (0, import_jsx_runtime42.jsx)("path", {
  d: "M4 7V4h16v3M5 20h6M13 4 8 20M15 15l5 5M20 15l-5 5"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-strikethroughIcon.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime());
var strikethroughIcon = (0, import_jsx_runtime43.jsx)("path", {
  d: "M16 4H9a3 3 0 0 0-2.83 4M14 12a4 4 0 0 1 0 8H6M4 12h16"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-subscriptIcon.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime());
var subscriptIcon = (0, import_jsx_runtime44.jsx)("path", {
  d: "m4 5 8 8M12 5l-8 8M20 19h-4c0-1.5.44-2 1.5-2.5S20 15.33 20 14c0-.47-.17-.93-.48-1.29a2.11 2.11 0 0 0-2.62-.44c-.42.24-.74.62-.9 1.07"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-superscriptIcon.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime());
var superscriptIcon = (0, import_jsx_runtime45.jsx)("path", {
  d: "m4 19 8-8M12 19l-8-8M20 12h-4c0-1.5.442-2 1.5-2.5S20 8.334 20 7.002c0-.472-.17-.93-.484-1.29a2.105 2.105 0 0 0-2.617-.436c-.42.239-.738.614-.899 1.06"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-typeIcon.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime());
var typeIcon = (0, import_jsx_runtime46.jsx)("path", {
  d: "M4 7V4h16v3M9 20h6M12 4v16"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-underlineIcon.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime());
var underlineIcon = (0, import_jsx_runtime47.jsx)("path", {
  d: "M6 4v6a6 6 0 0 0 12 0V4M4 20h16"
});

// node_modules/@react-aria/select/dist/import.mjs
var import_react58 = __toESM(require_react(), 1);
var $58aed456727eb0f3$export$703601b7e90536f8 = /* @__PURE__ */ new WeakMap();
function $58aed456727eb0f3$export$e64b2f635402ca43(props, state, ref) {
  let { keyboardDelegate, isDisabled, isRequired, name: name2, validationBehavior = "aria" } = props;
  let collator = (0, $325a3faab7a68acd$export$a16aca283550c30d)({
    usage: "search",
    sensitivity: "base"
  });
  let delegate = (0, import_react58.useMemo)(() => keyboardDelegate || new (0, $2a25aae57d74318e$export$a05409b8bb224a5a)(state.collection, state.disabledKeys, null, collator), [
    keyboardDelegate,
    state.collection,
    state.disabledKeys,
    collator
  ]);
  let { menuTriggerProps, menuProps } = (0, $168583247155ddda$export$dc9c12ed27dd1b49)({
    isDisabled,
    type: "listbox"
  }, state, ref);
  let onKeyDown = (e6) => {
    switch (e6.key) {
      case "ArrowLeft": {
        e6.preventDefault();
        let key = state.selectedKey != null ? delegate.getKeyAbove(state.selectedKey) : delegate.getFirstKey();
        if (key)
          state.setSelectedKey(key);
        break;
      }
      case "ArrowRight": {
        e6.preventDefault();
        let key = state.selectedKey != null ? delegate.getKeyBelow(state.selectedKey) : delegate.getFirstKey();
        if (key)
          state.setSelectedKey(key);
        break;
      }
    }
  };
  let { typeSelectProps } = (0, $fb3050f43d946246$export$e32c88dfddc6e1d8)({
    keyboardDelegate: delegate,
    selectionManager: state.selectionManager,
    onTypeSelect(key) {
      state.setSelectedKey(key);
    }
  });
  let { isInvalid, validationErrors, validationDetails } = state.displayValidation;
  let { labelProps, fieldProps, descriptionProps, errorMessageProps } = (0, $2baaea4c71418dea$export$294aa081a6c6f55d)({
    ...props,
    labelElementType: "span",
    isInvalid,
    errorMessage: props.errorMessage || validationErrors
  });
  typeSelectProps.onKeyDown = typeSelectProps.onKeyDownCapture;
  delete typeSelectProps.onKeyDownCapture;
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let triggerProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(typeSelectProps, menuTriggerProps, fieldProps);
  let valueId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  $58aed456727eb0f3$export$703601b7e90536f8.set(state, {
    isDisabled,
    isRequired,
    name: name2,
    validationBehavior
  });
  return {
    labelProps: {
      ...labelProps,
      onClick: () => {
        if (!props.isDisabled) {
          ref.current.focus();
          (0, $507fabe10e71c6fb$export$8397ddfc504fdb9a)("keyboard");
        }
      }
    },
    triggerProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, {
      ...triggerProps,
      isDisabled,
      onKeyDown: (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(triggerProps.onKeyDown, onKeyDown, props.onKeyDown),
      onKeyUp: props.onKeyUp,
      "aria-labelledby": [
        valueId,
        triggerProps["aria-labelledby"],
        triggerProps["aria-label"] && !triggerProps["aria-labelledby"] ? triggerProps.id : null
      ].filter(Boolean).join(" "),
      onFocus(e6) {
        if (state.isFocused)
          return;
        if (props.onFocus)
          props.onFocus(e6);
        if (props.onFocusChange)
          props.onFocusChange(true);
        state.setFocused(true);
      },
      onBlur(e6) {
        if (state.isOpen)
          return;
        if (props.onBlur)
          props.onBlur(e6);
        if (props.onFocusChange)
          props.onFocusChange(false);
        state.setFocused(false);
      }
    }),
    valueProps: {
      id: valueId
    },
    menuProps: {
      ...menuProps,
      autoFocus: state.focusStrategy || true,
      shouldSelectOnPressUp: true,
      shouldFocusOnHover: true,
      disallowEmptySelection: true,
      linkBehavior: "selection",
      onBlur: (e6) => {
        if (e6.currentTarget.contains(e6.relatedTarget))
          return;
        if (props.onBlur)
          props.onBlur(e6);
        if (props.onFocusChange)
          props.onFocusChange(false);
        state.setFocused(false);
      },
      "aria-labelledby": [
        fieldProps["aria-labelledby"],
        triggerProps["aria-label"] && !fieldProps["aria-labelledby"] ? triggerProps.id : null
      ].filter(Boolean).join(" ")
    },
    descriptionProps,
    errorMessageProps,
    isInvalid,
    validationErrors,
    validationDetails
  };
}
function $bdd25dc72710631f$export$f809e80f58e251d1(props, state, triggerRef) {
  let data = (0, $58aed456727eb0f3$export$703601b7e90536f8).get(state) || {};
  let { autoComplete, name: name2 = data.name, isDisabled = data.isDisabled } = props;
  let { validationBehavior, isRequired } = data;
  let modality = (0, $507fabe10e71c6fb$export$98e20ec92f614cfe)();
  let { visuallyHiddenProps } = (0, $5c3e21d68f1c4674$export$a966af930f325cab)();
  (0, $99facab73266f662$export$5add1d006293d136)(props.selectRef, state.selectedKey, state.setSelectedKey);
  (0, $e93e671b31057976$export$b8473d3665f3a75a)({
    validationBehavior,
    focus: () => triggerRef.current.focus()
  }, state, props.selectRef);
  var _state_selectedKey;
  return {
    containerProps: {
      ...visuallyHiddenProps,
      "aria-hidden": true,
      ["data-a11y-ignore"]: "aria-hidden-focus"
    },
    inputProps: {
      type: "text",
      tabIndex: modality == null || state.isFocused || state.isOpen ? -1 : 0,
      style: {
        fontSize: 16
      },
      onFocus: () => triggerRef.current.focus(),
      disabled: isDisabled
    },
    selectProps: {
      tabIndex: -1,
      autoComplete,
      disabled: isDisabled,
      required: validationBehavior === "native" && isRequired,
      name: name2,
      value: (_state_selectedKey = state.selectedKey) !== null && _state_selectedKey !== void 0 ? _state_selectedKey : "",
      onChange: (e6) => state.setSelectedKey(e6.target.value)
    }
  };
}
function $bdd25dc72710631f$export$cbd84cdb2e668835(props) {
  let { state, triggerRef, label, name: name2, isDisabled } = props;
  let selectRef = (0, import_react58.useRef)(null);
  let { containerProps, inputProps, selectProps } = $bdd25dc72710631f$export$f809e80f58e251d1({
    ...props,
    selectRef
  }, state, triggerRef);
  var _state_selectedKey;
  if (state.collection.size <= 300)
    return (0, import_react58.default).createElement("div", {
      ...containerProps,
      "data-testid": "hidden-select-container"
    }, (0, import_react58.default).createElement("input", inputProps), (0, import_react58.default).createElement("label", null, label, (0, import_react58.default).createElement("select", {
      ...selectProps,
      ref: selectRef
    }, (0, import_react58.default).createElement("option", null), [
      ...state.collection.getKeys()
    ].map((key) => {
      let item2 = state.collection.getItem(key);
      if (item2.type === "item")
        return (0, import_react58.default).createElement("option", {
          key: item2.key,
          value: item2.key
        }, item2.textValue);
    }))));
  else if (name2)
    return (0, import_react58.default).createElement("input", {
      type: "hidden",
      autoComplete: selectProps.autoComplete,
      name: name2,
      disabled: isDisabled,
      value: (_state_selectedKey = state.selectedKey) !== null && _state_selectedKey !== void 0 ? _state_selectedKey : ""
    });
  return null;
}

// node_modules/@react-stately/select/dist/import.mjs
var import_react59 = __toESM(require_react(), 1);
function $2bc3a590c5373a4e$export$5159ec8b34d4ec12(props) {
  let triggerState = (0, $fc909762b330b746$export$61c6a8c84e605fb6)(props);
  let [focusStrategy, setFocusStrategy] = (0, import_react59.useState)(null);
  let listState = (0, $a0d645289fe9b86b$export$e7f05e985daf4b5f)({
    ...props,
    onSelectionChange: (key) => {
      if (props.onSelectionChange != null)
        props.onSelectionChange(key);
      triggerState.close();
      validationState.commitValidation();
    }
  });
  let validationState = (0, $e5be200c675c3b3a$export$fc1a364ae1f3ff10)({
    ...props,
    value: listState.selectedKey
  });
  let [isFocused, setFocused] = (0, import_react59.useState)(false);
  return {
    ...validationState,
    ...listState,
    ...triggerState,
    focusStrategy,
    open(focusStrategy2 = null) {
      if (listState.collection.size !== 0) {
        setFocusStrategy(focusStrategy2);
        triggerState.open();
      }
    },
    toggle(focusStrategy2 = null) {
      if (listState.collection.size !== 0) {
        setFocusStrategy(focusStrategy2);
        triggerState.toggle();
      }
    },
    isFocused,
    setFocused
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-picker.js
var import_react60 = __toESM(require_react());

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-chevronsUpDownIcon.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime());
var chevronsUpDownIcon = (0, import_jsx_runtime48.jsx)("path", {
  d: "m7 15 5 5 5-5M7 9l5-5 5 5"
});

// node_modules/@keystar/ui/dist/keystar-ui-picker.js
var import_jsx_runtime49 = __toESM(require_jsx_runtime());
var localizedMessages7 = {
  "ar-AE": {
    loading: "جارٍ التحميل...",
    placeholder: "حدد خيارًا..."
  },
  "bg-BG": {
    loading: "Зареждане...",
    placeholder: "Изберете опция"
  },
  "cs-CZ": {
    loading: "Načítání...",
    placeholder: "Vyberte vhodnou možnost..."
  },
  "da-DK": {
    loading: "Indlæser ...",
    placeholder: "Vælg en mulighed ..."
  },
  "de-DE": {
    loading: "Laden...",
    placeholder: "Option auswählen..."
  },
  "el-GR": {
    loading: "Φόρτωση...",
    placeholder: "Επιλέξτε…"
  },
  "en-US": {
    placeholder: "Select an option…",
    loading: "Loading…"
  },
  "es-ES": {
    loading: "Cargando…",
    placeholder: "Selecciona una de estas opciones..."
  },
  "et-EE": {
    loading: "Laadimine...",
    placeholder: "Valige valikuline..."
  },
  "fi-FI": {
    loading: "Ladataan…",
    placeholder: "Valitse vaihtoehto..."
  },
  "fr-FR": {
    loading: "Chargement...",
    placeholder: "Sélectionnez une option..."
  },
  "he-IL": {
    loading: "טוען...",
    placeholder: "בחר אפשרות..."
  },
  "hr-HR": {
    loading: "Učitavam...",
    placeholder: "Odaberite opciju"
  },
  "hu-HU": {
    loading: "Betöltés folyamatban…",
    placeholder: "Válasszon egy opciót…"
  },
  "it-IT": {
    loading: "Caricamento...",
    placeholder: "Seleziona un’opzione..."
  },
  "ja-JP": {
    loading: "読み込み中...",
    placeholder: "オプションを選択..."
  },
  "ko-KR": {
    loading: "로드 중",
    placeholder: "선택 사항 선택"
  },
  "lt-LT": {
    loading: "Įkeliama...",
    placeholder: "Pasirinkite parinktį..."
  },
  "lv-LV": {
    loading: "Notiek ielāde...",
    placeholder: "Atlasiet opciju..."
  },
  "nb-NO": {
    loading: "Laster inn ...",
    placeholder: "Velg et alternativ..."
  },
  "nl-NL": {
    loading: "Laden...",
    placeholder: "Optie selecteren..."
  },
  "pl-PL": {
    loading: "Ładowanie...",
    placeholder: "Wybierz opcję..."
  },
  "pt-BR": {
    loading: "Carregando...",
    placeholder: "Selecione uma opção..."
  },
  "pt-PT": {
    loading: "A carregar...",
    placeholder: "Selecionar uma opção..."
  },
  "ro-RO": {
    loading: "Se încarcă...",
    placeholder: "Selectați o opțiune"
  },
  "ru-RU": {
    loading: "Загрузка...",
    placeholder: "Выбрать параметр..."
  },
  "sk-SK": {
    loading: "Načítava sa...",
    placeholder: "Vyberte možnosť..."
  },
  "sl-SI": {
    loading: "Nalaganje...",
    placeholder: "Izberite možnost"
  },
  "sr-SP": {
    loading: "Učitavam...",
    placeholder: "Izaberite opciju"
  },
  "sv-SE": {
    loading: "Läser in...",
    placeholder: "Välj ett alternativ..."
  },
  "tr-TR": {
    loading: "Yükleniyor...",
    placeholder: "Bir seçim yapın…"
  },
  "uk-UA": {
    loading: "Завантаження…",
    placeholder: "Виберіть опцію..."
  },
  "zh-CN": {
    loading: "正在加载...",
    placeholder: "选择一个选项..."
  },
  "zh-T": {
    loading: "正在載入",
    placeholder: "選取一個選項"
  }
};
function Picker(props, forwardedRef) {
  props = useSlotProps(props, "picker");
  props = useProviderProps(props);
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages7);
  let {
    align = "start",
    autoComplete,
    autoFocus,
    direction = "bottom",
    isDisabled,
    label,
    menuWidth,
    name: name2,
    placeholder = stringFormatter.format("placeholder"),
    prominence,
    shouldFlip = true
  } = props;
  let popoverRef = (0, import_react60.useRef)(null);
  let triggerRef = (0, import_react60.useRef)(null);
  let listboxRef = (0, import_react60.useRef)(null);
  let state = $2bc3a590c5373a4e$export$5159ec8b34d4ec12(props);
  let layout = useListBoxLayout(state);
  let {
    labelProps,
    triggerProps,
    valueProps,
    menuProps,
    descriptionProps,
    errorMessageProps
  } = $58aed456727eb0f3$export$e64b2f635402ca43({
    ...props,
    keyboardDelegate: layout
  }, state, triggerRef);
  let isMobile = useIsMobileDevice();
  let isLoadingInitial = props.isLoading && state.collection.size === 0;
  let isLoadingMore = props.isLoading && state.collection.size > 0;
  let listbox = (0, import_jsx_runtime49.jsx)(_ListBoxBase, {
    ...menuProps,
    ref: listboxRef,
    disallowEmptySelection: true,
    autoFocus: state.focusStrategy || true,
    shouldSelectOnPressUp: true,
    focusOnPointerEnter: true,
    layout,
    state,
    UNSAFE_className: listStyles,
    isLoading: isLoadingMore,
    onLoadMore: props.onLoadMore
  });
  let [buttonWidth, setButtonWidth] = (0, import_react60.useState)();
  let {
    scale
  } = useProvider();
  let onResize = (0, import_react60.useCallback)(() => {
    if (!isMobile && triggerRef.current) {
      let width = triggerRef.current.offsetWidth;
      setButtonWidth(width);
    }
  }, [triggerRef, setButtonWidth, isMobile]);
  $9daab02d461809db$export$683480f191c0e3ea({
    ref: triggerRef,
    onResize
  });
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(onResize, [scale, state.selectedKey, onResize]);
  let overlay;
  if (isMobile) {
    overlay = (0, import_jsx_runtime49.jsx)(Tray, {
      state,
      children: listbox
    });
  } else {
    let style = {
      minWidth: buttonWidth,
      width: menuWidth !== null && menuWidth !== void 0 ? menuWidth : buttonWidth
    };
    overlay = (0, import_jsx_runtime49.jsx)(Popover, {
      UNSAFE_style: style,
      ref: popoverRef,
      placement: `${direction} ${align}`,
      shouldFlip,
      hideArrow: true,
      state,
      triggerRef,
      scrollRef: listboxRef,
      children: listbox
    });
  }
  let contents = state.selectedItem ? state.selectedItem.rendered : placeholder;
  if (isReactText(contents)) {
    contents = (0, import_jsx_runtime49.jsx)(Text2, {
      children: contents
    });
  }
  let picker = (0, import_jsx_runtime49.jsxs)("div", {
    children: [(0, import_jsx_runtime49.jsx)($bdd25dc72710631f$export$cbd84cdb2e668835, {
      autoComplete,
      isDisabled,
      label,
      name: name2,
      state,
      triggerRef
    }), (0, import_jsx_runtime49.jsx)($f1ab8c75478c6f73$export$3351871ee4b288b8, {
      ...triggerProps,
      children: (0, import_jsx_runtime49.jsxs)(FieldButton, {
        "aria-required": true,
        prominence,
        ref: triggerRef,
        isActive: state.isOpen,
        isDisabled,
        autoFocus,
        UNSAFE_className: classNames(css({
          alignItems: "center",
          display: "flex",
          justifyContent: "space-between",
          position: "relative",
          width: "100%",
          /* Ensure that changing the selected item doesn't affect the size of the dropdown and its parents */
          contain: "size"
        })),
        children: [(0, import_jsx_runtime49.jsx)(SlotProvider, {
          slots: {
            icon: {
              marginEnd: "small"
            },
            text: {
              ...valueProps,
              // when no item is selected, we're styling the placeholder
              color: !state.selectedItem ? "neutralSecondary" : "inherit",
              weight: state.selectedItem ? "medium" : void 0
            },
            // we try to maintain most of the selected item's rendered content
            // within the button, but description text is too long
            description: {
              isHidden: true
            }
          },
          children: contents
        }), isLoadingInitial && (0, import_jsx_runtime49.jsx)(ProgressCircle, {
          isIndeterminate: true,
          size: "small",
          "aria-label": stringFormatter.format("loading"),
          UNSAFE_className: css({
            marginInlineStart: tokenSchema.size.space.small
          })
        }), (0, import_jsx_runtime49.jsx)(Icon, {
          src: chevronsUpDownIcon,
          UNSAFE_className: css({
            marginInlineStart: tokenSchema.size.space.small
          })
        })]
      })
    }), state.collection.size === 0 ? null : overlay]
  });
  return (0, import_jsx_runtime49.jsx)(FieldPrimitive, {
    width: "alias.singleLineWidth",
    ...props,
    ref: forwardedRef,
    labelProps,
    descriptionProps,
    errorMessageProps,
    supplementRequiredState: true,
    children: picker
  });
}
var _Picker = (0, import_react60.forwardRef)(Picker);

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-alignLeftIcon.js
var import_jsx_runtime50 = __toESM(require_jsx_runtime());
var alignLeftIcon = (0, import_jsx_runtime50.jsx)("path", {
  d: "M21 6H3M15 12H3M17 18H3"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-alignRightIcon.js
var import_jsx_runtime51 = __toESM(require_jsx_runtime());
var alignRightIcon = (0, import_jsx_runtime51.jsx)("path", {
  d: "M21 6H3M21 12H9M21 18H7"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-alignCenterIcon.js
var import_jsx_runtime52 = __toESM(require_jsx_runtime());
var alignCenterIcon = (0, import_jsx_runtime52.jsx)("path", {
  d: "M21 6H3M17 12H7M19 18H5"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-quoteIcon.js
var import_jsx_runtime53 = __toESM(require_jsx_runtime());
var quoteIcon = (0, import_jsx_runtime53.jsx)("path", {
  d: "M3 21c3 0 7-1 7-8V5c0-1.25-.756-2.017-2-2H4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2 1 0 1 0 1 1v1c0 1-1 2-2 2s-1 .008-1 1.031V20c0 1 0 1 1 1zM15 21c3 0 7-1 7-8V5c0-1.25-.757-2.017-2-2h-4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2h.75c0 2.25.25 4-2.75 4v3c0 1 0 1 1 1z"
});

// node_modules/match-sorter/dist/match-sorter.esm.js
var import_remove_accents = __toESM(require_remove_accents());
var rankings = {
  CASE_SENSITIVE_EQUAL: 7,
  EQUAL: 6,
  STARTS_WITH: 5,
  WORD_STARTS_WITH: 4,
  CONTAINS: 3,
  ACRONYM: 2,
  MATCHES: 1,
  NO_MATCH: 0
};
var defaultBaseSortFn = (a3, b2) => String(a3.rankedValue).localeCompare(String(b2.rankedValue));
function matchSorter(items, value2, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    keys: keys3,
    threshold = rankings.MATCHES,
    baseSort = defaultBaseSortFn,
    sorter = (matchedItems2) => matchedItems2.sort((a3, b2) => sortRankedValues(a3, b2, baseSort))
  } = options;
  const matchedItems = items.reduce(reduceItemsToRanked, []);
  return sorter(matchedItems).map((_ref) => {
    let {
      item: item2
    } = _ref;
    return item2;
  });
  function reduceItemsToRanked(matches, item2, index3) {
    const rankingInfo = getHighestRanking(item2, keys3, value2, options);
    const {
      rank,
      keyThreshold = threshold
    } = rankingInfo;
    if (rank >= keyThreshold) {
      matches.push({
        ...rankingInfo,
        item: item2,
        index: index3
      });
    }
    return matches;
  }
}
matchSorter.rankings = rankings;
function getHighestRanking(item2, keys3, value2, options) {
  if (!keys3) {
    const stringItem = item2;
    return {
      // ends up being duplicate of 'item' in matches but consistent
      rankedValue: stringItem,
      rank: getMatchRanking(stringItem, value2, options),
      keyIndex: -1,
      keyThreshold: options.threshold
    };
  }
  const valuesToRank = getAllValuesToRank(item2, keys3);
  return valuesToRank.reduce((_ref2, _ref3, i6) => {
    let {
      rank,
      rankedValue,
      keyIndex,
      keyThreshold
    } = _ref2;
    let {
      itemValue,
      attributes
    } = _ref3;
    let newRank = getMatchRanking(itemValue, value2, options);
    let newRankedValue = rankedValue;
    const {
      minRanking,
      maxRanking,
      threshold
    } = attributes;
    if (newRank < minRanking && newRank >= rankings.MATCHES) {
      newRank = minRanking;
    } else if (newRank > maxRanking) {
      newRank = maxRanking;
    }
    if (newRank > rank) {
      rank = newRank;
      keyIndex = i6;
      keyThreshold = threshold;
      newRankedValue = itemValue;
    }
    return {
      rankedValue: newRankedValue,
      rank,
      keyIndex,
      keyThreshold
    };
  }, {
    rankedValue: item2,
    rank: rankings.NO_MATCH,
    keyIndex: -1,
    keyThreshold: options.threshold
  });
}
function getMatchRanking(testString, stringToRank, options) {
  testString = prepareValueForComparison(testString, options);
  stringToRank = prepareValueForComparison(stringToRank, options);
  if (stringToRank.length > testString.length) {
    return rankings.NO_MATCH;
  }
  if (testString === stringToRank) {
    return rankings.CASE_SENSITIVE_EQUAL;
  }
  testString = testString.toLowerCase();
  stringToRank = stringToRank.toLowerCase();
  if (testString === stringToRank) {
    return rankings.EQUAL;
  }
  if (testString.startsWith(stringToRank)) {
    return rankings.STARTS_WITH;
  }
  if (testString.includes(` ${stringToRank}`)) {
    return rankings.WORD_STARTS_WITH;
  }
  if (testString.includes(stringToRank)) {
    return rankings.CONTAINS;
  } else if (stringToRank.length === 1) {
    return rankings.NO_MATCH;
  }
  if (getAcronym(testString).includes(stringToRank)) {
    return rankings.ACRONYM;
  }
  return getClosenessRanking(testString, stringToRank);
}
function getAcronym(string3) {
  let acronym = "";
  const wordsInString = string3.split(" ");
  wordsInString.forEach((wordInString) => {
    const splitByHyphenWords = wordInString.split("-");
    splitByHyphenWords.forEach((splitByHyphenWord) => {
      acronym += splitByHyphenWord.substr(0, 1);
    });
  });
  return acronym;
}
function getClosenessRanking(testString, stringToRank) {
  let matchingInOrderCharCount = 0;
  let charNumber = 0;
  function findMatchingCharacter(matchChar, string3, index3) {
    for (let j4 = index3, J = string3.length; j4 < J; j4++) {
      const stringChar = string3[j4];
      if (stringChar === matchChar) {
        matchingInOrderCharCount += 1;
        return j4 + 1;
      }
    }
    return -1;
  }
  function getRanking(spread2) {
    const spreadPercentage = 1 / spread2;
    const inOrderPercentage = matchingInOrderCharCount / stringToRank.length;
    const ranking = rankings.MATCHES + inOrderPercentage * spreadPercentage;
    return ranking;
  }
  const firstIndex = findMatchingCharacter(stringToRank[0], testString, 0);
  if (firstIndex < 0) {
    return rankings.NO_MATCH;
  }
  charNumber = firstIndex;
  for (let i6 = 1, I3 = stringToRank.length; i6 < I3; i6++) {
    const matchChar = stringToRank[i6];
    charNumber = findMatchingCharacter(matchChar, testString, charNumber);
    const found = charNumber > -1;
    if (!found) {
      return rankings.NO_MATCH;
    }
  }
  const spread = charNumber - firstIndex;
  return getRanking(spread);
}
function sortRankedValues(a3, b2, baseSort) {
  const aFirst = -1;
  const bFirst = 1;
  const {
    rank: aRank,
    keyIndex: aKeyIndex
  } = a3;
  const {
    rank: bRank,
    keyIndex: bKeyIndex
  } = b2;
  const same = aRank === bRank;
  if (same) {
    if (aKeyIndex === bKeyIndex) {
      return baseSort(a3, b2);
    } else {
      return aKeyIndex < bKeyIndex ? aFirst : bFirst;
    }
  } else {
    return aRank > bRank ? aFirst : bFirst;
  }
}
function prepareValueForComparison(value2, _ref4) {
  let {
    keepDiacritics
  } = _ref4;
  value2 = `${value2}`;
  if (!keepDiacritics) {
    value2 = (0, import_remove_accents.default)(value2);
  }
  return value2;
}
function getItemValues(item2, key) {
  if (typeof key === "object") {
    key = key.key;
  }
  let value2;
  if (typeof key === "function") {
    value2 = key(item2);
  } else if (item2 == null) {
    value2 = null;
  } else if (Object.hasOwnProperty.call(item2, key)) {
    value2 = item2[key];
  } else if (key.includes(".")) {
    return getNestedValues(key, item2);
  } else {
    value2 = null;
  }
  if (value2 == null) {
    return [];
  }
  if (Array.isArray(value2)) {
    return value2;
  }
  return [String(value2)];
}
function getNestedValues(path3, item2) {
  const keys3 = path3.split(".");
  let values3 = [item2];
  for (let i6 = 0, I3 = keys3.length; i6 < I3; i6++) {
    const nestedKey = keys3[i6];
    let nestedValues = [];
    for (let j4 = 0, J = values3.length; j4 < J; j4++) {
      const nestedItem = values3[j4];
      if (nestedItem == null)
        continue;
      if (Object.hasOwnProperty.call(nestedItem, nestedKey)) {
        const nestedValue = nestedItem[nestedKey];
        if (nestedValue != null) {
          nestedValues.push(nestedValue);
        }
      } else if (nestedKey === "*") {
        nestedValues = nestedValues.concat(nestedItem);
      }
    }
    values3 = nestedValues;
  }
  if (Array.isArray(values3[0])) {
    const result = [];
    return result.concat(...values3);
  }
  return values3;
}
function getAllValuesToRank(item2, keys3) {
  const allValues = [];
  for (let j4 = 0, J = keys3.length; j4 < J; j4++) {
    const key = keys3[j4];
    const attributes = getKeyAttributes(key);
    const itemValues = getItemValues(item2, key);
    for (let i6 = 0, I3 = itemValues.length; i6 < I3; i6++) {
      allValues.push({
        itemValue: itemValues[i6],
        attributes
      });
    }
  }
  return allValues;
}
var defaultKeyAttributes = {
  maxRanking: Infinity,
  minRanking: -Infinity
};
function getKeyAttributes(key) {
  if (typeof key === "string") {
    return defaultKeyAttributes;
  }
  return {
    ...defaultKeyAttributes,
    ...key
  };
}

// node_modules/@react-aria/combobox/dist/ar-AE.mjs
var $02cb4c75c506befe$exports = {};
$02cb4c75c506befe$exports = {
  "buttonLabel": `عرض المقترحات`,
  "countAnnouncement": (args2, formatter) => `${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} خيار`,
    other: () => `${formatter.number(args2.optionCount)} خيارات`
  })} متاحة.`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `المجموعة المدخلة ${args2.groupTitle}, مع ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} خيار`,
      other: () => `${formatter.number(args2.groupCount)} خيارات`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, محدد`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `مقترحات`,
  "selectedAnnouncement": (args2) => `${args2.optionText}، محدد`
};

// node_modules/@react-aria/combobox/dist/bg-BG.mjs
var $568b8163f1e56faf$exports = {};
$568b8163f1e56faf$exports = {
  "buttonLabel": `Покажи предложения`,
  "countAnnouncement": (args2, formatter) => `${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} опция`,
    other: () => `${formatter.number(args2.optionCount)} опции`
  })} на разположение.`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `Въведена група ${args2.groupTitle}, с ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} опция`,
      other: () => `${formatter.number(args2.groupCount)} опции`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, избрани`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `Предложения`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, избрани`
};

// node_modules/@react-aria/combobox/dist/cs-CZ.mjs
var $87581c0202d106b8$exports = {};
$87581c0202d106b8$exports = {
  "buttonLabel": `Zobrazit doporučení`,
  "countAnnouncement": (args2, formatter) => `K dispozici ${formatter.plural(args2.optionCount, {
    one: () => `je ${formatter.number(args2.optionCount)} možnost`,
    other: () => `jsou/je ${formatter.number(args2.optionCount)} možnosti/-í`
  })}.`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `Zadaná skupina „${args2.groupTitle}“ ${formatter.plural(args2.groupCount, {
      one: () => `s ${formatter.number(args2.groupCount)} možností`,
      other: () => `se ${formatter.number(args2.groupCount)} možnostmi`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: ` (vybráno)`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `Návrhy`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, vybráno`
};

// node_modules/@react-aria/combobox/dist/da-DK.mjs
var $a10a0369f5433ed1$exports = {};
$a10a0369f5433ed1$exports = {
  "buttonLabel": `Vis forslag`,
  "countAnnouncement": (args2, formatter) => `${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} mulighed tilgængelig`,
    other: () => `${formatter.number(args2.optionCount)} muligheder tilgængelige`
  })}.`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `Angivet gruppe ${args2.groupTitle}, med ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} mulighed`,
      other: () => `${formatter.number(args2.groupCount)} muligheder`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, valgt`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `Forslag`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, valgt`
};

// node_modules/@react-aria/combobox/dist/de-DE.mjs
var $bfd288727d5cb166$exports = {};
$bfd288727d5cb166$exports = {
  "buttonLabel": `Empfehlungen anzeigen`,
  "countAnnouncement": (args2, formatter) => `${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} Option`,
    other: () => `${formatter.number(args2.optionCount)} Optionen`
  })} verfügbar.`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `Eingetretene Gruppe ${args2.groupTitle}, mit ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} Option`,
      other: () => `${formatter.number(args2.groupCount)} Optionen`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, ausgewählt`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `Empfehlungen`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, ausgewählt`
};

// node_modules/@react-aria/combobox/dist/el-GR.mjs
var $ca177778f9a74e3c$exports = {};
$ca177778f9a74e3c$exports = {
  "buttonLabel": `Προβολή προτάσεων`,
  "countAnnouncement": (args2, formatter) => `${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} επιλογή`,
    other: () => `${formatter.number(args2.optionCount)} επιλογές `
  })} διαθέσιμες.`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `Εισαγμένη ομάδα ${args2.groupTitle}, με ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} επιλογή`,
      other: () => `${formatter.number(args2.groupCount)} επιλογές`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, επιλεγμένο`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `Προτάσεις`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, επιλέχθηκε`
};

// node_modules/@react-aria/combobox/dist/en-US.mjs
var $9b5aa79ef84beb6c$exports = {};
$9b5aa79ef84beb6c$exports = {
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `Entered group ${args2.groupTitle}, with ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} option`,
      other: () => `${formatter.number(args2.groupCount)} options`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, selected`,
    other: ``
  }, args2.isSelected)}`,
  "countAnnouncement": (args2, formatter) => `${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} option`,
    other: () => `${formatter.number(args2.optionCount)} options`
  })} available.`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, selected`,
  "buttonLabel": `Show suggestions`,
  "listboxLabel": `Suggestions`
};

// node_modules/@react-aria/combobox/dist/es-ES.mjs
var $57968e8209de2557$exports = {};
$57968e8209de2557$exports = {
  "buttonLabel": `Mostrar sugerencias`,
  "countAnnouncement": (args2, formatter) => `${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} opción`,
    other: () => `${formatter.number(args2.optionCount)} opciones`
  })} disponible(s).`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `Se ha unido al grupo ${args2.groupTitle}, con ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} opción`,
      other: () => `${formatter.number(args2.groupCount)} opciones`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, seleccionado`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `Sugerencias`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, seleccionado`
};

// node_modules/@react-aria/combobox/dist/et-EE.mjs
var $60690790bf4c1c6a$exports = {};
$60690790bf4c1c6a$exports = {
  "buttonLabel": `Kuva soovitused`,
  "countAnnouncement": (args2, formatter) => `${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} valik`,
    other: () => `${formatter.number(args2.optionCount)} valikud`
  })} saadaval.`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `Sisestatud rühm ${args2.groupTitle}, valikuga ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} valik`,
      other: () => `${formatter.number(args2.groupCount)} valikud`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, valitud`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `Soovitused`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, valitud`
};

// node_modules/@react-aria/combobox/dist/fi-FI.mjs
var $1101246e8c7d9357$exports = {};
$1101246e8c7d9357$exports = {
  "buttonLabel": `Näytä ehdotukset`,
  "countAnnouncement": (args2, formatter) => `${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} vaihtoehto`,
    other: () => `${formatter.number(args2.optionCount)} vaihtoehdot`
  })} saatavilla.`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `Mentiin ryhmään ${args2.groupTitle}, ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} vaihtoehdon`,
      other: () => `${formatter.number(args2.groupCount)} vaihtoehdon`
    })} kanssa.`,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, valittu`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `Ehdotukset`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, valittu`
};

// node_modules/@react-aria/combobox/dist/fr-FR.mjs
var $6404b5cb5b241730$exports = {};
$6404b5cb5b241730$exports = {
  "buttonLabel": `Afficher les suggestions`,
  "countAnnouncement": (args2, formatter) => `${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} option`,
    other: () => `${formatter.number(args2.optionCount)} options`
  })} disponible(s).`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `Groupe ${args2.groupTitle} rejoint, avec ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} option`,
      other: () => `${formatter.number(args2.groupCount)} options`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, sélectionné(s)`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `Suggestions`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, sélectionné`
};

// node_modules/@react-aria/combobox/dist/he-IL.mjs
var $dfeafa702e92e31f$exports = {};
$dfeafa702e92e31f$exports = {
  "buttonLabel": `הצג הצעות`,
  "countAnnouncement": (args2, formatter) => `${formatter.plural(args2.optionCount, {
    one: () => `אפשרות ${formatter.number(args2.optionCount)}`,
    other: () => `${formatter.number(args2.optionCount)} אפשרויות`
  })} במצב זמין.`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `נכנס לקבוצה ${args2.groupTitle}, עם ${formatter.plural(args2.groupCount, {
      one: () => `אפשרות ${formatter.number(args2.groupCount)}`,
      other: () => `${formatter.number(args2.groupCount)} אפשרויות`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, נבחר`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `הצעות`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, נבחר`
};

// node_modules/@react-aria/combobox/dist/hr-HR.mjs
var $2d125e0b34676352$exports = {};
$2d125e0b34676352$exports = {
  "buttonLabel": `Prikaži prijedloge`,
  "countAnnouncement": (args2, formatter) => `Dostupno još: ${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} opcija`,
    other: () => `${formatter.number(args2.optionCount)} opcije/a`
  })}.`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `Unesena skupina ${args2.groupTitle}, s ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} opcijom`,
      other: () => `${formatter.number(args2.groupCount)} opcije/a`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, odabranih`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `Prijedlozi`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, odabrano`
};

// node_modules/@react-aria/combobox/dist/hu-HU.mjs
var $ea029611d7634059$exports = {};
$ea029611d7634059$exports = {
  "buttonLabel": `Javaslatok megjelenítése`,
  "countAnnouncement": (args2, formatter) => `${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} lehetőség`,
    other: () => `${formatter.number(args2.optionCount)} lehetőség`
  })} áll rendelkezésre.`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `Belépett a(z) ${args2.groupTitle} csoportba, amely ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} lehetőséget`,
      other: () => `${formatter.number(args2.groupCount)} lehetőséget`
    })} tartalmaz. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, kijelölve`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `Javaslatok`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, kijelölve`
};

// node_modules/@react-aria/combobox/dist/it-IT.mjs
var $77f075bb86ad7091$exports = {};
$77f075bb86ad7091$exports = {
  "buttonLabel": `Mostra suggerimenti`,
  "countAnnouncement": (args2, formatter) => `${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} opzione disponibile`,
    other: () => `${formatter.number(args2.optionCount)} opzioni disponibili`
  })}.`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `Ingresso nel gruppo ${args2.groupTitle}, con ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} opzione`,
      other: () => `${formatter.number(args2.groupCount)} opzioni`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, selezionato`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `Suggerimenti`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, selezionato`
};

// node_modules/@react-aria/combobox/dist/ja-JP.mjs
var $6e87462e84907983$exports = {};
$6e87462e84907983$exports = {
  "buttonLabel": `候補を表示`,
  "countAnnouncement": (args2, formatter) => `${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} 個のオプション`,
    other: () => `${formatter.number(args2.optionCount)} 個のオプション`
  })}を利用できます。`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `入力されたグループ ${args2.groupTitle}、${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} 個のオプション`,
      other: () => `${formatter.number(args2.groupCount)} 個のオプション`
    })}を含む。`,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `、選択済み`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `候補`,
  "selectedAnnouncement": (args2) => `${args2.optionText}、選択済み`
};

// node_modules/@react-aria/combobox/dist/ko-KR.mjs
var $9246f2c6edc6b232$exports = {};
$9246f2c6edc6b232$exports = {
  "buttonLabel": `제안 사항 표시`,
  "countAnnouncement": (args2, formatter) => `${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)}개 옵션`,
    other: () => `${formatter.number(args2.optionCount)}개 옵션`
  })}을 사용할 수 있습니다.`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `입력한 그룹 ${args2.groupTitle}, ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)}개 옵션`,
      other: () => `${formatter.number(args2.groupCount)}개 옵션`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, 선택됨`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `제안`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, 선택됨`
};

// node_modules/@react-aria/combobox/dist/lt-LT.mjs
var $e587accc6c0a434c$exports = {};
$e587accc6c0a434c$exports = {
  "buttonLabel": `Rodyti pasiūlymus`,
  "countAnnouncement": (args2, formatter) => `Yra ${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} parinktis`,
    other: () => `${formatter.number(args2.optionCount)} parinktys (-ių)`
  })}.`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `Įvesta grupė ${args2.groupTitle}, su ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} parinktimi`,
      other: () => `${formatter.number(args2.groupCount)} parinktimis (-ių)`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, pasirinkta`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `Pasiūlymai`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, pasirinkta`
};

// node_modules/@react-aria/combobox/dist/lv-LV.mjs
var $03a1900e7400b5ab$exports = {};
$03a1900e7400b5ab$exports = {
  "buttonLabel": `Rādīt ieteikumus`,
  "countAnnouncement": (args2, formatter) => `Pieejamo opciju skaits: ${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} opcija`,
    other: () => `${formatter.number(args2.optionCount)} opcijas`
  })}.`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `Ievadīta grupa ${args2.groupTitle}, ar ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} opciju`,
      other: () => `${formatter.number(args2.groupCount)} opcijām`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, atlasīta`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `Ieteikumi`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, atlasīta`
};

// node_modules/@react-aria/combobox/dist/nb-NO.mjs
var $1387676441be6cf6$exports = {};
$1387676441be6cf6$exports = {
  "buttonLabel": `Vis forslag`,
  "countAnnouncement": (args2, formatter) => `${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} alternativ`,
    other: () => `${formatter.number(args2.optionCount)} alternativer`
  })} finnes.`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `Angitt gruppe ${args2.groupTitle}, med ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} alternativ`,
      other: () => `${formatter.number(args2.groupCount)} alternativer`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, valgt`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `Forslag`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, valgt`
};

// node_modules/@react-aria/combobox/dist/nl-NL.mjs
var $17e82ebf0f8ab91f$exports = {};
$17e82ebf0f8ab91f$exports = {
  "buttonLabel": `Suggesties weergeven`,
  "countAnnouncement": (args2, formatter) => `${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} optie`,
    other: () => `${formatter.number(args2.optionCount)} opties`
  })} beschikbaar.`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `Groep ${args2.groupTitle} ingevoerd met ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} optie`,
      other: () => `${formatter.number(args2.groupCount)} opties`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, geselecteerd`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `Suggesties`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, geselecteerd`
};

// node_modules/@react-aria/combobox/dist/pl-PL.mjs
var $2f5377d3471630e5$exports = {};
$2f5377d3471630e5$exports = {
  "buttonLabel": `Wyświetlaj sugestie`,
  "countAnnouncement": (args2, formatter) => `dostępna/dostępne(-nych) ${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} opcja`,
    other: () => `${formatter.number(args2.optionCount)} opcje(-i)`
  })}.`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `Dołączono do grupy ${args2.groupTitle}, z ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} opcją`,
      other: () => `${formatter.number(args2.groupCount)} opcjami`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, wybrano`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `Sugestie`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, wybrano`
};

// node_modules/@react-aria/combobox/dist/pt-BR.mjs
var $dee9868b6fa95ffe$exports = {};
$dee9868b6fa95ffe$exports = {
  "buttonLabel": `Mostrar sugestões`,
  "countAnnouncement": (args2, formatter) => `${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} opção`,
    other: () => `${formatter.number(args2.optionCount)} opções`
  })} disponível.`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `Grupo inserido ${args2.groupTitle}, com ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} opção`,
      other: () => `${formatter.number(args2.groupCount)} opções`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, selecionado`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `Sugestões`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, selecionado`
};

// node_modules/@react-aria/combobox/dist/pt-PT.mjs
var $f8b2e63637cbb5a6$exports = {};
$f8b2e63637cbb5a6$exports = {
  "buttonLabel": `Apresentar sugestões`,
  "countAnnouncement": (args2, formatter) => `${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} opção`,
    other: () => `${formatter.number(args2.optionCount)} opções`
  })} disponível.`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `Grupo introduzido ${args2.groupTitle}, com ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} opção`,
      other: () => `${formatter.number(args2.groupCount)} opções`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, selecionado`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `Sugestões`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, selecionado`
};

// node_modules/@react-aria/combobox/dist/ro-RO.mjs
var $46a885db3b44ea95$exports = {};
$46a885db3b44ea95$exports = {
  "buttonLabel": `Afișare sugestii`,
  "countAnnouncement": (args2, formatter) => `${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} opțiune`,
    other: () => `${formatter.number(args2.optionCount)} opțiuni`
  })} disponibile.`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `Grup ${args2.groupTitle} introdus, cu ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} opțiune`,
      other: () => `${formatter.number(args2.groupCount)} opțiuni`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, selectat`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `Sugestii`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, selectat`
};

// node_modules/@react-aria/combobox/dist/ru-RU.mjs
var $50d8a8f0afa9dee5$exports = {};
$50d8a8f0afa9dee5$exports = {
  "buttonLabel": `Показать предложения`,
  "countAnnouncement": (args2, formatter) => `${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} параметр`,
    other: () => `${formatter.number(args2.optionCount)} параметров`
  })} доступно.`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `Введенная группа ${args2.groupTitle}, с ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} параметром`,
      other: () => `${formatter.number(args2.groupCount)} параметрами`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, выбранными`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `Предложения`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, выбрано`
};

// node_modules/@react-aria/combobox/dist/sk-SK.mjs
var $2867ee6173245507$exports = {};
$2867ee6173245507$exports = {
  "buttonLabel": `Zobraziť návrhy`,
  "countAnnouncement": (args2, formatter) => `${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} možnosť`,
    other: () => `${formatter.number(args2.optionCount)} možnosti/-í`
  })} k dispozícii.`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `Zadaná skupina ${args2.groupTitle}, s ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} možnosťou`,
      other: () => `${formatter.number(args2.groupCount)} možnosťami`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, vybraté`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `Návrhy`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, vybraté`
};

// node_modules/@react-aria/combobox/dist/sl-SI.mjs
var $0631b65beeb09b50$exports = {};
$0631b65beeb09b50$exports = {
  "buttonLabel": `Prikaži predloge`,
  "countAnnouncement": (args2, formatter) => `Na voljo je ${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} opcija`,
    other: () => `${formatter.number(args2.optionCount)} opcije`
  })}.`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `Vnesena skupina ${args2.groupTitle}, z ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} opcija`,
      other: () => `${formatter.number(args2.groupCount)} opcije`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, izbrano`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `Predlogi`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, izbrano`
};

// node_modules/@react-aria/combobox/dist/sr-SP.mjs
var $65fc749265dcd686$exports = {};
$65fc749265dcd686$exports = {
  "buttonLabel": `Prikaži predloge`,
  "countAnnouncement": (args2, formatter) => `Dostupno još: ${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} opcija`,
    other: () => `${formatter.number(args2.optionCount)} opcije/a`
  })}.`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `Unesena grupa ${args2.groupTitle}, s ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} opcijom`,
      other: () => `${formatter.number(args2.groupCount)} optione/a`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, izabranih`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `Predlozi`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, izabrano`
};

// node_modules/@react-aria/combobox/dist/sv-SE.mjs
var $69ba655c7853c08e$exports = {};
$69ba655c7853c08e$exports = {
  "buttonLabel": `Visa förslag`,
  "countAnnouncement": (args2, formatter) => `${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} alternativ`,
    other: () => `${formatter.number(args2.optionCount)} alternativ`
  })} tillgängliga.`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `Ingick i gruppen ${args2.groupTitle} med ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} alternativ`,
      other: () => `${formatter.number(args2.groupCount)} alternativ`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, valda`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `Förslag`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, valda`
};

// node_modules/@react-aria/combobox/dist/tr-TR.mjs
var $a79794784d61577c$exports = {};
$a79794784d61577c$exports = {
  "buttonLabel": `Önerileri göster`,
  "countAnnouncement": (args2, formatter) => `${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} seçenek`,
    other: () => `${formatter.number(args2.optionCount)} seçenekler`
  })} kullanılabilir.`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `Girilen grup ${args2.groupTitle}, ile ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} seçenek`,
      other: () => `${formatter.number(args2.groupCount)} seçenekler`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, seçildi`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `Öneriler`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, seçildi`
};

// node_modules/@react-aria/combobox/dist/uk-UA.mjs
var $c2845791417ebaf4$exports = {};
$c2845791417ebaf4$exports = {
  "buttonLabel": `Показати пропозиції`,
  "countAnnouncement": (args2, formatter) => `${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} параметр`,
    other: () => `${formatter.number(args2.optionCount)} параметри(-ів)`
  })} доступно.`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `Введена група ${args2.groupTitle}, з ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} параметр`,
      other: () => `${formatter.number(args2.groupCount)} параметри(-ів)`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, вибрано`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `Пропозиції`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, вибрано`
};

// node_modules/@react-aria/combobox/dist/zh-CN.mjs
var $29b642d0025cc7a4$exports = {};
$29b642d0025cc7a4$exports = {
  "buttonLabel": `显示建议`,
  "countAnnouncement": (args2, formatter) => `有 ${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} 个选项`,
    other: () => `${formatter.number(args2.optionCount)} 个选项`
  })}可用。`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `进入了 ${args2.groupTitle} 组，其中有 ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} 个选项`,
      other: () => `${formatter.number(args2.groupCount)} 个选项`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, 已选择`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `建议`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, 已选择`
};

// node_modules/@react-aria/combobox/dist/zh-TW.mjs
var $cd36dd33f9d46936$exports = {};
$cd36dd33f9d46936$exports = {
  "buttonLabel": `顯示建議`,
  "countAnnouncement": (args2, formatter) => `${formatter.plural(args2.optionCount, {
    one: () => `${formatter.number(args2.optionCount)} 選項`,
    other: () => `${formatter.number(args2.optionCount)} 選項`
  })} 可用。`,
  "focusAnnouncement": (args2, formatter) => `${formatter.select({
    true: () => `輸入的群組 ${args2.groupTitle}, 有 ${formatter.plural(args2.groupCount, {
      one: () => `${formatter.number(args2.groupCount)} 選項`,
      other: () => `${formatter.number(args2.groupCount)} 選項`
    })}. `,
    other: ``
  }, args2.isGroupChange)}${args2.optionText}${formatter.select({
    true: `, 已選取`,
    other: ``
  }, args2.isSelected)}`,
  "listboxLabel": `建議`,
  "selectedAnnouncement": (args2) => `${args2.optionText}, 已選取`
};

// node_modules/@react-aria/combobox/dist/import.mjs
var import_react61 = __toESM(require_react(), 1);
function $parcel$interopDefault5(a3) {
  return a3 && a3.__esModule ? a3.default : a3;
}
var $de5926a92e8ebc5b$exports = {};
$de5926a92e8ebc5b$exports = {
  "ar-AE": $02cb4c75c506befe$exports,
  "bg-BG": $568b8163f1e56faf$exports,
  "cs-CZ": $87581c0202d106b8$exports,
  "da-DK": $a10a0369f5433ed1$exports,
  "de-DE": $bfd288727d5cb166$exports,
  "el-GR": $ca177778f9a74e3c$exports,
  "en-US": $9b5aa79ef84beb6c$exports,
  "es-ES": $57968e8209de2557$exports,
  "et-EE": $60690790bf4c1c6a$exports,
  "fi-FI": $1101246e8c7d9357$exports,
  "fr-FR": $6404b5cb5b241730$exports,
  "he-IL": $dfeafa702e92e31f$exports,
  "hr-HR": $2d125e0b34676352$exports,
  "hu-HU": $ea029611d7634059$exports,
  "it-IT": $77f075bb86ad7091$exports,
  "ja-JP": $6e87462e84907983$exports,
  "ko-KR": $9246f2c6edc6b232$exports,
  "lt-LT": $e587accc6c0a434c$exports,
  "lv-LV": $03a1900e7400b5ab$exports,
  "nb-NO": $1387676441be6cf6$exports,
  "nl-NL": $17e82ebf0f8ab91f$exports,
  "pl-PL": $2f5377d3471630e5$exports,
  "pt-BR": $dee9868b6fa95ffe$exports,
  "pt-PT": $f8b2e63637cbb5a6$exports,
  "ro-RO": $46a885db3b44ea95$exports,
  "ru-RU": $50d8a8f0afa9dee5$exports,
  "sk-SK": $2867ee6173245507$exports,
  "sl-SI": $0631b65beeb09b50$exports,
  "sr-SP": $65fc749265dcd686$exports,
  "sv-SE": $69ba655c7853c08e$exports,
  "tr-TR": $a79794784d61577c$exports,
  "uk-UA": $c2845791417ebaf4$exports,
  "zh-CN": $29b642d0025cc7a4$exports,
  "zh-TW": $cd36dd33f9d46936$exports
};
function $c350ade66beef0af$export$8c18d1b4f7232bbf(props, state) {
  let { buttonRef, popoverRef, inputRef, listBoxRef, keyboardDelegate, shouldFocusWrap, isReadOnly, isDisabled } = props;
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault5($de5926a92e8ebc5b$exports)), "@react-aria/combobox");
  let { menuTriggerProps, menuProps } = (0, $168583247155ddda$export$dc9c12ed27dd1b49)({
    type: "listbox",
    isDisabled: isDisabled || isReadOnly
  }, state, buttonRef);
  (0, $b1f0cad8af73213b$export$3585ede4d035bf14).set(state, {
    id: menuProps.id
  });
  let delegate = (0, import_react61.useMemo)(() => keyboardDelegate || new (0, $2a25aae57d74318e$export$a05409b8bb224a5a)(state.collection, state.disabledKeys, listBoxRef), [
    keyboardDelegate,
    state.collection,
    state.disabledKeys,
    listBoxRef
  ]);
  let { collectionProps } = (0, $ae20dd8cbca75726$export$d6daf82dcd84e87c)({
    selectionManager: state.selectionManager,
    keyboardDelegate: delegate,
    disallowTypeAhead: true,
    disallowEmptySelection: true,
    shouldFocusWrap,
    ref: inputRef,
    // Prevent item scroll behavior from being applied here, should be handled in the user's Popover + ListBox component
    isVirtualized: true
  });
  let router = (0, $ea8dcbcb9ea1b556$export$9a302a45f65d0572)();
  let onKeyDown = (e6) => {
    switch (e6.key) {
      case "Enter":
      case "Tab":
        if (state.isOpen && e6.key === "Enter")
          e6.preventDefault();
        if (state.isOpen && state.selectionManager.focusedKey != null && state.selectionManager.isLink(state.selectionManager.focusedKey)) {
          if (e6.key === "Enter") {
            let item2 = listBoxRef.current.querySelector(`[data-key="${CSS.escape(state.selectionManager.focusedKey.toString())}"]`);
            if (item2 instanceof HTMLAnchorElement)
              router.open(item2, e6);
          }
          state.close();
        } else
          state.commit();
        break;
      case "Escape":
        if (state.selectedKey !== null || state.inputValue === "" || props.allowsCustomValue)
          e6.continuePropagation();
        state.revert();
        break;
      case "ArrowDown":
        state.open("first", "manual");
        break;
      case "ArrowUp":
        state.open("last", "manual");
        break;
      case "ArrowLeft":
      case "ArrowRight":
        state.selectionManager.setFocusedKey(null);
        break;
    }
  };
  let onBlur = (e6) => {
    var _popoverRef_current;
    if (e6.relatedTarget === (buttonRef === null || buttonRef === void 0 ? void 0 : buttonRef.current) || ((_popoverRef_current = popoverRef.current) === null || _popoverRef_current === void 0 ? void 0 : _popoverRef_current.contains(e6.relatedTarget)))
      return;
    if (props.onBlur)
      props.onBlur(e6);
    state.setFocused(false);
  };
  let onFocus = (e6) => {
    if (state.isFocused)
      return;
    if (props.onFocus)
      props.onFocus(e6);
    state.setFocused(true);
  };
  let { isInvalid, validationErrors, validationDetails } = state.displayValidation;
  let { labelProps, inputProps, descriptionProps, errorMessageProps } = (0, $2d73ec29415bd339$export$712718f7aec83d5)({
    ...props,
    onChange: state.setInputValue,
    onKeyDown: !isReadOnly ? (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(state.isOpen && collectionProps.onKeyDown, onKeyDown, props.onKeyDown) : props.onKeyDown,
    onBlur,
    value: state.inputValue,
    onFocus,
    autoComplete: "off",
    validate: void 0,
    [(0, $e5be200c675c3b3a$export$a763b9476acd3eb)]: state
  }, inputRef);
  let onPress = (e6) => {
    if (e6.pointerType === "touch") {
      inputRef.current.focus();
      state.toggle(null, "manual");
    }
  };
  let onPressStart = (e6) => {
    if (e6.pointerType !== "touch") {
      inputRef.current.focus();
      state.toggle(e6.pointerType === "keyboard" || e6.pointerType === "virtual" ? "first" : null, "manual");
    }
  };
  let triggerLabelProps = (0, $313b98861ee5dd6c$export$d6875122194c7b44)({
    id: menuTriggerProps.id,
    "aria-label": stringFormatter.format("buttonLabel"),
    "aria-labelledby": props["aria-labelledby"] || labelProps.id
  });
  let listBoxProps = (0, $313b98861ee5dd6c$export$d6875122194c7b44)({
    id: menuProps.id,
    "aria-label": stringFormatter.format("listboxLabel"),
    "aria-labelledby": props["aria-labelledby"] || labelProps.id
  });
  let lastEventTime = (0, import_react61.useRef)(0);
  let onTouchEnd = (e6) => {
    if (isDisabled || isReadOnly)
      return;
    if (e6.timeStamp - lastEventTime.current < 500) {
      e6.preventDefault();
      inputRef.current.focus();
      return;
    }
    let rect = e6.target.getBoundingClientRect();
    let touch = e6.changedTouches[0];
    let centerX = Math.ceil(rect.left + 0.5 * rect.width);
    let centerY = Math.ceil(rect.top + 0.5 * rect.height);
    if (touch.clientX === centerX && touch.clientY === centerY) {
      e6.preventDefault();
      inputRef.current.focus();
      state.toggle(null, "manual");
      lastEventTime.current = e6.timeStamp;
    }
  };
  let focusedItem = state.selectionManager.focusedKey != null && state.isOpen ? state.collection.getItem(state.selectionManager.focusedKey) : void 0;
  var _focusedItem_parentKey;
  let sectionKey = (_focusedItem_parentKey = focusedItem === null || focusedItem === void 0 ? void 0 : focusedItem.parentKey) !== null && _focusedItem_parentKey !== void 0 ? _focusedItem_parentKey : null;
  var _state_selectionManager_focusedKey;
  let itemKey = (_state_selectionManager_focusedKey = state.selectionManager.focusedKey) !== null && _state_selectionManager_focusedKey !== void 0 ? _state_selectionManager_focusedKey : null;
  let lastSection = (0, import_react61.useRef)(sectionKey);
  let lastItem = (0, import_react61.useRef)(itemKey);
  (0, import_react61.useEffect)(() => {
    if ((0, $c87311424ea30a05$export$e1865c3bedcd822b)() && focusedItem != null && itemKey !== lastItem.current) {
      let isSelected = state.selectionManager.isSelected(itemKey);
      let section = sectionKey != null ? state.collection.getItem(sectionKey) : null;
      let sectionTitle = (section === null || section === void 0 ? void 0 : section["aria-label"]) || (typeof (section === null || section === void 0 ? void 0 : section.rendered) === "string" ? section.rendered : "") || "";
      let announcement = stringFormatter.format("focusAnnouncement", {
        isGroupChange: section && sectionKey !== lastSection.current,
        groupTitle: sectionTitle,
        groupCount: section ? [
          ...(0, $c5a24bc478652b5f$export$1005530eda016c13)(section, state.collection)
        ].length : 0,
        optionText: focusedItem["aria-label"] || focusedItem.textValue || "",
        isSelected
      });
      (0, $319e236875307eab$export$a9b970dcc4ae71a9)(announcement);
    }
    lastSection.current = sectionKey;
    lastItem.current = itemKey;
  });
  let optionCount = (0, $453cc9f0df89c0a5$export$77d5aafae4e095b2)(state.collection);
  let lastSize = (0, import_react61.useRef)(optionCount);
  let lastOpen = (0, import_react61.useRef)(state.isOpen);
  (0, import_react61.useEffect)(() => {
    let didOpenWithoutFocusedItem = state.isOpen !== lastOpen.current && (state.selectionManager.focusedKey == null || (0, $c87311424ea30a05$export$e1865c3bedcd822b)());
    if (state.isOpen && (didOpenWithoutFocusedItem || optionCount !== lastSize.current)) {
      let announcement = stringFormatter.format("countAnnouncement", {
        optionCount
      });
      (0, $319e236875307eab$export$a9b970dcc4ae71a9)(announcement);
    }
    lastSize.current = optionCount;
    lastOpen.current = state.isOpen;
  });
  let lastSelectedKey = (0, import_react61.useRef)(state.selectedKey);
  (0, import_react61.useEffect)(() => {
    if ((0, $c87311424ea30a05$export$e1865c3bedcd822b)() && state.isFocused && state.selectedItem && state.selectedKey !== lastSelectedKey.current) {
      let optionText = state.selectedItem["aria-label"] || state.selectedItem.textValue || "";
      let announcement = stringFormatter.format("selectedAnnouncement", {
        optionText
      });
      (0, $319e236875307eab$export$a9b970dcc4ae71a9)(announcement);
    }
    lastSelectedKey.current = state.selectedKey;
  });
  (0, import_react61.useEffect)(() => {
    if (state.isOpen)
      return (0, $5e3802645cc19319$export$1c3ebcada18427bf)([
        inputRef.current,
        popoverRef.current
      ]);
  }, [
    state.isOpen,
    inputRef,
    popoverRef
  ]);
  return {
    labelProps,
    buttonProps: {
      ...menuTriggerProps,
      ...triggerLabelProps,
      excludeFromTabOrder: true,
      onPress,
      onPressStart,
      isDisabled: isDisabled || isReadOnly
    },
    inputProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(inputProps, {
      role: "combobox",
      "aria-expanded": menuTriggerProps["aria-expanded"],
      "aria-controls": state.isOpen ? menuProps.id : void 0,
      // TODO: readd proper logic for completionMode = complete (aria-autocomplete: both)
      "aria-autocomplete": "list",
      "aria-activedescendant": focusedItem ? (0, $b1f0cad8af73213b$export$9145995848b05025)(state, focusedItem.key) : void 0,
      onTouchEnd,
      // This disable's iOS's autocorrect suggestions, since the combo box provides its own suggestions.
      autoCorrect: "off",
      // This disable's the macOS Safari spell check auto corrections.
      spellCheck: "false"
    }),
    listBoxProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(menuProps, listBoxProps, {
      autoFocus: state.focusStrategy,
      shouldUseVirtualFocus: true,
      shouldSelectOnPressUp: true,
      shouldFocusOnHover: true,
      linkBehavior: "selection"
    }),
    descriptionProps,
    errorMessageProps,
    isInvalid,
    validationErrors,
    validationDetails
  };
}

// node_modules/@react-stately/combobox/dist/import.mjs
var import_react62 = __toESM(require_react(), 1);
function $a9e7382a7d111cb5$export$b453a3bfd4a5fa9e(props) {
  var _collection_getItem, _collection_getItem1;
  let { defaultFilter, menuTrigger = "input", allowsEmptyCollection = false, allowsCustomValue, shouldCloseOnBlur = true } = props;
  let [showAllItems, setShowAllItems] = (0, import_react62.useState)(false);
  let [isFocused, setFocusedState] = (0, import_react62.useState)(false);
  let [focusStrategy, setFocusStrategy] = (0, import_react62.useState)(null);
  let onSelectionChange = (key) => {
    if (props.onSelectionChange)
      props.onSelectionChange(key);
    if (key === selectedKey) {
      resetInputValue();
      closeMenu();
    }
  };
  var _props_items;
  let { collection: collection2, selectionManager, selectedKey, setSelectedKey, selectedItem, disabledKeys } = (0, $a0d645289fe9b86b$export$e7f05e985daf4b5f)({
    ...props,
    onSelectionChange,
    items: (_props_items = props.items) !== null && _props_items !== void 0 ? _props_items : props.defaultItems
  });
  var _props_defaultInputValue, _ref;
  let [inputValue, setInputValue] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(props.inputValue, (_ref = (_props_defaultInputValue = props.defaultInputValue) !== null && _props_defaultInputValue !== void 0 ? _props_defaultInputValue : (_collection_getItem = collection2.getItem(selectedKey)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue) !== null && _ref !== void 0 ? _ref : "", props.onInputChange);
  let originalCollection = collection2;
  let filteredCollection = (0, import_react62.useMemo)(() => (
    // No default filter if items are controlled.
    props.items != null || !defaultFilter ? collection2 : $a9e7382a7d111cb5$var$filterCollection(collection2, inputValue, defaultFilter)
  ), [
    collection2,
    inputValue,
    defaultFilter,
    props.items
  ]);
  let [lastCollection, setLastCollection] = (0, import_react62.useState)(filteredCollection);
  let menuOpenTrigger = (0, import_react62.useRef)("focus");
  let onOpenChange = (open2) => {
    if (props.onOpenChange)
      props.onOpenChange(open2, open2 ? menuOpenTrigger.current : void 0);
    selectionManager.setFocused(open2);
    if (!open2)
      selectionManager.setFocusedKey(null);
  };
  let triggerState = (0, $fc909762b330b746$export$61c6a8c84e605fb6)({
    ...props,
    onOpenChange,
    isOpen: void 0,
    defaultOpen: void 0
  });
  let open = (focusStrategy2 = null, trigger2) => {
    let displayAllItems = trigger2 === "manual" || trigger2 === "focus" && menuTrigger === "focus";
    if (allowsEmptyCollection || filteredCollection.size > 0 || displayAllItems && originalCollection.size > 0 || props.items) {
      if (displayAllItems && !triggerState.isOpen && props.items === void 0)
        setShowAllItems(true);
      menuOpenTrigger.current = trigger2;
      setFocusStrategy(focusStrategy2);
      triggerState.open();
    }
  };
  let toggle = (focusStrategy2 = null, trigger2) => {
    let displayAllItems = trigger2 === "manual" || trigger2 === "focus" && menuTrigger === "focus";
    if (!(allowsEmptyCollection || filteredCollection.size > 0 || displayAllItems && originalCollection.size > 0 || props.items) && !triggerState.isOpen)
      return;
    if (displayAllItems && !triggerState.isOpen && props.items === void 0)
      setShowAllItems(true);
    if (!triggerState.isOpen)
      menuOpenTrigger.current = trigger2;
    toggleMenu(focusStrategy2);
  };
  let updateLastCollection = (0, import_react62.useCallback)(() => {
    setLastCollection(showAllItems ? originalCollection : filteredCollection);
  }, [
    showAllItems,
    originalCollection,
    filteredCollection
  ]);
  let toggleMenu = (0, import_react62.useCallback)((focusStrategy2 = null) => {
    if (triggerState.isOpen)
      updateLastCollection();
    setFocusStrategy(focusStrategy2);
    triggerState.toggle();
  }, [
    triggerState,
    updateLastCollection
  ]);
  let closeMenu = (0, import_react62.useCallback)(() => {
    if (triggerState.isOpen) {
      updateLastCollection();
      triggerState.close();
    }
  }, [
    triggerState,
    updateLastCollection
  ]);
  let [lastValue, setLastValue] = (0, import_react62.useState)(inputValue);
  let resetInputValue = () => {
    var _collection_getItem2;
    var _collection_getItem_textValue2;
    let itemText = (_collection_getItem_textValue2 = (_collection_getItem2 = collection2.getItem(selectedKey)) === null || _collection_getItem2 === void 0 ? void 0 : _collection_getItem2.textValue) !== null && _collection_getItem_textValue2 !== void 0 ? _collection_getItem_textValue2 : "";
    setLastValue(itemText);
    setInputValue(itemText);
  };
  var _props_selectedKey, _ref1;
  let lastSelectedKey = (0, import_react62.useRef)((_ref1 = (_props_selectedKey = props.selectedKey) !== null && _props_selectedKey !== void 0 ? _props_selectedKey : props.defaultSelectedKey) !== null && _ref1 !== void 0 ? _ref1 : null);
  var _collection_getItem_textValue;
  let lastSelectedKeyText = (0, import_react62.useRef)((_collection_getItem_textValue = (_collection_getItem1 = collection2.getItem(selectedKey)) === null || _collection_getItem1 === void 0 ? void 0 : _collection_getItem1.textValue) !== null && _collection_getItem_textValue !== void 0 ? _collection_getItem_textValue : "");
  (0, import_react62.useEffect)(() => {
    var _collection_getItem2;
    if (isFocused && (filteredCollection.size > 0 || allowsEmptyCollection) && !triggerState.isOpen && inputValue !== lastValue && menuTrigger !== "manual")
      open(null, "input");
    if (!showAllItems && !allowsEmptyCollection && triggerState.isOpen && filteredCollection.size === 0)
      closeMenu();
    if (selectedKey != null && selectedKey !== lastSelectedKey.current)
      closeMenu();
    if (inputValue !== lastValue) {
      selectionManager.setFocusedKey(null);
      setShowAllItems(false);
      if (inputValue === "" && (props.inputValue === void 0 || props.selectedKey === void 0))
        setSelectedKey(null);
    }
    if (selectedKey !== lastSelectedKey.current && (props.inputValue === void 0 || props.selectedKey === void 0))
      resetInputValue();
    else if (lastValue !== inputValue)
      setLastValue(inputValue);
    var _collection_getItem_textValue2;
    let selectedItemText = (_collection_getItem_textValue2 = (_collection_getItem2 = collection2.getItem(selectedKey)) === null || _collection_getItem2 === void 0 ? void 0 : _collection_getItem2.textValue) !== null && _collection_getItem_textValue2 !== void 0 ? _collection_getItem_textValue2 : "";
    if (!isFocused && selectedKey != null && props.inputValue === void 0 && selectedKey === lastSelectedKey.current) {
      if (lastSelectedKeyText.current !== selectedItemText) {
        setLastValue(selectedItemText);
        setInputValue(selectedItemText);
      }
    }
    lastSelectedKey.current = selectedKey;
    lastSelectedKeyText.current = selectedItemText;
  });
  let validation = (0, $e5be200c675c3b3a$export$fc1a364ae1f3ff10)({
    ...props,
    value: (0, import_react62.useMemo)(() => ({
      inputValue,
      selectedKey
    }), [
      inputValue,
      selectedKey
    ])
  });
  let revert = () => {
    if (allowsCustomValue && selectedKey == null)
      commitCustomValue();
    else
      commitSelection();
  };
  let commitCustomValue = () => {
    lastSelectedKey.current = null;
    setSelectedKey(null);
    closeMenu();
  };
  let commitSelection = () => {
    if (props.selectedKey !== void 0 && props.inputValue !== void 0) {
      var _collection_getItem2;
      props.onSelectionChange(selectedKey);
      var _collection_getItem_textValue2;
      let itemText = (_collection_getItem_textValue2 = (_collection_getItem2 = collection2.getItem(selectedKey)) === null || _collection_getItem2 === void 0 ? void 0 : _collection_getItem2.textValue) !== null && _collection_getItem_textValue2 !== void 0 ? _collection_getItem_textValue2 : "";
      setLastValue(itemText);
      closeMenu();
    } else {
      resetInputValue();
      closeMenu();
    }
  };
  const commitValue = () => {
    if (allowsCustomValue) {
      var _collection_getItem2;
      var _collection_getItem_textValue2;
      const itemText = (_collection_getItem_textValue2 = (_collection_getItem2 = collection2.getItem(selectedKey)) === null || _collection_getItem2 === void 0 ? void 0 : _collection_getItem2.textValue) !== null && _collection_getItem_textValue2 !== void 0 ? _collection_getItem_textValue2 : "";
      inputValue === itemText ? commitSelection() : commitCustomValue();
    } else
      commitSelection();
  };
  let commit = () => {
    if (triggerState.isOpen && selectionManager.focusedKey != null) {
      if (selectedKey === selectionManager.focusedKey)
        commitSelection();
      else
        setSelectedKey(selectionManager.focusedKey);
    } else
      commitValue();
  };
  let valueOnFocus = (0, import_react62.useRef)(inputValue);
  let setFocused = (isFocused2) => {
    if (isFocused2) {
      valueOnFocus.current = inputValue;
      if (menuTrigger === "focus")
        open(null, "focus");
    } else {
      if (shouldCloseOnBlur)
        commitValue();
      if (inputValue !== valueOnFocus.current)
        validation.commitValidation();
    }
    setFocusedState(isFocused2);
  };
  let displayedCollection = (0, import_react62.useMemo)(() => {
    if (triggerState.isOpen) {
      if (showAllItems)
        return originalCollection;
      else
        return filteredCollection;
    } else
      return lastCollection;
  }, [
    triggerState.isOpen,
    originalCollection,
    filteredCollection,
    showAllItems,
    lastCollection
  ]);
  return {
    ...validation,
    ...triggerState,
    focusStrategy,
    toggle,
    open,
    close: commitValue,
    selectionManager,
    selectedKey,
    setSelectedKey,
    disabledKeys,
    isFocused,
    setFocused,
    selectedItem,
    collection: displayedCollection,
    inputValue,
    setInputValue,
    commit,
    revert
  };
}
function $a9e7382a7d111cb5$var$filterCollection(collection2, inputValue, filter3) {
  return new (0, $a02d57049d202695$export$d085fb9e920b5ca7)($a9e7382a7d111cb5$var$filterNodes(collection2, collection2, inputValue, filter3));
}
function $a9e7382a7d111cb5$var$filterNodes(collection2, nodes, inputValue, filter3) {
  let filteredNode = [];
  for (let node4 of nodes) {
    if (node4.type === "section" && node4.hasChildNodes) {
      let filtered = $a9e7382a7d111cb5$var$filterNodes(collection2, (0, $c5a24bc478652b5f$export$1005530eda016c13)(node4, collection2), inputValue, filter3);
      if ([
        ...filtered
      ].some((node5) => node5.type === "item"))
        filteredNode.push({
          ...node4,
          childNodes: filtered
        });
    } else if (node4.type === "item" && filter3(node4.textValue, inputValue))
      filteredNode.push({
        ...node4
      });
    else if (node4.type !== "item")
      filteredNode.push({
        ...node4
      });
  }
  return filteredNode;
}

// node_modules/@keystar/ui/dist/keystar-ui-combobox.js
var import_react63 = __toESM(require_react());
var import_jsx_runtime54 = __toESM(require_jsx_runtime());
var comboboxClassList = new ClassList("Combobox", ["input", "mobile-trigger"]);
var localizedMessages8 = {
  "ar-AE": {
    clear: "مسح",
    invalid: "(غير صالح)",
    loading: "جارٍ التحميل...",
    noResults: "لا توجد نتائج"
  },
  "bg-BG": {
    clear: "Изчисти",
    invalid: "(невалиден)",
    loading: "Зареждане...",
    noResults: "Няма резултати"
  },
  "cs-CZ": {
    clear: "Vymazat",
    invalid: "(neplatné)",
    loading: "Načítání...",
    noResults: "Žádné výsledky"
  },
  "da-DK": {
    clear: "Ryd",
    invalid: "(ugyldig)",
    loading: "Indlæser ...",
    noResults: "Ingen resultater"
  },
  "de-DE": {
    clear: "Löschen",
    invalid: "(ungültig)",
    loading: "Wird geladen...",
    noResults: "Keine Ergebnisse"
  },
  "el-GR": {
    clear: "Καθαρισμός",
    invalid: "(δεν ισχύει)",
    loading: "Φόρτωση...",
    noResults: "Χωρίς αποτέλεσμα"
  },
  "en-US": {
    loading: "Loading...",
    noResults: "No results",
    clear: "Clear",
    invalid: "(invalid)"
  },
  "es-ES": {
    clear: "Borrar",
    invalid: "(no válido)",
    loading: "Cargando...",
    noResults: "Sin resultados"
  },
  "et-EE": {
    clear: "Puhasta",
    invalid: "(kehtetu)",
    loading: "Laadimine...",
    noResults: "Tulemusi pole"
  },
  "fi-FI": {
    clear: "Kirkas",
    invalid: "(epäkelpo)",
    loading: "Ladataan...",
    noResults: "Ei tuloksia"
  },
  "fr-FR": {
    clear: "Effacer",
    invalid: "(non valide)",
    loading: "Chargement en cours...",
    noResults: "Aucun résultat"
  },
  "he-IL": {
    clear: "נקי",
    invalid: "(לא חוקי)",
    loading: "טוען...",
    noResults: "אין תוצאות"
  },
  "hr-HR": {
    clear: "Izbriši",
    invalid: "(nevažeće)",
    loading: "Učitavam...",
    noResults: "Nema rezultata"
  },
  "hu-HU": {
    clear: "Törlés",
    invalid: "(érvénytelen)",
    loading: "Betöltés folyamatban…",
    noResults: "Nincsenek találatok"
  },
  "it-IT": {
    clear: "Cancella",
    invalid: "(non valido)",
    loading: "Caricamento in corso...",
    noResults: "Nessun risultato"
  },
  "ja-JP": {
    clear: "クリア",
    invalid: "(無効)",
    loading: "読み込み中...",
    noResults: "結果なし"
  },
  "ko-KR": {
    clear: "지우기",
    invalid: "(유효하지 않음)",
    loading: "로드 중...",
    noResults: "결과 없음"
  },
  "lt-LT": {
    clear: "Skaidrus",
    invalid: "(netinkama)",
    loading: "Įkeliama...",
    noResults: "Be rezultatų"
  },
  "lv-LV": {
    clear: "Notīrīt",
    invalid: "(nederīgs)",
    loading: "Notiek ielāde...",
    noResults: "Nav rezultātu"
  },
  "nb-NO": {
    clear: "Tøm",
    invalid: "(ugyldig)",
    loading: "Laster inn ...",
    noResults: "Ingen resultater"
  },
  "nl-NL": {
    clear: "Helder",
    invalid: "(ongeldig)",
    loading: "Laden...",
    noResults: "Geen resultaten"
  },
  "pl-PL": {
    clear: "Wyczyść",
    invalid: "(nieprawidłowy)",
    loading: "Trwa ładowanie...",
    noResults: "Brak wyników"
  },
  "pt-BR": {
    clear: "Limpar",
    invalid: "(inválido)",
    loading: "Carregando...",
    noResults: "Nenhum resultado"
  },
  "pt-PT": {
    clear: "Limpar",
    invalid: "(inválido)",
    loading: "A carregar...",
    noResults: "Sem resultados"
  },
  "ro-RO": {
    clear: "Golire",
    invalid: "(nevalid)",
    loading: "Se încarcă...",
    noResults: "Niciun rezultat"
  },
  "ru-RU": {
    clear: "Очистить",
    invalid: "(недействительно)",
    loading: "Загрузка...",
    noResults: "Результаты отсутствуют"
  },
  "sk-SK": {
    clear: "Vymazať",
    invalid: "(neplatné)",
    loading: "Načítava sa...",
    noResults: "Žiadne výsledky"
  },
  "sl-SI": {
    clear: "Jasen",
    invalid: "(neveljavno)",
    loading: "Nalaganje...",
    noResults: "Ni rezultatov"
  },
  "sr-SP": {
    clear: "Izbriši",
    invalid: "(nevažeće)",
    loading: "Učitavam...",
    noResults: "Nema rezultata"
  },
  "sv-SE": {
    clear: "Rensa",
    invalid: "(ogiltigt)",
    loading: "Läser in...",
    noResults: "Inga resultat"
  },
  "tr-TR": {
    clear: "Temizle",
    invalid: "(geçersiz)",
    loading: "Yükleniyor...",
    noResults: "Sonuç yok"
  },
  "uk-UA": {
    clear: "Очистити",
    invalid: "(недійсне)",
    loading: "Завантаження...",
    noResults: "Результатів немає"
  },
  "zh-CN": {
    clear: "透明",
    invalid: "（无效）",
    loading: "正在加载...",
    noResults: "无结果"
  },
  "zh-TW": {
    clear: "清除",
    invalid: "(無效)",
    loading: "正在載入...",
    noResults: "無任何結果"
  }
};
function MobileCombobox(props, forwardedRef) {
  props = useProviderProps(props);
  let {
    isDisabled,
    validationState,
    isReadOnly
  } = props;
  let {
    contains
  } = $bb77f239b46e8c72$export$3274cf84b703fff({
    sensitivity: "base"
  });
  let state = $a9e7382a7d111cb5$export$b453a3bfd4a5fa9e({
    ...props,
    defaultFilter: contains,
    allowsEmptyCollection: true,
    // Needs to be false here otherwise we double up on
    // commitSelection/commitCustomValue calls when user taps on underlay (i.e.
    // initial tap will call setFocused(false) ->
    // commitSelection/commitCustomValue via onBlur, then the closing of the
    // tray will call setFocused(false) again due to cleanup effect)
    shouldCloseOnBlur: false
  });
  let buttonRef = (0, import_react63.useRef)(null);
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let {
    triggerProps,
    overlayProps
  } = $628037886ba31236$export$f9d5c8beee7d008d({
    type: "listbox"
  }, state, buttonRef);
  let {
    labelProps,
    fieldProps
  } = $2baaea4c71418dea$export$294aa081a6c6f55d({
    ...props,
    labelElementType: "span"
  });
  labelProps.onClick = () => {
    let button = buttonRef.current;
    if (button && !props.isDisabled) {
      button.focus();
      $507fabe10e71c6fb$export$8397ddfc504fdb9a("keyboard");
    }
  };
  return (0, import_jsx_runtime54.jsxs)(import_jsx_runtime54.Fragment, {
    children: [(0, import_jsx_runtime54.jsx)(FieldPrimitive, {
      ...props,
      labelProps,
      ref: domRef,
      supplementRequiredState: true,
      children: (0, import_jsx_runtime54.jsx)(ComboboxButton, {
        ...$3ef42575df84b30b$export$9d1611c77c2fe928(triggerProps, fieldProps, {
          autoFocus: props.autoFocus
        }),
        ref: buttonRef,
        isDisabled,
        isReadOnly,
        isPlaceholder: !state.inputValue,
        validationState,
        onPress: () => !isReadOnly && state.open(null, "manual"),
        children: state.inputValue || props.placeholder || ""
      })
    }), (0, import_jsx_runtime54.jsx)(Tray, {
      state,
      isFixedHeight: true,
      ...overlayProps,
      children: (0, import_jsx_runtime54.jsx)(ComboboxTray, {
        ...props,
        onClose: state.close,
        overlayProps,
        state
      })
    })]
  });
}
var ComboboxButton = import_react63.default.forwardRef(function ComboboxButton2(props, forwardedRef) {
  let {
    isDisabled,
    isPlaceholder,
    validationState,
    children,
    style
  } = props;
  let valueId = $bdb11010cef70236$export$f680877a34711e37();
  let invalidId = $bdb11010cef70236$export$f680877a34711e37();
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({});
  let {
    buttonProps,
    isPressed
  } = $701a24aa0da5b062$export$ea18c227d4417cc3({
    ...props,
    "aria-labelledby": [props["aria-labelledby"], props["aria-label"] && !props["aria-labelledby"] ? props.id : null, valueId, validationState === "invalid" ? invalidId : null].filter(Boolean).join(" "),
    elementType: "div"
  }, domRef);
  return (0, import_jsx_runtime54.jsx)(FocusRing, {
    children: (0, import_jsx_runtime54.jsxs)(Flex, {
      position: "relative",
      width: "alias.singleLineWidth",
      zIndex: 0,
      ...toDataAttributes({
        readonly: props.isReadOnly
      }),
      ...$3ef42575df84b30b$export$9d1611c77c2fe928(hoverProps, buttonProps),
      "aria-haspopup": "dialog",
      ref: domRef,
      UNSAFE_className: comboboxClassList.element("mobile-trigger"),
      UNSAFE_style: {
        ...style,
        outline: "none"
      },
      children: [(0, import_jsx_runtime54.jsx)(Flex, {
        alignItems: "center",
        paddingX: "medium",
        flex: true,
        children: (0, import_jsx_runtime54.jsx)(Text2, {
          id: valueId,
          color: isPlaceholder ? "neutralSecondary" : void 0,
          trim: false,
          truncate: true,
          children
        })
      }), (0, import_jsx_runtime54.jsx)(InputStateIndicator2, {
        isHovered,
        isPressed,
        isDisabled,
        validationState
      }), (0, import_jsx_runtime54.jsx)(CosmeticFieldButton, {
        isHovered,
        isPressed,
        isDisabled,
        validationState,
        UNSAFE_className: css({
          borderEndStartRadius: 0,
          borderStartStartRadius: 0,
          [`${comboboxClassList.selector("mobile-trigger")}[data-focus] &`]: {
            borderColor: tokenSchema.color.alias.borderFocused
          }
        }),
        children: (0, import_jsx_runtime54.jsx)(Icon, {
          src: chevronDownIcon
        })
      })]
    })
  });
});
var CosmeticFieldButton = (props) => {
  let {
    isHovered,
    isPressed,
    ...otherProps
  } = props;
  let {
    children,
    styleProps
  } = useFieldButton(otherProps, {
    isHovered,
    isPressed
  });
  return (0, import_jsx_runtime54.jsx)("div", {
    "data-disabled": props.isDisabled,
    ...styleProps,
    children
  });
};
var InputStateIndicator2 = (props) => {
  let {
    isDisabled,
    isHovered,
    isPressed
  } = props;
  return (0, import_jsx_runtime54.jsx)("div", {
    role: "presentation",
    ...toDataAttributes({
      disabled: isDisabled,
      interaction: isPressed ? "press" : isHovered ? "hover" : void 0,
      validation: props.validationState
    }),
    className: css({
      backgroundColor: tokenSchema.color.background.canvas,
      border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.alias.borderIdle}`,
      borderRadius: tokenSchema.size.radius.regular,
      inset: 0,
      position: "absolute",
      transition: transition(["border-color", "box-shadow"]),
      zIndex: -1,
      "&[data-interaction=hover]": {
        borderColor: tokenSchema.color.alias.borderHovered
      },
      "&[data-validation=invalid]": {
        borderColor: tokenSchema.color.alias.borderInvalid
      },
      [`${comboboxClassList.selector("mobile-trigger")}[data-focus] &`]: {
        borderColor: tokenSchema.color.alias.borderFocused
      },
      [`${comboboxClassList.selector("mobile-trigger")}[data-focus]:not([data-readonly]) &`]: {
        boxShadow: `0 0 0 1px ${tokenSchema.color.alias.borderFocused}`
      },
      "&[data-disabled=true]": {
        backgroundColor: tokenSchema.color.background.surfaceSecondary,
        borderColor: "transparent"
      }
    })
  });
};
function ComboboxTray(props) {
  let {
    state,
    isDisabled,
    validationState,
    label,
    overlayProps,
    loadingState,
    onLoadMore,
    onClose
  } = props;
  let timeoutRef = (0, import_react63.useRef)();
  let [showLoading, setShowLoading] = (0, import_react63.useState)(false);
  let inputRef = (0, import_react63.useRef)(null);
  let buttonRef = (0, import_react63.useRef)(null);
  let popoverRef = (0, import_react63.useRef)(null);
  let listBoxRef = (0, import_react63.useRef)(null);
  let layout = useListBoxLayout(state);
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages8);
  let {
    inputProps,
    listBoxProps,
    labelProps
  } = $c350ade66beef0af$export$8c18d1b4f7232bbf({
    ...props,
    keyboardDelegate: layout,
    buttonRef,
    popoverRef,
    listBoxRef,
    inputRef
  }, state);
  import_react63.default.useEffect(() => {
    let input = inputRef.current;
    if (input) {
      $6a99195332edec8b$export$80f3e147d781571c(input);
    }
    return () => {
      state.setFocused(false);
    };
  }, []);
  let {
    dialogProps
  } = $40df3f8667284809$export$d55e7ee900f34e93({
    "aria-labelledby": $bdb11010cef70236$export$f680877a34711e37(labelProps.id)
  }, popoverRef);
  inputProps.role = "searchbox";
  inputProps["aria-haspopup"] = "listbox";
  delete inputProps.onTouchEnd;
  let clearButton = (0, import_jsx_runtime54.jsx)(ClearButton, {
    preventFocus: true,
    "aria-label": stringFormatter.format("clear"),
    excludeFromTabOrder: true,
    onPress: () => {
      state.setInputValue("");
      let input = inputRef.current;
      if (input) {
        input.focus();
      }
    },
    isDisabled
  });
  let loadingCircle = (0, import_jsx_runtime54.jsx)(Flex, {
    alignItems: "center",
    flexShrink: 0,
    justifyContent: "center",
    pointerEvents: "none",
    width: "element.regular",
    children: (0, import_jsx_runtime54.jsx)(ProgressCircle, {
      "aria-label": stringFormatter.format("loading"),
      size: "small",
      isIndeterminate: true
    })
  });
  let isTouchDown = (0, import_react63.useRef)(false);
  let onTouchStart = () => {
    isTouchDown.current = true;
  };
  let onTouchEnd = () => {
    isTouchDown.current = false;
  };
  let onScroll = (0, import_react63.useCallback)(() => {
    let input = inputRef.current;
    let popover = popoverRef.current;
    if (!input || document.activeElement !== input || !isTouchDown.current) {
      return;
    }
    if (popover) {
      popover.focus();
    }
  }, [inputRef, popoverRef, isTouchDown]);
  let inputValue = inputProps.value;
  let lastInputValue = (0, import_react63.useRef)(inputValue);
  (0, import_react63.useEffect)(() => {
    if (loadingState === "filtering" && !showLoading) {
      if (!timeoutRef.current) {
        timeoutRef.current = setTimeout(() => {
          setShowLoading(true);
        }, 500);
      }
      if (inputValue !== lastInputValue.current) {
        clearTimeout(timeoutRef.current);
        timeoutRef.current = setTimeout(() => {
          setShowLoading(true);
        }, 500);
      }
    } else if (loadingState !== "filtering") {
      setShowLoading(false);
      clearTimeout(timeoutRef.current);
      timeoutRef.current = void 0;
    }
    lastInputValue.current = inputValue;
  }, [loadingState, inputValue, showLoading]);
  let onKeyDown = (e6) => {
    let popover = popoverRef.current;
    if (popover && e6.key === "Enter" && state.selectionManager.focusedKey == null) {
      popover.focus();
    } else {
      var _inputProps$onKeyDown;
      (_inputProps$onKeyDown = inputProps.onKeyDown) === null || _inputProps$onKeyDown === void 0 || _inputProps$onKeyDown.call(inputProps, e6);
    }
  };
  return (0, import_jsx_runtime54.jsx)($9bf71ea28793e738$export$20e40289641fbbb6, {
    restoreFocus: true,
    contain: true,
    children: (0, import_jsx_runtime54.jsxs)(Flex, {
      direction: "column",
      height: "100%",
      ref: popoverRef,
      ...$3ef42575df84b30b$export$9d1611c77c2fe928(overlayProps, dialogProps),
      children: [(0, import_jsx_runtime54.jsx)($86ea4cb521eb2e37$export$2317d149ed6f78c4, {
        onDismiss: onClose
      }), (0, import_jsx_runtime54.jsx)(TextFieldPrimitive, {
        label,
        labelProps,
        inputProps: {
          ...inputProps,
          onKeyDown
        },
        ref: inputRef,
        isDisabled,
        marginX: "small",
        marginTop: "regular",
        endElement: (0, import_jsx_runtime54.jsxs)(Flex, {
          children: [showLoading && loadingState === "filtering" && loadingCircle, (state.inputValue !== "" || loadingState === "filtering" || validationState != null) && !props.isReadOnly && clearButton]
        })
      }), (0, import_jsx_runtime54.jsx)(_ListBoxBase, {
        ...listBoxProps,
        domProps: {
          onTouchStart,
          onTouchEnd
        },
        disallowEmptySelection: true,
        shouldSelectOnPressUp: true,
        focusOnPointerEnter: true,
        layout,
        state,
        shouldUseVirtualFocus: true,
        renderEmptyState: () => loadingState !== "loading" && (0, import_jsx_runtime54.jsx)(Flex, {
          height: "element.regular",
          alignItems: "center",
          paddingX: "medium",
          children: (0, import_jsx_runtime54.jsx)(Text2, {
            color: "neutralSecondary",
            children: stringFormatter.format("noResults")
          })
        }),
        ref: listBoxRef,
        onScroll,
        onLoadMore,
        isLoading: loadingState === "loading" || loadingState === "loadingMore"
      }), (0, import_jsx_runtime54.jsx)($86ea4cb521eb2e37$export$2317d149ed6f78c4, {
        onDismiss: onClose
      })]
    })
  });
}
var _MobileCombobox = import_react63.default.forwardRef(MobileCombobox);
function Combobox(props, forwardedRef) {
  props = useProviderProps(props);
  props = validateTextFieldProps(props);
  let isMobile = useIsMobileDevice();
  if (isMobile) {
    return (0, import_jsx_runtime54.jsx)(_MobileCombobox, {
      ...props,
      menuTrigger: "input",
      ref: forwardedRef
    });
  } else {
    return (0, import_jsx_runtime54.jsx)(ComboboxBase, {
      ...props,
      ref: forwardedRef
    });
  }
}
var ComboboxBase = import_react63.default.forwardRef(function ComboboxBase2(props, forwardedRef) {
  let {
    align = "start",
    menuTrigger = "input",
    shouldFlip = true,
    direction = "bottom",
    loadingState,
    menuWidth: menuWidthProp,
    onLoadMore
  } = props;
  let isAsync = loadingState != null;
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages8);
  let buttonRef = (0, import_react63.useRef)(null);
  let inputRef = (0, import_react63.useRef)(null);
  let listBoxRef = (0, import_react63.useRef)(null);
  let [popoverRefLikeValue, popoverRef] = useStatefulRef();
  let fieldRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let {
    contains
  } = $bb77f239b46e8c72$export$3274cf84b703fff({
    sensitivity: "base"
  });
  let state = $a9e7382a7d111cb5$export$b453a3bfd4a5fa9e({
    ...props,
    defaultFilter: contains,
    allowsEmptyCollection: isAsync
  });
  let layout = useListBoxLayout(state);
  let {
    buttonProps,
    inputProps,
    listBoxProps,
    labelProps,
    descriptionProps,
    errorMessageProps
  } = $c350ade66beef0af$export$8c18d1b4f7232bbf({
    ...props,
    keyboardDelegate: layout,
    buttonRef,
    popoverRef: popoverRefLikeValue,
    listBoxRef,
    inputRef,
    menuTrigger
  }, state);
  let [menuWidth, setMenuWidth] = (0, import_react63.useState)();
  let {
    scale
  } = useProvider();
  let onResize = (0, import_react63.useCallback)(() => {
    if (buttonRef.current && inputRef.current) {
      let buttonWidth = buttonRef.current.offsetWidth;
      let inputWidth = inputRef.current.offsetWidth;
      setMenuWidth(inputWidth + buttonWidth);
    }
  }, [buttonRef, inputRef, setMenuWidth]);
  $9daab02d461809db$export$683480f191c0e3ea({
    ref: fieldRef,
    onResize
  });
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(onResize, [scale, onResize]);
  let style = {
    width: menuWidth,
    minWidth: menuWidthProp !== null && menuWidthProp !== void 0 ? menuWidthProp : menuWidth
  };
  return (0, import_jsx_runtime54.jsxs)(import_jsx_runtime54.Fragment, {
    children: [(0, import_jsx_runtime54.jsx)(FieldPrimitive, {
      width: "alias.singleLineWidth",
      ...props,
      descriptionProps,
      errorMessageProps,
      labelProps,
      ref: fieldRef,
      children: (0, import_jsx_runtime54.jsx)(ComboboxInput, {
        ...props,
        isOpen: state.isOpen,
        loadingState,
        inputProps,
        inputRef,
        triggerProps: buttonProps,
        triggerRef: buttonRef
      })
    }), (0, import_jsx_runtime54.jsx)(Popover, {
      state,
      UNSAFE_style: style,
      ref: popoverRef,
      triggerRef: align === "end" ? buttonRef : inputRef,
      scrollRef: listBoxRef,
      placement: `${direction} ${align}`,
      hideArrow: true,
      isNonModal: true,
      shouldFlip,
      children: (0, import_jsx_runtime54.jsx)(_ListBoxBase, {
        ...listBoxProps,
        ref: listBoxRef,
        disallowEmptySelection: true,
        autoFocus: state.focusStrategy,
        shouldSelectOnPressUp: true,
        focusOnPointerEnter: true,
        layout,
        state,
        shouldUseVirtualFocus: true,
        isLoading: loadingState === "loadingMore",
        onLoadMore,
        UNSAFE_className: listStyles,
        renderEmptyState: () => isAsync && (0, import_jsx_runtime54.jsx)(Flex, {
          height: "element.regular",
          alignItems: "center",
          paddingX: "medium",
          children: (0, import_jsx_runtime54.jsx)(Text2, {
            color: "neutralSecondary",
            children: loadingState === "loading" ? stringFormatter.format("loading") : stringFormatter.format("noResults")
          })
        })
      })
    })]
  });
});
function useStatefulRef() {
  let [current, statefulRef] = (0, import_react63.useState)(null);
  return (0, import_react63.useMemo)(() => {
    return [{
      current
    }, statefulRef];
  }, [current, statefulRef]);
}
var ComboboxInput = import_react63.default.forwardRef(function ComboboxInput2(props, forwardedRef) {
  let {
    isDisabled,
    inputProps,
    inputRef,
    triggerProps,
    triggerRef,
    autoFocus,
    style,
    loadingState,
    isOpen,
    menuTrigger
  } = props;
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages8);
  let timeoutRef = (0, import_react63.useRef)();
  let [showLoading, setShowLoading] = (0, import_react63.useState)(false);
  let loadingCircle = (0, import_jsx_runtime54.jsx)(Flex, {
    alignItems: "center",
    flexShrink: 0,
    justifyContent: "center",
    pointerEvents: "none",
    width: "element.regular",
    children: (0, import_jsx_runtime54.jsx)(ProgressCircle, {
      "aria-label": stringFormatter.format("loading"),
      size: "small",
      isIndeterminate: true
    })
  });
  let isLoading = loadingState === "loading" || loadingState === "filtering";
  let inputValue = inputProps.value;
  let lastInputValue = (0, import_react63.useRef)(inputValue);
  (0, import_react63.useEffect)(() => {
    if (isLoading && !showLoading) {
      if (!timeoutRef.current) {
        timeoutRef.current = setTimeout(() => {
          setShowLoading(true);
        }, 500);
      }
      if (inputValue !== lastInputValue.current) {
        clearTimeout(timeoutRef.current);
        timeoutRef.current = setTimeout(() => {
          setShowLoading(true);
        }, 500);
      }
    } else if (!isLoading) {
      setShowLoading(false);
      clearTimeout(timeoutRef.current);
      timeoutRef.current = void 0;
    }
    lastInputValue.current = inputValue;
  }, [isLoading, showLoading, inputValue]);
  return (0, import_jsx_runtime54.jsx)(FocusRing, {
    autoFocus,
    isTextInput: true,
    within: true,
    children: (0, import_jsx_runtime54.jsx)("div", {
      ref: forwardedRef,
      style,
      children: (0, import_jsx_runtime54.jsx)(TextFieldPrimitive, {
        inputProps: {
          ...inputProps,
          className: comboboxClassList.element("input")
        },
        ref: inputRef,
        isDisabled,
        endElement: (0, import_jsx_runtime54.jsxs)(import_jsx_runtime54.Fragment, {
          children: [showLoading && (isOpen || menuTrigger === "manual" || loadingState === "loading") ? loadingCircle : null, (0, import_jsx_runtime54.jsx)($f1ab8c75478c6f73$export$3351871ee4b288b8, {
            preventFocusOnPress: true,
            isPressed: isOpen,
            children: (0, import_jsx_runtime54.jsx)(FieldButton, {
              ...triggerProps,
              ref: triggerRef,
              UNSAFE_className: css({
                borderEndStartRadius: 0,
                borderStartStartRadius: 0,
                [`${comboboxClassList.selector("input")}[aria-invalid] ~ &`]: {
                  borderColor: tokenSchema.color.alias.borderInvalid
                },
                [`${comboboxClassList.selector("input")}[readonly] ~ &`]: {
                  borderColor: tokenSchema.color.alias.borderIdle
                },
                [`${comboboxClassList.selector("input")}:focus ~ &`]: {
                  borderColor: tokenSchema.color.alias.borderFocused
                }
              }),
              children: (0, import_jsx_runtime54.jsx)(Icon, {
                src: chevronDownIcon
              })
            })
          })]
        })
      })
    })
  });
});
var _Combobox = import_react63.default.forwardRef(Combobox);

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-trashIcon.js
var import_jsx_runtime55 = __toESM(require_jsx_runtime());
var trashIcon = (0, import_jsx_runtime55.jsx)("path", {
  d: "M3 6h18M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-columnsIcon.js
var import_jsx_runtime56 = __toESM(require_jsx_runtime());
var columnsIcon = (0, import_jsx_runtime56.jsxs)(import_jsx_runtime56.Fragment, {
  children: [(0, import_jsx_runtime56.jsx)("rect", {
    width: 18,
    height: 18,
    x: 3,
    y: 3,
    rx: 2
  }), (0, import_jsx_runtime56.jsx)("path", {
    d: "M12 3v18"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-listIcon.js
var import_jsx_runtime57 = __toESM(require_jsx_runtime());
var listIcon = (0, import_jsx_runtime57.jsx)("path", {
  d: "M8 6h13M8 12h13M8 18h13M3 6h.01M3 12h.01M3 18h.01"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-listOrderedIcon.js
var import_jsx_runtime58 = __toESM(require_jsx_runtime());
var listOrderedIcon = (0, import_jsx_runtime58.jsx)("path", {
  d: "M10 6h11M10 12h11M10 18h11M4 6h1v4M4 10h2M6 18H4c0-1 2-2 2-3s-1-1.5-2-1"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-fileUpIcon.js
var import_jsx_runtime59 = __toESM(require_jsx_runtime());
var fileUpIcon = (0, import_jsx_runtime59.jsxs)(import_jsx_runtime59.Fragment, {
  children: [(0, import_jsx_runtime59.jsx)("path", {
    d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"
  }), (0, import_jsx_runtime59.jsx)("path", {
    d: "M14 2v4a2 2 0 0 0 2 2h4M12 12v6M15 15l-3-3-3 3"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-imageIcon.js
var import_jsx_runtime60 = __toESM(require_jsx_runtime());
var imageIcon = (0, import_jsx_runtime60.jsxs)(import_jsx_runtime60.Fragment, {
  children: [(0, import_jsx_runtime60.jsx)("rect", {
    width: 18,
    height: 18,
    x: 3,
    y: 3,
    rx: 2,
    ry: 2
  }), (0, import_jsx_runtime60.jsx)("circle", {
    cx: 9,
    cy: 9,
    r: 2
  }), (0, import_jsx_runtime60.jsx)("path", {
    d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"
  })]
});

// node_modules/@react-aria/numberfield/dist/ar-AE.mjs
var $fb78e0f6ab6349ed$exports = {};
$fb78e0f6ab6349ed$exports = {
  "decrease": (args2) => `خفض ${args2.fieldLabel}`,
  "increase": (args2) => `زيادة ${args2.fieldLabel}`,
  "numberField": `حقل رقمي`
};

// node_modules/@react-aria/numberfield/dist/bg-BG.mjs
var $2776acdd9959a647$exports = {};
$2776acdd9959a647$exports = {
  "decrease": (args2) => `Намаляване ${args2.fieldLabel}`,
  "increase": (args2) => `Усилване ${args2.fieldLabel}`,
  "numberField": `Номер на полето`
};

// node_modules/@react-aria/numberfield/dist/cs-CZ.mjs
var $741954410a365ad3$exports = {};
$741954410a365ad3$exports = {
  "decrease": (args2) => `Snížit ${args2.fieldLabel}`,
  "increase": (args2) => `Zvýšit ${args2.fieldLabel}`,
  "numberField": `Číselné pole`
};

// node_modules/@react-aria/numberfield/dist/da-DK.mjs
var $8321ed0f8ab642f0$exports = {};
$8321ed0f8ab642f0$exports = {
  "decrease": (args2) => `Reducer ${args2.fieldLabel}`,
  "increase": (args2) => `Øg ${args2.fieldLabel}`,
  "numberField": `Talfelt`
};

// node_modules/@react-aria/numberfield/dist/de-DE.mjs
var $92978e0c4ecafa32$exports = {};
$92978e0c4ecafa32$exports = {
  "decrease": (args2) => `${args2.fieldLabel} verringern`,
  "increase": (args2) => `${args2.fieldLabel} erhöhen`,
  "numberField": `Nummernfeld`
};

// node_modules/@react-aria/numberfield/dist/el-GR.mjs
var $ac5ff71962864a84$exports = {};
$ac5ff71962864a84$exports = {
  "decrease": (args2) => `Μείωση ${args2.fieldLabel}`,
  "increase": (args2) => `Αύξηση ${args2.fieldLabel}`,
  "numberField": `Πεδίο αριθμού`
};

// node_modules/@react-aria/numberfield/dist/en-US.mjs
var $efe4685e2440d8be$exports = {};
$efe4685e2440d8be$exports = {
  "decrease": (args2) => `Decrease ${args2.fieldLabel}`,
  "increase": (args2) => `Increase ${args2.fieldLabel}`,
  "numberField": `Number field`
};

// node_modules/@react-aria/numberfield/dist/es-ES.mjs
var $e50a9a48739b90e1$exports = {};
$e50a9a48739b90e1$exports = {
  "decrease": (args2) => `Reducir ${args2.fieldLabel}`,
  "increase": (args2) => `Aumentar ${args2.fieldLabel}`,
  "numberField": `Campo de número`
};

// node_modules/@react-aria/numberfield/dist/et-EE.mjs
var $6e0d5294ecbb8ab6$exports = {};
$6e0d5294ecbb8ab6$exports = {
  "decrease": (args2) => `Vähenda ${args2.fieldLabel}`,
  "increase": (args2) => `Suurenda ${args2.fieldLabel}`,
  "numberField": `Numbri väli`
};

// node_modules/@react-aria/numberfield/dist/fi-FI.mjs
var $e7129d65f607f77f$exports = {};
$e7129d65f607f77f$exports = {
  "decrease": (args2) => `Vähennä ${args2.fieldLabel}`,
  "increase": (args2) => `Lisää ${args2.fieldLabel}`,
  "numberField": `Numerokenttä`
};

// node_modules/@react-aria/numberfield/dist/fr-FR.mjs
var $d72adf5b20573e34$exports = {};
$d72adf5b20573e34$exports = {
  "decrease": (args2) => `Diminuer ${args2.fieldLabel}`,
  "increase": (args2) => `Augmenter ${args2.fieldLabel}`,
  "numberField": `Champ de nombre`
};

// node_modules/@react-aria/numberfield/dist/he-IL.mjs
var $a25c707e88b844a7$exports = {};
$a25c707e88b844a7$exports = {
  "decrease": (args2) => `הקטן ${args2.fieldLabel}`,
  "increase": (args2) => `הגדל ${args2.fieldLabel}`,
  "numberField": `שדה מספר`
};

// node_modules/@react-aria/numberfield/dist/hr-HR.mjs
var $69b41140b9a4ca54$exports = {};
$69b41140b9a4ca54$exports = {
  "decrease": (args2) => `Smanji ${args2.fieldLabel}`,
  "increase": (args2) => `Povećaj ${args2.fieldLabel}`,
  "numberField": `Polje broja`
};

// node_modules/@react-aria/numberfield/dist/hu-HU.mjs
var $81dab28f37f59d1a$exports = {};
$81dab28f37f59d1a$exports = {
  "decrease": (args2) => `${args2.fieldLabel} csökkentése`,
  "increase": (args2) => `${args2.fieldLabel} növelése`,
  "numberField": `Számmező`
};

// node_modules/@react-aria/numberfield/dist/it-IT.mjs
var $866555b31f2d7711$exports = {};
$866555b31f2d7711$exports = {
  "decrease": (args2) => `Riduci ${args2.fieldLabel}`,
  "increase": (args2) => `Aumenta ${args2.fieldLabel}`,
  "numberField": `Campo numero`
};

// node_modules/@react-aria/numberfield/dist/ja-JP.mjs
var $dafcd55d52b9d371$exports = {};
$dafcd55d52b9d371$exports = {
  "decrease": (args2) => `${args2.fieldLabel}を縮小`,
  "increase": (args2) => `${args2.fieldLabel}を拡大`,
  "numberField": `数値フィールド`
};

// node_modules/@react-aria/numberfield/dist/ko-KR.mjs
var $f090c1f8c5da0145$exports = {};
$f090c1f8c5da0145$exports = {
  "decrease": (args2) => `${args2.fieldLabel} 감소`,
  "increase": (args2) => `${args2.fieldLabel} 증가`,
  "numberField": `번호 필드`
};

// node_modules/@react-aria/numberfield/dist/lt-LT.mjs
var $6f10f3a13360a75c$exports = {};
$6f10f3a13360a75c$exports = {
  "decrease": (args2) => `Sumažinti ${args2.fieldLabel}`,
  "increase": (args2) => `Padidinti ${args2.fieldLabel}`,
  "numberField": `Numerio laukas`
};

// node_modules/@react-aria/numberfield/dist/lv-LV.mjs
var $47432cefd4b7bd1b$exports = {};
$47432cefd4b7bd1b$exports = {
  "decrease": (args2) => `Samazināšana ${args2.fieldLabel}`,
  "increase": (args2) => `Palielināšana ${args2.fieldLabel}`,
  "numberField": `Skaitļu lauks`
};

// node_modules/@react-aria/numberfield/dist/nb-NO.mjs
var $dc578a950a2bf23d$exports = {};
$dc578a950a2bf23d$exports = {
  "decrease": (args2) => `Reduser ${args2.fieldLabel}`,
  "increase": (args2) => `Øk ${args2.fieldLabel}`,
  "numberField": `Tallfelt`
};

// node_modules/@react-aria/numberfield/dist/nl-NL.mjs
var $353f1bfca4dc395a$exports = {};
$353f1bfca4dc395a$exports = {
  "decrease": (args2) => `${args2.fieldLabel} verlagen`,
  "increase": (args2) => `${args2.fieldLabel} verhogen`,
  "numberField": `Getalveld`
};

// node_modules/@react-aria/numberfield/dist/pl-PL.mjs
var $241bc0bbd870e982$exports = {};
$241bc0bbd870e982$exports = {
  "decrease": (args2) => `Zmniejsz ${args2.fieldLabel}`,
  "increase": (args2) => `Zwiększ ${args2.fieldLabel}`,
  "numberField": `Pole numeru`
};

// node_modules/@react-aria/numberfield/dist/pt-BR.mjs
var $da3005c7bd72b0a8$exports = {};
$da3005c7bd72b0a8$exports = {
  "decrease": (args2) => `Diminuir ${args2.fieldLabel}`,
  "increase": (args2) => `Aumentar ${args2.fieldLabel}`,
  "numberField": `Campo de número`
};

// node_modules/@react-aria/numberfield/dist/pt-PT.mjs
var $cf48bfc540882310$exports = {};
$cf48bfc540882310$exports = {
  "decrease": (args2) => `Diminuir ${args2.fieldLabel}`,
  "increase": (args2) => `Aumentar ${args2.fieldLabel}`,
  "numberField": `Campo numérico`
};

// node_modules/@react-aria/numberfield/dist/ro-RO.mjs
var $b63a28c481ab9ee3$exports = {};
$b63a28c481ab9ee3$exports = {
  "decrease": (args2) => `Scădere ${args2.fieldLabel}`,
  "increase": (args2) => `Creștere ${args2.fieldLabel}`,
  "numberField": `Câmp numeric`
};

// node_modules/@react-aria/numberfield/dist/ru-RU.mjs
var $19f9df95c2464ab6$exports = {};
$19f9df95c2464ab6$exports = {
  "decrease": (args2) => `Уменьшение ${args2.fieldLabel}`,
  "increase": (args2) => `Увеличение ${args2.fieldLabel}`,
  "numberField": `Числовое поле`
};

// node_modules/@react-aria/numberfield/dist/sk-SK.mjs
var $b272932a685e8482$exports = {};
$b272932a685e8482$exports = {
  "decrease": (args2) => `Znížiť ${args2.fieldLabel}`,
  "increase": (args2) => `Zvýšiť ${args2.fieldLabel}`,
  "numberField": `Číselné pole`
};

// node_modules/@react-aria/numberfield/dist/sl-SI.mjs
var $cbaf8b5b61f9e544$exports = {};
$cbaf8b5b61f9e544$exports = {
  "decrease": (args2) => `Upadati ${args2.fieldLabel}`,
  "increase": (args2) => `Povečajte ${args2.fieldLabel}`,
  "numberField": `Številčno polje`
};

// node_modules/@react-aria/numberfield/dist/sr-SP.mjs
var $e0a3af6ac1449b2f$exports = {};
$e0a3af6ac1449b2f$exports = {
  "decrease": (args2) => `Smanji ${args2.fieldLabel}`,
  "increase": (args2) => `Povećaj ${args2.fieldLabel}`,
  "numberField": `Polje broja`
};

// node_modules/@react-aria/numberfield/dist/sv-SE.mjs
var $71e167d2458a6019$exports = {};
$71e167d2458a6019$exports = {
  "decrease": (args2) => `Minska ${args2.fieldLabel}`,
  "increase": (args2) => `Öka ${args2.fieldLabel}`,
  "numberField": `Nummerfält`
};

// node_modules/@react-aria/numberfield/dist/tr-TR.mjs
var $3719245abc082946$exports = {};
$3719245abc082946$exports = {
  "decrease": (args2) => `${args2.fieldLabel} azalt`,
  "increase": (args2) => `${args2.fieldLabel} arttır`,
  "numberField": `Sayı alanı`
};

// node_modules/@react-aria/numberfield/dist/uk-UA.mjs
var $2ccc589e2f51824d$exports = {};
$2ccc589e2f51824d$exports = {
  "decrease": (args2) => `Зменшити ${args2.fieldLabel}`,
  "increase": (args2) => `Збільшити ${args2.fieldLabel}`,
  "numberField": `Поле номера`
};

// node_modules/@react-aria/numberfield/dist/zh-CN.mjs
var $e1103cb9b4c13942$exports = {};
$e1103cb9b4c13942$exports = {
  "decrease": (args2) => `降低 ${args2.fieldLabel}`,
  "increase": (args2) => `提高 ${args2.fieldLabel}`,
  "numberField": `数字字段`
};

// node_modules/@react-aria/numberfield/dist/zh-TW.mjs
var $448607634f80dccb$exports = {};
$448607634f80dccb$exports = {
  "decrease": (args2) => `縮小 ${args2.fieldLabel}`,
  "increase": (args2) => `放大 ${args2.fieldLabel}`,
  "numberField": `數字欄位`
};

// node_modules/@react-aria/numberfield/dist/import.mjs
var import_react65 = __toESM(require_react(), 1);

// node_modules/@react-aria/spinbutton/dist/ar-AE.mjs
var $ed6aae4e5f766f1e$exports = {};
$ed6aae4e5f766f1e$exports = {
  "Empty": `فارغ`
};

// node_modules/@react-aria/spinbutton/dist/bg-BG.mjs
var $38854e2b175151fa$exports = {};
$38854e2b175151fa$exports = {
  "Empty": `Изпразни`
};

// node_modules/@react-aria/spinbutton/dist/cs-CZ.mjs
var $15b25ab20f3945b2$exports = {};
$15b25ab20f3945b2$exports = {
  "Empty": `Prázdné`
};

// node_modules/@react-aria/spinbutton/dist/da-DK.mjs
var $692a4298b6b649a2$exports = {};
$692a4298b6b649a2$exports = {
  "Empty": `Tom`
};

// node_modules/@react-aria/spinbutton/dist/de-DE.mjs
var $1c6e1539193f1243$exports = {};
$1c6e1539193f1243$exports = {
  "Empty": `Leer`
};

// node_modules/@react-aria/spinbutton/dist/el-GR.mjs
var $1e8678632c464b6d$exports = {};
$1e8678632c464b6d$exports = {
  "Empty": `Άδειο`
};

// node_modules/@react-aria/spinbutton/dist/en-US.mjs
var $4adc85d9bf5b9eed$exports = {};
$4adc85d9bf5b9eed$exports = {
  "Empty": `Empty`
};

// node_modules/@react-aria/spinbutton/dist/es-ES.mjs
var $41c4b2bb61dafbca$exports = {};
$41c4b2bb61dafbca$exports = {
  "Empty": `Vacío`
};

// node_modules/@react-aria/spinbutton/dist/et-EE.mjs
var $405f8b24f5dd2a60$exports = {};
$405f8b24f5dd2a60$exports = {
  "Empty": `Tühjenda`
};

// node_modules/@react-aria/spinbutton/dist/fi-FI.mjs
var $7efe3ed02b9b9dd4$exports = {};
$7efe3ed02b9b9dd4$exports = {
  "Empty": `Tyhjä`
};

// node_modules/@react-aria/spinbutton/dist/fr-FR.mjs
var $99fc4c101d92daf3$exports = {};
$99fc4c101d92daf3$exports = {
  "Empty": `Vide`
};

// node_modules/@react-aria/spinbutton/dist/he-IL.mjs
var $f9e155e6e8cacaa2$exports = {};
$f9e155e6e8cacaa2$exports = {
  "Empty": `ריק`
};

// node_modules/@react-aria/spinbutton/dist/hr-HR.mjs
var $c31b5e8e9a249fd5$exports = {};
$c31b5e8e9a249fd5$exports = {
  "Empty": `Prazno`
};

// node_modules/@react-aria/spinbutton/dist/hu-HU.mjs
var $9c5435bc17499bd9$exports = {};
$9c5435bc17499bd9$exports = {
  "Empty": `Üres`
};

// node_modules/@react-aria/spinbutton/dist/it-IT.mjs
var $6d1fc8e84d8165e1$exports = {};
$6d1fc8e84d8165e1$exports = {
  "Empty": `Vuoto`
};

// node_modules/@react-aria/spinbutton/dist/ja-JP.mjs
var $46ea6b3641b83e71$exports = {};
$46ea6b3641b83e71$exports = {
  "Empty": `空`
};

// node_modules/@react-aria/spinbutton/dist/ko-KR.mjs
var $0e3cc9a288289dc5$exports = {};
$0e3cc9a288289dc5$exports = {
  "Empty": `비어 있음`
};

// node_modules/@react-aria/spinbutton/dist/lt-LT.mjs
var $4ff2bb25c0089ffb$exports = {};
$4ff2bb25c0089ffb$exports = {
  "Empty": `Tuščias`
};

// node_modules/@react-aria/spinbutton/dist/lv-LV.mjs
var $6cf33cd4c010a2fb$exports = {};
$6cf33cd4c010a2fb$exports = {
  "Empty": `Tukšs`
};

// node_modules/@react-aria/spinbutton/dist/nb-NO.mjs
var $5a9f8486f8b8837e$exports = {};
$5a9f8486f8b8837e$exports = {
  "Empty": `Tom`
};

// node_modules/@react-aria/spinbutton/dist/nl-NL.mjs
var $583f94d807f6ecea$exports = {};
$583f94d807f6ecea$exports = {
  "Empty": `Leeg`
};

// node_modules/@react-aria/spinbutton/dist/pl-PL.mjs
var $cc4dcfeea2b4050d$exports = {};
$cc4dcfeea2b4050d$exports = {
  "Empty": `Pusty`
};

// node_modules/@react-aria/spinbutton/dist/pt-BR.mjs
var $68ac2954d56e12b4$exports = {};
$68ac2954d56e12b4$exports = {
  "Empty": `Vazio`
};

// node_modules/@react-aria/spinbutton/dist/pt-PT.mjs
var $fdb0616f309780b0$exports = {};
$fdb0616f309780b0$exports = {
  "Empty": `Vazio`
};

// node_modules/@react-aria/spinbutton/dist/ro-RO.mjs
var $fe1eccf4ee1d6f52$exports = {};
$fe1eccf4ee1d6f52$exports = {
  "Empty": `Gol`
};

// node_modules/@react-aria/spinbutton/dist/ru-RU.mjs
var $a38b6c4e18725976$exports = {};
$a38b6c4e18725976$exports = {
  "Empty": `Не заполнено`
};

// node_modules/@react-aria/spinbutton/dist/sk-SK.mjs
var $6c14ae2b766b652c$exports = {};
$6c14ae2b766b652c$exports = {
  "Empty": `Prázdne`
};

// node_modules/@react-aria/spinbutton/dist/sl-SI.mjs
var $8f1c9692e16dc5eb$exports = {};
$8f1c9692e16dc5eb$exports = {
  "Empty": `Prazen`
};

// node_modules/@react-aria/spinbutton/dist/sr-SP.mjs
var $d2aa7abea627cafa$exports = {};
$d2aa7abea627cafa$exports = {
  "Empty": `Prazno`
};

// node_modules/@react-aria/spinbutton/dist/sv-SE.mjs
var $676b82e4b56408e6$exports = {};
$676b82e4b56408e6$exports = {
  "Empty": `Tomt`
};

// node_modules/@react-aria/spinbutton/dist/tr-TR.mjs
var $14c9042552d7ce08$exports = {};
$14c9042552d7ce08$exports = {
  "Empty": `Boş`
};

// node_modules/@react-aria/spinbutton/dist/uk-UA.mjs
var $393254ebcb66c9f5$exports = {};
$393254ebcb66c9f5$exports = {
  "Empty": `Пусто`
};

// node_modules/@react-aria/spinbutton/dist/zh-CN.mjs
var $d49d621f310cf6ce$exports = {};
$d49d621f310cf6ce$exports = {
  "Empty": `空`
};

// node_modules/@react-aria/spinbutton/dist/zh-TW.mjs
var $94b60c866ca5dfe6$exports = {};
$94b60c866ca5dfe6$exports = {
  "Empty": `空白`
};

// node_modules/@react-aria/spinbutton/dist/import.mjs
var import_react64 = __toESM(require_react(), 1);
function $parcel$interopDefault6(a3) {
  return a3 && a3.__esModule ? a3.default : a3;
}
var $a99895ee3dc79e61$exports = {};
$a99895ee3dc79e61$exports = {
  "ar-AE": $ed6aae4e5f766f1e$exports,
  "bg-BG": $38854e2b175151fa$exports,
  "cs-CZ": $15b25ab20f3945b2$exports,
  "da-DK": $692a4298b6b649a2$exports,
  "de-DE": $1c6e1539193f1243$exports,
  "el-GR": $1e8678632c464b6d$exports,
  "en-US": $4adc85d9bf5b9eed$exports,
  "es-ES": $41c4b2bb61dafbca$exports,
  "et-EE": $405f8b24f5dd2a60$exports,
  "fi-FI": $7efe3ed02b9b9dd4$exports,
  "fr-FR": $99fc4c101d92daf3$exports,
  "he-IL": $f9e155e6e8cacaa2$exports,
  "hr-HR": $c31b5e8e9a249fd5$exports,
  "hu-HU": $9c5435bc17499bd9$exports,
  "it-IT": $6d1fc8e84d8165e1$exports,
  "ja-JP": $46ea6b3641b83e71$exports,
  "ko-KR": $0e3cc9a288289dc5$exports,
  "lt-LT": $4ff2bb25c0089ffb$exports,
  "lv-LV": $6cf33cd4c010a2fb$exports,
  "nb-NO": $5a9f8486f8b8837e$exports,
  "nl-NL": $583f94d807f6ecea$exports,
  "pl-PL": $cc4dcfeea2b4050d$exports,
  "pt-BR": $68ac2954d56e12b4$exports,
  "pt-PT": $fdb0616f309780b0$exports,
  "ro-RO": $fe1eccf4ee1d6f52$exports,
  "ru-RU": $a38b6c4e18725976$exports,
  "sk-SK": $6c14ae2b766b652c$exports,
  "sl-SI": $8f1c9692e16dc5eb$exports,
  "sr-SP": $d2aa7abea627cafa$exports,
  "sv-SE": $676b82e4b56408e6$exports,
  "tr-TR": $14c9042552d7ce08$exports,
  "uk-UA": $393254ebcb66c9f5$exports,
  "zh-CN": $d49d621f310cf6ce$exports,
  "zh-TW": $94b60c866ca5dfe6$exports
};
function $d2e8511e6f209edf$export$e908e06f4b8e3402(props) {
  const _async = (0, import_react64.useRef)();
  let { value: value2, textValue, minValue, maxValue, isDisabled, isReadOnly, isRequired, onIncrement, onIncrementPage, onDecrement, onDecrementPage, onDecrementToMin, onIncrementToMax } = props;
  const stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault6($a99895ee3dc79e61$exports)), "@react-aria/spinbutton");
  const clearAsync = () => clearTimeout(_async.current);
  (0, import_react64.useEffect)(() => {
    return () => clearAsync();
  }, []);
  let onKeyDown = (e6) => {
    if (e6.ctrlKey || e6.metaKey || e6.shiftKey || e6.altKey || isReadOnly)
      return;
    switch (e6.key) {
      case "PageUp":
        if (onIncrementPage) {
          e6.preventDefault();
          onIncrementPage === null || onIncrementPage === void 0 ? void 0 : onIncrementPage();
          break;
        }
      case "ArrowUp":
      case "Up":
        if (onIncrement) {
          e6.preventDefault();
          onIncrement === null || onIncrement === void 0 ? void 0 : onIncrement();
        }
        break;
      case "PageDown":
        if (onDecrementPage) {
          e6.preventDefault();
          onDecrementPage === null || onDecrementPage === void 0 ? void 0 : onDecrementPage();
          break;
        }
      case "ArrowDown":
      case "Down":
        if (onDecrement) {
          e6.preventDefault();
          onDecrement === null || onDecrement === void 0 ? void 0 : onDecrement();
        }
        break;
      case "Home":
        if (onDecrementToMin) {
          e6.preventDefault();
          onDecrementToMin === null || onDecrementToMin === void 0 ? void 0 : onDecrementToMin();
        }
        break;
      case "End":
        if (onIncrementToMax) {
          e6.preventDefault();
          onIncrementToMax === null || onIncrementToMax === void 0 ? void 0 : onIncrementToMax();
        }
        break;
    }
  };
  let isFocused = (0, import_react64.useRef)(false);
  let onFocus = () => {
    isFocused.current = true;
  };
  let onBlur = () => {
    isFocused.current = false;
  };
  let ariaTextValue = textValue === "" ? stringFormatter.format("Empty") : (textValue || `${value2}`).replace("-", "−");
  (0, import_react64.useEffect)(() => {
    if (isFocused.current) {
      (0, $319e236875307eab$export$d10ae4f68404609a)("assertive");
      (0, $319e236875307eab$export$a9b970dcc4ae71a9)(ariaTextValue, "assertive");
    }
  }, [
    ariaTextValue
  ]);
  const onIncrementPressStart = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((initialStepDelay) => {
    clearAsync();
    onIncrement === null || onIncrement === void 0 ? void 0 : onIncrement();
    _async.current = window.setTimeout(() => {
      if (maxValue === void 0 || isNaN(maxValue) || value2 === void 0 || isNaN(value2) || value2 < maxValue)
        onIncrementPressStart(60);
    }, initialStepDelay);
  });
  const onDecrementPressStart = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((initialStepDelay) => {
    clearAsync();
    onDecrement === null || onDecrement === void 0 ? void 0 : onDecrement();
    _async.current = window.setTimeout(() => {
      if (minValue === void 0 || isNaN(minValue) || value2 === void 0 || isNaN(value2) || value2 > minValue)
        onDecrementPressStart(60);
    }, initialStepDelay);
  });
  let cancelContextMenu = (e6) => {
    e6.preventDefault();
  };
  let { addGlobalListener, removeAllGlobalListeners } = (0, $03deb23ff14920c4$export$4eaf04e54aa8eed6)();
  return {
    spinButtonProps: {
      role: "spinbutton",
      "aria-valuenow": value2 !== void 0 && !isNaN(value2) ? value2 : void 0,
      "aria-valuetext": ariaTextValue,
      "aria-valuemin": minValue,
      "aria-valuemax": maxValue,
      "aria-disabled": isDisabled || void 0,
      "aria-readonly": isReadOnly || void 0,
      "aria-required": isRequired || void 0,
      onKeyDown,
      onFocus,
      onBlur
    },
    incrementButtonProps: {
      onPressStart: () => {
        onIncrementPressStart(400);
        addGlobalListener(window, "contextmenu", cancelContextMenu);
      },
      onPressEnd: () => {
        clearAsync();
        removeAllGlobalListeners();
      },
      onFocus,
      onBlur
    },
    decrementButtonProps: {
      onPressStart: () => {
        onDecrementPressStart(400);
        addGlobalListener(window, "contextmenu", cancelContextMenu);
      },
      onPressEnd: () => {
        clearAsync();
        removeAllGlobalListeners();
      },
      onFocus,
      onBlur
    }
  };
}

// node_modules/@react-aria/numberfield/dist/import.mjs
function $parcel$interopDefault7(a3) {
  return a3 && a3.__esModule ? a3.default : a3;
}
var $280a227d7cb94b92$exports = {};
$280a227d7cb94b92$exports = {
  "ar-AE": $fb78e0f6ab6349ed$exports,
  "bg-BG": $2776acdd9959a647$exports,
  "cs-CZ": $741954410a365ad3$exports,
  "da-DK": $8321ed0f8ab642f0$exports,
  "de-DE": $92978e0c4ecafa32$exports,
  "el-GR": $ac5ff71962864a84$exports,
  "en-US": $efe4685e2440d8be$exports,
  "es-ES": $e50a9a48739b90e1$exports,
  "et-EE": $6e0d5294ecbb8ab6$exports,
  "fi-FI": $e7129d65f607f77f$exports,
  "fr-FR": $d72adf5b20573e34$exports,
  "he-IL": $a25c707e88b844a7$exports,
  "hr-HR": $69b41140b9a4ca54$exports,
  "hu-HU": $81dab28f37f59d1a$exports,
  "it-IT": $866555b31f2d7711$exports,
  "ja-JP": $dafcd55d52b9d371$exports,
  "ko-KR": $f090c1f8c5da0145$exports,
  "lt-LT": $6f10f3a13360a75c$exports,
  "lv-LV": $47432cefd4b7bd1b$exports,
  "nb-NO": $dc578a950a2bf23d$exports,
  "nl-NL": $353f1bfca4dc395a$exports,
  "pl-PL": $241bc0bbd870e982$exports,
  "pt-BR": $da3005c7bd72b0a8$exports,
  "pt-PT": $cf48bfc540882310$exports,
  "ro-RO": $b63a28c481ab9ee3$exports,
  "ru-RU": $19f9df95c2464ab6$exports,
  "sk-SK": $b272932a685e8482$exports,
  "sl-SI": $cbaf8b5b61f9e544$exports,
  "sr-SP": $e0a3af6ac1449b2f$exports,
  "sv-SE": $71e167d2458a6019$exports,
  "tr-TR": $3719245abc082946$exports,
  "uk-UA": $2ccc589e2f51824d$exports,
  "zh-CN": $e1103cb9b4c13942$exports,
  "zh-TW": $448607634f80dccb$exports
};
function $81397a9303501bda$export$23f548e970bdf099(props, state, inputRef) {
  let { id: id2, decrementAriaLabel, incrementAriaLabel, isDisabled, isReadOnly, isRequired, minValue, maxValue, autoFocus, label, formatOptions, onBlur = () => {
  }, onFocus, onFocusChange, onKeyDown, onKeyUp, description, errorMessage, isWheelDisabled, ...otherProps } = props;
  let { increment: increment2, incrementToMax, decrement, decrementToMin, numberValue, inputValue, commit, commitValidation } = state;
  const stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault7($280a227d7cb94b92$exports)), "@react-aria/numberfield");
  let inputId = (0, $bdb11010cef70236$export$f680877a34711e37)(id2);
  let { focusProps } = (0, $a1ea59d68270f0dd$export$f8168d8dd8fd66e6)({
    onBlur() {
      commit();
    }
  });
  let numberFormatter = (0, $a916eb452884faea$export$b7a616150fdb9f44)(formatOptions);
  let intlOptions = (0, import_react65.useMemo)(() => numberFormatter.resolvedOptions(), [
    numberFormatter
  ]);
  let textValueFormatter = (0, $a916eb452884faea$export$b7a616150fdb9f44)({
    ...formatOptions,
    currencySign: void 0
  });
  let textValue = (0, import_react65.useMemo)(() => isNaN(numberValue) ? "" : textValueFormatter.format(numberValue), [
    textValueFormatter,
    numberValue
  ]);
  let { spinButtonProps, incrementButtonProps: incButtonProps, decrementButtonProps: decButtonProps } = (0, $d2e8511e6f209edf$export$e908e06f4b8e3402)({
    isDisabled,
    isReadOnly,
    isRequired,
    maxValue,
    minValue,
    onIncrement: increment2,
    onIncrementToMax: incrementToMax,
    onDecrement: decrement,
    onDecrementToMin: decrementToMin,
    value: numberValue,
    textValue
  });
  let [focusWithin, setFocusWithin] = (0, import_react65.useState)(false);
  let { focusWithinProps } = (0, $9ab94262bd0047c7$export$420e68273165f4ec)({
    isDisabled,
    onFocusWithinChange: setFocusWithin
  });
  let onWheel = (0, import_react65.useCallback)((e6) => {
    if (Math.abs(e6.deltaY) <= Math.abs(e6.deltaX))
      return;
    if (e6.deltaY > 0)
      increment2();
    else if (e6.deltaY < 0)
      decrement();
  }, [
    decrement,
    increment2
  ]);
  let scrollingDisabled = isWheelDisabled || isDisabled || isReadOnly || !focusWithin;
  (0, $7d0a636d7a4dcefd$export$2123ff2b87c81ca)({
    onScroll: onWheel,
    isDisabled: scrollingDisabled
  }, inputRef);
  let hasDecimals = intlOptions.maximumFractionDigits > 0;
  let hasNegative = state.minValue === void 0 || isNaN(state.minValue) || state.minValue < 0;
  let inputMode = "numeric";
  if ((0, $c87311424ea30a05$export$186c6964ca17d99)()) {
    if (hasNegative)
      inputMode = "text";
    else if (hasDecimals)
      inputMode = "decimal";
  } else if ((0, $c87311424ea30a05$export$a11b0059900ceec8)()) {
    if (hasNegative)
      inputMode = "numeric";
    else if (hasDecimals)
      inputMode = "decimal";
  }
  let onChange2 = (value2) => {
    if (state.validate(value2))
      state.setInputValue(value2);
  };
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props);
  let onKeyDownEnter = (0, import_react65.useCallback)((e6) => {
    if (e6.key === "Enter") {
      commit();
      commitValidation();
    } else
      e6.continuePropagation();
  }, [
    commit,
    commitValidation
  ]);
  let { isInvalid, validationErrors, validationDetails } = state.displayValidation;
  let { labelProps, inputProps: textFieldProps, descriptionProps, errorMessageProps } = (0, $d841c8010a73d545$export$4f384c9210e583c3)({
    ...otherProps,
    ...domProps,
    name: void 0,
    label,
    autoFocus,
    isDisabled,
    isReadOnly,
    isRequired,
    validate: void 0,
    [(0, $e5be200c675c3b3a$export$a763b9476acd3eb)]: state,
    value: inputValue,
    defaultValue: void 0,
    autoComplete: "off",
    "aria-label": props["aria-label"] || void 0,
    "aria-labelledby": props["aria-labelledby"] || void 0,
    id: inputId,
    type: "text",
    inputMode,
    onChange: onChange2,
    onBlur,
    onFocus,
    onFocusChange,
    onKeyDown: (0, import_react65.useMemo)(() => (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(onKeyDownEnter, onKeyDown), [
      onKeyDownEnter,
      onKeyDown
    ]),
    onKeyUp,
    description,
    errorMessage
  }, state, inputRef);
  (0, $99facab73266f662$export$5add1d006293d136)(inputRef, state.numberValue, state.setNumberValue);
  let inputProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(spinButtonProps, focusProps, textFieldProps, {
    // override the spinbutton role, we can't focus a spin button with VO
    role: null,
    // ignore aria-roledescription on iOS so that required state will announce when it is present
    "aria-roledescription": !(0, $c87311424ea30a05$export$fedb369cb70207f1)() ? stringFormatter.format("numberField") : null,
    "aria-valuemax": null,
    "aria-valuemin": null,
    "aria-valuenow": null,
    "aria-valuetext": null,
    autoCorrect: "off",
    spellCheck: "false"
  });
  if (props.validationBehavior === "native")
    inputProps["aria-required"] = void 0;
  let onButtonPressStart = (e6) => {
    var _inputRef_current;
    if (document.activeElement === inputRef.current)
      return;
    if (e6.pointerType === "mouse")
      (_inputRef_current = inputRef.current) === null || _inputRef_current === void 0 ? void 0 : _inputRef_current.focus();
    else
      e6.target.focus();
  };
  let fieldLabel = props["aria-label"] || (typeof props.label === "string" ? props.label : "");
  let ariaLabelledby;
  if (!fieldLabel)
    ariaLabelledby = props.label != null ? labelProps.id : props["aria-labelledby"];
  let incrementId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  let decrementId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  let incrementButtonProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(incButtonProps, {
    "aria-label": incrementAriaLabel || stringFormatter.format("increase", {
      fieldLabel
    }).trim(),
    id: ariaLabelledby && !incrementAriaLabel ? incrementId : null,
    "aria-labelledby": ariaLabelledby && !incrementAriaLabel ? `${incrementId} ${ariaLabelledby}` : null,
    "aria-controls": inputId,
    excludeFromTabOrder: true,
    preventFocusOnPress: true,
    allowFocusWhenDisabled: true,
    isDisabled: !state.canIncrement,
    onPressStart: onButtonPressStart
  });
  let decrementButtonProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(decButtonProps, {
    "aria-label": decrementAriaLabel || stringFormatter.format("decrease", {
      fieldLabel
    }).trim(),
    id: ariaLabelledby && !decrementAriaLabel ? decrementId : null,
    "aria-labelledby": ariaLabelledby && !decrementAriaLabel ? `${decrementId} ${ariaLabelledby}` : null,
    "aria-controls": inputId,
    excludeFromTabOrder: true,
    preventFocusOnPress: true,
    allowFocusWhenDisabled: true,
    isDisabled: !state.canDecrement,
    onPressStart: onButtonPressStart
  });
  return {
    groupProps: {
      ...focusWithinProps,
      role: "group",
      "aria-disabled": isDisabled,
      "aria-invalid": isInvalid ? "true" : void 0
    },
    labelProps,
    inputProps,
    incrementButtonProps,
    decrementButtonProps,
    errorMessageProps,
    descriptionProps,
    isInvalid,
    validationErrors,
    validationDetails
  };
}

// node_modules/@react-stately/numberfield/dist/import.mjs
var import_react66 = __toESM(require_react(), 1);
function $de67e98908f0c6ee$export$7f629e9dc1ecf37c(props) {
  let { minValue, maxValue, step, formatOptions, value: value2, defaultValue = NaN, onChange: onChange2, locale, isDisabled, isReadOnly } = props;
  if (value2 === null)
    value2 = NaN;
  if (value2 !== void 0 && !isNaN(value2)) {
    if (step !== void 0 && !isNaN(step))
      value2 = (0, $9446cca9a3875146$export$cb6e0bb50bc19463)(value2, minValue, maxValue, step);
    else
      value2 = (0, $9446cca9a3875146$export$7d15b64cf5a3a4c4)(value2, minValue, maxValue);
  }
  if (!isNaN(defaultValue)) {
    if (step !== void 0 && !isNaN(step))
      defaultValue = (0, $9446cca9a3875146$export$cb6e0bb50bc19463)(defaultValue, minValue, maxValue, step);
    else
      defaultValue = (0, $9446cca9a3875146$export$7d15b64cf5a3a4c4)(defaultValue, minValue, maxValue);
  }
  let [numberValue, setNumberValue] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(value2, isNaN(defaultValue) ? NaN : defaultValue, onChange2);
  let [inputValue, setInputValue] = (0, import_react66.useState)(() => isNaN(numberValue) ? "" : new (0, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(locale, formatOptions).format(numberValue));
  let numberParser = (0, import_react66.useMemo)(() => new (0, $6c7bd7858deea686$export$cd11ab140839f11d)(locale, formatOptions), [
    locale,
    formatOptions
  ]);
  let numberingSystem = (0, import_react66.useMemo)(() => numberParser.getNumberingSystem(inputValue), [
    numberParser,
    inputValue
  ]);
  let formatter = (0, import_react66.useMemo)(() => new (0, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(locale, {
    ...formatOptions,
    numberingSystem
  }), [
    locale,
    formatOptions,
    numberingSystem
  ]);
  let intlOptions = (0, import_react66.useMemo)(() => formatter.resolvedOptions(), [
    formatter
  ]);
  let format2 = (0, import_react66.useCallback)((value3) => isNaN(value3) || value3 === null ? "" : formatter.format(value3), [
    formatter
  ]);
  let validation = (0, $e5be200c675c3b3a$export$fc1a364ae1f3ff10)({
    ...props,
    value: numberValue
  });
  let clampStep = step !== void 0 && !isNaN(step) ? step : 1;
  if (intlOptions.style === "percent" && (step === void 0 || isNaN(step)))
    clampStep = 0.01;
  let [prevValue, setPrevValue] = (0, import_react66.useState)(numberValue);
  let [prevLocale, setPrevLocale] = (0, import_react66.useState)(locale);
  let [prevFormatOptions, setPrevFormatOptions] = (0, import_react66.useState)(formatOptions);
  if (!Object.is(numberValue, prevValue) || locale !== prevLocale || formatOptions !== prevFormatOptions) {
    setInputValue(format2(numberValue));
    setPrevValue(numberValue);
    setPrevLocale(locale);
    setPrevFormatOptions(formatOptions);
  }
  let parsedValue = (0, import_react66.useMemo)(() => numberParser.parse(inputValue), [
    numberParser,
    inputValue
  ]);
  let commit = () => {
    if (!inputValue.length) {
      setNumberValue(NaN);
      setInputValue(value2 === void 0 ? "" : format2(numberValue));
      return;
    }
    if (isNaN(parsedValue)) {
      setInputValue(format2(numberValue));
      return;
    }
    let clampedValue;
    if (step === void 0 || isNaN(step))
      clampedValue = (0, $9446cca9a3875146$export$7d15b64cf5a3a4c4)(parsedValue, minValue, maxValue);
    else
      clampedValue = (0, $9446cca9a3875146$export$cb6e0bb50bc19463)(parsedValue, minValue, maxValue, step);
    clampedValue = numberParser.parse(format2(clampedValue));
    setNumberValue(clampedValue);
    setInputValue(format2(value2 === void 0 ? clampedValue : numberValue));
  };
  let safeNextStep = (operation, minMax = 0) => {
    let prev2 = parsedValue;
    if (isNaN(prev2)) {
      let newValue = isNaN(minMax) ? 0 : minMax;
      return (0, $9446cca9a3875146$export$cb6e0bb50bc19463)(newValue, minValue, maxValue, clampStep);
    } else {
      let newValue = (0, $9446cca9a3875146$export$cb6e0bb50bc19463)(prev2, minValue, maxValue, clampStep);
      if (operation === "+" && newValue > prev2 || operation === "-" && newValue < prev2)
        return newValue;
      return (0, $9446cca9a3875146$export$cb6e0bb50bc19463)($de67e98908f0c6ee$var$handleDecimalOperation(operation, prev2, clampStep), minValue, maxValue, clampStep);
    }
  };
  let increment2 = () => {
    let newValue = safeNextStep("+", minValue);
    if (newValue === numberValue)
      setInputValue(format2(newValue));
    setNumberValue(newValue);
    validation.commitValidation();
  };
  let decrement = () => {
    let newValue = safeNextStep("-", maxValue);
    if (newValue === numberValue)
      setInputValue(format2(newValue));
    setNumberValue(newValue);
    validation.commitValidation();
  };
  let incrementToMax = () => {
    if (maxValue != null) {
      setNumberValue((0, $9446cca9a3875146$export$cb6e0bb50bc19463)(maxValue, minValue, maxValue, clampStep));
      validation.commitValidation();
    }
  };
  let decrementToMin = () => {
    if (minValue != null) {
      setNumberValue(minValue);
      validation.commitValidation();
    }
  };
  let canIncrement = (0, import_react66.useMemo)(() => !isDisabled && !isReadOnly && (isNaN(parsedValue) || maxValue === void 0 || isNaN(maxValue) || (0, $9446cca9a3875146$export$cb6e0bb50bc19463)(parsedValue, minValue, maxValue, clampStep) > parsedValue || $de67e98908f0c6ee$var$handleDecimalOperation("+", parsedValue, clampStep) <= maxValue), [
    isDisabled,
    isReadOnly,
    minValue,
    maxValue,
    clampStep,
    parsedValue
  ]);
  let canDecrement = (0, import_react66.useMemo)(() => !isDisabled && !isReadOnly && (isNaN(parsedValue) || minValue === void 0 || isNaN(minValue) || (0, $9446cca9a3875146$export$cb6e0bb50bc19463)(parsedValue, minValue, maxValue, clampStep) < parsedValue || $de67e98908f0c6ee$var$handleDecimalOperation("-", parsedValue, clampStep) >= minValue), [
    isDisabled,
    isReadOnly,
    minValue,
    maxValue,
    clampStep,
    parsedValue
  ]);
  let validate3 = (value3) => numberParser.isValidPartialNumber(value3, minValue, maxValue);
  return {
    ...validation,
    validate: validate3,
    increment: increment2,
    incrementToMax,
    decrement,
    decrementToMin,
    canIncrement,
    canDecrement,
    minValue,
    maxValue,
    numberValue: parsedValue,
    setNumberValue,
    setInputValue,
    inputValue,
    commit
  };
}
function $de67e98908f0c6ee$var$handleDecimalOperation(operator, value1, value2) {
  let result = operator === "+" ? value1 + value2 : value1 - value2;
  if (value1 % 1 !== 0 || value2 % 1 !== 0) {
    const value1Decimal = value1.toString().split(".");
    const value2Decimal = value2.toString().split(".");
    const value1DecimalLength = value1Decimal[1] && value1Decimal[1].length || 0;
    const value2DecimalLength = value2Decimal[1] && value2Decimal[1].length || 0;
    const multiplier = Math.pow(10, Math.max(value1DecimalLength, value2DecimalLength));
    value1 = Math.round(value1 * multiplier);
    value2 = Math.round(value2 * multiplier);
    result = operator === "+" ? value1 + value2 : value1 - value2;
    result /= multiplier;
  }
  return result;
}

// node_modules/@keystar/ui/dist/keystar-ui-number-field.js
var import_react67 = __toESM(require_react());

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-chevronUpIcon.js
var import_jsx_runtime61 = __toESM(require_jsx_runtime());
var chevronUpIcon = (0, import_jsx_runtime61.jsx)("path", {
  d: "m18 15-6-6-6 6"
});

// node_modules/@keystar/ui/dist/keystar-ui-number-field.js
var import_jsx_runtime62 = __toESM(require_jsx_runtime());
var StepButton = (0, import_react67.forwardRef)(function StepButton2(props, forwardedRef) {
  props = useProviderProps(props);
  let {
    scale
  } = useProvider();
  let {
    direction
  } = props;
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let {
    buttonProps,
    isPressed
  } = $701a24aa0da5b062$export$ea18c227d4417cc3({
    ...props,
    elementType: "div"
  }, domRef);
  let {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456(props);
  let incrementIcon = scale === "large" ? plusIcon : chevronUpIcon;
  let decrementIcon = scale === "large" ? minusIcon : chevronDownIcon;
  return (0, import_jsx_runtime62.jsxs)("div", {
    ...toDataAttributes({
      direction,
      hovered: isHovered || void 0,
      pressed: isPressed || void 0,
      scale
    }),
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(hoverProps, buttonProps),
    ref: domRef,
    className: classNames(css({
      alignItems: "center",
      color: tokenSchema.color.alias.foregroundIdle,
      cursor: "default",
      display: "flex",
      justifyContent: "center",
      transition: transition("border-color"),
      svg: {
        position: "absolute"
        // stop SVG from taking space; affecting layout.
      },
      // states
      "&[data-hovered]": {
        backgroundColor: tokenSchema.color.alias.backgroundHovered,
        color: tokenSchema.color.alias.foregroundHovered
      },
      "&[data-pressed]": {
        backgroundColor: tokenSchema.color.alias.backgroundPressed
      },
      "&[aria-disabled=true]": {
        backgroundColor: tokenSchema.color.background.surfaceSecondary,
        color: tokenSchema.color.alias.foregroundDisabled
      },
      "&[data-direction=up]": {
        gridArea: "increment"
      },
      "&[data-direction=down]": {
        gridArea: "decrement"
      },
      // fine pointers
      "&:not([data-scale=large])": {
        "&[data-direction=up]": {
          borderStartStartRadius: tokenSchema.size.radius.small,
          borderStartEndRadius: tokenSchema.size.radius.small
        },
        "&[data-direction=down]": {
          borderEndStartRadius: tokenSchema.size.radius.small,
          borderEndEndRadius: tokenSchema.size.radius.small
        },
        svg: {
          width: tokenSchema.size.icon.small
        }
      },
      // coarse pointers
      "&[data-scale=large]": {
        "&[data-direction=up]": {
          borderStartEndRadius: tokenSchema.size.radius.regular,
          borderEndEndRadius: tokenSchema.size.radius.regular
        },
        "&[data-direction=down]": {
          borderEndStartRadius: tokenSchema.size.radius.regular,
          borderStartStartRadius: tokenSchema.size.radius.regular
        },
        "input:enabled ~ &": {
          border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.alias.borderIdle}`
        },
        "input:focus ~ &": {
          borderColor: tokenSchema.color.alias.borderFocused
        }
      }
    })),
    children: [direction === "up" && (0, import_jsx_runtime62.jsx)(Icon, {
      src: incrementIcon
    }), direction === "down" && (0, import_jsx_runtime62.jsx)(Icon, {
      src: decrementIcon
    })]
  });
});
var NumberField = (0, import_react67.forwardRef)(function NumberField2(props, forwardedRef) {
  props = useProviderProps(props);
  let {
    isReadOnly,
    isDisabled,
    hideStepper,
    label,
    description
  } = props;
  let {
    locale
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let state = $de67e98908f0c6ee$export$7f629e9dc1ecf37c({
    ...props,
    locale
  });
  let inputRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let {
    groupProps,
    labelProps,
    inputProps,
    incrementButtonProps,
    decrementButtonProps,
    descriptionProps,
    errorMessageProps
  } = $81397a9303501bda$export$23f548e970bdf099(props, state, inputRef);
  let inputWrapperStyleProps = useInputWrapperStyleProps();
  return (0, import_jsx_runtime62.jsx)(TextFieldPrimitive, {
    width: "alias.singleLineWidth",
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(props),
    ...onlyStyleProps(props),
    label,
    description,
    errorMessage: props.errorMessage,
    descriptionProps,
    errorMessageProps,
    labelProps,
    inputWrapperProps: {
      ...groupProps,
      ...inputWrapperStyleProps
    },
    ref: inputRef,
    inputProps,
    isDisabled,
    isReadOnly,
    endElement: !hideStepper && (0, import_jsx_runtime62.jsxs)(import_jsx_runtime62.Fragment, {
      children: [(0, import_jsx_runtime62.jsx)(StepButton, {
        direction: "up",
        ...incrementButtonProps
      }), (0, import_jsx_runtime62.jsx)(StepButton, {
        direction: "down",
        ...decrementButtonProps
      })]
    })
  });
});
function useInputWrapperStyleProps() {
  let {
    scale
  } = useProvider();
  let className = css({
    display: "grid",
    gap: tokenSchema.size.border.regular,
    gridTemplateColumns: `1fr calc(${tokenSchema.size.element.regular} - ${tokenSchema.size.border.regular} * 2) ${tokenSchema.size.border.regular}`,
    gridTemplateRows: `${tokenSchema.size.border.regular} auto auto ${tokenSchema.size.border.regular}`,
    gridTemplateAreas: '"field . ." "field increment ." "field decrement ." "field . ."',
    '&[data-scale="large"]': {
      gridTemplateColumns: `${tokenSchema.size.element.regular} 1fr ${tokenSchema.size.element.regular}`,
      gridTemplateRows: "auto",
      gridTemplateAreas: '"decrement field increment"'
    },
    input: {
      gridArea: "field"
    }
  });
  return {
    ...toDataAttributes({
      scale
    }),
    className
  };
}

// node_modules/decimal.js/decimal.mjs
var EXP_LIMIT = 9e15;
var MAX_DIGITS = 1e9;
var NUMERALS = "0123456789abcdef";
var LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
var PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
var DEFAULTS = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -EXP_LIMIT,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: EXP_LIMIT,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: false
  // true/false
};
var inexact;
var quadrant;
var external = true;
var decimalError = "[DecimalError] ";
var invalidArgument = decimalError + "Invalid argument: ";
var precisionLimitExceeded = decimalError + "Precision limit exceeded";
var cryptoUnavailable = decimalError + "crypto unavailable";
var tag = "[object Decimal]";
var mathfloor = Math.floor;
var mathpow = Math.pow;
var isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
var isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
var isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
var isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
var BASE = 1e7;
var LOG_BASE = 7;
var MAX_SAFE_INTEGER2 = 9007199254740991;
var LN10_PRECISION = LN10.length - 1;
var PI_PRECISION = PI.length - 1;
var P2 = { toStringTag: tag };
P2.absoluteValue = P2.abs = function() {
  var x4 = new this.constructor(this);
  if (x4.s < 0)
    x4.s = 1;
  return finalise(x4);
};
P2.ceil = function() {
  return finalise(new this.constructor(this), this.e + 1, 2);
};
P2.clampedTo = P2.clamp = function(min3, max4) {
  var k2, x4 = this, Ctor = x4.constructor;
  min3 = new Ctor(min3);
  max4 = new Ctor(max4);
  if (!min3.s || !max4.s)
    return new Ctor(NaN);
  if (min3.gt(max4))
    throw Error(invalidArgument + max4);
  k2 = x4.cmp(min3);
  return k2 < 0 ? min3 : x4.cmp(max4) > 0 ? max4 : new Ctor(x4);
};
P2.comparedTo = P2.cmp = function(y4) {
  var i6, j4, xdL, ydL, x4 = this, xd = x4.d, yd = (y4 = new x4.constructor(y4)).d, xs = x4.s, ys = y4.s;
  if (!xd || !yd) {
    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
  }
  if (!xd[0] || !yd[0])
    return xd[0] ? xs : yd[0] ? -ys : 0;
  if (xs !== ys)
    return xs;
  if (x4.e !== y4.e)
    return x4.e > y4.e ^ xs < 0 ? 1 : -1;
  xdL = xd.length;
  ydL = yd.length;
  for (i6 = 0, j4 = xdL < ydL ? xdL : ydL; i6 < j4; ++i6) {
    if (xd[i6] !== yd[i6])
      return xd[i6] > yd[i6] ^ xs < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
};
P2.cosine = P2.cos = function() {
  var pr, rm, x4 = this, Ctor = x4.constructor;
  if (!x4.d)
    return new Ctor(NaN);
  if (!x4.d[0])
    return new Ctor(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x4.e, x4.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x4 = cosine(Ctor, toLessThanHalfPi(Ctor, x4));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 3 ? x4.neg() : x4, pr, rm, true);
};
P2.cubeRoot = P2.cbrt = function() {
  var e6, m3, n6, r7, rep, s4, sd, t5, t32, t3plusx, x4 = this, Ctor = x4.constructor;
  if (!x4.isFinite() || x4.isZero())
    return new Ctor(x4);
  external = false;
  s4 = x4.s * mathpow(x4.s * x4, 1 / 3);
  if (!s4 || Math.abs(s4) == 1 / 0) {
    n6 = digitsToString(x4.d);
    e6 = x4.e;
    if (s4 = (e6 - n6.length + 1) % 3)
      n6 += s4 == 1 || s4 == -2 ? "0" : "00";
    s4 = mathpow(n6, 1 / 3);
    e6 = mathfloor((e6 + 1) / 3) - (e6 % 3 == (e6 < 0 ? -1 : 2));
    if (s4 == 1 / 0) {
      n6 = "5e" + e6;
    } else {
      n6 = s4.toExponential();
      n6 = n6.slice(0, n6.indexOf("e") + 1) + e6;
    }
    r7 = new Ctor(n6);
    r7.s = x4.s;
  } else {
    r7 = new Ctor(s4.toString());
  }
  sd = (e6 = Ctor.precision) + 3;
  for (; ; ) {
    t5 = r7;
    t32 = t5.times(t5).times(t5);
    t3plusx = t32.plus(x4);
    r7 = divide(t3plusx.plus(x4).times(t5), t3plusx.plus(t32), sd + 2, 1);
    if (digitsToString(t5.d).slice(0, sd) === (n6 = digitsToString(r7.d)).slice(0, sd)) {
      n6 = n6.slice(sd - 3, sd + 1);
      if (n6 == "9999" || !rep && n6 == "4999") {
        if (!rep) {
          finalise(t5, e6 + 1, 0);
          if (t5.times(t5).times(t5).eq(x4)) {
            r7 = t5;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n6 || !+n6.slice(1) && n6.charAt(0) == "5") {
          finalise(r7, e6 + 1, 1);
          m3 = !r7.times(r7).times(r7).eq(x4);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r7, e6, Ctor.rounding, m3);
};
P2.decimalPlaces = P2.dp = function() {
  var w2, d5 = this.d, n6 = NaN;
  if (d5) {
    w2 = d5.length - 1;
    n6 = (w2 - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
    w2 = d5[w2];
    if (w2)
      for (; w2 % 10 == 0; w2 /= 10)
        n6--;
    if (n6 < 0)
      n6 = 0;
  }
  return n6;
};
P2.dividedBy = P2.div = function(y4) {
  return divide(this, new this.constructor(y4));
};
P2.dividedToIntegerBy = P2.divToInt = function(y4) {
  var x4 = this, Ctor = x4.constructor;
  return finalise(divide(x4, new Ctor(y4), 0, 1, 1), Ctor.precision, Ctor.rounding);
};
P2.equals = P2.eq = function(y4) {
  return this.cmp(y4) === 0;
};
P2.floor = function() {
  return finalise(new this.constructor(this), this.e + 1, 3);
};
P2.greaterThan = P2.gt = function(y4) {
  return this.cmp(y4) > 0;
};
P2.greaterThanOrEqualTo = P2.gte = function(y4) {
  var k2 = this.cmp(y4);
  return k2 == 1 || k2 === 0;
};
P2.hyperbolicCosine = P2.cosh = function() {
  var k2, n6, pr, rm, len, x4 = this, Ctor = x4.constructor, one2 = new Ctor(1);
  if (!x4.isFinite())
    return new Ctor(x4.s ? 1 / 0 : NaN);
  if (x4.isZero())
    return one2;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x4.e, x4.sd()) + 4;
  Ctor.rounding = 1;
  len = x4.d.length;
  if (len < 32) {
    k2 = Math.ceil(len / 3);
    n6 = (1 / tinyPow(4, k2)).toString();
  } else {
    k2 = 16;
    n6 = "2.3283064365386962890625e-10";
  }
  x4 = taylorSeries(Ctor, 1, x4.times(n6), new Ctor(1), true);
  var cosh2_x, i6 = k2, d8 = new Ctor(8);
  for (; i6--; ) {
    cosh2_x = x4.times(x4);
    x4 = one2.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
  }
  return finalise(x4, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P2.hyperbolicSine = P2.sinh = function() {
  var k2, pr, rm, len, x4 = this, Ctor = x4.constructor;
  if (!x4.isFinite() || x4.isZero())
    return new Ctor(x4);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x4.e, x4.sd()) + 4;
  Ctor.rounding = 1;
  len = x4.d.length;
  if (len < 3) {
    x4 = taylorSeries(Ctor, 2, x4, x4, true);
  } else {
    k2 = 1.4 * Math.sqrt(len);
    k2 = k2 > 16 ? 16 : k2 | 0;
    x4 = x4.times(1 / tinyPow(5, k2));
    x4 = taylorSeries(Ctor, 2, x4, x4, true);
    var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
    for (; k2--; ) {
      sinh2_x = x4.times(x4);
      x4 = x4.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
    }
  }
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(x4, pr, rm, true);
};
P2.hyperbolicTangent = P2.tanh = function() {
  var pr, rm, x4 = this, Ctor = x4.constructor;
  if (!x4.isFinite())
    return new Ctor(x4.s);
  if (x4.isZero())
    return new Ctor(x4);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;
  return divide(x4.sinh(), x4.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
};
P2.inverseCosine = P2.acos = function() {
  var halfPi, x4 = this, Ctor = x4.constructor, k2 = x4.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
  if (k2 !== -1) {
    return k2 === 0 ? x4.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
  }
  if (x4.isZero())
    return getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x4 = x4.asin();
  halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return halfPi.minus(x4);
};
P2.inverseHyperbolicCosine = P2.acosh = function() {
  var pr, rm, x4 = this, Ctor = x4.constructor;
  if (x4.lte(1))
    return new Ctor(x4.eq(1) ? 0 : NaN);
  if (!x4.isFinite())
    return new Ctor(x4);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(Math.abs(x4.e), x4.sd()) + 4;
  Ctor.rounding = 1;
  external = false;
  x4 = x4.times(x4).minus(1).sqrt().plus(x4);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x4.ln();
};
P2.inverseHyperbolicSine = P2.asinh = function() {
  var pr, rm, x4 = this, Ctor = x4.constructor;
  if (!x4.isFinite() || x4.isZero())
    return new Ctor(x4);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 2 * Math.max(Math.abs(x4.e), x4.sd()) + 6;
  Ctor.rounding = 1;
  external = false;
  x4 = x4.times(x4).plus(1).sqrt().plus(x4);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x4.ln();
};
P2.inverseHyperbolicTangent = P2.atanh = function() {
  var pr, rm, wpr, xsd, x4 = this, Ctor = x4.constructor;
  if (!x4.isFinite())
    return new Ctor(NaN);
  if (x4.e >= 0)
    return new Ctor(x4.abs().eq(1) ? x4.s / 0 : x4.isZero() ? x4 : NaN);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  xsd = x4.sd();
  if (Math.max(xsd, pr) < 2 * -x4.e - 1)
    return finalise(new Ctor(x4), pr, rm, true);
  Ctor.precision = wpr = xsd - x4.e;
  x4 = divide(x4.plus(1), new Ctor(1).minus(x4), wpr + pr, 1);
  Ctor.precision = pr + 4;
  Ctor.rounding = 1;
  x4 = x4.ln();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x4.times(0.5);
};
P2.inverseSine = P2.asin = function() {
  var halfPi, k2, pr, rm, x4 = this, Ctor = x4.constructor;
  if (x4.isZero())
    return new Ctor(x4);
  k2 = x4.abs().cmp(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (k2 !== -1) {
    if (k2 === 0) {
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
      halfPi.s = x4.s;
      return halfPi;
    }
    return new Ctor(NaN);
  }
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x4 = x4.div(new Ctor(1).minus(x4.times(x4)).sqrt().plus(1)).atan();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x4.times(2);
};
P2.inverseTangent = P2.atan = function() {
  var i6, j4, k2, n6, px2, t5, r7, wpr, x22, x4 = this, Ctor = x4.constructor, pr = Ctor.precision, rm = Ctor.rounding;
  if (!x4.isFinite()) {
    if (!x4.s)
      return new Ctor(NaN);
    if (pr + 4 <= PI_PRECISION) {
      r7 = getPi(Ctor, pr + 4, rm).times(0.5);
      r7.s = x4.s;
      return r7;
    }
  } else if (x4.isZero()) {
    return new Ctor(x4);
  } else if (x4.abs().eq(1) && pr + 4 <= PI_PRECISION) {
    r7 = getPi(Ctor, pr + 4, rm).times(0.25);
    r7.s = x4.s;
    return r7;
  }
  Ctor.precision = wpr = pr + 10;
  Ctor.rounding = 1;
  k2 = Math.min(28, wpr / LOG_BASE + 2 | 0);
  for (i6 = k2; i6; --i6)
    x4 = x4.div(x4.times(x4).plus(1).sqrt().plus(1));
  external = false;
  j4 = Math.ceil(wpr / LOG_BASE);
  n6 = 1;
  x22 = x4.times(x4);
  r7 = new Ctor(x4);
  px2 = x4;
  for (; i6 !== -1; ) {
    px2 = px2.times(x22);
    t5 = r7.minus(px2.div(n6 += 2));
    px2 = px2.times(x22);
    r7 = t5.plus(px2.div(n6 += 2));
    if (r7.d[j4] !== void 0)
      for (i6 = j4; r7.d[i6] === t5.d[i6] && i6--; )
        ;
  }
  if (k2)
    r7 = r7.times(2 << k2 - 1);
  external = true;
  return finalise(r7, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P2.isFinite = function() {
  return !!this.d;
};
P2.isInteger = P2.isInt = function() {
  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
};
P2.isNaN = function() {
  return !this.s;
};
P2.isNegative = P2.isNeg = function() {
  return this.s < 0;
};
P2.isPositive = P2.isPos = function() {
  return this.s > 0;
};
P2.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
P2.lessThan = P2.lt = function(y4) {
  return this.cmp(y4) < 0;
};
P2.lessThanOrEqualTo = P2.lte = function(y4) {
  return this.cmp(y4) < 1;
};
P2.logarithm = P2.log = function(base) {
  var isBase10, d5, denominator, k2, inf, num, sd, r7, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
  if (base == null) {
    base = new Ctor(10);
    isBase10 = true;
  } else {
    base = new Ctor(base);
    d5 = base.d;
    if (base.s < 0 || !d5 || !d5[0] || base.eq(1))
      return new Ctor(NaN);
    isBase10 = base.eq(10);
  }
  d5 = arg.d;
  if (arg.s < 0 || !d5 || !d5[0] || arg.eq(1)) {
    return new Ctor(d5 && !d5[0] ? -1 / 0 : arg.s != 1 ? NaN : d5 ? 0 : 1 / 0);
  }
  if (isBase10) {
    if (d5.length > 1) {
      inf = true;
    } else {
      for (k2 = d5[0]; k2 % 10 === 0; )
        k2 /= 10;
      inf = k2 !== 1;
    }
  }
  external = false;
  sd = pr + guard;
  num = naturalLogarithm(arg, sd);
  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
  r7 = divide(num, denominator, sd, 1);
  if (checkRoundingDigits(r7.d, k2 = pr, rm)) {
    do {
      sd += 10;
      num = naturalLogarithm(arg, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
      r7 = divide(num, denominator, sd, 1);
      if (!inf) {
        if (+digitsToString(r7.d).slice(k2 + 1, k2 + 15) + 1 == 1e14) {
          r7 = finalise(r7, pr + 1, 0);
        }
        break;
      }
    } while (checkRoundingDigits(r7.d, k2 += 10, rm));
  }
  external = true;
  return finalise(r7, pr, rm);
};
P2.minus = P2.sub = function(y4) {
  var d5, e6, i6, j4, k2, len, pr, rm, xd, xe, xLTy, yd, x4 = this, Ctor = x4.constructor;
  y4 = new Ctor(y4);
  if (!x4.d || !y4.d) {
    if (!x4.s || !y4.s)
      y4 = new Ctor(NaN);
    else if (x4.d)
      y4.s = -y4.s;
    else
      y4 = new Ctor(y4.d || x4.s !== y4.s ? x4 : NaN);
    return y4;
  }
  if (x4.s != y4.s) {
    y4.s = -y4.s;
    return x4.plus(y4);
  }
  xd = x4.d;
  yd = y4.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (yd[0])
      y4.s = -y4.s;
    else if (xd[0])
      y4 = new Ctor(x4);
    else
      return new Ctor(rm === 3 ? -0 : 0);
    return external ? finalise(y4, pr, rm) : y4;
  }
  e6 = mathfloor(y4.e / LOG_BASE);
  xe = mathfloor(x4.e / LOG_BASE);
  xd = xd.slice();
  k2 = xe - e6;
  if (k2) {
    xLTy = k2 < 0;
    if (xLTy) {
      d5 = xd;
      k2 = -k2;
      len = yd.length;
    } else {
      d5 = yd;
      e6 = xe;
      len = xd.length;
    }
    i6 = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
    if (k2 > i6) {
      k2 = i6;
      d5.length = 1;
    }
    d5.reverse();
    for (i6 = k2; i6--; )
      d5.push(0);
    d5.reverse();
  } else {
    i6 = xd.length;
    len = yd.length;
    xLTy = i6 < len;
    if (xLTy)
      len = i6;
    for (i6 = 0; i6 < len; i6++) {
      if (xd[i6] != yd[i6]) {
        xLTy = xd[i6] < yd[i6];
        break;
      }
    }
    k2 = 0;
  }
  if (xLTy) {
    d5 = xd;
    xd = yd;
    yd = d5;
    y4.s = -y4.s;
  }
  len = xd.length;
  for (i6 = yd.length - len; i6 > 0; --i6)
    xd[len++] = 0;
  for (i6 = yd.length; i6 > k2; ) {
    if (xd[--i6] < yd[i6]) {
      for (j4 = i6; j4 && xd[--j4] === 0; )
        xd[j4] = BASE - 1;
      --xd[j4];
      xd[i6] += BASE;
    }
    xd[i6] -= yd[i6];
  }
  for (; xd[--len] === 0; )
    xd.pop();
  for (; xd[0] === 0; xd.shift())
    --e6;
  if (!xd[0])
    return new Ctor(rm === 3 ? -0 : 0);
  y4.d = xd;
  y4.e = getBase10Exponent(xd, e6);
  return external ? finalise(y4, pr, rm) : y4;
};
P2.modulo = P2.mod = function(y4) {
  var q2, x4 = this, Ctor = x4.constructor;
  y4 = new Ctor(y4);
  if (!x4.d || !y4.s || y4.d && !y4.d[0])
    return new Ctor(NaN);
  if (!y4.d || x4.d && !x4.d[0]) {
    return finalise(new Ctor(x4), Ctor.precision, Ctor.rounding);
  }
  external = false;
  if (Ctor.modulo == 9) {
    q2 = divide(x4, y4.abs(), 0, 3, 1);
    q2.s *= y4.s;
  } else {
    q2 = divide(x4, y4, 0, Ctor.modulo, 1);
  }
  q2 = q2.times(y4);
  external = true;
  return x4.minus(q2);
};
P2.naturalExponential = P2.exp = function() {
  return naturalExponential(this);
};
P2.naturalLogarithm = P2.ln = function() {
  return naturalLogarithm(this);
};
P2.negated = P2.neg = function() {
  var x4 = new this.constructor(this);
  x4.s = -x4.s;
  return finalise(x4);
};
P2.plus = P2.add = function(y4) {
  var carry, d5, e6, i6, k2, len, pr, rm, xd, yd, x4 = this, Ctor = x4.constructor;
  y4 = new Ctor(y4);
  if (!x4.d || !y4.d) {
    if (!x4.s || !y4.s)
      y4 = new Ctor(NaN);
    else if (!x4.d)
      y4 = new Ctor(y4.d || x4.s === y4.s ? x4 : NaN);
    return y4;
  }
  if (x4.s != y4.s) {
    y4.s = -y4.s;
    return x4.minus(y4);
  }
  xd = x4.d;
  yd = y4.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (!yd[0])
      y4 = new Ctor(x4);
    return external ? finalise(y4, pr, rm) : y4;
  }
  k2 = mathfloor(x4.e / LOG_BASE);
  e6 = mathfloor(y4.e / LOG_BASE);
  xd = xd.slice();
  i6 = k2 - e6;
  if (i6) {
    if (i6 < 0) {
      d5 = xd;
      i6 = -i6;
      len = yd.length;
    } else {
      d5 = yd;
      e6 = k2;
      len = xd.length;
    }
    k2 = Math.ceil(pr / LOG_BASE);
    len = k2 > len ? k2 + 1 : len + 1;
    if (i6 > len) {
      i6 = len;
      d5.length = 1;
    }
    d5.reverse();
    for (; i6--; )
      d5.push(0);
    d5.reverse();
  }
  len = xd.length;
  i6 = yd.length;
  if (len - i6 < 0) {
    i6 = len;
    d5 = yd;
    yd = xd;
    xd = d5;
  }
  for (carry = 0; i6; ) {
    carry = (xd[--i6] = xd[i6] + yd[i6] + carry) / BASE | 0;
    xd[i6] %= BASE;
  }
  if (carry) {
    xd.unshift(carry);
    ++e6;
  }
  for (len = xd.length; xd[--len] == 0; )
    xd.pop();
  y4.d = xd;
  y4.e = getBase10Exponent(xd, e6);
  return external ? finalise(y4, pr, rm) : y4;
};
P2.precision = P2.sd = function(z3) {
  var k2, x4 = this;
  if (z3 !== void 0 && z3 !== !!z3 && z3 !== 1 && z3 !== 0)
    throw Error(invalidArgument + z3);
  if (x4.d) {
    k2 = getPrecision(x4.d);
    if (z3 && x4.e + 1 > k2)
      k2 = x4.e + 1;
  } else {
    k2 = NaN;
  }
  return k2;
};
P2.round = function() {
  var x4 = this, Ctor = x4.constructor;
  return finalise(new Ctor(x4), x4.e + 1, Ctor.rounding);
};
P2.sine = P2.sin = function() {
  var pr, rm, x4 = this, Ctor = x4.constructor;
  if (!x4.isFinite())
    return new Ctor(NaN);
  if (x4.isZero())
    return new Ctor(x4);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x4.e, x4.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x4 = sine(Ctor, toLessThanHalfPi(Ctor, x4));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant > 2 ? x4.neg() : x4, pr, rm, true);
};
P2.squareRoot = P2.sqrt = function() {
  var m3, n6, sd, r7, rep, t5, x4 = this, d5 = x4.d, e6 = x4.e, s4 = x4.s, Ctor = x4.constructor;
  if (s4 !== 1 || !d5 || !d5[0]) {
    return new Ctor(!s4 || s4 < 0 && (!d5 || d5[0]) ? NaN : d5 ? x4 : 1 / 0);
  }
  external = false;
  s4 = Math.sqrt(+x4);
  if (s4 == 0 || s4 == 1 / 0) {
    n6 = digitsToString(d5);
    if ((n6.length + e6) % 2 == 0)
      n6 += "0";
    s4 = Math.sqrt(n6);
    e6 = mathfloor((e6 + 1) / 2) - (e6 < 0 || e6 % 2);
    if (s4 == 1 / 0) {
      n6 = "5e" + e6;
    } else {
      n6 = s4.toExponential();
      n6 = n6.slice(0, n6.indexOf("e") + 1) + e6;
    }
    r7 = new Ctor(n6);
  } else {
    r7 = new Ctor(s4.toString());
  }
  sd = (e6 = Ctor.precision) + 3;
  for (; ; ) {
    t5 = r7;
    r7 = t5.plus(divide(x4, t5, sd + 2, 1)).times(0.5);
    if (digitsToString(t5.d).slice(0, sd) === (n6 = digitsToString(r7.d)).slice(0, sd)) {
      n6 = n6.slice(sd - 3, sd + 1);
      if (n6 == "9999" || !rep && n6 == "4999") {
        if (!rep) {
          finalise(t5, e6 + 1, 0);
          if (t5.times(t5).eq(x4)) {
            r7 = t5;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n6 || !+n6.slice(1) && n6.charAt(0) == "5") {
          finalise(r7, e6 + 1, 1);
          m3 = !r7.times(r7).eq(x4);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r7, e6, Ctor.rounding, m3);
};
P2.tangent = P2.tan = function() {
  var pr, rm, x4 = this, Ctor = x4.constructor;
  if (!x4.isFinite())
    return new Ctor(NaN);
  if (x4.isZero())
    return new Ctor(x4);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 10;
  Ctor.rounding = 1;
  x4 = x4.sin();
  x4.s = 1;
  x4 = divide(x4, new Ctor(1).minus(x4.times(x4)).sqrt(), pr + 10, 0);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 4 ? x4.neg() : x4, pr, rm, true);
};
P2.times = P2.mul = function(y4) {
  var carry, e6, i6, k2, r7, rL, t5, xdL, ydL, x4 = this, Ctor = x4.constructor, xd = x4.d, yd = (y4 = new Ctor(y4)).d;
  y4.s *= x4.s;
  if (!xd || !xd[0] || !yd || !yd[0]) {
    return new Ctor(!y4.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y4.s / 0 : y4.s * 0);
  }
  e6 = mathfloor(x4.e / LOG_BASE) + mathfloor(y4.e / LOG_BASE);
  xdL = xd.length;
  ydL = yd.length;
  if (xdL < ydL) {
    r7 = xd;
    xd = yd;
    yd = r7;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r7 = [];
  rL = xdL + ydL;
  for (i6 = rL; i6--; )
    r7.push(0);
  for (i6 = ydL; --i6 >= 0; ) {
    carry = 0;
    for (k2 = xdL + i6; k2 > i6; ) {
      t5 = r7[k2] + yd[i6] * xd[k2 - i6 - 1] + carry;
      r7[k2--] = t5 % BASE | 0;
      carry = t5 / BASE | 0;
    }
    r7[k2] = (r7[k2] + carry) % BASE | 0;
  }
  for (; !r7[--rL]; )
    r7.pop();
  if (carry)
    ++e6;
  else
    r7.shift();
  y4.d = r7;
  y4.e = getBase10Exponent(r7, e6);
  return external ? finalise(y4, Ctor.precision, Ctor.rounding) : y4;
};
P2.toBinary = function(sd, rm) {
  return toStringBinary(this, 2, sd, rm);
};
P2.toDecimalPlaces = P2.toDP = function(dp, rm) {
  var x4 = this, Ctor = x4.constructor;
  x4 = new Ctor(x4);
  if (dp === void 0)
    return x4;
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0)
    rm = Ctor.rounding;
  else
    checkInt32(rm, 0, 8);
  return finalise(x4, dp + x4.e + 1, rm);
};
P2.toExponential = function(dp, rm) {
  var str, x4 = this, Ctor = x4.constructor;
  if (dp === void 0) {
    str = finiteToString(x4, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x4 = finalise(new Ctor(x4), dp + 1, rm);
    str = finiteToString(x4, true, dp + 1);
  }
  return x4.isNeg() && !x4.isZero() ? "-" + str : str;
};
P2.toFixed = function(dp, rm) {
  var str, y4, x4 = this, Ctor = x4.constructor;
  if (dp === void 0) {
    str = finiteToString(x4);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    y4 = finalise(new Ctor(x4), dp + x4.e + 1, rm);
    str = finiteToString(y4, false, dp + y4.e + 1);
  }
  return x4.isNeg() && !x4.isZero() ? "-" + str : str;
};
P2.toFraction = function(maxD) {
  var d5, d0, d1, d22, e6, k2, n6, n0, n1, pr, q2, r7, x4 = this, xd = x4.d, Ctor = x4.constructor;
  if (!xd)
    return new Ctor(x4);
  n1 = d0 = new Ctor(1);
  d1 = n0 = new Ctor(0);
  d5 = new Ctor(d1);
  e6 = d5.e = getPrecision(xd) - x4.e - 1;
  k2 = e6 % LOG_BASE;
  d5.d[0] = mathpow(10, k2 < 0 ? LOG_BASE + k2 : k2);
  if (maxD == null) {
    maxD = e6 > 0 ? d5 : n1;
  } else {
    n6 = new Ctor(maxD);
    if (!n6.isInt() || n6.lt(n1))
      throw Error(invalidArgument + n6);
    maxD = n6.gt(d5) ? e6 > 0 ? d5 : n1 : n6;
  }
  external = false;
  n6 = new Ctor(digitsToString(xd));
  pr = Ctor.precision;
  Ctor.precision = e6 = xd.length * LOG_BASE * 2;
  for (; ; ) {
    q2 = divide(n6, d5, 0, 1, 1);
    d22 = d0.plus(q2.times(d1));
    if (d22.cmp(maxD) == 1)
      break;
    d0 = d1;
    d1 = d22;
    d22 = n1;
    n1 = n0.plus(q2.times(d22));
    n0 = d22;
    d22 = d5;
    d5 = n6.minus(q2.times(d22));
    n6 = d22;
  }
  d22 = divide(maxD.minus(d0), d1, 0, 1, 1);
  n0 = n0.plus(d22.times(n1));
  d0 = d0.plus(d22.times(d1));
  n0.s = n1.s = x4.s;
  r7 = divide(n1, d1, e6, 1).minus(x4).abs().cmp(divide(n0, d0, e6, 1).minus(x4).abs()) < 1 ? [n1, d1] : [n0, d0];
  Ctor.precision = pr;
  external = true;
  return r7;
};
P2.toHexadecimal = P2.toHex = function(sd, rm) {
  return toStringBinary(this, 16, sd, rm);
};
P2.toNearest = function(y4, rm) {
  var x4 = this, Ctor = x4.constructor;
  x4 = new Ctor(x4);
  if (y4 == null) {
    if (!x4.d)
      return x4;
    y4 = new Ctor(1);
    rm = Ctor.rounding;
  } else {
    y4 = new Ctor(y4);
    if (rm === void 0) {
      rm = Ctor.rounding;
    } else {
      checkInt32(rm, 0, 8);
    }
    if (!x4.d)
      return y4.s ? x4 : y4;
    if (!y4.d) {
      if (y4.s)
        y4.s = x4.s;
      return y4;
    }
  }
  if (y4.d[0]) {
    external = false;
    x4 = divide(x4, y4, 0, rm, 1).times(y4);
    external = true;
    finalise(x4);
  } else {
    y4.s = x4.s;
    x4 = y4;
  }
  return x4;
};
P2.toNumber = function() {
  return +this;
};
P2.toOctal = function(sd, rm) {
  return toStringBinary(this, 8, sd, rm);
};
P2.toPower = P2.pow = function(y4) {
  var e6, k2, pr, r7, rm, s4, x4 = this, Ctor = x4.constructor, yn = +(y4 = new Ctor(y4));
  if (!x4.d || !y4.d || !x4.d[0] || !y4.d[0])
    return new Ctor(mathpow(+x4, yn));
  x4 = new Ctor(x4);
  if (x4.eq(1))
    return x4;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (y4.eq(1))
    return finalise(x4, pr, rm);
  e6 = mathfloor(y4.e / LOG_BASE);
  if (e6 >= y4.d.length - 1 && (k2 = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER2) {
    r7 = intPow(Ctor, x4, k2, pr);
    return y4.s < 0 ? new Ctor(1).div(r7) : finalise(r7, pr, rm);
  }
  s4 = x4.s;
  if (s4 < 0) {
    if (e6 < y4.d.length - 1)
      return new Ctor(NaN);
    if ((y4.d[e6] & 1) == 0)
      s4 = 1;
    if (x4.e == 0 && x4.d[0] == 1 && x4.d.length == 1) {
      x4.s = s4;
      return x4;
    }
  }
  k2 = mathpow(+x4, yn);
  e6 = k2 == 0 || !isFinite(k2) ? mathfloor(yn * (Math.log("0." + digitsToString(x4.d)) / Math.LN10 + x4.e + 1)) : new Ctor(k2 + "").e;
  if (e6 > Ctor.maxE + 1 || e6 < Ctor.minE - 1)
    return new Ctor(e6 > 0 ? s4 / 0 : 0);
  external = false;
  Ctor.rounding = x4.s = 1;
  k2 = Math.min(12, (e6 + "").length);
  r7 = naturalExponential(y4.times(naturalLogarithm(x4, pr + k2)), pr);
  if (r7.d) {
    r7 = finalise(r7, pr + 5, 1);
    if (checkRoundingDigits(r7.d, pr, rm)) {
      e6 = pr + 10;
      r7 = finalise(naturalExponential(y4.times(naturalLogarithm(x4, e6 + k2)), e6), e6 + 5, 1);
      if (+digitsToString(r7.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
        r7 = finalise(r7, pr + 1, 0);
      }
    }
  }
  r7.s = s4;
  external = true;
  Ctor.rounding = rm;
  return finalise(r7, pr, rm);
};
P2.toPrecision = function(sd, rm) {
  var str, x4 = this, Ctor = x4.constructor;
  if (sd === void 0) {
    str = finiteToString(x4, x4.e <= Ctor.toExpNeg || x4.e >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x4 = finalise(new Ctor(x4), sd, rm);
    str = finiteToString(x4, sd <= x4.e || x4.e <= Ctor.toExpNeg, sd);
  }
  return x4.isNeg() && !x4.isZero() ? "-" + str : str;
};
P2.toSignificantDigits = P2.toSD = function(sd, rm) {
  var x4 = this, Ctor = x4.constructor;
  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  }
  return finalise(new Ctor(x4), sd, rm);
};
P2.toString = function() {
  var x4 = this, Ctor = x4.constructor, str = finiteToString(x4, x4.e <= Ctor.toExpNeg || x4.e >= Ctor.toExpPos);
  return x4.isNeg() && !x4.isZero() ? "-" + str : str;
};
P2.truncated = P2.trunc = function() {
  return finalise(new this.constructor(this), this.e + 1, 1);
};
P2.valueOf = P2.toJSON = function() {
  var x4 = this, Ctor = x4.constructor, str = finiteToString(x4, x4.e <= Ctor.toExpNeg || x4.e >= Ctor.toExpPos);
  return x4.isNeg() ? "-" + str : str;
};
function digitsToString(d5) {
  var i6, k2, ws, indexOfLastWord = d5.length - 1, str = "", w2 = d5[0];
  if (indexOfLastWord > 0) {
    str += w2;
    for (i6 = 1; i6 < indexOfLastWord; i6++) {
      ws = d5[i6] + "";
      k2 = LOG_BASE - ws.length;
      if (k2)
        str += getZeroString(k2);
      str += ws;
    }
    w2 = d5[i6];
    ws = w2 + "";
    k2 = LOG_BASE - ws.length;
    if (k2)
      str += getZeroString(k2);
  } else if (w2 === 0) {
    return "0";
  }
  for (; w2 % 10 === 0; )
    w2 /= 10;
  return str + w2;
}
function checkInt32(i6, min3, max4) {
  if (i6 !== ~~i6 || i6 < min3 || i6 > max4) {
    throw Error(invalidArgument + i6);
  }
}
function checkRoundingDigits(d5, i6, rm, repeating) {
  var di, k2, r7, rd;
  for (k2 = d5[0]; k2 >= 10; k2 /= 10)
    --i6;
  if (--i6 < 0) {
    i6 += LOG_BASE;
    di = 0;
  } else {
    di = Math.ceil((i6 + 1) / LOG_BASE);
    i6 %= LOG_BASE;
  }
  k2 = mathpow(10, LOG_BASE - i6);
  rd = d5[di] % k2 | 0;
  if (repeating == null) {
    if (i6 < 3) {
      if (i6 == 0)
        rd = rd / 100 | 0;
      else if (i6 == 1)
        rd = rd / 10 | 0;
      r7 = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
    } else {
      r7 = (rm < 4 && rd + 1 == k2 || rm > 3 && rd + 1 == k2 / 2) && (d5[di + 1] / k2 / 100 | 0) == mathpow(10, i6 - 2) - 1 || (rd == k2 / 2 || rd == 0) && (d5[di + 1] / k2 / 100 | 0) == 0;
    }
  } else {
    if (i6 < 4) {
      if (i6 == 0)
        rd = rd / 1e3 | 0;
      else if (i6 == 1)
        rd = rd / 100 | 0;
      else if (i6 == 2)
        rd = rd / 10 | 0;
      r7 = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
    } else {
      r7 = ((repeating || rm < 4) && rd + 1 == k2 || !repeating && rm > 3 && rd + 1 == k2 / 2) && (d5[di + 1] / k2 / 1e3 | 0) == mathpow(10, i6 - 3) - 1;
    }
  }
  return r7;
}
function convertBase(str, baseIn, baseOut) {
  var j4, arr = [0], arrL, i6 = 0, strL = str.length;
  for (; i6 < strL; ) {
    for (arrL = arr.length; arrL--; )
      arr[arrL] *= baseIn;
    arr[0] += NUMERALS.indexOf(str.charAt(i6++));
    for (j4 = 0; j4 < arr.length; j4++) {
      if (arr[j4] > baseOut - 1) {
        if (arr[j4 + 1] === void 0)
          arr[j4 + 1] = 0;
        arr[j4 + 1] += arr[j4] / baseOut | 0;
        arr[j4] %= baseOut;
      }
    }
  }
  return arr.reverse();
}
function cosine(Ctor, x4) {
  var k2, len, y4;
  if (x4.isZero())
    return x4;
  len = x4.d.length;
  if (len < 32) {
    k2 = Math.ceil(len / 3);
    y4 = (1 / tinyPow(4, k2)).toString();
  } else {
    k2 = 16;
    y4 = "2.3283064365386962890625e-10";
  }
  Ctor.precision += k2;
  x4 = taylorSeries(Ctor, 1, x4.times(y4), new Ctor(1));
  for (var i6 = k2; i6--; ) {
    var cos2x = x4.times(x4);
    x4 = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
  }
  Ctor.precision -= k2;
  return x4;
}
var divide = /* @__PURE__ */ function() {
  function multiplyInteger(x4, k2, base) {
    var temp, carry = 0, i6 = x4.length;
    for (x4 = x4.slice(); i6--; ) {
      temp = x4[i6] * k2 + carry;
      x4[i6] = temp % base | 0;
      carry = temp / base | 0;
    }
    if (carry)
      x4.unshift(carry);
    return x4;
  }
  function compare(a3, b2, aL, bL) {
    var i6, r7;
    if (aL != bL) {
      r7 = aL > bL ? 1 : -1;
    } else {
      for (i6 = r7 = 0; i6 < aL; i6++) {
        if (a3[i6] != b2[i6]) {
          r7 = a3[i6] > b2[i6] ? 1 : -1;
          break;
        }
      }
    }
    return r7;
  }
  function subtract(a3, b2, aL, base) {
    var i6 = 0;
    for (; aL--; ) {
      a3[aL] -= i6;
      i6 = a3[aL] < b2[aL] ? 1 : 0;
      a3[aL] = i6 * base + a3[aL] - b2[aL];
    }
    for (; !a3[0] && a3.length > 1; )
      a3.shift();
  }
  return function(x4, y4, pr, rm, dp, base) {
    var cmp, e6, i6, k2, logBase, more, prod, prodL, q2, qd, rem, remL, rem0, sd, t5, xi, xL, yd0, yL, yz, Ctor = x4.constructor, sign2 = x4.s == y4.s ? 1 : -1, xd = x4.d, yd = y4.d;
    if (!xd || !xd[0] || !yd || !yd[0]) {
      return new Ctor(
        // Return NaN if either NaN, or both Infinity or 0.
        !x4.s || !y4.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : (
          // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.
          xd && xd[0] == 0 || !yd ? sign2 * 0 : sign2 / 0
        )
      );
    }
    if (base) {
      logBase = 1;
      e6 = x4.e - y4.e;
    } else {
      base = BASE;
      logBase = LOG_BASE;
      e6 = mathfloor(x4.e / logBase) - mathfloor(y4.e / logBase);
    }
    yL = yd.length;
    xL = xd.length;
    q2 = new Ctor(sign2);
    qd = q2.d = [];
    for (i6 = 0; yd[i6] == (xd[i6] || 0); i6++)
      ;
    if (yd[i6] > (xd[i6] || 0))
      e6--;
    if (pr == null) {
      sd = pr = Ctor.precision;
      rm = Ctor.rounding;
    } else if (dp) {
      sd = pr + (x4.e - y4.e) + 1;
    } else {
      sd = pr;
    }
    if (sd < 0) {
      qd.push(1);
      more = true;
    } else {
      sd = sd / logBase + 2 | 0;
      i6 = 0;
      if (yL == 1) {
        k2 = 0;
        yd = yd[0];
        sd++;
        for (; (i6 < xL || k2) && sd--; i6++) {
          t5 = k2 * base + (xd[i6] || 0);
          qd[i6] = t5 / yd | 0;
          k2 = t5 % yd | 0;
        }
        more = k2 || i6 < xL;
      } else {
        k2 = base / (yd[0] + 1) | 0;
        if (k2 > 1) {
          yd = multiplyInteger(yd, k2, base);
          xd = multiplyInteger(xd, k2, base);
          yL = yd.length;
          xL = xd.length;
        }
        xi = yL;
        rem = xd.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; )
          rem[remL++] = 0;
        yz = yd.slice();
        yz.unshift(0);
        yd0 = yd[0];
        if (yd[1] >= base / 2)
          ++yd0;
        do {
          k2 = 0;
          cmp = compare(yd, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base + (rem[1] || 0);
            k2 = rem0 / yd0 | 0;
            if (k2 > 1) {
              if (k2 >= base)
                k2 = base - 1;
              prod = multiplyInteger(yd, k2, base);
              prodL = prod.length;
              remL = rem.length;
              cmp = compare(prod, rem, prodL, remL);
              if (cmp == 1) {
                k2--;
                subtract(prod, yL < prodL ? yz : yd, prodL, base);
              }
            } else {
              if (k2 == 0)
                cmp = k2 = 1;
              prod = yd.slice();
            }
            prodL = prod.length;
            if (prodL < remL)
              prod.unshift(0);
            subtract(rem, prod, remL, base);
            if (cmp == -1) {
              remL = rem.length;
              cmp = compare(yd, rem, yL, remL);
              if (cmp < 1) {
                k2++;
                subtract(rem, yL < remL ? yz : yd, remL, base);
              }
            }
            remL = rem.length;
          } else if (cmp === 0) {
            k2++;
            rem = [0];
          }
          qd[i6++] = k2;
          if (cmp && rem[0]) {
            rem[remL++] = xd[xi] || 0;
          } else {
            rem = [xd[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] !== void 0) && sd--);
        more = rem[0] !== void 0;
      }
      if (!qd[0])
        qd.shift();
    }
    if (logBase == 1) {
      q2.e = e6;
      inexact = more;
    } else {
      for (i6 = 1, k2 = qd[0]; k2 >= 10; k2 /= 10)
        i6++;
      q2.e = i6 + e6 * logBase - 1;
      finalise(q2, dp ? pr + q2.e + 1 : pr, rm, more);
    }
    return q2;
  };
}();
function finalise(x4, sd, rm, isTruncated) {
  var digits, i6, j4, k2, rd, roundUp, w2, xd, xdi, Ctor = x4.constructor;
  out:
    if (sd != null) {
      xd = x4.d;
      if (!xd)
        return x4;
      for (digits = 1, k2 = xd[0]; k2 >= 10; k2 /= 10)
        digits++;
      i6 = sd - digits;
      if (i6 < 0) {
        i6 += LOG_BASE;
        j4 = sd;
        w2 = xd[xdi = 0];
        rd = w2 / mathpow(10, digits - j4 - 1) % 10 | 0;
      } else {
        xdi = Math.ceil((i6 + 1) / LOG_BASE);
        k2 = xd.length;
        if (xdi >= k2) {
          if (isTruncated) {
            for (; k2++ <= xdi; )
              xd.push(0);
            w2 = rd = 0;
            digits = 1;
            i6 %= LOG_BASE;
            j4 = i6 - LOG_BASE + 1;
          } else {
            break out;
          }
        } else {
          w2 = k2 = xd[xdi];
          for (digits = 1; k2 >= 10; k2 /= 10)
            digits++;
          i6 %= LOG_BASE;
          j4 = i6 - LOG_BASE + digits;
          rd = j4 < 0 ? 0 : w2 / mathpow(10, digits - j4 - 1) % 10 | 0;
        }
      }
      isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j4 < 0 ? w2 : w2 % mathpow(10, digits - j4 - 1));
      roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x4.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
      (i6 > 0 ? j4 > 0 ? w2 / mathpow(10, digits - j4) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x4.s < 0 ? 8 : 7));
      if (sd < 1 || !xd[0]) {
        xd.length = 0;
        if (roundUp) {
          sd -= x4.e + 1;
          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
          x4.e = -sd || 0;
        } else {
          xd[0] = x4.e = 0;
        }
        return x4;
      }
      if (i6 == 0) {
        xd.length = xdi;
        k2 = 1;
        xdi--;
      } else {
        xd.length = xdi + 1;
        k2 = mathpow(10, LOG_BASE - i6);
        xd[xdi] = j4 > 0 ? (w2 / mathpow(10, digits - j4) % mathpow(10, j4) | 0) * k2 : 0;
      }
      if (roundUp) {
        for (; ; ) {
          if (xdi == 0) {
            for (i6 = 1, j4 = xd[0]; j4 >= 10; j4 /= 10)
              i6++;
            j4 = xd[0] += k2;
            for (k2 = 1; j4 >= 10; j4 /= 10)
              k2++;
            if (i6 != k2) {
              x4.e++;
              if (xd[0] == BASE)
                xd[0] = 1;
            }
            break;
          } else {
            xd[xdi] += k2;
            if (xd[xdi] != BASE)
              break;
            xd[xdi--] = 0;
            k2 = 1;
          }
        }
      }
      for (i6 = xd.length; xd[--i6] === 0; )
        xd.pop();
    }
  if (external) {
    if (x4.e > Ctor.maxE) {
      x4.d = null;
      x4.e = NaN;
    } else if (x4.e < Ctor.minE) {
      x4.e = 0;
      x4.d = [0];
    }
  }
  return x4;
}
function finiteToString(x4, isExp, sd) {
  if (!x4.isFinite())
    return nonFiniteToString(x4);
  var k2, e6 = x4.e, str = digitsToString(x4.d), len = str.length;
  if (isExp) {
    if (sd && (k2 = sd - len) > 0) {
      str = str.charAt(0) + "." + str.slice(1) + getZeroString(k2);
    } else if (len > 1) {
      str = str.charAt(0) + "." + str.slice(1);
    }
    str = str + (x4.e < 0 ? "e" : "e+") + x4.e;
  } else if (e6 < 0) {
    str = "0." + getZeroString(-e6 - 1) + str;
    if (sd && (k2 = sd - len) > 0)
      str += getZeroString(k2);
  } else if (e6 >= len) {
    str += getZeroString(e6 + 1 - len);
    if (sd && (k2 = sd - e6 - 1) > 0)
      str = str + "." + getZeroString(k2);
  } else {
    if ((k2 = e6 + 1) < len)
      str = str.slice(0, k2) + "." + str.slice(k2);
    if (sd && (k2 = sd - len) > 0) {
      if (e6 + 1 === len)
        str += ".";
      str += getZeroString(k2);
    }
  }
  return str;
}
function getBase10Exponent(digits, e6) {
  var w2 = digits[0];
  for (e6 *= LOG_BASE; w2 >= 10; w2 /= 10)
    e6++;
  return e6;
}
function getLn10(Ctor, sd, pr) {
  if (sd > LN10_PRECISION) {
    external = true;
    if (pr)
      Ctor.precision = pr;
    throw Error(precisionLimitExceeded);
  }
  return finalise(new Ctor(LN10), sd, 1, true);
}
function getPi(Ctor, sd, rm) {
  if (sd > PI_PRECISION)
    throw Error(precisionLimitExceeded);
  return finalise(new Ctor(PI), sd, rm, true);
}
function getPrecision(digits) {
  var w2 = digits.length - 1, len = w2 * LOG_BASE + 1;
  w2 = digits[w2];
  if (w2) {
    for (; w2 % 10 == 0; w2 /= 10)
      len--;
    for (w2 = digits[0]; w2 >= 10; w2 /= 10)
      len++;
  }
  return len;
}
function getZeroString(k2) {
  var zs = "";
  for (; k2--; )
    zs += "0";
  return zs;
}
function intPow(Ctor, x4, n6, pr) {
  var isTruncated, r7 = new Ctor(1), k2 = Math.ceil(pr / LOG_BASE + 4);
  external = false;
  for (; ; ) {
    if (n6 % 2) {
      r7 = r7.times(x4);
      if (truncate(r7.d, k2))
        isTruncated = true;
    }
    n6 = mathfloor(n6 / 2);
    if (n6 === 0) {
      n6 = r7.d.length - 1;
      if (isTruncated && r7.d[n6] === 0)
        ++r7.d[n6];
      break;
    }
    x4 = x4.times(x4);
    truncate(x4.d, k2);
  }
  external = true;
  return r7;
}
function isOdd2(n6) {
  return n6.d[n6.d.length - 1] & 1;
}
function maxOrMin(Ctor, args2, ltgt) {
  var y4, x4 = new Ctor(args2[0]), i6 = 0;
  for (; ++i6 < args2.length; ) {
    y4 = new Ctor(args2[i6]);
    if (!y4.s) {
      x4 = y4;
      break;
    } else if (x4[ltgt](y4)) {
      x4 = y4;
    }
  }
  return x4;
}
function naturalExponential(x4, sd) {
  var denominator, guard, j4, pow2, sum2, t5, wpr, rep = 0, i6 = 0, k2 = 0, Ctor = x4.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (!x4.d || !x4.d[0] || x4.e > 17) {
    return new Ctor(x4.d ? !x4.d[0] ? 1 : x4.s < 0 ? 0 : 1 / 0 : x4.s ? x4.s < 0 ? 0 : x4 : 0 / 0);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  t5 = new Ctor(0.03125);
  while (x4.e > -2) {
    x4 = x4.times(t5);
    k2 += 5;
  }
  guard = Math.log(mathpow(2, k2)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow2 = sum2 = new Ctor(1);
  Ctor.precision = wpr;
  for (; ; ) {
    pow2 = finalise(pow2.times(x4), wpr, 1);
    denominator = denominator.times(++i6);
    t5 = sum2.plus(divide(pow2, denominator, wpr, 1));
    if (digitsToString(t5.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      j4 = k2;
      while (j4--)
        sum2 = finalise(sum2.times(sum2), wpr, 1);
      if (sd == null) {
        if (rep < 3 && checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += 10;
          denominator = pow2 = t5 = new Ctor(1);
          i6 = 0;
          rep++;
        } else {
          return finalise(sum2, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum2;
      }
    }
    sum2 = t5;
  }
}
function naturalLogarithm(y4, sd) {
  var c5, c0, denominator, e6, numerator, rep, sum2, t5, wpr, x1, x22, n6 = 1, guard = 10, x4 = y4, xd = x4.d, Ctor = x4.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (x4.s < 0 || !xd || !xd[0] || !x4.e && xd[0] == 1 && xd.length == 1) {
    return new Ctor(xd && !xd[0] ? -1 / 0 : x4.s != 1 ? NaN : xd ? 0 : x4);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  Ctor.precision = wpr += guard;
  c5 = digitsToString(xd);
  c0 = c5.charAt(0);
  if (Math.abs(e6 = x4.e) < 15e14) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c5.charAt(1) > 3) {
      x4 = x4.times(y4);
      c5 = digitsToString(x4.d);
      c0 = c5.charAt(0);
      n6++;
    }
    e6 = x4.e;
    if (c0 > 1) {
      x4 = new Ctor("0." + c5);
      e6++;
    } else {
      x4 = new Ctor(c0 + "." + c5.slice(1));
    }
  } else {
    t5 = getLn10(Ctor, wpr + 2, pr).times(e6 + "");
    x4 = naturalLogarithm(new Ctor(c0 + "." + c5.slice(1)), wpr - guard).plus(t5);
    Ctor.precision = pr;
    return sd == null ? finalise(x4, pr, rm, external = true) : x4;
  }
  x1 = x4;
  sum2 = numerator = x4 = divide(x4.minus(1), x4.plus(1), wpr, 1);
  x22 = finalise(x4.times(x4), wpr, 1);
  denominator = 3;
  for (; ; ) {
    numerator = finalise(numerator.times(x22), wpr, 1);
    t5 = sum2.plus(divide(numerator, new Ctor(denominator), wpr, 1));
    if (digitsToString(t5.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      sum2 = sum2.times(2);
      if (e6 !== 0)
        sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e6 + ""));
      sum2 = divide(sum2, new Ctor(n6), wpr, 1);
      if (sd == null) {
        if (checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += guard;
          t5 = numerator = x4 = divide(x1.minus(1), x1.plus(1), wpr, 1);
          x22 = finalise(x4.times(x4), wpr, 1);
          denominator = rep = 1;
        } else {
          return finalise(sum2, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum2;
      }
    }
    sum2 = t5;
    denominator += 2;
  }
}
function nonFiniteToString(x4) {
  return String(x4.s * x4.s / 0);
}
function parseDecimal(x4, str) {
  var e6, i6, len;
  if ((e6 = str.indexOf(".")) > -1)
    str = str.replace(".", "");
  if ((i6 = str.search(/e/i)) > 0) {
    if (e6 < 0)
      e6 = i6;
    e6 += +str.slice(i6 + 1);
    str = str.substring(0, i6);
  } else if (e6 < 0) {
    e6 = str.length;
  }
  for (i6 = 0; str.charCodeAt(i6) === 48; i6++)
    ;
  for (len = str.length; str.charCodeAt(len - 1) === 48; --len)
    ;
  str = str.slice(i6, len);
  if (str) {
    len -= i6;
    x4.e = e6 = e6 - i6 - 1;
    x4.d = [];
    i6 = (e6 + 1) % LOG_BASE;
    if (e6 < 0)
      i6 += LOG_BASE;
    if (i6 < len) {
      if (i6)
        x4.d.push(+str.slice(0, i6));
      for (len -= LOG_BASE; i6 < len; )
        x4.d.push(+str.slice(i6, i6 += LOG_BASE));
      str = str.slice(i6);
      i6 = LOG_BASE - str.length;
    } else {
      i6 -= len;
    }
    for (; i6--; )
      str += "0";
    x4.d.push(+str);
    if (external) {
      if (x4.e > x4.constructor.maxE) {
        x4.d = null;
        x4.e = NaN;
      } else if (x4.e < x4.constructor.minE) {
        x4.e = 0;
        x4.d = [0];
      }
    }
  } else {
    x4.e = 0;
    x4.d = [0];
  }
  return x4;
}
function parseOther(x4, str) {
  var base, Ctor, divisor, i6, isFloat2, len, p5, xd, xe;
  if (str.indexOf("_") > -1) {
    str = str.replace(/(\d)_(?=\d)/g, "$1");
    if (isDecimal.test(str))
      return parseDecimal(x4, str);
  } else if (str === "Infinity" || str === "NaN") {
    if (!+str)
      x4.s = NaN;
    x4.e = NaN;
    x4.d = null;
    return x4;
  }
  if (isHex.test(str)) {
    base = 16;
    str = str.toLowerCase();
  } else if (isBinary.test(str)) {
    base = 2;
  } else if (isOctal.test(str)) {
    base = 8;
  } else {
    throw Error(invalidArgument + str);
  }
  i6 = str.search(/p/i);
  if (i6 > 0) {
    p5 = +str.slice(i6 + 1);
    str = str.substring(2, i6);
  } else {
    str = str.slice(2);
  }
  i6 = str.indexOf(".");
  isFloat2 = i6 >= 0;
  Ctor = x4.constructor;
  if (isFloat2) {
    str = str.replace(".", "");
    len = str.length;
    i6 = len - i6;
    divisor = intPow(Ctor, new Ctor(base), i6, i6 * 2);
  }
  xd = convertBase(str, base, BASE);
  xe = xd.length - 1;
  for (i6 = xe; xd[i6] === 0; --i6)
    xd.pop();
  if (i6 < 0)
    return new Ctor(x4.s * 0);
  x4.e = getBase10Exponent(xd, xe);
  x4.d = xd;
  external = false;
  if (isFloat2)
    x4 = divide(x4, divisor, len * 4);
  if (p5)
    x4 = x4.times(Math.abs(p5) < 54 ? mathpow(2, p5) : Decimal.pow(2, p5));
  external = true;
  return x4;
}
function sine(Ctor, x4) {
  var k2, len = x4.d.length;
  if (len < 3) {
    return x4.isZero() ? x4 : taylorSeries(Ctor, 2, x4, x4);
  }
  k2 = 1.4 * Math.sqrt(len);
  k2 = k2 > 16 ? 16 : k2 | 0;
  x4 = x4.times(1 / tinyPow(5, k2));
  x4 = taylorSeries(Ctor, 2, x4, x4);
  var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
  for (; k2--; ) {
    sin2_x = x4.times(x4);
    x4 = x4.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
  }
  return x4;
}
function taylorSeries(Ctor, n6, x4, y4, isHyperbolic) {
  var j4, t5, u4, x22, i6 = 1, pr = Ctor.precision, k2 = Math.ceil(pr / LOG_BASE);
  external = false;
  x22 = x4.times(x4);
  u4 = new Ctor(y4);
  for (; ; ) {
    t5 = divide(u4.times(x22), new Ctor(n6++ * n6++), pr, 1);
    u4 = isHyperbolic ? y4.plus(t5) : y4.minus(t5);
    y4 = divide(t5.times(x22), new Ctor(n6++ * n6++), pr, 1);
    t5 = u4.plus(y4);
    if (t5.d[k2] !== void 0) {
      for (j4 = k2; t5.d[j4] === u4.d[j4] && j4--; )
        ;
      if (j4 == -1)
        break;
    }
    j4 = u4;
    u4 = y4;
    y4 = t5;
    t5 = j4;
    i6++;
  }
  external = true;
  t5.d.length = k2 + 1;
  return t5;
}
function tinyPow(b2, e6) {
  var n6 = b2;
  while (--e6)
    n6 *= b2;
  return n6;
}
function toLessThanHalfPi(Ctor, x4) {
  var t5, isNeg = x4.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
  x4 = x4.abs();
  if (x4.lte(halfPi)) {
    quadrant = isNeg ? 4 : 1;
    return x4;
  }
  t5 = x4.divToInt(pi);
  if (t5.isZero()) {
    quadrant = isNeg ? 3 : 2;
  } else {
    x4 = x4.minus(t5.times(pi));
    if (x4.lte(halfPi)) {
      quadrant = isOdd2(t5) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
      return x4;
    }
    quadrant = isOdd2(t5) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
  }
  return x4.minus(pi).abs();
}
function toStringBinary(x4, baseOut, sd, rm) {
  var base, e6, i6, k2, len, roundUp, str, xd, y4, Ctor = x4.constructor, isExp = sd !== void 0;
  if (isExp) {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  } else {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  }
  if (!x4.isFinite()) {
    str = nonFiniteToString(x4);
  } else {
    str = finiteToString(x4);
    i6 = str.indexOf(".");
    if (isExp) {
      base = 2;
      if (baseOut == 16) {
        sd = sd * 4 - 3;
      } else if (baseOut == 8) {
        sd = sd * 3 - 2;
      }
    } else {
      base = baseOut;
    }
    if (i6 >= 0) {
      str = str.replace(".", "");
      y4 = new Ctor(1);
      y4.e = str.length - i6;
      y4.d = convertBase(finiteToString(y4), 10, base);
      y4.e = y4.d.length;
    }
    xd = convertBase(str, 10, base);
    e6 = len = xd.length;
    for (; xd[--len] == 0; )
      xd.pop();
    if (!xd[0]) {
      str = isExp ? "0p+0" : "0";
    } else {
      if (i6 < 0) {
        e6--;
      } else {
        x4 = new Ctor(x4);
        x4.d = xd;
        x4.e = e6;
        x4 = divide(x4, y4, sd, rm, 0, base);
        xd = x4.d;
        e6 = x4.e;
        roundUp = inexact;
      }
      i6 = xd[sd];
      k2 = base / 2;
      roundUp = roundUp || xd[sd + 1] !== void 0;
      roundUp = rm < 4 ? (i6 !== void 0 || roundUp) && (rm === 0 || rm === (x4.s < 0 ? 3 : 2)) : i6 > k2 || i6 === k2 && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x4.s < 0 ? 8 : 7));
      xd.length = sd;
      if (roundUp) {
        for (; ++xd[--sd] > base - 1; ) {
          xd[sd] = 0;
          if (!sd) {
            ++e6;
            xd.unshift(1);
          }
        }
      }
      for (len = xd.length; !xd[len - 1]; --len)
        ;
      for (i6 = 0, str = ""; i6 < len; i6++)
        str += NUMERALS.charAt(xd[i6]);
      if (isExp) {
        if (len > 1) {
          if (baseOut == 16 || baseOut == 8) {
            i6 = baseOut == 16 ? 4 : 3;
            for (--len; len % i6; len++)
              str += "0";
            xd = convertBase(str, base, baseOut);
            for (len = xd.length; !xd[len - 1]; --len)
              ;
            for (i6 = 1, str = "1."; i6 < len; i6++)
              str += NUMERALS.charAt(xd[i6]);
          } else {
            str = str.charAt(0) + "." + str.slice(1);
          }
        }
        str = str + (e6 < 0 ? "p" : "p+") + e6;
      } else if (e6 < 0) {
        for (; ++e6; )
          str = "0" + str;
        str = "0." + str;
      } else {
        if (++e6 > len)
          for (e6 -= len; e6--; )
            str += "0";
        else if (e6 < len)
          str = str.slice(0, e6) + "." + str.slice(e6);
      }
    }
    str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
  }
  return x4.s < 0 ? "-" + str : str;
}
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
function abs3(x4) {
  return new this(x4).abs();
}
function acos(x4) {
  return new this(x4).acos();
}
function acosh(x4) {
  return new this(x4).acosh();
}
function add(x4, y4) {
  return new this(x4).plus(y4);
}
function asin(x4) {
  return new this(x4).asin();
}
function asinh(x4) {
  return new this(x4).asinh();
}
function atan(x4) {
  return new this(x4).atan();
}
function atanh(x4) {
  return new this(x4).atanh();
}
function atan2(y4, x4) {
  y4 = new this(y4);
  x4 = new this(x4);
  var r7, pr = this.precision, rm = this.rounding, wpr = pr + 4;
  if (!y4.s || !x4.s) {
    r7 = new this(NaN);
  } else if (!y4.d && !x4.d) {
    r7 = getPi(this, wpr, 1).times(x4.s > 0 ? 0.25 : 0.75);
    r7.s = y4.s;
  } else if (!x4.d || y4.isZero()) {
    r7 = x4.s < 0 ? getPi(this, pr, rm) : new this(0);
    r7.s = y4.s;
  } else if (!y4.d || x4.isZero()) {
    r7 = getPi(this, wpr, 1).times(0.5);
    r7.s = y4.s;
  } else if (x4.s < 0) {
    this.precision = wpr;
    this.rounding = 1;
    r7 = this.atan(divide(y4, x4, wpr, 1));
    x4 = getPi(this, wpr, 1);
    this.precision = pr;
    this.rounding = rm;
    r7 = y4.s < 0 ? r7.minus(x4) : r7.plus(x4);
  } else {
    r7 = this.atan(divide(y4, x4, wpr, 1));
  }
  return r7;
}
function cbrt(x4) {
  return new this(x4).cbrt();
}
function ceil2(x4) {
  return finalise(x4 = new this(x4), x4.e + 1, 2);
}
function clamp(x4, min3, max4) {
  return new this(x4).clamp(min3, max4);
}
function config(obj) {
  if (!obj || typeof obj !== "object")
    throw Error(decimalError + "Object expected");
  var i6, p5, v6, useDefaults = obj.defaults === true, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -EXP_LIMIT,
    0,
    "toExpPos",
    0,
    EXP_LIMIT,
    "maxE",
    0,
    EXP_LIMIT,
    "minE",
    -EXP_LIMIT,
    0,
    "modulo",
    0,
    9
  ];
  for (i6 = 0; i6 < ps.length; i6 += 3) {
    if (p5 = ps[i6], useDefaults)
      this[p5] = DEFAULTS[p5];
    if ((v6 = obj[p5]) !== void 0) {
      if (mathfloor(v6) === v6 && v6 >= ps[i6 + 1] && v6 <= ps[i6 + 2])
        this[p5] = v6;
      else
        throw Error(invalidArgument + p5 + ": " + v6);
    }
  }
  if (p5 = "crypto", useDefaults)
    this[p5] = DEFAULTS[p5];
  if ((v6 = obj[p5]) !== void 0) {
    if (v6 === true || v6 === false || v6 === 0 || v6 === 1) {
      if (v6) {
        if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
          this[p5] = true;
        } else {
          throw Error(cryptoUnavailable);
        }
      } else {
        this[p5] = false;
      }
    } else {
      throw Error(invalidArgument + p5 + ": " + v6);
    }
  }
  return this;
}
function cos(x4) {
  return new this(x4).cos();
}
function cosh(x4) {
  return new this(x4).cosh();
}
function clone(obj) {
  var i6, p5, ps;
  function Decimal2(v6) {
    var e6, i7, t5, x4 = this;
    if (!(x4 instanceof Decimal2))
      return new Decimal2(v6);
    x4.constructor = Decimal2;
    if (isDecimalInstance(v6)) {
      x4.s = v6.s;
      if (external) {
        if (!v6.d || v6.e > Decimal2.maxE) {
          x4.e = NaN;
          x4.d = null;
        } else if (v6.e < Decimal2.minE) {
          x4.e = 0;
          x4.d = [0];
        } else {
          x4.e = v6.e;
          x4.d = v6.d.slice();
        }
      } else {
        x4.e = v6.e;
        x4.d = v6.d ? v6.d.slice() : v6.d;
      }
      return;
    }
    t5 = typeof v6;
    if (t5 === "number") {
      if (v6 === 0) {
        x4.s = 1 / v6 < 0 ? -1 : 1;
        x4.e = 0;
        x4.d = [0];
        return;
      }
      if (v6 < 0) {
        v6 = -v6;
        x4.s = -1;
      } else {
        x4.s = 1;
      }
      if (v6 === ~~v6 && v6 < 1e7) {
        for (e6 = 0, i7 = v6; i7 >= 10; i7 /= 10)
          e6++;
        if (external) {
          if (e6 > Decimal2.maxE) {
            x4.e = NaN;
            x4.d = null;
          } else if (e6 < Decimal2.minE) {
            x4.e = 0;
            x4.d = [0];
          } else {
            x4.e = e6;
            x4.d = [v6];
          }
        } else {
          x4.e = e6;
          x4.d = [v6];
        }
        return;
      } else if (v6 * 0 !== 0) {
        if (!v6)
          x4.s = NaN;
        x4.e = NaN;
        x4.d = null;
        return;
      }
      return parseDecimal(x4, v6.toString());
    } else if (t5 !== "string") {
      throw Error(invalidArgument + v6);
    }
    if ((i7 = v6.charCodeAt(0)) === 45) {
      v6 = v6.slice(1);
      x4.s = -1;
    } else {
      if (i7 === 43)
        v6 = v6.slice(1);
      x4.s = 1;
    }
    return isDecimal.test(v6) ? parseDecimal(x4, v6) : parseOther(x4, v6);
  }
  Decimal2.prototype = P2;
  Decimal2.ROUND_UP = 0;
  Decimal2.ROUND_DOWN = 1;
  Decimal2.ROUND_CEIL = 2;
  Decimal2.ROUND_FLOOR = 3;
  Decimal2.ROUND_HALF_UP = 4;
  Decimal2.ROUND_HALF_DOWN = 5;
  Decimal2.ROUND_HALF_EVEN = 6;
  Decimal2.ROUND_HALF_CEIL = 7;
  Decimal2.ROUND_HALF_FLOOR = 8;
  Decimal2.EUCLID = 9;
  Decimal2.config = Decimal2.set = config;
  Decimal2.clone = clone;
  Decimal2.isDecimal = isDecimalInstance;
  Decimal2.abs = abs3;
  Decimal2.acos = acos;
  Decimal2.acosh = acosh;
  Decimal2.add = add;
  Decimal2.asin = asin;
  Decimal2.asinh = asinh;
  Decimal2.atan = atan;
  Decimal2.atanh = atanh;
  Decimal2.atan2 = atan2;
  Decimal2.cbrt = cbrt;
  Decimal2.ceil = ceil2;
  Decimal2.clamp = clamp;
  Decimal2.cos = cos;
  Decimal2.cosh = cosh;
  Decimal2.div = div;
  Decimal2.exp = exp;
  Decimal2.floor = floor2;
  Decimal2.hypot = hypot;
  Decimal2.ln = ln2;
  Decimal2.log = log;
  Decimal2.log10 = log102;
  Decimal2.log2 = log2;
  Decimal2.max = max3;
  Decimal2.min = min2;
  Decimal2.mod = mod;
  Decimal2.mul = mul;
  Decimal2.pow = pow;
  Decimal2.random = random;
  Decimal2.round = round2;
  Decimal2.sign = sign;
  Decimal2.sin = sin;
  Decimal2.sinh = sinh;
  Decimal2.sqrt = sqrt;
  Decimal2.sub = sub;
  Decimal2.sum = sum;
  Decimal2.tan = tan;
  Decimal2.tanh = tanh;
  Decimal2.trunc = trunc;
  if (obj === void 0)
    obj = {};
  if (obj) {
    if (obj.defaults !== true) {
      ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
      for (i6 = 0; i6 < ps.length; )
        if (!obj.hasOwnProperty(p5 = ps[i6++]))
          obj[p5] = this[p5];
    }
  }
  Decimal2.config(obj);
  return Decimal2;
}
function div(x4, y4) {
  return new this(x4).div(y4);
}
function exp(x4) {
  return new this(x4).exp();
}
function floor2(x4) {
  return finalise(x4 = new this(x4), x4.e + 1, 3);
}
function hypot() {
  var i6, n6, t5 = new this(0);
  external = false;
  for (i6 = 0; i6 < arguments.length; ) {
    n6 = new this(arguments[i6++]);
    if (!n6.d) {
      if (n6.s) {
        external = true;
        return new this(1 / 0);
      }
      t5 = n6;
    } else if (t5.d) {
      t5 = t5.plus(n6.times(n6));
    }
  }
  external = true;
  return t5.sqrt();
}
function isDecimalInstance(obj) {
  return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
}
function ln2(x4) {
  return new this(x4).ln();
}
function log(x4, y4) {
  return new this(x4).log(y4);
}
function log2(x4) {
  return new this(x4).log(2);
}
function log102(x4) {
  return new this(x4).log(10);
}
function max3() {
  return maxOrMin(this, arguments, "lt");
}
function min2() {
  return maxOrMin(this, arguments, "gt");
}
function mod(x4, y4) {
  return new this(x4).mod(y4);
}
function mul(x4, y4) {
  return new this(x4).mul(y4);
}
function pow(x4, y4) {
  return new this(x4).pow(y4);
}
function random(sd) {
  var d5, e6, k2, n6, i6 = 0, r7 = new this(1), rd = [];
  if (sd === void 0)
    sd = this.precision;
  else
    checkInt32(sd, 1, MAX_DIGITS);
  k2 = Math.ceil(sd / LOG_BASE);
  if (!this.crypto) {
    for (; i6 < k2; )
      rd[i6++] = Math.random() * 1e7 | 0;
  } else if (crypto.getRandomValues) {
    d5 = crypto.getRandomValues(new Uint32Array(k2));
    for (; i6 < k2; ) {
      n6 = d5[i6];
      if (n6 >= 429e7) {
        d5[i6] = crypto.getRandomValues(new Uint32Array(1))[0];
      } else {
        rd[i6++] = n6 % 1e7;
      }
    }
  } else if (crypto.randomBytes) {
    d5 = crypto.randomBytes(k2 *= 4);
    for (; i6 < k2; ) {
      n6 = d5[i6] + (d5[i6 + 1] << 8) + (d5[i6 + 2] << 16) + ((d5[i6 + 3] & 127) << 24);
      if (n6 >= 214e7) {
        crypto.randomBytes(4).copy(d5, i6);
      } else {
        rd.push(n6 % 1e7);
        i6 += 4;
      }
    }
    i6 = k2 / 4;
  } else {
    throw Error(cryptoUnavailable);
  }
  k2 = rd[--i6];
  sd %= LOG_BASE;
  if (k2 && sd) {
    n6 = mathpow(10, LOG_BASE - sd);
    rd[i6] = (k2 / n6 | 0) * n6;
  }
  for (; rd[i6] === 0; i6--)
    rd.pop();
  if (i6 < 0) {
    e6 = 0;
    rd = [0];
  } else {
    e6 = -1;
    for (; rd[0] === 0; e6 -= LOG_BASE)
      rd.shift();
    for (k2 = 1, n6 = rd[0]; n6 >= 10; n6 /= 10)
      k2++;
    if (k2 < LOG_BASE)
      e6 -= LOG_BASE - k2;
  }
  r7.e = e6;
  r7.d = rd;
  return r7;
}
function round2(x4) {
  return finalise(x4 = new this(x4), x4.e + 1, this.rounding);
}
function sign(x4) {
  x4 = new this(x4);
  return x4.d ? x4.d[0] ? x4.s : 0 * x4.s : x4.s || NaN;
}
function sin(x4) {
  return new this(x4).sin();
}
function sinh(x4) {
  return new this(x4).sinh();
}
function sqrt(x4) {
  return new this(x4).sqrt();
}
function sub(x4, y4) {
  return new this(x4).sub(y4);
}
function sum() {
  var i6 = 0, args2 = arguments, x4 = new this(args2[i6]);
  external = false;
  for (; x4.s && ++i6 < args2.length; )
    x4 = x4.plus(args2[i6]);
  external = true;
  return finalise(x4, this.precision, this.rounding);
}
function tan(x4) {
  return new this(x4).tan();
}
function tanh(x4) {
  return new this(x4).tanh();
}
function trunc(x4) {
  return finalise(x4 = new this(x4), x4.e + 1, 1);
}
P2[Symbol.for("nodejs.util.inspect.custom")] = P2.toString;
P2[Symbol.toStringTag] = "Decimal";
var Decimal = P2.constructor = clone(DEFAULTS);
LN10 = new Decimal(LN10);
PI = new Decimal(PI);
var decimal_default = Decimal;

// node_modules/minimatch/dist/mjs/index.js
var import_brace_expansion = __toESM(require_brace_expansion());

// node_modules/minimatch/dist/mjs/assert-valid-pattern.js
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = (pattern) => {
  if (typeof pattern !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};

// node_modules/minimatch/dist/mjs/brace-expressions.js
var posixClasses = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
  "[:alpha:]": ["\\p{L}\\p{Nl}", true],
  "[:ascii:]": ["\\x00-\\x7f", false],
  "[:blank:]": ["\\p{Zs}\\t", true],
  "[:cntrl:]": ["\\p{Cc}", true],
  "[:digit:]": ["\\p{Nd}", true],
  "[:graph:]": ["\\p{Z}\\p{C}", true, true],
  "[:lower:]": ["\\p{Ll}", true],
  "[:print:]": ["\\p{C}", true],
  "[:punct:]": ["\\p{P}", true],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
  "[:upper:]": ["\\p{Lu}", true],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
  "[:xdigit:]": ["A-Fa-f0-9", false]
};
var braceEscape = (s4) => s4.replace(/[[\]\\-]/g, "\\$&");
var regexpEscape = (s4) => s4.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var rangesToString = (ranges) => ranges.join("");
var parseClass = (glob, position3) => {
  const pos = position3;
  if (glob.charAt(pos) !== "[") {
    throw new Error("not in a brace expression");
  }
  const ranges = [];
  const negs = [];
  let i6 = pos + 1;
  let sawStart = false;
  let uflag = false;
  let escaping2 = false;
  let negate2 = false;
  let endPos = pos;
  let rangeStart = "";
  WHILE:
    while (i6 < glob.length) {
      const c5 = glob.charAt(i6);
      if ((c5 === "!" || c5 === "^") && i6 === pos + 1) {
        negate2 = true;
        i6++;
        continue;
      }
      if (c5 === "]" && sawStart && !escaping2) {
        endPos = i6 + 1;
        break;
      }
      sawStart = true;
      if (c5 === "\\") {
        if (!escaping2) {
          escaping2 = true;
          i6++;
          continue;
        }
      }
      if (c5 === "[" && !escaping2) {
        for (const [cls, [unip, u4, neg]] of Object.entries(posixClasses)) {
          if (glob.startsWith(cls, i6)) {
            if (rangeStart) {
              return ["$.", false, glob.length - pos, true];
            }
            i6 += cls.length;
            if (neg)
              negs.push(unip);
            else
              ranges.push(unip);
            uflag = uflag || u4;
            continue WHILE;
          }
        }
      }
      escaping2 = false;
      if (rangeStart) {
        if (c5 > rangeStart) {
          ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c5));
        } else if (c5 === rangeStart) {
          ranges.push(braceEscape(c5));
        }
        rangeStart = "";
        i6++;
        continue;
      }
      if (glob.startsWith("-]", i6 + 1)) {
        ranges.push(braceEscape(c5 + "-"));
        i6 += 2;
        continue;
      }
      if (glob.startsWith("-", i6 + 1)) {
        rangeStart = c5;
        i6 += 2;
        continue;
      }
      ranges.push(braceEscape(c5));
      i6++;
    }
  if (endPos < i6) {
    return ["", false, 0, false];
  }
  if (!ranges.length && !negs.length) {
    return ["$.", false, glob.length - pos, true];
  }
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate2) {
    const r7 = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [regexpEscape(r7), false, endPos - pos, false];
  }
  const sranges = "[" + (negate2 ? "^" : "") + rangesToString(ranges) + "]";
  const snegs = "[" + (negate2 ? "" : "^") + rangesToString(negs) + "]";
  const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
  return [comb, uflag, endPos - pos, true];
};

// node_modules/minimatch/dist/mjs/unescape.js
var unescape2 = (s4, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s4.replace(/\[([^\/\\])\]/g, "$1") : s4.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
};

// node_modules/minimatch/dist/mjs/ast.js
var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
var isExtglobType = (c5) => types.has(c5);
var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
var startNoDot = "(?!\\.)";
var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
var justDots = /* @__PURE__ */ new Set(["..", "."]);
var reSpecials = new Set("().*{}+?[]^$\\!");
var regExpEscape = (s4) => s4.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var qmark = "[^/]";
var star = qmark + "*?";
var starNoEmpty = qmark + "+?";
var _root2, _hasMagic, _uflag, _parts, _parent, _parentIndex, _negs, _filledNegs, _options, _toString, _emptyExt, _fillNegs, fillNegs_fn, _parseAST, parseAST_fn, _partsToRegExp, partsToRegExp_fn, _parseGlob, parseGlob_fn;
var _AST = class _AST {
  constructor(type2, parent, options = {}) {
    __privateAdd(this, _fillNegs);
    __privateAdd(this, _partsToRegExp);
    __publicField(this, "type");
    __privateAdd(this, _root2, void 0);
    __privateAdd(this, _hasMagic, void 0);
    __privateAdd(this, _uflag, false);
    __privateAdd(this, _parts, []);
    __privateAdd(this, _parent, void 0);
    __privateAdd(this, _parentIndex, void 0);
    __privateAdd(this, _negs, void 0);
    __privateAdd(this, _filledNegs, false);
    __privateAdd(this, _options, void 0);
    __privateAdd(this, _toString, void 0);
    // set to true if it's an extglob with no children
    // (which really means one child of '')
    __privateAdd(this, _emptyExt, false);
    this.type = type2;
    if (type2)
      __privateSet(this, _hasMagic, true);
    __privateSet(this, _parent, parent);
    __privateSet(this, _root2, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _root2) : this);
    __privateSet(this, _options, __privateGet(this, _root2) === this ? options : __privateGet(__privateGet(this, _root2), _options));
    __privateSet(this, _negs, __privateGet(this, _root2) === this ? [] : __privateGet(__privateGet(this, _root2), _negs));
    if (type2 === "!" && !__privateGet(__privateGet(this, _root2), _filledNegs))
      __privateGet(this, _negs).push(this);
    __privateSet(this, _parentIndex, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0);
  }
  get hasMagic() {
    if (__privateGet(this, _hasMagic) !== void 0)
      return __privateGet(this, _hasMagic);
    for (const p5 of __privateGet(this, _parts)) {
      if (typeof p5 === "string")
        continue;
      if (p5.type || p5.hasMagic)
        return __privateSet(this, _hasMagic, true);
    }
    return __privateGet(this, _hasMagic);
  }
  // reconstructs the pattern
  toString() {
    if (__privateGet(this, _toString) !== void 0)
      return __privateGet(this, _toString);
    if (!this.type) {
      return __privateSet(this, _toString, __privateGet(this, _parts).map((p5) => String(p5)).join(""));
    } else {
      return __privateSet(this, _toString, this.type + "(" + __privateGet(this, _parts).map((p5) => String(p5)).join("|") + ")");
    }
  }
  push(...parts) {
    for (const p5 of parts) {
      if (p5 === "")
        continue;
      if (typeof p5 !== "string" && !(p5 instanceof _AST && __privateGet(p5, _parent) === this)) {
        throw new Error("invalid part: " + p5);
      }
      __privateGet(this, _parts).push(p5);
    }
  }
  toJSON() {
    var _a3;
    const ret = this.type === null ? __privateGet(this, _parts).slice().map((p5) => typeof p5 === "string" ? p5 : p5.toJSON()) : [this.type, ...__privateGet(this, _parts).map((p5) => p5.toJSON())];
    if (this.isStart() && !this.type)
      ret.unshift([]);
    if (this.isEnd() && (this === __privateGet(this, _root2) || __privateGet(__privateGet(this, _root2), _filledNegs) && ((_a3 = __privateGet(this, _parent)) == null ? void 0 : _a3.type) === "!")) {
      ret.push({});
    }
    return ret;
  }
  isStart() {
    var _a3;
    if (__privateGet(this, _root2) === this)
      return true;
    if (!((_a3 = __privateGet(this, _parent)) == null ? void 0 : _a3.isStart()))
      return false;
    if (__privateGet(this, _parentIndex) === 0)
      return true;
    const p5 = __privateGet(this, _parent);
    for (let i6 = 0; i6 < __privateGet(this, _parentIndex); i6++) {
      const pp = __privateGet(p5, _parts)[i6];
      if (!(pp instanceof _AST && pp.type === "!")) {
        return false;
      }
    }
    return true;
  }
  isEnd() {
    var _a3, _b, _c;
    if (__privateGet(this, _root2) === this)
      return true;
    if (((_a3 = __privateGet(this, _parent)) == null ? void 0 : _a3.type) === "!")
      return true;
    if (!((_b = __privateGet(this, _parent)) == null ? void 0 : _b.isEnd()))
      return false;
    if (!this.type)
      return (_c = __privateGet(this, _parent)) == null ? void 0 : _c.isEnd();
    const pl = __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0;
    return __privateGet(this, _parentIndex) === pl - 1;
  }
  copyIn(part) {
    if (typeof part === "string")
      this.push(part);
    else
      this.push(part.clone(this));
  }
  clone(parent) {
    const c5 = new _AST(this.type, parent);
    for (const p5 of __privateGet(this, _parts)) {
      c5.copyIn(p5);
    }
    return c5;
  }
  static fromGlob(pattern, options = {}) {
    var _a3;
    const ast = new _AST(null, void 0, options);
    __privateMethod(_a3 = _AST, _parseAST, parseAST_fn).call(_a3, pattern, ast, 0, options);
    return ast;
  }
  // returns the regular expression if there's magic, or the unescaped
  // string if not.
  toMMPattern() {
    if (this !== __privateGet(this, _root2))
      return __privateGet(this, _root2).toMMPattern();
    const glob = this.toString();
    const [re, body, hasMagic, uflag] = this.toRegExpSource();
    const anyMagic = hasMagic || __privateGet(this, _hasMagic) || __privateGet(this, _options).nocase && !__privateGet(this, _options).nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();
    if (!anyMagic) {
      return body;
    }
    const flags = (__privateGet(this, _options).nocase ? "i" : "") + (uflag ? "u" : "");
    return Object.assign(new RegExp(`^${re}$`, flags), {
      _src: re,
      _glob: glob
    });
  }
  // returns the string match, the regexp source, whether there's magic
  // in the regexp (so a regular expression is required) and whether or
  // not the uflag is needed for the regular expression (for posix classes)
  // TODO: instead of injecting the start/end at this point, just return
  // the BODY of the regexp, along with the start/end portions suitable
  // for binding the start/end in either a joined full-path makeRe context
  // (where we bind to (^|/), or a standalone matchPart context (where
  // we bind to ^, and not /).  Otherwise slashes get duped!
  //
  // In part-matching mode, the start is:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: ^(?!\.\.?$)
  // - if dots allowed or not possible: ^
  // - if dots possible and not allowed: ^(?!\.)
  // end is:
  // - if not isEnd(): nothing
  // - else: $
  //
  // In full-path matching mode, we put the slash at the START of the
  // pattern, so start is:
  // - if first pattern: same as part-matching mode
  // - if not isStart(): nothing
  // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
  // - if dots allowed or not possible: /
  // - if dots possible and not allowed: /(?!\.)
  // end is:
  // - if last pattern, same as part-matching mode
  // - else nothing
  //
  // Always put the (?:$|/) on negated tails, though, because that has to be
  // there to bind the end of the negated pattern portion, and it's easier to
  // just stick it in now rather than try to inject it later in the middle of
  // the pattern.
  //
  // We can just always return the same end, and leave it up to the caller
  // to know whether it's going to be used joined or in parts.
  // And, if the start is adjusted slightly, can do the same there:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
  // - if dots allowed or not possible: (?:/|^)
  // - if dots possible and not allowed: (?:/|^)(?!\.)
  //
  // But it's better to have a simpler binding without a conditional, for
  // performance, so probably better to return both start options.
  //
  // Then the caller just ignores the end if it's not the first pattern,
  // and the start always gets applied.
  //
  // But that's always going to be $ if it's the ending pattern, or nothing,
  // so the caller can just attach $ at the end of the pattern when building.
  //
  // So the todo is:
  // - better detect what kind of start is needed
  // - return both flavors of starting pattern
  // - attach $ at the end of the pattern when creating the actual RegExp
  //
  // Ah, but wait, no, that all only applies to the root when the first pattern
  // is not an extglob. If the first pattern IS an extglob, then we need all
  // that dot prevention biz to live in the extglob portions, because eg
  // +(*|.x*) can match .xy but not .yx.
  //
  // So, return the two flavors if it's #root and the first child is not an
  // AST, otherwise leave it to the child AST to handle it, and there,
  // use the (?:^|/) style of start binding.
  //
  // Even simplified further:
  // - Since the start for a join is eg /(?!\.) and the start for a part
  // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
  // or start or whatever) and prepend ^ or / at the Regexp construction.
  toRegExpSource(allowDot) {
    var _a3;
    const dot = allowDot ?? !!__privateGet(this, _options).dot;
    if (__privateGet(this, _root2) === this)
      __privateMethod(this, _fillNegs, fillNegs_fn).call(this);
    if (!this.type) {
      const noEmpty = this.isStart() && this.isEnd();
      const src = __privateGet(this, _parts).map((p5) => {
        var _a4;
        const [re, _2, hasMagic, uflag] = typeof p5 === "string" ? __privateMethod(_a4 = _AST, _parseGlob, parseGlob_fn).call(_a4, p5, __privateGet(this, _hasMagic), noEmpty) : p5.toRegExpSource(allowDot);
        __privateSet(this, _hasMagic, __privateGet(this, _hasMagic) || hasMagic);
        __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
        return re;
      }).join("");
      let start3 = "";
      if (this.isStart()) {
        if (typeof __privateGet(this, _parts)[0] === "string") {
          const dotTravAllowed = __privateGet(this, _parts).length === 1 && justDots.has(__privateGet(this, _parts)[0]);
          if (!dotTravAllowed) {
            const aps = addPatternStart;
            const needNoTrav = (
              // dots are allowed, and the pattern starts with [ or .
              dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
              src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
              src.startsWith("\\.\\.") && aps.has(src.charAt(4))
            );
            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
            start3 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
          }
        }
      }
      let end = "";
      if (this.isEnd() && __privateGet(__privateGet(this, _root2), _filledNegs) && ((_a3 = __privateGet(this, _parent)) == null ? void 0 : _a3.type) === "!") {
        end = "(?:$|\\/)";
      }
      const final2 = start3 + src + end;
      return [
        final2,
        unescape2(src),
        __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
        __privateGet(this, _uflag)
      ];
    }
    const repeated = this.type === "*" || this.type === "+";
    const start2 = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let body = __privateMethod(this, _partsToRegExp, partsToRegExp_fn).call(this, dot);
    if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
      const s4 = this.toString();
      __privateSet(this, _parts, [s4]);
      this.type = null;
      __privateSet(this, _hasMagic, void 0);
      return [s4, unescape2(this.toString()), false, false];
    }
    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : __privateMethod(this, _partsToRegExp, partsToRegExp_fn).call(this, true);
    if (bodyDotAllowed === body) {
      bodyDotAllowed = "";
    }
    if (bodyDotAllowed) {
      body = `(?:${body})(?:${bodyDotAllowed})*?`;
    }
    let final = "";
    if (this.type === "!" && __privateGet(this, _emptyExt)) {
      final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
    } else {
      const close = this.type === "!" ? (
        // !() must match something,but !(x) can match ''
        "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
      ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
      final = start2 + body + close;
    }
    return [
      final,
      unescape2(body),
      __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
      __privateGet(this, _uflag)
    ];
  }
};
_root2 = new WeakMap();
_hasMagic = new WeakMap();
_uflag = new WeakMap();
_parts = new WeakMap();
_parent = new WeakMap();
_parentIndex = new WeakMap();
_negs = new WeakMap();
_filledNegs = new WeakMap();
_options = new WeakMap();
_toString = new WeakMap();
_emptyExt = new WeakMap();
_fillNegs = new WeakSet();
fillNegs_fn = function() {
  if (this !== __privateGet(this, _root2))
    throw new Error("should only call on root");
  if (__privateGet(this, _filledNegs))
    return this;
  this.toString();
  __privateSet(this, _filledNegs, true);
  let n6;
  while (n6 = __privateGet(this, _negs).pop()) {
    if (n6.type !== "!")
      continue;
    let p5 = n6;
    let pp = __privateGet(p5, _parent);
    while (pp) {
      for (let i6 = __privateGet(p5, _parentIndex) + 1; !pp.type && i6 < __privateGet(pp, _parts).length; i6++) {
        for (const part of __privateGet(n6, _parts)) {
          if (typeof part === "string") {
            throw new Error("string part in extglob AST??");
          }
          part.copyIn(__privateGet(pp, _parts)[i6]);
        }
      }
      p5 = pp;
      pp = __privateGet(p5, _parent);
    }
  }
  return this;
};
_parseAST = new WeakSet();
parseAST_fn = function(str, ast, pos, opt) {
  var _a3, _b;
  let escaping2 = false;
  let inBrace = false;
  let braceStart = -1;
  let braceNeg = false;
  if (ast.type === null) {
    let i7 = pos;
    let acc2 = "";
    while (i7 < str.length) {
      const c5 = str.charAt(i7++);
      if (escaping2 || c5 === "\\") {
        escaping2 = !escaping2;
        acc2 += c5;
        continue;
      }
      if (inBrace) {
        if (i7 === braceStart + 1) {
          if (c5 === "^" || c5 === "!") {
            braceNeg = true;
          }
        } else if (c5 === "]" && !(i7 === braceStart + 2 && braceNeg)) {
          inBrace = false;
        }
        acc2 += c5;
        continue;
      } else if (c5 === "[") {
        inBrace = true;
        braceStart = i7;
        braceNeg = false;
        acc2 += c5;
        continue;
      }
      if (!opt.noext && isExtglobType(c5) && str.charAt(i7) === "(") {
        ast.push(acc2);
        acc2 = "";
        const ext2 = new _AST(c5, ast);
        i7 = __privateMethod(_a3 = _AST, _parseAST, parseAST_fn).call(_a3, str, ext2, i7, opt);
        ast.push(ext2);
        continue;
      }
      acc2 += c5;
    }
    ast.push(acc2);
    return i7;
  }
  let i6 = pos + 1;
  let part = new _AST(null, ast);
  const parts = [];
  let acc = "";
  while (i6 < str.length) {
    const c5 = str.charAt(i6++);
    if (escaping2 || c5 === "\\") {
      escaping2 = !escaping2;
      acc += c5;
      continue;
    }
    if (inBrace) {
      if (i6 === braceStart + 1) {
        if (c5 === "^" || c5 === "!") {
          braceNeg = true;
        }
      } else if (c5 === "]" && !(i6 === braceStart + 2 && braceNeg)) {
        inBrace = false;
      }
      acc += c5;
      continue;
    } else if (c5 === "[") {
      inBrace = true;
      braceStart = i6;
      braceNeg = false;
      acc += c5;
      continue;
    }
    if (isExtglobType(c5) && str.charAt(i6) === "(") {
      part.push(acc);
      acc = "";
      const ext2 = new _AST(c5, part);
      part.push(ext2);
      i6 = __privateMethod(_b = _AST, _parseAST, parseAST_fn).call(_b, str, ext2, i6, opt);
      continue;
    }
    if (c5 === "|") {
      part.push(acc);
      acc = "";
      parts.push(part);
      part = new _AST(null, ast);
      continue;
    }
    if (c5 === ")") {
      if (acc === "" && __privateGet(ast, _parts).length === 0) {
        __privateSet(ast, _emptyExt, true);
      }
      part.push(acc);
      acc = "";
      ast.push(...parts, part);
      return i6;
    }
    acc += c5;
  }
  ast.type = null;
  __privateSet(ast, _hasMagic, void 0);
  __privateSet(ast, _parts, [str.substring(pos - 1)]);
  return i6;
};
_partsToRegExp = new WeakSet();
partsToRegExp_fn = function(dot) {
  return __privateGet(this, _parts).map((p5) => {
    if (typeof p5 === "string") {
      throw new Error("string type in extglob ast??");
    }
    const [re, _2, _hasMagic2, uflag] = p5.toRegExpSource(dot);
    __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
    return re;
  }).filter((p5) => !(this.isStart() && this.isEnd()) || !!p5).join("|");
};
_parseGlob = new WeakSet();
parseGlob_fn = function(glob, hasMagic, noEmpty = false) {
  let escaping2 = false;
  let re = "";
  let uflag = false;
  for (let i6 = 0; i6 < glob.length; i6++) {
    const c5 = glob.charAt(i6);
    if (escaping2) {
      escaping2 = false;
      re += (reSpecials.has(c5) ? "\\" : "") + c5;
      continue;
    }
    if (c5 === "\\") {
      if (i6 === glob.length - 1) {
        re += "\\\\";
      } else {
        escaping2 = true;
      }
      continue;
    }
    if (c5 === "[") {
      const [src, needUflag, consumed, magic] = parseClass(glob, i6);
      if (consumed) {
        re += src;
        uflag = uflag || needUflag;
        i6 += consumed - 1;
        hasMagic = hasMagic || magic;
        continue;
      }
    }
    if (c5 === "*") {
      if (noEmpty && glob === "*")
        re += starNoEmpty;
      else
        re += star;
      hasMagic = true;
      continue;
    }
    if (c5 === "?") {
      re += qmark;
      hasMagic = true;
      continue;
    }
    re += regExpEscape(c5);
  }
  return [re, unescape2(glob), !!hasMagic, uflag];
};
__privateAdd(_AST, _parseAST);
__privateAdd(_AST, _parseGlob);
var AST = _AST;

// node_modules/minimatch/dist/mjs/escape.js
var escape2 = (s4, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s4.replace(/[?*()[\]]/g, "[$&]") : s4.replace(/[?*()[\]\\]/g, "\\$&");
};

// node_modules/minimatch/dist/mjs/index.js
var minimatch = (p5, pattern, options = {}) => {
  assertValidPattern(pattern);
  if (!options.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  return new Minimatch(pattern, options).match(p5);
};
var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
var starDotExtTest = (ext2) => (f6) => !f6.startsWith(".") && f6.endsWith(ext2);
var starDotExtTestDot = (ext2) => (f6) => f6.endsWith(ext2);
var starDotExtTestNocase = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f6) => !f6.startsWith(".") && f6.toLowerCase().endsWith(ext2);
};
var starDotExtTestNocaseDot = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f6) => f6.toLowerCase().endsWith(ext2);
};
var starDotStarRE = /^\*+\.\*+$/;
var starDotStarTest = (f6) => !f6.startsWith(".") && f6.includes(".");
var starDotStarTestDot = (f6) => f6 !== "." && f6 !== ".." && f6.includes(".");
var dotStarRE = /^\.\*+$/;
var dotStarTest = (f6) => f6 !== "." && f6 !== ".." && f6.startsWith(".");
var starRE = /^\*+$/;
var starTest = (f6) => f6.length !== 0 && !f6.startsWith(".");
var starTestDot = (f6) => f6.length !== 0 && f6 !== "." && f6 !== "..";
var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
var qmarksTestNocase = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f6) => noext(f6) && f6.toLowerCase().endsWith(ext2);
};
var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f6) => noext(f6) && f6.toLowerCase().endsWith(ext2);
};
var qmarksTestDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  return !ext2 ? noext : (f6) => noext(f6) && f6.endsWith(ext2);
};
var qmarksTest = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  return !ext2 ? noext : (f6) => noext(f6) && f6.endsWith(ext2);
};
var qmarksTestNoExt = ([$0]) => {
  const len = $0.length;
  return (f6) => f6.length === len && !f6.startsWith(".");
};
var qmarksTestNoExtDot = ([$0]) => {
  const len = $0.length;
  return (f6) => f6.length === len && f6 !== "." && f6 !== "..";
};
var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
var path = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
};
var sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
minimatch.sep = sep;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var qmark2 = "[^/]";
var star2 = qmark2 + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var filter = (pattern, options = {}) => (p5) => minimatch(p5, pattern, options);
minimatch.filter = filter;
var ext = (a3, b2 = {}) => Object.assign({}, a3, b2);
var defaults = (def) => {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch;
  }
  const orig = minimatch;
  const m3 = (p5, pattern, options = {}) => orig(p5, pattern, ext(def, options));
  return Object.assign(m3, {
    Minimatch: class Minimatch extends orig.Minimatch {
      constructor(pattern, options = {}) {
        super(pattern, ext(def, options));
      }
      static defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      }
    },
    AST: class AST extends orig.AST {
      /* c8 ignore start */
      constructor(type2, parent, options = {}) {
        super(type2, parent, ext(def, options));
      }
      /* c8 ignore stop */
      static fromGlob(pattern, options = {}) {
        return orig.AST.fromGlob(pattern, ext(def, options));
      }
    },
    unescape: (s4, options = {}) => orig.unescape(s4, ext(def, options)),
    escape: (s4, options = {}) => orig.escape(s4, ext(def, options)),
    filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
    defaults: (options) => orig.defaults(ext(def, options)),
    makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
    braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
    match: (list3, pattern, options = {}) => orig.match(list3, pattern, ext(def, options)),
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults;
var braceExpand = (pattern, options = {}) => {
  assertValidPattern(pattern);
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    return [pattern];
  }
  return (0, import_brace_expansion.default)(pattern);
};
minimatch.braceExpand = braceExpand;
var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
var match2 = (list3, pattern, options = {}) => {
  const mm = new Minimatch(pattern, options);
  list3 = list3.filter((f6) => mm.match(f6));
  if (mm.options.nonull && !list3.length) {
    list3.push(pattern);
  }
  return list3;
};
minimatch.match = match2;
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
var regExpEscape2 = (s4) => s4.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var Minimatch = class {
  constructor(pattern, options = {}) {
    __publicField(this, "options");
    __publicField(this, "set");
    __publicField(this, "pattern");
    __publicField(this, "windowsPathsNoEscape");
    __publicField(this, "nonegate");
    __publicField(this, "negate");
    __publicField(this, "comment");
    __publicField(this, "empty");
    __publicField(this, "preserveMultipleSlashes");
    __publicField(this, "partial");
    __publicField(this, "globSet");
    __publicField(this, "globParts");
    __publicField(this, "nocase");
    __publicField(this, "isWindows");
    __publicField(this, "platform");
    __publicField(this, "windowsNoMagicRoot");
    __publicField(this, "regexp");
    assertValidPattern(pattern);
    options = options || {};
    this.options = options;
    this.pattern = pattern;
    this.platform = options.platform || defaultPlatform;
    this.isWindows = this.platform === "win32";
    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, "/");
    }
    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
    this.regexp = null;
    this.negate = false;
    this.nonegate = !!options.nonegate;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    this.nocase = !!this.options.nocase;
    this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
    this.globSet = [];
    this.globParts = [];
    this.set = [];
    this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1) {
      return true;
    }
    for (const pattern of this.set) {
      for (const part of pattern) {
        if (typeof part !== "string")
          return true;
      }
    }
    return false;
  }
  debug(..._2) {
  }
  make() {
    const pattern = this.pattern;
    const options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    this.globSet = [...new Set(this.braceExpand())];
    if (options.debug) {
      this.debug = (...args2) => console.error(...args2);
    }
    this.debug(this.pattern, this.globSet);
    const rawGlobParts = this.globSet.map((s4) => this.slashSplit(s4));
    this.globParts = this.preprocess(rawGlobParts);
    this.debug(this.pattern, this.globParts);
    let set2 = this.globParts.map((s4, _2, __) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const isUNC = s4[0] === "" && s4[1] === "" && (s4[2] === "?" || !globMagic.test(s4[2])) && !globMagic.test(s4[3]);
        const isDrive = /^[a-z]:/i.test(s4[0]);
        if (isUNC) {
          return [...s4.slice(0, 4), ...s4.slice(4).map((ss) => this.parse(ss))];
        } else if (isDrive) {
          return [s4[0], ...s4.slice(1).map((ss) => this.parse(ss))];
        }
      }
      return s4.map((ss) => this.parse(ss));
    });
    this.debug(this.pattern, set2);
    this.set = set2.filter((s4) => s4.indexOf(false) === -1);
    if (this.isWindows) {
      for (let i6 = 0; i6 < this.set.length; i6++) {
        const p5 = this.set[i6];
        if (p5[0] === "" && p5[1] === "" && this.globParts[i6][2] === "?" && typeof p5[3] === "string" && /^[a-z]:$/i.test(p5[3])) {
          p5[2] = "?";
        }
      }
    }
    this.debug(this.pattern, this.set);
  }
  // various transforms to equivalent pattern sets that are
  // faster to process in a filesystem walk.  The goal is to
  // eliminate what we can, and push all ** patterns as far
  // to the right as possible, even if it increases the number
  // of patterns that we have to process.
  preprocess(globParts) {
    if (this.options.noglobstar) {
      for (let i6 = 0; i6 < globParts.length; i6++) {
        for (let j4 = 0; j4 < globParts[i6].length; j4++) {
          if (globParts[i6][j4] === "**") {
            globParts[i6][j4] = "*";
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      globParts = this.firstPhasePreProcess(globParts);
      globParts = this.secondPhasePreProcess(globParts);
    } else if (optimizationLevel >= 1) {
      globParts = this.levelOneOptimize(globParts);
    } else {
      globParts = this.adjascentGlobstarOptimize(globParts);
    }
    return globParts;
  }
  // just get rid of adjascent ** portions
  adjascentGlobstarOptimize(globParts) {
    return globParts.map((parts) => {
      let gs = -1;
      while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
        let i6 = gs;
        while (parts[i6 + 1] === "**") {
          i6++;
        }
        if (i6 !== gs) {
          parts.splice(gs, i6 - gs);
        }
      }
      return parts;
    });
  }
  // get rid of adjascent ** and resolve .. portions
  levelOneOptimize(globParts) {
    return globParts.map((parts) => {
      parts = parts.reduce((set2, part) => {
        const prev2 = set2[set2.length - 1];
        if (part === "**" && prev2 === "**") {
          return set2;
        }
        if (part === "..") {
          if (prev2 && prev2 !== ".." && prev2 !== "." && prev2 !== "**") {
            set2.pop();
            return set2;
          }
        }
        set2.push(part);
        return set2;
      }, []);
      return parts.length === 0 ? [""] : parts;
    });
  }
  levelTwoFileOptimize(parts) {
    if (!Array.isArray(parts)) {
      parts = this.slashSplit(parts);
    }
    let didSomething = false;
    do {
      didSomething = false;
      if (!this.preserveMultipleSlashes) {
        for (let i6 = 1; i6 < parts.length - 1; i6++) {
          const p5 = parts[i6];
          if (i6 === 1 && p5 === "" && parts[0] === "")
            continue;
          if (p5 === "." || p5 === "") {
            didSomething = true;
            parts.splice(i6, 1);
            i6--;
          }
        }
        if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
          didSomething = true;
          parts.pop();
        }
      }
      let dd = 0;
      while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
        const p5 = parts[dd - 1];
        if (p5 && p5 !== "." && p5 !== ".." && p5 !== "**") {
          didSomething = true;
          parts.splice(dd - 1, 2);
          dd -= 2;
        }
      }
    } while (didSomething);
    return parts.length === 0 ? [""] : parts;
  }
  // First phase: single-pattern processing
  // <pre> is 1 or more portions
  // <rest> is 1 or more portions
  // <p> is any portion other than ., .., '', or **
  // <e> is . or ''
  //
  // **/.. is *brutal* for filesystem walking performance, because
  // it effectively resets the recursive walk each time it occurs,
  // and ** cannot be reduced out by a .. pattern part like a regexp
  // or most strings (other than .., ., and '') can be.
  //
  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
  // <pre>/<e>/<rest> -> <pre>/<rest>
  // <pre>/<p>/../<rest> -> <pre>/<rest>
  // **/**/<rest> -> **/<rest>
  //
  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
  // this WOULD be allowed if ** did follow symlinks, or * didn't
  firstPhasePreProcess(globParts) {
    let didSomething = false;
    do {
      didSomething = false;
      for (let parts of globParts) {
        let gs = -1;
        while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
          let gss = gs;
          while (parts[gss + 1] === "**") {
            gss++;
          }
          if (gss > gs) {
            parts.splice(gs + 1, gss - gs);
          }
          let next2 = parts[gs + 1];
          const p5 = parts[gs + 2];
          const p22 = parts[gs + 3];
          if (next2 !== "..")
            continue;
          if (!p5 || p5 === "." || p5 === ".." || !p22 || p22 === "." || p22 === "..") {
            continue;
          }
          didSomething = true;
          parts.splice(gs, 1);
          const other = parts.slice(0);
          other[gs] = "**";
          globParts.push(other);
          gs--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let i6 = 1; i6 < parts.length - 1; i6++) {
            const p5 = parts[i6];
            if (i6 === 1 && p5 === "" && parts[0] === "")
              continue;
            if (p5 === "." || p5 === "") {
              didSomething = true;
              parts.splice(i6, 1);
              i6--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
          const p5 = parts[dd - 1];
          if (p5 && p5 !== "." && p5 !== ".." && p5 !== "**") {
            didSomething = true;
            const needDot = dd === 1 && parts[dd + 1] === "**";
            const splin = needDot ? ["."] : [];
            parts.splice(dd - 1, 2, ...splin);
            if (parts.length === 0)
              parts.push("");
            dd -= 2;
          }
        }
      }
    } while (didSomething);
    return globParts;
  }
  // second phase: multi-pattern dedupes
  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
  //
  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
  // ^-- not valid because ** doens't follow symlinks
  secondPhasePreProcess(globParts) {
    for (let i6 = 0; i6 < globParts.length - 1; i6++) {
      for (let j4 = i6 + 1; j4 < globParts.length; j4++) {
        const matched = this.partsMatch(globParts[i6], globParts[j4], !this.preserveMultipleSlashes);
        if (!matched)
          continue;
        globParts[i6] = matched;
        globParts[j4] = [];
      }
    }
    return globParts.filter((gs) => gs.length);
  }
  partsMatch(a3, b2, emptyGSMatch = false) {
    let ai = 0;
    let bi = 0;
    let result = [];
    let which = "";
    while (ai < a3.length && bi < b2.length) {
      if (a3[ai] === b2[bi]) {
        result.push(which === "b" ? b2[bi] : a3[ai]);
        ai++;
        bi++;
      } else if (emptyGSMatch && a3[ai] === "**" && b2[bi] === a3[ai + 1]) {
        result.push(a3[ai]);
        ai++;
      } else if (emptyGSMatch && b2[bi] === "**" && a3[ai] === b2[bi + 1]) {
        result.push(b2[bi]);
        bi++;
      } else if (a3[ai] === "*" && b2[bi] && (this.options.dot || !b2[bi].startsWith(".")) && b2[bi] !== "**") {
        if (which === "b")
          return false;
        which = "a";
        result.push(a3[ai]);
        ai++;
        bi++;
      } else if (b2[bi] === "*" && a3[ai] && (this.options.dot || !a3[ai].startsWith(".")) && a3[ai] !== "**") {
        if (which === "a")
          return false;
        which = "b";
        result.push(b2[bi]);
        ai++;
        bi++;
      } else {
        return false;
      }
    }
    return a3.length === b2.length && result;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const pattern = this.pattern;
    let negate2 = false;
    let negateOffset = 0;
    for (let i6 = 0; i6 < pattern.length && pattern.charAt(i6) === "!"; i6++) {
      negate2 = !negate2;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.slice(negateOffset);
    this.negate = negate2;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(file, pattern, partial2 = false) {
    const options = this.options;
    if (this.isWindows) {
      const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
      const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
      const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
      const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
      const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
      const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
      if (typeof fdi === "number" && typeof pdi === "number") {
        const [fd, pd] = [file[fdi], pattern[pdi]];
        if (fd.toLowerCase() === pd.toLowerCase()) {
          pattern[pdi] = fd;
          if (pdi > fdi) {
            pattern = pattern.slice(pdi);
          } else if (fdi > pdi) {
            file = file.slice(fdi);
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      file = this.levelTwoFileOptimize(file);
    }
    this.debug("matchOne", this, { file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p5 = pattern[pi];
      var f6 = file[fi];
      this.debug(pattern, p5, f6);
      if (p5 === false) {
        return false;
      }
      if (p5 === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p5, f6]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial2)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial2) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl) {
            return true;
          }
        }
        return false;
      }
      let hit;
      if (typeof p5 === "string") {
        hit = f6 === p5;
        this.debug("string match", p5, f6, hit);
      } else {
        hit = p5.test(f6);
        this.debug("pattern match", p5, f6, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial2;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    } else {
      throw new Error("wtf?");
    }
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern) {
    assertValidPattern(pattern);
    const options = this.options;
    if (pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    let m3;
    let fastTest = null;
    if (m3 = pattern.match(starRE)) {
      fastTest = options.dot ? starTestDot : starTest;
    } else if (m3 = pattern.match(starDotExtRE)) {
      fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m3[1]);
    } else if (m3 = pattern.match(qmarksRE)) {
      fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m3);
    } else if (m3 = pattern.match(starDotStarRE)) {
      fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
    } else if (m3 = pattern.match(dotStarRE)) {
      fastTest = dotStarTest;
    }
    const re = AST.fromGlob(pattern, this.options).toMMPattern();
    return fastTest ? Object.assign(re, { test: fastTest }) : re;
  }
  makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    const set2 = this.set;
    if (!set2.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options = this.options;
    const twoStar = options.noglobstar ? star2 : options.dot ? twoStarDot : twoStarNoDot;
    const flags = new Set(options.nocase ? ["i"] : []);
    let re = set2.map((pattern) => {
      const pp = pattern.map((p5) => {
        if (p5 instanceof RegExp) {
          for (const f6 of p5.flags.split(""))
            flags.add(f6);
        }
        return typeof p5 === "string" ? regExpEscape2(p5) : p5 === GLOBSTAR ? GLOBSTAR : p5._src;
      });
      pp.forEach((p5, i6) => {
        const next2 = pp[i6 + 1];
        const prev2 = pp[i6 - 1];
        if (p5 !== GLOBSTAR || prev2 === GLOBSTAR) {
          return;
        }
        if (prev2 === void 0) {
          if (next2 !== void 0 && next2 !== GLOBSTAR) {
            pp[i6 + 1] = "(?:\\/|" + twoStar + "\\/)?" + next2;
          } else {
            pp[i6] = twoStar;
          }
        } else if (next2 === void 0) {
          pp[i6 - 1] = prev2 + "(?:\\/|" + twoStar + ")?";
        } else if (next2 !== GLOBSTAR) {
          pp[i6 - 1] = prev2 + "(?:\\/|\\/" + twoStar + "\\/)" + next2;
          pp[i6 + 1] = GLOBSTAR;
        }
      });
      return pp.filter((p5) => p5 !== GLOBSTAR).join("/");
    }).join("|");
    const [open, close] = set2.length > 1 ? ["(?:", ")"] : ["", ""];
    re = "^" + open + re + close + "$";
    if (this.negate)
      re = "^(?!" + re + ").+$";
    try {
      this.regexp = new RegExp(re, [...flags].join(""));
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  slashSplit(p5) {
    if (this.preserveMultipleSlashes) {
      return p5.split("/");
    } else if (this.isWindows && /^\/\/[^\/]+/.test(p5)) {
      return ["", ...p5.split(/\/+/)];
    } else {
      return p5.split(/\/+/);
    }
  }
  match(f6, partial2 = this.partial) {
    this.debug("match", f6, this.pattern);
    if (this.comment) {
      return false;
    }
    if (this.empty) {
      return f6 === "";
    }
    if (f6 === "/" && partial2) {
      return true;
    }
    const options = this.options;
    if (this.isWindows) {
      f6 = f6.split("\\").join("/");
    }
    const ff = this.slashSplit(f6);
    this.debug(this.pattern, "split", ff);
    const set2 = this.set;
    this.debug(this.pattern, "set", set2);
    let filename = ff[ff.length - 1];
    if (!filename) {
      for (let i6 = ff.length - 2; !filename && i6 >= 0; i6--) {
        filename = ff[i6];
      }
    }
    for (let i6 = 0; i6 < set2.length; i6++) {
      const pattern = set2[i6];
      let file = ff;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      const hit = this.matchOne(file, pattern, partial2);
      if (hit) {
        if (options.flipNegate) {
          return true;
        }
        return !this.negate;
      }
    }
    if (options.flipNegate) {
      return false;
    }
    return this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
};
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape2;
minimatch.unescape = unescape2;

// node_modules/graphql/version.mjs
var versionInfo = Object.freeze({
  major: 16,
  minor: 8,
  patch: 1,
  preReleaseTag: null
});

// node_modules/graphql/jsutils/devAssert.mjs
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}

// node_modules/graphql/jsutils/isObjectLike.mjs
function isObjectLike(value2) {
  return typeof value2 == "object" && value2 !== null;
}

// node_modules/graphql/jsutils/invariant.mjs
function invariant(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(
      message != null ? message : "Unexpected invariant triggered."
    );
  }
}

// node_modules/graphql/language/location.mjs
var LineRegExp = /\r\n|[\n\r]/g;
function getLocation(source, position3) {
  let lastLineStart = 0;
  let line2 = 1;
  for (const match3 of source.body.matchAll(LineRegExp)) {
    typeof match3.index === "number" || invariant(false);
    if (match3.index >= position3) {
      break;
    }
    lastLineStart = match3.index + match3[0].length;
    line2 += 1;
  }
  return {
    line: line2,
    column: position3 + 1 - lastLineStart
  };
}

// node_modules/graphql/language/printLocation.mjs
function printLocation(location2) {
  return printSourceLocation(
    location2.source,
    getLocation(location2.source, location2.start)
  );
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i6 = 0; i6 < locationLine.length; i6 += 80) {
      subLines.push(locationLine.slice(i6, i6 + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    // Lines specified like this: ["prefix", "string"],
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  const existingLines = lines.filter(([_2, line2]) => line2 !== void 0);
  const padLen = Math.max(...existingLines.map(([prefix4]) => prefix4.length));
  return existingLines.map(([prefix4, line2]) => prefix4.padStart(padLen) + (line2 ? " " + line2 : "")).join("\n");
}

// node_modules/graphql/error/GraphQLError.mjs
function toNormalizedOptions(args2) {
  const firstArg = args2[0];
  if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
    return {
      nodes: firstArg,
      source: args2[1],
      positions: args2[2],
      path: args2[3],
      originalError: args2[4],
      extensions: args2[5]
    };
  }
  return firstArg;
}
var GraphQLError = class _GraphQLError extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(message, ...rawArgs) {
    var _this$nodes, _nodeLocations$, _ref;
    const { nodes, source, positions, path: path3, originalError, extensions } = toNormalizedOptions(rawArgs);
    super(message);
    this.name = "GraphQLError";
    this.path = path3 !== null && path3 !== void 0 ? path3 : void 0;
    this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
    this.nodes = undefinedIfEmpty(
      Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
    );
    const nodeLocations = undefinedIfEmpty(
      (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node4) => node4.loc).filter((loc) => loc != null)
    );
    this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
    this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
    this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
    const originalExtensions = isObjectLike(
      originalError === null || originalError === void 0 ? void 0 : originalError.extensions
    ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
    this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
    Object.defineProperties(this, {
      message: {
        writable: true,
        enumerable: true
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== void 0 && originalError.stack) {
      Object.defineProperty(this, "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _GraphQLError);
    } else {
      Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let output = this.message;
    if (this.nodes) {
      for (const node4 of this.nodes) {
        if (node4.loc) {
          output += "\n\n" + printLocation(node4.loc);
        }
      }
    } else if (this.source && this.locations) {
      for (const location2 of this.locations) {
        output += "\n\n" + printSourceLocation(this.source, location2);
      }
    }
    return output;
  }
  toJSON() {
    const formattedError = {
      message: this.message
    };
    if (this.locations != null) {
      formattedError.locations = this.locations;
    }
    if (this.path != null) {
      formattedError.path = this.path;
    }
    if (this.extensions != null && Object.keys(this.extensions).length > 0) {
      formattedError.extensions = this.extensions;
    }
    return formattedError;
  }
};
function undefinedIfEmpty(array) {
  return array === void 0 || array.length === 0 ? void 0 : array;
}

// node_modules/graphql/error/syntaxError.mjs
function syntaxError(source, position3, description) {
  return new GraphQLError(`Syntax Error: ${description}`, {
    source,
    positions: [position3]
  });
}

// node_modules/graphql/language/ast.mjs
var Location = class {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
};
var Token = class {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(kind, start2, end, line2, column2, value2) {
    this.kind = kind;
    this.start = start2;
    this.end = end;
    this.line = line2;
    this.column = column2;
    this.value = value2;
    this.prev = null;
    this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
};
var QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
var kindValues = new Set(Object.keys(QueryDocumentKeys));
function isNode2(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
var OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));

// node_modules/graphql/language/directiveLocation.mjs
var DirectiveLocation;
(function(DirectiveLocation2) {
  DirectiveLocation2["QUERY"] = "QUERY";
  DirectiveLocation2["MUTATION"] = "MUTATION";
  DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
  DirectiveLocation2["FIELD"] = "FIELD";
  DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
  DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
  DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
  DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
  DirectiveLocation2["SCHEMA"] = "SCHEMA";
  DirectiveLocation2["SCALAR"] = "SCALAR";
  DirectiveLocation2["OBJECT"] = "OBJECT";
  DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
  DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
  DirectiveLocation2["INTERFACE"] = "INTERFACE";
  DirectiveLocation2["UNION"] = "UNION";
  DirectiveLocation2["ENUM"] = "ENUM";
  DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
  DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
  DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
})(DirectiveLocation || (DirectiveLocation = {}));

// node_modules/graphql/language/kinds.mjs
var Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (Kind = {}));

// node_modules/graphql/language/characterClasses.mjs
function isWhiteSpace(code3) {
  return code3 === 9 || code3 === 32;
}
function isDigit(code3) {
  return code3 >= 48 && code3 <= 57;
}
function isLetter(code3) {
  return code3 >= 97 && code3 <= 122 || // A-Z
  code3 >= 65 && code3 <= 90;
}
function isNameStart(code3) {
  return isLetter(code3) || code3 === 95;
}
function isNameContinue(code3) {
  return isLetter(code3) || isDigit(code3) || code3 === 95;
}

// node_modules/graphql/language/blockString.mjs
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i6 = 0; i6 < lines.length; ++i6) {
    var _firstNonEmptyLine;
    const line2 = lines[i6];
    const indent2 = leadingWhitespace(line2);
    if (indent2 === line2.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i6;
    lastNonEmptyLine = i6;
    if (i6 !== 0 && indent2 < commonIndent) {
      commonIndent = indent2;
    }
  }
  return lines.map((line2, i6) => i6 === 0 ? line2 : line2.slice(commonIndent)).slice(
    (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
    lastNonEmptyLine + 1
  );
}
function leadingWhitespace(str) {
  let i6 = 0;
  while (i6 < str.length && isWhiteSpace(str.charCodeAt(i6))) {
    ++i6;
  }
  return i6;
}
function printBlockString(value2, options) {
  const escapedValue = value2.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line2) => line2.length === 0 || isWhiteSpace(line2.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value2.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value2.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
  (!isSingleLine || value2.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value2.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}

// node_modules/graphql/language/tokenKind.mjs
var TokenKind;
(function(TokenKind2) {
  TokenKind2["SOF"] = "<SOF>";
  TokenKind2["EOF"] = "<EOF>";
  TokenKind2["BANG"] = "!";
  TokenKind2["DOLLAR"] = "$";
  TokenKind2["AMP"] = "&";
  TokenKind2["PAREN_L"] = "(";
  TokenKind2["PAREN_R"] = ")";
  TokenKind2["SPREAD"] = "...";
  TokenKind2["COLON"] = ":";
  TokenKind2["EQUALS"] = "=";
  TokenKind2["AT"] = "@";
  TokenKind2["BRACKET_L"] = "[";
  TokenKind2["BRACKET_R"] = "]";
  TokenKind2["BRACE_L"] = "{";
  TokenKind2["PIPE"] = "|";
  TokenKind2["BRACE_R"] = "}";
  TokenKind2["NAME"] = "Name";
  TokenKind2["INT"] = "Int";
  TokenKind2["FLOAT"] = "Float";
  TokenKind2["STRING"] = "String";
  TokenKind2["BLOCK_STRING"] = "BlockString";
  TokenKind2["COMMENT"] = "Comment";
})(TokenKind || (TokenKind = {}));

// node_modules/graphql/language/lexer.mjs
var Lexer = class {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(source) {
    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
    this.source = source;
    this.lastToken = startOfFileToken;
    this.token = startOfFileToken;
    this.line = 1;
    this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    this.lastToken = this.token;
    const token2 = this.token = this.lookahead();
    return token2;
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let token2 = this.token;
    if (token2.kind !== TokenKind.EOF) {
      do {
        if (token2.next) {
          token2 = token2.next;
        } else {
          const nextToken = readNextToken(this, token2.end);
          token2.next = nextToken;
          nextToken.prev = token2;
          token2 = nextToken;
        }
      } while (token2.kind === TokenKind.COMMENT);
    }
    return token2;
  }
};
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
function isUnicodeScalarValue(code3) {
  return code3 >= 0 && code3 <= 55295 || code3 >= 57344 && code3 <= 1114111;
}
function isSupplementaryCodePoint(body, location2) {
  return isLeadingSurrogate(body.charCodeAt(location2)) && isTrailingSurrogate(body.charCodeAt(location2 + 1));
}
function isLeadingSurrogate(code3) {
  return code3 >= 55296 && code3 <= 56319;
}
function isTrailingSurrogate(code3) {
  return code3 >= 56320 && code3 <= 57343;
}
function printCodePointAt(lexer, location2) {
  const code3 = lexer.source.body.codePointAt(location2);
  if (code3 === void 0) {
    return TokenKind.EOF;
  } else if (code3 >= 32 && code3 <= 126) {
    const char2 = String.fromCodePoint(code3);
    return char2 === '"' ? `'"'` : `"${char2}"`;
  }
  return "U+" + code3.toString(16).toUpperCase().padStart(4, "0");
}
function createToken2(lexer, kind, start2, end, value2) {
  const line2 = lexer.line;
  const col = 1 + start2 - lexer.lineStart;
  return new Token(kind, start2, end, line2, col, value2);
}
function readNextToken(lexer, start2) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position3 = start2;
  while (position3 < bodyLength) {
    const code3 = body.charCodeAt(position3);
    switch (code3) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++position3;
        continue;
      case 10:
        ++position3;
        ++lexer.line;
        lexer.lineStart = position3;
        continue;
      case 13:
        if (body.charCodeAt(position3 + 1) === 10) {
          position3 += 2;
        } else {
          ++position3;
        }
        ++lexer.line;
        lexer.lineStart = position3;
        continue;
      case 35:
        return readComment(lexer, position3);
      case 33:
        return createToken2(lexer, TokenKind.BANG, position3, position3 + 1);
      case 36:
        return createToken2(lexer, TokenKind.DOLLAR, position3, position3 + 1);
      case 38:
        return createToken2(lexer, TokenKind.AMP, position3, position3 + 1);
      case 40:
        return createToken2(lexer, TokenKind.PAREN_L, position3, position3 + 1);
      case 41:
        return createToken2(lexer, TokenKind.PAREN_R, position3, position3 + 1);
      case 46:
        if (body.charCodeAt(position3 + 1) === 46 && body.charCodeAt(position3 + 2) === 46) {
          return createToken2(lexer, TokenKind.SPREAD, position3, position3 + 3);
        }
        break;
      case 58:
        return createToken2(lexer, TokenKind.COLON, position3, position3 + 1);
      case 61:
        return createToken2(lexer, TokenKind.EQUALS, position3, position3 + 1);
      case 64:
        return createToken2(lexer, TokenKind.AT, position3, position3 + 1);
      case 91:
        return createToken2(lexer, TokenKind.BRACKET_L, position3, position3 + 1);
      case 93:
        return createToken2(lexer, TokenKind.BRACKET_R, position3, position3 + 1);
      case 123:
        return createToken2(lexer, TokenKind.BRACE_L, position3, position3 + 1);
      case 124:
        return createToken2(lexer, TokenKind.PIPE, position3, position3 + 1);
      case 125:
        return createToken2(lexer, TokenKind.BRACE_R, position3, position3 + 1);
      case 34:
        if (body.charCodeAt(position3 + 1) === 34 && body.charCodeAt(position3 + 2) === 34) {
          return readBlockString(lexer, position3);
        }
        return readString(lexer, position3);
    }
    if (isDigit(code3) || code3 === 45) {
      return readNumber(lexer, position3, code3);
    }
    if (isNameStart(code3)) {
      return readName(lexer, position3);
    }
    throw syntaxError(
      lexer.source,
      position3,
      code3 === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code3) || isSupplementaryCodePoint(body, position3) ? `Unexpected character: ${printCodePointAt(lexer, position3)}.` : `Invalid character: ${printCodePointAt(lexer, position3)}.`
    );
  }
  return createToken2(lexer, TokenKind.EOF, bodyLength, bodyLength);
}
function readComment(lexer, start2) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position3 = start2 + 1;
  while (position3 < bodyLength) {
    const code3 = body.charCodeAt(position3);
    if (code3 === 10 || code3 === 13) {
      break;
    }
    if (isUnicodeScalarValue(code3)) {
      ++position3;
    } else if (isSupplementaryCodePoint(body, position3)) {
      position3 += 2;
    } else {
      break;
    }
  }
  return createToken2(
    lexer,
    TokenKind.COMMENT,
    start2,
    position3,
    body.slice(start2 + 1, position3)
  );
}
function readNumber(lexer, start2, firstCode) {
  const body = lexer.source.body;
  let position3 = start2;
  let code3 = firstCode;
  let isFloat2 = false;
  if (code3 === 45) {
    code3 = body.charCodeAt(++position3);
  }
  if (code3 === 48) {
    code3 = body.charCodeAt(++position3);
    if (isDigit(code3)) {
      throw syntaxError(
        lexer.source,
        position3,
        `Invalid number, unexpected digit after 0: ${printCodePointAt(
          lexer,
          position3
        )}.`
      );
    }
  } else {
    position3 = readDigits(lexer, position3, code3);
    code3 = body.charCodeAt(position3);
  }
  if (code3 === 46) {
    isFloat2 = true;
    code3 = body.charCodeAt(++position3);
    position3 = readDigits(lexer, position3, code3);
    code3 = body.charCodeAt(position3);
  }
  if (code3 === 69 || code3 === 101) {
    isFloat2 = true;
    code3 = body.charCodeAt(++position3);
    if (code3 === 43 || code3 === 45) {
      code3 = body.charCodeAt(++position3);
    }
    position3 = readDigits(lexer, position3, code3);
    code3 = body.charCodeAt(position3);
  }
  if (code3 === 46 || isNameStart(code3)) {
    throw syntaxError(
      lexer.source,
      position3,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        position3
      )}.`
    );
  }
  return createToken2(
    lexer,
    isFloat2 ? TokenKind.FLOAT : TokenKind.INT,
    start2,
    position3,
    body.slice(start2, position3)
  );
}
function readDigits(lexer, start2, firstCode) {
  if (!isDigit(firstCode)) {
    throw syntaxError(
      lexer.source,
      start2,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        start2
      )}.`
    );
  }
  const body = lexer.source.body;
  let position3 = start2 + 1;
  while (isDigit(body.charCodeAt(position3))) {
    ++position3;
  }
  return position3;
}
function readString(lexer, start2) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position3 = start2 + 1;
  let chunkStart = position3;
  let value2 = "";
  while (position3 < bodyLength) {
    const code3 = body.charCodeAt(position3);
    if (code3 === 34) {
      value2 += body.slice(chunkStart, position3);
      return createToken2(lexer, TokenKind.STRING, start2, position3 + 1, value2);
    }
    if (code3 === 92) {
      value2 += body.slice(chunkStart, position3);
      const escape3 = body.charCodeAt(position3 + 1) === 117 ? body.charCodeAt(position3 + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position3) : readEscapedUnicodeFixedWidth(lexer, position3) : readEscapedCharacter(lexer, position3);
      value2 += escape3.value;
      position3 += escape3.size;
      chunkStart = position3;
      continue;
    }
    if (code3 === 10 || code3 === 13) {
      break;
    }
    if (isUnicodeScalarValue(code3)) {
      ++position3;
    } else if (isSupplementaryCodePoint(body, position3)) {
      position3 += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position3,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position3
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position3, "Unterminated string.");
}
function readEscapedUnicodeVariableWidth(lexer, position3) {
  const body = lexer.source.body;
  let point3 = 0;
  let size3 = 3;
  while (size3 < 12) {
    const code3 = body.charCodeAt(position3 + size3++);
    if (code3 === 125) {
      if (size3 < 5 || !isUnicodeScalarValue(point3)) {
        break;
      }
      return {
        value: String.fromCodePoint(point3),
        size: size3
      };
    }
    point3 = point3 << 4 | readHexDigit(code3);
    if (point3 < 0) {
      break;
    }
  }
  throw syntaxError(
    lexer.source,
    position3,
    `Invalid Unicode escape sequence: "${body.slice(
      position3,
      position3 + size3
    )}".`
  );
}
function readEscapedUnicodeFixedWidth(lexer, position3) {
  const body = lexer.source.body;
  const code3 = read16BitHexCode(body, position3 + 2);
  if (isUnicodeScalarValue(code3)) {
    return {
      value: String.fromCodePoint(code3),
      size: 6
    };
  }
  if (isLeadingSurrogate(code3)) {
    if (body.charCodeAt(position3 + 6) === 92 && body.charCodeAt(position3 + 7) === 117) {
      const trailingCode = read16BitHexCode(body, position3 + 8);
      if (isTrailingSurrogate(trailingCode)) {
        return {
          value: String.fromCodePoint(code3, trailingCode),
          size: 12
        };
      }
    }
  }
  throw syntaxError(
    lexer.source,
    position3,
    `Invalid Unicode escape sequence: "${body.slice(position3, position3 + 6)}".`
  );
}
function read16BitHexCode(body, position3) {
  return readHexDigit(body.charCodeAt(position3)) << 12 | readHexDigit(body.charCodeAt(position3 + 1)) << 8 | readHexDigit(body.charCodeAt(position3 + 2)) << 4 | readHexDigit(body.charCodeAt(position3 + 3));
}
function readHexDigit(code3) {
  return code3 >= 48 && code3 <= 57 ? code3 - 48 : code3 >= 65 && code3 <= 70 ? code3 - 55 : code3 >= 97 && code3 <= 102 ? code3 - 87 : -1;
}
function readEscapedCharacter(lexer, position3) {
  const body = lexer.source.body;
  const code3 = body.charCodeAt(position3 + 1);
  switch (code3) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: "\n",
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw syntaxError(
    lexer.source,
    position3,
    `Invalid character escape sequence: "${body.slice(
      position3,
      position3 + 2
    )}".`
  );
}
function readBlockString(lexer, start2) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let lineStart = lexer.lineStart;
  let position3 = start2 + 3;
  let chunkStart = position3;
  let currentLine = "";
  const blockLines = [];
  while (position3 < bodyLength) {
    const code3 = body.charCodeAt(position3);
    if (code3 === 34 && body.charCodeAt(position3 + 1) === 34 && body.charCodeAt(position3 + 2) === 34) {
      currentLine += body.slice(chunkStart, position3);
      blockLines.push(currentLine);
      const token2 = createToken2(
        lexer,
        TokenKind.BLOCK_STRING,
        start2,
        position3 + 3,
        // Return a string of the lines joined with U+000A.
        dedentBlockStringLines(blockLines).join("\n")
      );
      lexer.line += blockLines.length - 1;
      lexer.lineStart = lineStart;
      return token2;
    }
    if (code3 === 92 && body.charCodeAt(position3 + 1) === 34 && body.charCodeAt(position3 + 2) === 34 && body.charCodeAt(position3 + 3) === 34) {
      currentLine += body.slice(chunkStart, position3);
      chunkStart = position3 + 1;
      position3 += 4;
      continue;
    }
    if (code3 === 10 || code3 === 13) {
      currentLine += body.slice(chunkStart, position3);
      blockLines.push(currentLine);
      if (code3 === 13 && body.charCodeAt(position3 + 1) === 10) {
        position3 += 2;
      } else {
        ++position3;
      }
      currentLine = "";
      chunkStart = position3;
      lineStart = position3;
      continue;
    }
    if (isUnicodeScalarValue(code3)) {
      ++position3;
    } else if (isSupplementaryCodePoint(body, position3)) {
      position3 += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position3,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position3
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position3, "Unterminated string.");
}
function readName(lexer, start2) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position3 = start2 + 1;
  while (position3 < bodyLength) {
    const code3 = body.charCodeAt(position3);
    if (isNameContinue(code3)) {
      ++position3;
    } else {
      break;
    }
  }
  return createToken2(
    lexer,
    TokenKind.NAME,
    start2,
    position3,
    body.slice(start2, position3)
  );
}

// node_modules/graphql/jsutils/inspect.mjs
var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;
function inspect(value2) {
  return formatValue2(value2, []);
}
function formatValue2(value2, seenValues) {
  switch (typeof value2) {
    case "string":
      return JSON.stringify(value2);
    case "function":
      return value2.name ? `[function ${value2.name}]` : "[function]";
    case "object":
      return formatObjectValue(value2, seenValues);
    default:
      return String(value2);
  }
}
function formatObjectValue(value2, previouslySeenValues) {
  if (value2 === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value2)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value2];
  if (isJSONable(value2)) {
    const jsonValue = value2.toJSON();
    if (jsonValue !== value2) {
      return typeof jsonValue === "string" ? jsonValue : formatValue2(jsonValue, seenValues);
    }
  } else if (Array.isArray(value2)) {
    return formatArray(value2, seenValues);
  }
  return formatObject(value2, seenValues);
}
function isJSONable(value2) {
  return typeof value2.toJSON === "function";
}
function formatObject(object2, seenValues) {
  const entries2 = Object.entries(object2);
  if (entries2.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object2) + "]";
  }
  const properties = entries2.map(
    ([key, value2]) => key + ": " + formatValue2(value2, seenValues)
  );
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array.length);
  const remaining = array.length - len;
  const items = [];
  for (let i6 = 0; i6 < len; ++i6) {
    items.push(formatValue2(array[i6], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object2) {
  const tag2 = Object.prototype.toString.call(object2).replace(/^\[object /, "").replace(/]$/, "");
  if (tag2 === "Object" && typeof object2.constructor === "function") {
    const name2 = object2.constructor.name;
    if (typeof name2 === "string" && name2 !== "") {
      return name2;
    }
  }
  return tag2;
}

// node_modules/graphql/jsutils/instanceOf.mjs
var instanceOf = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  globalThis.process && globalThis.process.env.NODE_ENV === "production" ? function instanceOf2(value2, constructor) {
    return value2 instanceof constructor;
  } : function instanceOf3(value2, constructor) {
    if (value2 instanceof constructor) {
      return true;
    }
    if (typeof value2 === "object" && value2 !== null) {
      var _value$constructor;
      const className = constructor.prototype[Symbol.toStringTag];
      const valueClassName = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in value2 ? value2[Symbol.toStringTag] : (_value$constructor = value2.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
      );
      if (className === valueClassName) {
        const stringifiedValue = inspect(value2);
        throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return false;
  }
);

// node_modules/graphql/language/source.mjs
var Source = class {
  constructor(body, name2 = "GraphQL request", locationOffset = {
    line: 1,
    column: 1
  }) {
    typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
    this.body = body;
    this.name = name2;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert(
      false,
      "line in locationOffset is 1-indexed and must be positive."
    );
    this.locationOffset.column > 0 || devAssert(
      false,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
};
function isSource(source) {
  return instanceOf(source, Source);
}

// node_modules/graphql/language/parser.mjs
function parse4(source, options) {
  const parser2 = new Parser2(source, options);
  return parser2.parseDocument();
}
var Parser2 = class {
  constructor(source, options = {}) {
    const sourceObj = isSource(source) ? source : new Source(source);
    this._lexer = new Lexer(sourceObj);
    this._options = options;
    this._tokenCounter = 0;
  }
  /**
   * Converts a name lex token into a name parse node.
   */
  parseName() {
    const token2 = this.expectToken(TokenKind.NAME);
    return this.node(token2, {
      kind: Kind.NAME,
      value: token2.value
    });
  }
  // Implements the parsing rules in the Document section.
  /**
   * Document : Definition+
   */
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: Kind.DOCUMENT,
      definitions: this.many(
        TokenKind.SOF,
        this.parseDefinition,
        TokenKind.EOF
      )
    });
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  parseDefinition() {
    if (this.peek(TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    }
    const hasDescription = this.peekDescription();
    const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (hasDescription) {
        throw syntaxError(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are supported only on type definitions."
        );
      }
      switch (keywordToken.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  // Implements the parsing rules in the Operations section.
  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  parseOperationDefinition() {
    const start2 = this._lexer.token;
    if (this.peek(TokenKind.BRACE_L)) {
      return this.node(start2, {
        kind: Kind.OPERATION_DEFINITION,
        operation: OperationTypeNode.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    }
    const operation = this.parseOperationType();
    let name2;
    if (this.peek(TokenKind.NAME)) {
      name2 = this.parseName();
    }
    return this.node(start2, {
      kind: Kind.OPERATION_DEFINITION,
      operation,
      name: name2,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * OperationType : one of query mutation subscription
   */
  parseOperationType() {
    const operationToken = this.expectToken(TokenKind.NAME);
    switch (operationToken.value) {
      case "query":
        return OperationTypeNode.QUERY;
      case "mutation":
        return OperationTypeNode.MUTATION;
      case "subscription":
        return OperationTypeNode.SUBSCRIPTION;
    }
    throw this.unexpected(operationToken);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  parseVariableDefinitions() {
    return this.optionalMany(
      TokenKind.PAREN_L,
      this.parseVariableDefinition,
      TokenKind.PAREN_R
    );
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: Kind.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  /**
   * Variable : $ Name
   */
  parseVariable() {
    const start2 = this._lexer.token;
    this.expectToken(TokenKind.DOLLAR);
    return this.node(start2, {
      kind: Kind.VARIABLE,
      name: this.parseName()
    });
  }
  /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: Kind.SELECTION_SET,
      selections: this.many(
        TokenKind.BRACE_L,
        this.parseSelection,
        TokenKind.BRACE_R
      )
    });
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  parseSelection() {
    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  parseField() {
    const start2 = this._lexer.token;
    const nameOrAlias = this.parseName();
    let alias;
    let name2;
    if (this.expectOptionalToken(TokenKind.COLON)) {
      alias = nameOrAlias;
      name2 = this.parseName();
    } else {
      name2 = nameOrAlias;
    }
    return this.node(start2, {
      kind: Kind.FIELD,
      alias,
      name: name2,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  parseArguments(isConst) {
    const item2 = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(TokenKind.PAREN_L, item2, TokenKind.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  parseArgument(isConst = false) {
    const start2 = this._lexer.token;
    const name2 = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start2, {
      kind: Kind.ARGUMENT,
      name: name2,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseConstArgument() {
    return this.parseArgument(true);
  }
  // Implements the parsing rules in the Fragments section.
  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  parseFragment() {
    const start2 = this._lexer.token;
    this.expectToken(TokenKind.SPREAD);
    const hasTypeCondition = this.expectOptionalKeyword("on");
    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
      return this.node(start2, {
        kind: Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false)
      });
    }
    return this.node(start2, {
      kind: Kind.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  parseFragmentDefinition() {
    const start2 = this._lexer.token;
    this.expectKeyword("fragment");
    if (this._options.allowLegacyFragmentVariables === true) {
      return this.node(start2, {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    return this.node(start2, {
      kind: Kind.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentName : Name but not `on`
   */
  parseFragmentName() {
    if (this._lexer.token.value === "on") {
      throw this.unexpected();
    }
    return this.parseName();
  }
  // Implements the parsing rules in the Values section.
  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseValueLiteral(isConst) {
    const token2 = this._lexer.token;
    switch (token2.kind) {
      case TokenKind.BRACKET_L:
        return this.parseList(isConst);
      case TokenKind.BRACE_L:
        return this.parseObject(isConst);
      case TokenKind.INT:
        this.advanceLexer();
        return this.node(token2, {
          kind: Kind.INT,
          value: token2.value
        });
      case TokenKind.FLOAT:
        this.advanceLexer();
        return this.node(token2, {
          kind: Kind.FLOAT,
          value: token2.value
        });
      case TokenKind.STRING:
      case TokenKind.BLOCK_STRING:
        return this.parseStringLiteral();
      case TokenKind.NAME:
        this.advanceLexer();
        switch (token2.value) {
          case "true":
            return this.node(token2, {
              kind: Kind.BOOLEAN,
              value: true
            });
          case "false":
            return this.node(token2, {
              kind: Kind.BOOLEAN,
              value: false
            });
          case "null":
            return this.node(token2, {
              kind: Kind.NULL
            });
          default:
            return this.node(token2, {
              kind: Kind.ENUM,
              value: token2.value
            });
        }
      case TokenKind.DOLLAR:
        if (isConst) {
          this.expectToken(TokenKind.DOLLAR);
          if (this._lexer.token.kind === TokenKind.NAME) {
            const varName = this._lexer.token.value;
            throw syntaxError(
              this._lexer.source,
              token2.start,
              `Unexpected variable "$${varName}" in constant value.`
            );
          } else {
            throw this.unexpected(token2);
          }
        }
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(true);
  }
  parseStringLiteral() {
    const token2 = this._lexer.token;
    this.advanceLexer();
    return this.node(token2, {
      kind: Kind.STRING,
      value: token2.value,
      block: token2.kind === TokenKind.BLOCK_STRING
    });
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  parseList(isConst) {
    const item2 = () => this.parseValueLiteral(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.LIST,
      values: this.any(TokenKind.BRACKET_L, item2, TokenKind.BRACKET_R)
    });
  }
  /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */
  parseObject(isConst) {
    const item2 = () => this.parseObjectField(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.OBJECT,
      fields: this.any(TokenKind.BRACE_L, item2, TokenKind.BRACE_R)
    });
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  parseObjectField(isConst) {
    const start2 = this._lexer.token;
    const name2 = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start2, {
      kind: Kind.OBJECT_FIELD,
      name: name2,
      value: this.parseValueLiteral(isConst)
    });
  }
  // Implements the parsing rules in the Directives section.
  /**
   * Directives[Const] : Directive[?Const]+
   */
  parseDirectives(isConst) {
    const directives2 = [];
    while (this.peek(TokenKind.AT)) {
      directives2.push(this.parseDirective(isConst));
    }
    return directives2;
  }
  parseConstDirectives() {
    return this.parseDirectives(true);
  }
  /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */
  parseDirective(isConst) {
    const start2 = this._lexer.token;
    this.expectToken(TokenKind.AT);
    return this.node(start2, {
      kind: Kind.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst)
    });
  }
  // Implements the parsing rules in the Types section.
  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  parseTypeReference() {
    const start2 = this._lexer.token;
    let type2;
    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
      const innerType = this.parseTypeReference();
      this.expectToken(TokenKind.BRACKET_R);
      type2 = this.node(start2, {
        kind: Kind.LIST_TYPE,
        type: innerType
      });
    } else {
      type2 = this.parseNamedType();
    }
    if (this.expectOptionalToken(TokenKind.BANG)) {
      return this.node(start2, {
        kind: Kind.NON_NULL_TYPE,
        type: type2
      });
    }
    return type2;
  }
  /**
   * NamedType : Name
   */
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: Kind.NAMED_TYPE,
      name: this.parseName()
    });
  }
  // Implements the parsing rules in the Type Definition section.
  peekDescription() {
    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  }
  /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */
  parseSchemaDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("schema");
    const directives2 = this.parseConstDirectives();
    const operationTypes = this.many(
      TokenKind.BRACE_L,
      this.parseOperationTypeDefinition,
      TokenKind.BRACE_R
    );
    return this.node(start2, {
      kind: Kind.SCHEMA_DEFINITION,
      description,
      directives: directives2,
      operationTypes
    });
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  parseOperationTypeDefinition() {
    const start2 = this._lexer.token;
    const operation = this.parseOperationType();
    this.expectToken(TokenKind.COLON);
    const type2 = this.parseNamedType();
    return this.node(start2, {
      kind: Kind.OPERATION_TYPE_DEFINITION,
      operation,
      type: type2
    });
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  parseScalarTypeDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("scalar");
    const name2 = this.parseName();
    const directives2 = this.parseConstDirectives();
    return this.node(start2, {
      kind: Kind.SCALAR_TYPE_DEFINITION,
      description,
      name: name2,
      directives: directives2
    });
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  parseObjectTypeDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("type");
    const name2 = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives2 = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start2, {
      kind: Kind.OBJECT_TYPE_DEFINITION,
      description,
      name: name2,
      interfaces,
      directives: directives2,
      fields
    });
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
  }
  /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */
  parseFieldsDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseFieldDefinition,
      TokenKind.BRACE_R
    );
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  parseFieldDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    const name2 = this.parseName();
    const args2 = this.parseArgumentDefs();
    this.expectToken(TokenKind.COLON);
    const type2 = this.parseTypeReference();
    const directives2 = this.parseConstDirectives();
    return this.node(start2, {
      kind: Kind.FIELD_DEFINITION,
      description,
      name: name2,
      arguments: args2,
      type: type2,
      directives: directives2
    });
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  parseArgumentDefs() {
    return this.optionalMany(
      TokenKind.PAREN_L,
      this.parseInputValueDef,
      TokenKind.PAREN_R
    );
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  parseInputValueDef() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    const name2 = this.parseName();
    this.expectToken(TokenKind.COLON);
    const type2 = this.parseTypeReference();
    let defaultValue;
    if (this.expectOptionalToken(TokenKind.EQUALS)) {
      defaultValue = this.parseConstValueLiteral();
    }
    const directives2 = this.parseConstDirectives();
    return this.node(start2, {
      kind: Kind.INPUT_VALUE_DEFINITION,
      description,
      name: name2,
      type: type2,
      defaultValue,
      directives: directives2
    });
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  parseInterfaceTypeDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("interface");
    const name2 = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives2 = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start2, {
      kind: Kind.INTERFACE_TYPE_DEFINITION,
      description,
      name: name2,
      interfaces,
      directives: directives2,
      fields
    });
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  parseUnionTypeDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("union");
    const name2 = this.parseName();
    const directives2 = this.parseConstDirectives();
    const types3 = this.parseUnionMemberTypes();
    return this.node(start2, {
      kind: Kind.UNION_TYPE_DEFINITION,
      description,
      name: name2,
      directives: directives2,
      types: types3
    });
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  parseUnionMemberTypes() {
    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  parseEnumTypeDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("enum");
    const name2 = this.parseName();
    const directives2 = this.parseConstDirectives();
    const values3 = this.parseEnumValuesDefinition();
    return this.node(start2, {
      kind: Kind.ENUM_TYPE_DEFINITION,
      description,
      name: name2,
      directives: directives2,
      values: values3
    });
  }
  /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */
  parseEnumValuesDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseEnumValueDefinition,
      TokenKind.BRACE_R
    );
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */
  parseEnumValueDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    const name2 = this.parseEnumValueName();
    const directives2 = this.parseConstDirectives();
    return this.node(start2, {
      kind: Kind.ENUM_VALUE_DEFINITION,
      description,
      name: name2,
      directives: directives2
    });
  }
  /**
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
      throw syntaxError(
        this._lexer.source,
        this._lexer.token.start,
        `${getTokenDesc(
          this._lexer.token
        )} is reserved and cannot be used for an enum value.`
      );
    }
    return this.parseName();
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  parseInputObjectTypeDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("input");
    const name2 = this.parseName();
    const directives2 = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    return this.node(start2, {
      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description,
      name: name2,
      directives: directives2,
      fields
    });
  }
  /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */
  parseInputFieldsDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseInputValueDef,
      TokenKind.BRACE_R
    );
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  parseTypeSystemExtension() {
    const keywordToken = this._lexer.lookahead();
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */
  parseSchemaExtension() {
    const start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("schema");
    const directives2 = this.parseConstDirectives();
    const operationTypes = this.optionalMany(
      TokenKind.BRACE_L,
      this.parseOperationTypeDefinition,
      TokenKind.BRACE_R
    );
    if (directives2.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }
    return this.node(start2, {
      kind: Kind.SCHEMA_EXTENSION,
      directives: directives2,
      operationTypes
    });
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  parseScalarTypeExtension() {
    const start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("scalar");
    const name2 = this.parseName();
    const directives2 = this.parseConstDirectives();
    if (directives2.length === 0) {
      throw this.unexpected();
    }
    return this.node(start2, {
      kind: Kind.SCALAR_TYPE_EXTENSION,
      name: name2,
      directives: directives2
    });
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  parseObjectTypeExtension() {
    const start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("type");
    const name2 = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives2 = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives2.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start2, {
      kind: Kind.OBJECT_TYPE_EXTENSION,
      name: name2,
      interfaces,
      directives: directives2,
      fields
    });
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  parseInterfaceTypeExtension() {
    const start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("interface");
    const name2 = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives2 = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives2.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start2, {
      kind: Kind.INTERFACE_TYPE_EXTENSION,
      name: name2,
      interfaces,
      directives: directives2,
      fields
    });
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  parseUnionTypeExtension() {
    const start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("union");
    const name2 = this.parseName();
    const directives2 = this.parseConstDirectives();
    const types3 = this.parseUnionMemberTypes();
    if (directives2.length === 0 && types3.length === 0) {
      throw this.unexpected();
    }
    return this.node(start2, {
      kind: Kind.UNION_TYPE_EXTENSION,
      name: name2,
      directives: directives2,
      types: types3
    });
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  parseEnumTypeExtension() {
    const start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("enum");
    const name2 = this.parseName();
    const directives2 = this.parseConstDirectives();
    const values3 = this.parseEnumValuesDefinition();
    if (directives2.length === 0 && values3.length === 0) {
      throw this.unexpected();
    }
    return this.node(start2, {
      kind: Kind.ENUM_TYPE_EXTENSION,
      name: name2,
      directives: directives2,
      values: values3
    });
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  parseInputObjectTypeExtension() {
    const start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("input");
    const name2 = this.parseName();
    const directives2 = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    if (directives2.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start2, {
      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
      name: name2,
      directives: directives2,
      fields
    });
  }
  /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */
  parseDirectiveDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("directive");
    this.expectToken(TokenKind.AT);
    const name2 = this.parseName();
    const args2 = this.parseArgumentDefs();
    const repeatable = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const locations = this.parseDirectiveLocations();
    return this.node(start2, {
      kind: Kind.DIRECTIVE_DEFINITION,
      description,
      name: name2,
      arguments: args2,
      repeatable,
      locations
    });
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  parseDirectiveLocations() {
    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  parseDirectiveLocation() {
    const start2 = this._lexer.token;
    const name2 = this.parseName();
    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name2.value)) {
      return name2;
    }
    throw this.unexpected(start2);
  }
  // Core parsing utility functions
  /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */
  node(startToken, node4) {
    if (this._options.noLocation !== true) {
      node4.loc = new Location(
        startToken,
        this._lexer.lastToken,
        this._lexer.source
      );
    }
    return node4;
  }
  /**
   * Determines if the next token is of a given kind
   */
  peek(kind) {
    return this._lexer.token.kind === kind;
  }
  /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectToken(kind) {
    const token2 = this._lexer.token;
    if (token2.kind === kind) {
      this.advanceLexer();
      return token2;
    }
    throw syntaxError(
      this._lexer.source,
      token2.start,
      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token2)}.`
    );
  }
  /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalToken(kind) {
    const token2 = this._lexer.token;
    if (token2.kind === kind) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectKeyword(value2) {
    const token2 = this._lexer.token;
    if (token2.kind === TokenKind.NAME && token2.value === value2) {
      this.advanceLexer();
    } else {
      throw syntaxError(
        this._lexer.source,
        token2.start,
        `Expected "${value2}", found ${getTokenDesc(token2)}.`
      );
    }
  }
  /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalKeyword(value2) {
    const token2 = this._lexer.token;
    if (token2.kind === TokenKind.NAME && token2.value === value2) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */
  unexpected(atToken) {
    const token2 = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
    return syntaxError(
      this._lexer.source,
      token2.start,
      `Unexpected ${getTokenDesc(token2)}.`
    );
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }
    return nodes;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));
    return nodes;
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */
  delimitedMany(delimiterKind, parseFn) {
    this.expectOptionalToken(delimiterKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (this.expectOptionalToken(delimiterKind));
    return nodes;
  }
  advanceLexer() {
    const { maxTokens } = this._options;
    const token2 = this._lexer.advance();
    if (maxTokens !== void 0 && token2.kind !== TokenKind.EOF) {
      ++this._tokenCounter;
      if (this._tokenCounter > maxTokens) {
        throw syntaxError(
          this._lexer.source,
          token2.start,
          `Document contains more that ${maxTokens} tokens. Parsing aborted.`
        );
      }
    }
  }
};
function getTokenDesc(token2) {
  const value2 = token2.value;
  return getTokenKindDesc(token2.kind) + (value2 != null ? ` "${value2}"` : "");
}
function getTokenKindDesc(kind) {
  return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
}

// node_modules/graphql/jsutils/didYouMean.mjs
var MAX_SUGGESTIONS = 5;
function didYouMean(firstArg, secondArg) {
  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
  let message = " Did you mean ";
  if (subMessage) {
    message += subMessage + " ";
  }
  const suggestions = suggestionsArg.map((x4) => `"${x4}"`);
  switch (suggestions.length) {
    case 0:
      return "";
    case 1:
      return message + suggestions[0] + "?";
    case 2:
      return message + suggestions[0] + " or " + suggestions[1] + "?";
  }
  const selected = suggestions.slice(0, MAX_SUGGESTIONS);
  const lastItem = selected.pop();
  return message + selected.join(", ") + ", or " + lastItem + "?";
}

// node_modules/graphql/jsutils/identityFunc.mjs
function identityFunc(x4) {
  return x4;
}

// node_modules/graphql/jsutils/keyMap.mjs
function keyMap(list3, keyFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item2 of list3) {
    result[keyFn(item2)] = item2;
  }
  return result;
}

// node_modules/graphql/jsutils/keyValMap.mjs
function keyValMap(list3, keyFn, valFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item2 of list3) {
    result[keyFn(item2)] = valFn(item2);
  }
  return result;
}

// node_modules/graphql/jsutils/mapValue.mjs
function mapValue(map4, fn2) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const key of Object.keys(map4)) {
    result[key] = fn2(map4[key], key);
  }
  return result;
}

// node_modules/graphql/jsutils/naturalCompare.mjs
function naturalCompare(aStr, bStr) {
  let aIndex = 0;
  let bIndex = 0;
  while (aIndex < aStr.length && bIndex < bStr.length) {
    let aChar = aStr.charCodeAt(aIndex);
    let bChar = bStr.charCodeAt(bIndex);
    if (isDigit2(aChar) && isDigit2(bChar)) {
      let aNum = 0;
      do {
        ++aIndex;
        aNum = aNum * 10 + aChar - DIGIT_0;
        aChar = aStr.charCodeAt(aIndex);
      } while (isDigit2(aChar) && aNum > 0);
      let bNum = 0;
      do {
        ++bIndex;
        bNum = bNum * 10 + bChar - DIGIT_0;
        bChar = bStr.charCodeAt(bIndex);
      } while (isDigit2(bChar) && bNum > 0);
      if (aNum < bNum) {
        return -1;
      }
      if (aNum > bNum) {
        return 1;
      }
    } else {
      if (aChar < bChar) {
        return -1;
      }
      if (aChar > bChar) {
        return 1;
      }
      ++aIndex;
      ++bIndex;
    }
  }
  return aStr.length - bStr.length;
}
var DIGIT_0 = 48;
var DIGIT_9 = 57;
function isDigit2(code3) {
  return !isNaN(code3) && DIGIT_0 <= code3 && code3 <= DIGIT_9;
}

// node_modules/graphql/jsutils/suggestionList.mjs
function suggestionList(input, options) {
  const optionsByDistance = /* @__PURE__ */ Object.create(null);
  const lexicalDistance = new LexicalDistance(input);
  const threshold = Math.floor(input.length * 0.4) + 1;
  for (const option of options) {
    const distance = lexicalDistance.measure(option, threshold);
    if (distance !== void 0) {
      optionsByDistance[option] = distance;
    }
  }
  return Object.keys(optionsByDistance).sort((a3, b2) => {
    const distanceDiff = optionsByDistance[a3] - optionsByDistance[b2];
    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a3, b2);
  });
}
var LexicalDistance = class {
  constructor(input) {
    this._input = input;
    this._inputLowerCase = input.toLowerCase();
    this._inputArray = stringToArray(this._inputLowerCase);
    this._rows = [
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0)
    ];
  }
  measure(option, threshold) {
    if (this._input === option) {
      return 0;
    }
    const optionLowerCase = option.toLowerCase();
    if (this._inputLowerCase === optionLowerCase) {
      return 1;
    }
    let a3 = stringToArray(optionLowerCase);
    let b2 = this._inputArray;
    if (a3.length < b2.length) {
      const tmp = a3;
      a3 = b2;
      b2 = tmp;
    }
    const aLength = a3.length;
    const bLength = b2.length;
    if (aLength - bLength > threshold) {
      return void 0;
    }
    const rows = this._rows;
    for (let j4 = 0; j4 <= bLength; j4++) {
      rows[0][j4] = j4;
    }
    for (let i6 = 1; i6 <= aLength; i6++) {
      const upRow = rows[(i6 - 1) % 3];
      const currentRow = rows[i6 % 3];
      let smallestCell = currentRow[0] = i6;
      for (let j4 = 1; j4 <= bLength; j4++) {
        const cost = a3[i6 - 1] === b2[j4 - 1] ? 0 : 1;
        let currentCell = Math.min(
          upRow[j4] + 1,
          // delete
          currentRow[j4 - 1] + 1,
          // insert
          upRow[j4 - 1] + cost
          // substitute
        );
        if (i6 > 1 && j4 > 1 && a3[i6 - 1] === b2[j4 - 2] && a3[i6 - 2] === b2[j4 - 1]) {
          const doubleDiagonalCell = rows[(i6 - 2) % 3][j4 - 2];
          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
        }
        if (currentCell < smallestCell) {
          smallestCell = currentCell;
        }
        currentRow[j4] = currentCell;
      }
      if (smallestCell > threshold) {
        return void 0;
      }
    }
    const distance = rows[aLength % 3][bLength];
    return distance <= threshold ? distance : void 0;
  }
};
function stringToArray(str) {
  const strLength = str.length;
  const array = new Array(strLength);
  for (let i6 = 0; i6 < strLength; ++i6) {
    array[i6] = str.charCodeAt(i6);
  }
  return array;
}

// node_modules/graphql/jsutils/toObjMap.mjs
function toObjMap(obj) {
  if (obj == null) {
    return /* @__PURE__ */ Object.create(null);
  }
  if (Object.getPrototypeOf(obj) === null) {
    return obj;
  }
  const map4 = /* @__PURE__ */ Object.create(null);
  for (const [key, value2] of Object.entries(obj)) {
    map4[key] = value2;
  }
  return map4;
}

// node_modules/graphql/language/printString.mjs
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
var escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];

// node_modules/graphql/language/visitor.mjs
var BREAK = Object.freeze({});
function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root);
  let keys3 = [root];
  let index3 = -1;
  let edits = [];
  let node4 = root;
  let key = void 0;
  let parent = void 0;
  const path3 = [];
  const ancestors = [];
  do {
    index3++;
    const isLeaving = index3 === keys3.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path3[path3.length - 1];
      node4 = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node4 = node4.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node4.splice(arrayKey, 1);
              editOffset++;
            } else {
              node4[arrayKey] = editValue;
            }
          }
        } else {
          node4 = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(node4)
          );
          for (const [editKey, editValue] of edits) {
            node4[editKey] = editValue;
          }
        }
      }
      index3 = stack.index;
      keys3 = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index3 : keys3[index3];
      node4 = parent[key];
      if (node4 === null || node4 === void 0) {
        continue;
      }
      path3.push(key);
    }
    let result;
    if (!Array.isArray(node4)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode2(node4) || devAssert(false, `Invalid AST Node: ${inspect(node4)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node4.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node4.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node4, key, parent, path3, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path3.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode2(result)) {
            node4 = result;
          } else {
            path3.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node4]);
    }
    if (isLeaving) {
      path3.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index: index3,
        keys: keys3,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node4);
      keys3 = inArray ? node4 : (_node$kind = visitorKeys[node4.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index3 = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node4;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}

// node_modules/graphql/language/printer.mjs
function print2(ast) {
  return visit(ast, printDocASTReducer);
}
var MAX_LINE_LENGTH = 80;
var printDocASTReducer = {
  Name: {
    leave: (node4) => node4.value
  },
  Variable: {
    leave: (node4) => "$" + node4.name
  },
  // Document
  Document: {
    leave: (node4) => join(node4.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node4) {
      const varDefs = wrap("(", join(node4.variableDefinitions, ", "), ")");
      const prefix4 = join(
        [
          node4.operation,
          join([node4.name, varDefs]),
          join(node4.directives, " ")
        ],
        " "
      );
      return (prefix4 === "query" ? "" : prefix4 + " ") + node4.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type: type2, defaultValue, directives: directives2 }) => variable + ": " + type2 + wrap(" = ", defaultValue) + wrap(" ", join(directives2, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block4(selections)
  },
  Field: {
    leave({ alias, name: name2, arguments: args2, directives: directives2, selectionSet: selectionSet2 }) {
      const prefix4 = wrap("", alias, ": ") + name2;
      let argsLine = prefix4 + wrap("(", join(args2, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix4 + wrap("(\n", indent(join(args2, "\n")), "\n)");
      }
      return join([argsLine, join(directives2, " "), selectionSet2], " ");
    }
  },
  Argument: {
    leave: ({ name: name2, value: value2 }) => name2 + ": " + value2
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name: name2, directives: directives2 }) => "..." + name2 + wrap(" ", join(directives2, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition: typeCondition2, directives: directives2, selectionSet: selectionSet2 }) => join(
      [
        "...",
        wrap("on ", typeCondition2),
        join(directives2, " "),
        selectionSet2
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name: name2, typeCondition: typeCondition2, variableDefinitions, directives: directives2, selectionSet: selectionSet2 }) => (
      // or removed in the future.
      `fragment ${name2}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition2} ${wrap("", join(directives2, " "), " ")}` + selectionSet2
    )
  },
  // Value
  IntValue: {
    leave: ({ value: value2 }) => value2
  },
  FloatValue: {
    leave: ({ value: value2 }) => value2
  },
  StringValue: {
    leave: ({ value: value2, block: isBlockString }) => isBlockString ? printBlockString(value2) : printString(value2)
  },
  BooleanValue: {
    leave: ({ value: value2 }) => value2 ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: value2 }) => value2
  },
  ListValue: {
    leave: ({ values: values3 }) => "[" + join(values3, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: name2, value: value2 }) => name2 + ": " + value2
  },
  // Directive
  Directive: {
    leave: ({ name: name2, arguments: args2 }) => "@" + name2 + wrap("(", join(args2, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name: name2 }) => name2
  },
  ListType: {
    leave: ({ type: type2 }) => "[" + type2 + "]"
  },
  NonNullType: {
    leave: ({ type: type2 }) => type2 + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description, directives: directives2, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives2, " "), block4(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type: type2 }) => operation + ": " + type2
  },
  ScalarTypeDefinition: {
    leave: ({ description, name: name2, directives: directives2 }) => wrap("", description, "\n") + join(["scalar", name2, join(directives2, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name: name2, interfaces, directives: directives2, fields }) => wrap("", description, "\n") + join(
      [
        "type",
        name2,
        wrap("implements ", join(interfaces, " & ")),
        join(directives2, " "),
        block4(fields)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description, name: name2, arguments: args2, type: type2, directives: directives2 }) => wrap("", description, "\n") + name2 + (hasMultilineItems(args2) ? wrap("(\n", indent(join(args2, "\n")), "\n)") : wrap("(", join(args2, ", "), ")")) + ": " + type2 + wrap(" ", join(directives2, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name: name2, type: type2, defaultValue, directives: directives2 }) => wrap("", description, "\n") + join(
      [name2 + ": " + type2, wrap("= ", defaultValue), join(directives2, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name: name2, interfaces, directives: directives2, fields }) => wrap("", description, "\n") + join(
      [
        "interface",
        name2,
        wrap("implements ", join(interfaces, " & ")),
        join(directives2, " "),
        block4(fields)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description, name: name2, directives: directives2, types: types3 }) => wrap("", description, "\n") + join(
      ["union", name2, join(directives2, " "), wrap("= ", join(types3, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description, name: name2, directives: directives2, values: values3 }) => wrap("", description, "\n") + join(["enum", name2, join(directives2, " "), block4(values3)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name: name2, directives: directives2 }) => wrap("", description, "\n") + join([name2, join(directives2, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name: name2, directives: directives2, fields }) => wrap("", description, "\n") + join(["input", name2, join(directives2, " "), block4(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name: name2, arguments: args2, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name2 + (hasMultilineItems(args2) ? wrap("(\n", indent(join(args2, "\n")), "\n)") : wrap("(", join(args2, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: directives2, operationTypes }) => join(
      ["extend schema", join(directives2, " "), block4(operationTypes)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name: name2, directives: directives2 }) => join(["extend scalar", name2, join(directives2, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: name2, interfaces, directives: directives2, fields }) => join(
      [
        "extend type",
        name2,
        wrap("implements ", join(interfaces, " & ")),
        join(directives2, " "),
        block4(fields)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name: name2, interfaces, directives: directives2, fields }) => join(
      [
        "extend interface",
        name2,
        wrap("implements ", join(interfaces, " & ")),
        join(directives2, " "),
        block4(fields)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name: name2, directives: directives2, types: types3 }) => join(
      [
        "extend union",
        name2,
        join(directives2, " "),
        wrap("= ", join(types3, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name: name2, directives: directives2, values: values3 }) => join(["extend enum", name2, join(directives2, " "), block4(values3)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: name2, directives: directives2, fields }) => join(["extend input", name2, join(directives2, " "), block4(fields)], " ")
  }
};
function join(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x4) => x4).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block4(array) {
  return wrap("{\n", indent(join(array, "\n")), "\n}");
}
function wrap(start2, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start2 + maybeString + end : "";
}
function indent(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}

// node_modules/graphql/utilities/valueFromASTUntyped.mjs
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind.NULL:
      return null;
    case Kind.INT:
      return parseInt(valueNode.value, 10);
    case Kind.FLOAT:
      return parseFloat(valueNode.value);
    case Kind.STRING:
    case Kind.ENUM:
    case Kind.BOOLEAN:
      return valueNode.value;
    case Kind.LIST:
      return valueNode.values.map(
        (node4) => valueFromASTUntyped(node4, variables)
      );
    case Kind.OBJECT:
      return keyValMap(
        valueNode.fields,
        (field2) => field2.name.value,
        (field2) => valueFromASTUntyped(field2.value, variables)
      );
    case Kind.VARIABLE:
      return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
  }
}

// node_modules/graphql/type/assertName.mjs
function assertName(name2) {
  name2 != null || devAssert(false, "Must provide name.");
  typeof name2 === "string" || devAssert(false, "Expected name to be a string.");
  if (name2.length === 0) {
    throw new GraphQLError("Expected name to be a non-empty string.");
  }
  for (let i6 = 1; i6 < name2.length; ++i6) {
    if (!isNameContinue(name2.charCodeAt(i6))) {
      throw new GraphQLError(
        `Names must only contain [_a-zA-Z0-9] but "${name2}" does not.`
      );
    }
  }
  if (!isNameStart(name2.charCodeAt(0))) {
    throw new GraphQLError(
      `Names must start with [_a-zA-Z] but "${name2}" does not.`
    );
  }
  return name2;
}
function assertEnumValueName(name2) {
  if (name2 === "true" || name2 === "false" || name2 === "null") {
    throw new GraphQLError(`Enum values cannot be named: ${name2}`);
  }
  return assertName(name2);
}

// node_modules/graphql/type/definition.mjs
function isType(type2) {
  return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isInputObjectType(type2) || isListType(type2) || isNonNullType(type2);
}
function isScalarType(type2) {
  return instanceOf(type2, GraphQLScalarType);
}
function isObjectType(type2) {
  return instanceOf(type2, GraphQLObjectType);
}
function isInterfaceType(type2) {
  return instanceOf(type2, GraphQLInterfaceType);
}
function isUnionType(type2) {
  return instanceOf(type2, GraphQLUnionType);
}
function isEnumType(type2) {
  return instanceOf(type2, GraphQLEnumType);
}
function isInputObjectType(type2) {
  return instanceOf(type2, GraphQLInputObjectType);
}
function isListType(type2) {
  return instanceOf(type2, GraphQLList);
}
function isNonNullType(type2) {
  return instanceOf(type2, GraphQLNonNull);
}
function isInputType(type2) {
  return isScalarType(type2) || isEnumType(type2) || isInputObjectType(type2) || isWrappingType(type2) && isInputType(type2.ofType);
}
function isLeafType(type2) {
  return isScalarType(type2) || isEnumType(type2);
}
function isCompositeType(type2) {
  return isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2);
}
function isAbstractType(type2) {
  return isInterfaceType(type2) || isUnionType(type2);
}
var GraphQLList = class {
  constructor(ofType) {
    isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLList";
  }
  toString() {
    return "[" + String(this.ofType) + "]";
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLNonNull = class {
  constructor(ofType) {
    isNullableType(ofType) || devAssert(
      false,
      `Expected ${inspect(ofType)} to be a GraphQL nullable type.`
    );
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLNonNull";
  }
  toString() {
    return String(this.ofType) + "!";
  }
  toJSON() {
    return this.toString();
  }
};
function isWrappingType(type2) {
  return isListType(type2) || isNonNullType(type2);
}
function isNullableType(type2) {
  return isType(type2) && !isNonNullType(type2);
}
function getNullableType(type2) {
  if (type2) {
    return isNonNullType(type2) ? type2.ofType : type2;
  }
}
function getNamedType(type2) {
  if (type2) {
    let unwrappedType = type2;
    while (isWrappingType(unwrappedType)) {
      unwrappedType = unwrappedType.ofType;
    }
    return unwrappedType;
  }
}
function resolveReadonlyArrayThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function resolveObjMapThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
var GraphQLScalarType = class {
  constructor(config3) {
    var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
    const parseValue2 = (_config$parseValue = config3.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;
    this.name = assertName(config3.name);
    this.description = config3.description;
    this.specifiedByURL = config3.specifiedByURL;
    this.serialize = (_config$serialize = config3.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;
    this.parseValue = parseValue2;
    this.parseLiteral = (_config$parseLiteral = config3.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node4, variables) => parseValue2(valueFromASTUntyped(node4, variables));
    this.extensions = toObjMap(config3.extensions);
    this.astNode = config3.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config3.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
    config3.specifiedByURL == null || typeof config3.specifiedByURL === "string" || devAssert(
      false,
      `${this.name} must provide "specifiedByURL" as a string, but got: ${inspect(config3.specifiedByURL)}.`
    );
    config3.serialize == null || typeof config3.serialize === "function" || devAssert(
      false,
      `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
    );
    if (config3.parseLiteral) {
      typeof config3.parseValue === "function" && typeof config3.parseLiteral === "function" || devAssert(
        false,
        `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
      );
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLScalarType";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      specifiedByURL: this.specifiedByURL,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLObjectType = class {
  constructor(config3) {
    var _config$extensionASTN2;
    this.name = assertName(config3.name);
    this.description = config3.description;
    this.isTypeOf = config3.isTypeOf;
    this.extensions = toObjMap(config3.extensions);
    this.astNode = config3.astNode;
    this.extensionASTNodes = (_config$extensionASTN2 = config3.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
    this._fields = () => defineFieldMap(config3);
    this._interfaces = () => defineInterfaces(config3);
    config3.isTypeOf == null || typeof config3.isTypeOf === "function" || devAssert(
      false,
      `${this.name} must provide "isTypeOf" as a function, but got: ${inspect(config3.isTypeOf)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineInterfaces(config3) {
  var _config$interfaces;
  const interfaces = resolveReadonlyArrayThunk(
    (_config$interfaces = config3.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []
  );
  Array.isArray(interfaces) || devAssert(
    false,
    `${config3.name} interfaces must be an Array or a function which returns an Array.`
  );
  return interfaces;
}
function defineFieldMap(config3) {
  const fieldMap = resolveObjMapThunk(config3.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config3.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    var _fieldConfig$args;
    isPlainObj(fieldConfig) || devAssert(
      false,
      `${config3.name}.${fieldName} field config must be an object.`
    );
    fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(
      false,
      `${config3.name}.${fieldName} field resolver must be a function if provided, but got: ${inspect(fieldConfig.resolve)}.`
    );
    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
    isPlainObj(argsConfig) || devAssert(
      false,
      `${config3.name}.${fieldName} args must be an object with argument names as keys.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: defineArguments(argsConfig),
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function defineArguments(config3) {
  return Object.entries(config3).map(([argName, argConfig]) => ({
    name: assertName(argName),
    description: argConfig.description,
    type: argConfig.type,
    defaultValue: argConfig.defaultValue,
    deprecationReason: argConfig.deprecationReason,
    extensions: toObjMap(argConfig.extensions),
    astNode: argConfig.astNode
  }));
}
function isPlainObj(obj) {
  return isObjectLike(obj) && !Array.isArray(obj);
}
function fieldsToFieldsConfig(fields) {
  return mapValue(fields, (field2) => ({
    description: field2.description,
    type: field2.type,
    args: argsToArgsConfig(field2.args),
    resolve: field2.resolve,
    subscribe: field2.subscribe,
    deprecationReason: field2.deprecationReason,
    extensions: field2.extensions,
    astNode: field2.astNode
  }));
}
function argsToArgsConfig(args2) {
  return keyValMap(
    args2,
    (arg) => arg.name,
    (arg) => ({
      description: arg.description,
      type: arg.type,
      defaultValue: arg.defaultValue,
      deprecationReason: arg.deprecationReason,
      extensions: arg.extensions,
      astNode: arg.astNode
    })
  );
}
function isRequiredArgument(arg) {
  return isNonNullType(arg.type) && arg.defaultValue === void 0;
}
var GraphQLInterfaceType = class {
  constructor(config3) {
    var _config$extensionASTN3;
    this.name = assertName(config3.name);
    this.description = config3.description;
    this.resolveType = config3.resolveType;
    this.extensions = toObjMap(config3.extensions);
    this.astNode = config3.astNode;
    this.extensionASTNodes = (_config$extensionASTN3 = config3.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
    this._fields = defineFieldMap.bind(void 0, config3);
    this._interfaces = defineInterfaces.bind(void 0, config3);
    config3.resolveType == null || typeof config3.resolveType === "function" || devAssert(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect(config3.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInterfaceType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLUnionType = class {
  constructor(config3) {
    var _config$extensionASTN4;
    this.name = assertName(config3.name);
    this.description = config3.description;
    this.resolveType = config3.resolveType;
    this.extensions = toObjMap(config3.extensions);
    this.astNode = config3.astNode;
    this.extensionASTNodes = (_config$extensionASTN4 = config3.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
    this._types = defineTypes.bind(void 0, config3);
    config3.resolveType == null || typeof config3.resolveType === "function" || devAssert(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect(config3.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLUnionType";
  }
  getTypes() {
    if (typeof this._types === "function") {
      this._types = this._types();
    }
    return this._types;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineTypes(config3) {
  const types3 = resolveReadonlyArrayThunk(config3.types);
  Array.isArray(types3) || devAssert(
    false,
    `Must provide Array of types or a function which returns such an array for Union ${config3.name}.`
  );
  return types3;
}
var GraphQLEnumType = class {
  /* <T> */
  constructor(config3) {
    var _config$extensionASTN5;
    this.name = assertName(config3.name);
    this.description = config3.description;
    this.extensions = toObjMap(config3.extensions);
    this.astNode = config3.astNode;
    this.extensionASTNodes = (_config$extensionASTN5 = config3.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
    this._values = defineEnumValues(this.name, config3.values);
    this._valueLookup = new Map(
      this._values.map((enumValue) => [enumValue.value, enumValue])
    );
    this._nameLookup = keyMap(this._values, (value2) => value2.name);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLEnumType";
  }
  getValues() {
    return this._values;
  }
  getValue(name2) {
    return this._nameLookup[name2];
  }
  serialize(outputValue) {
    const enumValue = this._valueLookup.get(outputValue);
    if (enumValue === void 0) {
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent value: ${inspect(outputValue)}`
      );
    }
    return enumValue.name;
  }
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      const valueStr = inspect(inputValue);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr)
      );
    }
    const enumValue = this.getValue(inputValue);
    if (enumValue == null) {
      throw new GraphQLError(
        `Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue)
      );
    }
    return enumValue.value;
  }
  parseLiteral(valueNode, _variables) {
    if (valueNode.kind !== Kind.ENUM) {
      const valueStr = print2(valueNode);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    const enumValue = this.getValue(valueNode.value);
    if (enumValue == null) {
      const valueStr = print2(valueNode);
      throw new GraphQLError(
        `Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    return enumValue.value;
  }
  toConfig() {
    const values3 = keyValMap(
      this.getValues(),
      (value2) => value2.name,
      (value2) => ({
        description: value2.description,
        value: value2.value,
        deprecationReason: value2.deprecationReason,
        extensions: value2.extensions,
        astNode: value2.astNode
      })
    );
    return {
      name: this.name,
      description: this.description,
      values: values3,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function didYouMeanEnumValue(enumType, unknownValueStr) {
  const allNames = enumType.getValues().map((value2) => value2.name);
  const suggestedValues = suggestionList(unknownValueStr, allNames);
  return didYouMean("the enum value", suggestedValues);
}
function defineEnumValues(typeName, valueMap) {
  isPlainObj(valueMap) || devAssert(
    false,
    `${typeName} values must be an object with value names as keys.`
  );
  return Object.entries(valueMap).map(([valueName, valueConfig]) => {
    isPlainObj(valueConfig) || devAssert(
      false,
      `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${inspect(valueConfig)}.`
    );
    return {
      name: assertEnumValueName(valueName),
      description: valueConfig.description,
      value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
      deprecationReason: valueConfig.deprecationReason,
      extensions: toObjMap(valueConfig.extensions),
      astNode: valueConfig.astNode
    };
  });
}
var GraphQLInputObjectType = class {
  constructor(config3) {
    var _config$extensionASTN6;
    this.name = assertName(config3.name);
    this.description = config3.description;
    this.extensions = toObjMap(config3.extensions);
    this.astNode = config3.astNode;
    this.extensionASTNodes = (_config$extensionASTN6 = config3.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
    this._fields = defineInputFieldMap.bind(void 0, config3);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInputObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  toConfig() {
    const fields = mapValue(this.getFields(), (field2) => ({
      description: field2.description,
      type: field2.type,
      defaultValue: field2.defaultValue,
      deprecationReason: field2.deprecationReason,
      extensions: field2.extensions,
      astNode: field2.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      fields,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineInputFieldMap(config3) {
  const fieldMap = resolveObjMapThunk(config3.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config3.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    !("resolve" in fieldConfig) || devAssert(
      false,
      `${config3.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function isRequiredInputField(field2) {
  return isNonNullType(field2.type) && field2.defaultValue === void 0;
}

// node_modules/graphql/utilities/typeComparators.mjs
function isTypeSubTypeOf(schema, maybeSubType, superType) {
  if (maybeSubType === superType) {
    return true;
  }
  if (isNonNullType(superType)) {
    if (isNonNullType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isNonNullType(maybeSubType)) {
    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
  }
  if (isListType(superType)) {
    if (isListType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isListType(maybeSubType)) {
    return false;
  }
  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);
}
function doTypesOverlap(schema, typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isAbstractType(typeA)) {
    if (isAbstractType(typeB)) {
      return schema.getPossibleTypes(typeA).some((type2) => schema.isSubType(typeB, type2));
    }
    return schema.isSubType(typeA, typeB);
  }
  if (isAbstractType(typeB)) {
    return schema.isSubType(typeB, typeA);
  }
  return false;
}

// node_modules/graphql/type/scalars.mjs
var GRAPHQL_MAX_INT = 2147483647;
var GRAPHQL_MIN_INT = -2147483648;
var GraphQLInt = new GraphQLScalarType({
  name: "Int",
  description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isInteger(num)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect(coercedValue)}`
      );
    }
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        "Int cannot represent non 32-bit signed integer value: " + inspect(coercedValue)
      );
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect(inputValue)}`
      );
    }
    if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${inputValue}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${print2(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    const num = parseInt(valueNode.value, 10);
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${valueNode.value}`,
        {
          nodes: valueNode
        }
      );
    }
    return num;
  }
});
var GraphQLFloat = new GraphQLScalarType({
  name: "Float",
  description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isFinite(num)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect(coercedValue)}`
      );
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${print2(valueNode)}`,
        valueNode
      );
    }
    return parseFloat(valueNode.value);
  }
});
var GraphQLString = new GraphQLScalarType({
  name: "String",
  description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (typeof coercedValue === "boolean") {
      return coercedValue ? "true" : "false";
    }
    if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
      return coercedValue.toString();
    }
    throw new GraphQLError(
      `String cannot represent value: ${inspect(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      throw new GraphQLError(
        `String cannot represent a non string value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING) {
      throw new GraphQLError(
        `String cannot represent a non string value: ${print2(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var GraphQLBoolean = new GraphQLScalarType({
  name: "Boolean",
  description: "The `Boolean` scalar type represents `true` or `false`.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue;
    }
    if (Number.isFinite(coercedValue)) {
      return coercedValue !== 0;
    }
    throw new GraphQLError(
      `Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "boolean") {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.BOOLEAN) {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${print2(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var GraphQLID = new GraphQLScalarType({
  name: "ID",
  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (Number.isInteger(coercedValue)) {
      return String(coercedValue);
    }
    throw new GraphQLError(
      `ID cannot represent value: ${inspect(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue === "string") {
      return inputValue;
    }
    if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
      return inputValue.toString();
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`);
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        "ID cannot represent a non-string and non-integer value: " + print2(valueNode),
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var specifiedScalarTypes = Object.freeze([
  GraphQLString,
  GraphQLInt,
  GraphQLFloat,
  GraphQLBoolean,
  GraphQLID
]);
function serializeObject(outputValue) {
  if (isObjectLike(outputValue)) {
    if (typeof outputValue.valueOf === "function") {
      const valueOfResult = outputValue.valueOf();
      if (!isObjectLike(valueOfResult)) {
        return valueOfResult;
      }
    }
    if (typeof outputValue.toJSON === "function") {
      return outputValue.toJSON();
    }
  }
  return outputValue;
}

// node_modules/graphql/type/directives.mjs
var GraphQLDirective = class {
  constructor(config3) {
    var _config$isRepeatable, _config$args;
    this.name = assertName(config3.name);
    this.description = config3.description;
    this.locations = config3.locations;
    this.isRepeatable = (_config$isRepeatable = config3.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
    this.extensions = toObjMap(config3.extensions);
    this.astNode = config3.astNode;
    Array.isArray(config3.locations) || devAssert(false, `@${config3.name} locations must be an Array.`);
    const args2 = (_config$args = config3.args) !== null && _config$args !== void 0 ? _config$args : {};
    isObjectLike(args2) && !Array.isArray(args2) || devAssert(
      false,
      `@${config3.name} args must be an object with argument names as keys.`
    );
    this.args = defineArguments(args2);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLDirective";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      locations: this.locations,
      args: argsToArgsConfig(this.args),
      isRepeatable: this.isRepeatable,
      extensions: this.extensions,
      astNode: this.astNode
    };
  }
  toString() {
    return "@" + this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLIncludeDirective = new GraphQLDirective({
  name: "include",
  description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Included when true."
    }
  }
});
var GraphQLSkipDirective = new GraphQLDirective({
  name: "skip",
  description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Skipped when true."
    }
  }
});
var DEFAULT_DEPRECATION_REASON = "No longer supported";
var GraphQLDeprecatedDirective = new GraphQLDirective({
  name: "deprecated",
  description: "Marks an element of a GraphQL schema as no longer supported.",
  locations: [
    DirectiveLocation.FIELD_DEFINITION,
    DirectiveLocation.ARGUMENT_DEFINITION,
    DirectiveLocation.INPUT_FIELD_DEFINITION,
    DirectiveLocation.ENUM_VALUE
  ],
  args: {
    reason: {
      type: GraphQLString,
      description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
      defaultValue: DEFAULT_DEPRECATION_REASON
    }
  }
});
var GraphQLSpecifiedByDirective = new GraphQLDirective({
  name: "specifiedBy",
  description: "Exposes a URL that specifies the behavior of this scalar.",
  locations: [DirectiveLocation.SCALAR],
  args: {
    url: {
      type: new GraphQLNonNull(GraphQLString),
      description: "The URL that specifies the behavior of this scalar."
    }
  }
});
var specifiedDirectives = Object.freeze([
  GraphQLIncludeDirective,
  GraphQLSkipDirective,
  GraphQLDeprecatedDirective,
  GraphQLSpecifiedByDirective
]);

// node_modules/graphql/jsutils/isIterableObject.mjs
function isIterableObject(maybeIterable) {
  return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
}

// node_modules/graphql/utilities/astFromValue.mjs
function astFromValue(value2, type2) {
  if (isNonNullType(type2)) {
    const astValue = astFromValue(value2, type2.ofType);
    if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value2 === null) {
    return {
      kind: Kind.NULL
    };
  }
  if (value2 === void 0) {
    return null;
  }
  if (isListType(type2)) {
    const itemType = type2.ofType;
    if (isIterableObject(value2)) {
      const valuesNodes = [];
      for (const item2 of value2) {
        const itemNode = astFromValue(item2, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return {
        kind: Kind.LIST,
        values: valuesNodes
      };
    }
    return astFromValue(value2, itemType);
  }
  if (isInputObjectType(type2)) {
    if (!isObjectLike(value2)) {
      return null;
    }
    const fieldNodes = [];
    for (const field2 of Object.values(type2.getFields())) {
      const fieldValue = astFromValue(value2[field2.name], field2.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind.OBJECT_FIELD,
          name: {
            kind: Kind.NAME,
            value: field2.name
          },
          value: fieldValue
        });
      }
    }
    return {
      kind: Kind.OBJECT,
      fields: fieldNodes
    };
  }
  if (isLeafType(type2)) {
    const serialized = type2.serialize(value2);
    if (serialized == null) {
      return null;
    }
    if (typeof serialized === "boolean") {
      return {
        kind: Kind.BOOLEAN,
        value: serialized
      };
    }
    if (typeof serialized === "number" && Number.isFinite(serialized)) {
      const stringNum = String(serialized);
      return integerStringRegExp.test(stringNum) ? {
        kind: Kind.INT,
        value: stringNum
      } : {
        kind: Kind.FLOAT,
        value: stringNum
      };
    }
    if (typeof serialized === "string") {
      if (isEnumType(type2)) {
        return {
          kind: Kind.ENUM,
          value: serialized
        };
      }
      if (type2 === GraphQLID && integerStringRegExp.test(serialized)) {
        return {
          kind: Kind.INT,
          value: serialized
        };
      }
      return {
        kind: Kind.STRING,
        value: serialized
      };
    }
    throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);
  }
  invariant(false, "Unexpected input type: " + inspect(type2));
}
var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;

// node_modules/graphql/type/introspection.mjs
var __Schema = new GraphQLObjectType({
  name: "__Schema",
  description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
  fields: () => ({
    description: {
      type: GraphQLString,
      resolve: (schema) => schema.description
    },
    types: {
      description: "A list of all types supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
      resolve(schema) {
        return Object.values(schema.getTypeMap());
      }
    },
    queryType: {
      description: "The type that query operations will be rooted at.",
      type: new GraphQLNonNull(__Type),
      resolve: (schema) => schema.getQueryType()
    },
    mutationType: {
      description: "If this server supports mutation, the type that mutation operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getMutationType()
    },
    subscriptionType: {
      description: "If this server support subscription, the type that subscription operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getSubscriptionType()
    },
    directives: {
      description: "A list of all directives supported by this server.",
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__Directive))
      ),
      resolve: (schema) => schema.getDirectives()
    }
  })
});
var __Directive = new GraphQLObjectType({
  name: "__Directive",
  description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (directive) => directive.name
    },
    description: {
      type: GraphQLString,
      resolve: (directive) => directive.description
    },
    isRepeatable: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (directive) => directive.isRepeatable
    },
    locations: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__DirectiveLocation))
      ),
      resolve: (directive) => directive.locations
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field2, { includeDeprecated }) {
        return includeDeprecated ? field2.args : field2.args.filter((arg) => arg.deprecationReason == null);
      }
    }
  })
});
var __DirectiveLocation = new GraphQLEnumType({
  name: "__DirectiveLocation",
  description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
  values: {
    QUERY: {
      value: DirectiveLocation.QUERY,
      description: "Location adjacent to a query operation."
    },
    MUTATION: {
      value: DirectiveLocation.MUTATION,
      description: "Location adjacent to a mutation operation."
    },
    SUBSCRIPTION: {
      value: DirectiveLocation.SUBSCRIPTION,
      description: "Location adjacent to a subscription operation."
    },
    FIELD: {
      value: DirectiveLocation.FIELD,
      description: "Location adjacent to a field."
    },
    FRAGMENT_DEFINITION: {
      value: DirectiveLocation.FRAGMENT_DEFINITION,
      description: "Location adjacent to a fragment definition."
    },
    FRAGMENT_SPREAD: {
      value: DirectiveLocation.FRAGMENT_SPREAD,
      description: "Location adjacent to a fragment spread."
    },
    INLINE_FRAGMENT: {
      value: DirectiveLocation.INLINE_FRAGMENT,
      description: "Location adjacent to an inline fragment."
    },
    VARIABLE_DEFINITION: {
      value: DirectiveLocation.VARIABLE_DEFINITION,
      description: "Location adjacent to a variable definition."
    },
    SCHEMA: {
      value: DirectiveLocation.SCHEMA,
      description: "Location adjacent to a schema definition."
    },
    SCALAR: {
      value: DirectiveLocation.SCALAR,
      description: "Location adjacent to a scalar definition."
    },
    OBJECT: {
      value: DirectiveLocation.OBJECT,
      description: "Location adjacent to an object type definition."
    },
    FIELD_DEFINITION: {
      value: DirectiveLocation.FIELD_DEFINITION,
      description: "Location adjacent to a field definition."
    },
    ARGUMENT_DEFINITION: {
      value: DirectiveLocation.ARGUMENT_DEFINITION,
      description: "Location adjacent to an argument definition."
    },
    INTERFACE: {
      value: DirectiveLocation.INTERFACE,
      description: "Location adjacent to an interface definition."
    },
    UNION: {
      value: DirectiveLocation.UNION,
      description: "Location adjacent to a union definition."
    },
    ENUM: {
      value: DirectiveLocation.ENUM,
      description: "Location adjacent to an enum definition."
    },
    ENUM_VALUE: {
      value: DirectiveLocation.ENUM_VALUE,
      description: "Location adjacent to an enum value definition."
    },
    INPUT_OBJECT: {
      value: DirectiveLocation.INPUT_OBJECT,
      description: "Location adjacent to an input object type definition."
    },
    INPUT_FIELD_DEFINITION: {
      value: DirectiveLocation.INPUT_FIELD_DEFINITION,
      description: "Location adjacent to an input object field definition."
    }
  }
});
var __Type = new GraphQLObjectType({
  name: "__Type",
  description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
  fields: () => ({
    kind: {
      type: new GraphQLNonNull(__TypeKind),
      resolve(type2) {
        if (isScalarType(type2)) {
          return TypeKind.SCALAR;
        }
        if (isObjectType(type2)) {
          return TypeKind.OBJECT;
        }
        if (isInterfaceType(type2)) {
          return TypeKind.INTERFACE;
        }
        if (isUnionType(type2)) {
          return TypeKind.UNION;
        }
        if (isEnumType(type2)) {
          return TypeKind.ENUM;
        }
        if (isInputObjectType(type2)) {
          return TypeKind.INPUT_OBJECT;
        }
        if (isListType(type2)) {
          return TypeKind.LIST;
        }
        if (isNonNullType(type2)) {
          return TypeKind.NON_NULL;
        }
        invariant(false, `Unexpected type: "${inspect(type2)}".`);
      }
    },
    name: {
      type: GraphQLString,
      resolve: (type2) => "name" in type2 ? type2.name : void 0
    },
    description: {
      type: GraphQLString,
      resolve: (type2) => (
        /* c8 ignore next */
        "description" in type2 ? type2.description : void 0
      )
    },
    specifiedByURL: {
      type: GraphQLString,
      resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
    },
    fields: {
      type: new GraphQLList(new GraphQLNonNull(__Field)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type2, { includeDeprecated }) {
        if (isObjectType(type2) || isInterfaceType(type2)) {
          const fields = Object.values(type2.getFields());
          return includeDeprecated ? fields : fields.filter((field2) => field2.deprecationReason == null);
        }
      }
    },
    interfaces: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type2) {
        if (isObjectType(type2) || isInterfaceType(type2)) {
          return type2.getInterfaces();
        }
      }
    },
    possibleTypes: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type2, _args, _context, { schema }) {
        if (isAbstractType(type2)) {
          return schema.getPossibleTypes(type2);
        }
      }
    },
    enumValues: {
      type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type2, { includeDeprecated }) {
        if (isEnumType(type2)) {
          const values3 = type2.getValues();
          return includeDeprecated ? values3 : values3.filter((field2) => field2.deprecationReason == null);
        }
      }
    },
    inputFields: {
      type: new GraphQLList(new GraphQLNonNull(__InputValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type2, { includeDeprecated }) {
        if (isInputObjectType(type2)) {
          const values3 = Object.values(type2.getFields());
          return includeDeprecated ? values3 : values3.filter((field2) => field2.deprecationReason == null);
        }
      }
    },
    ofType: {
      type: __Type,
      resolve: (type2) => "ofType" in type2 ? type2.ofType : void 0
    }
  })
});
var __Field = new GraphQLObjectType({
  name: "__Field",
  description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (field2) => field2.name
    },
    description: {
      type: GraphQLString,
      resolve: (field2) => field2.description
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field2, { includeDeprecated }) {
        return includeDeprecated ? field2.args : field2.args.filter((arg) => arg.deprecationReason == null);
      }
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (field2) => field2.type
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field2) => field2.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (field2) => field2.deprecationReason
    }
  })
});
var __InputValue = new GraphQLObjectType({
  name: "__InputValue",
  description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (inputValue) => inputValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (inputValue) => inputValue.description
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (inputValue) => inputValue.type
    },
    defaultValue: {
      type: GraphQLString,
      description: "A GraphQL-formatted string representing the default value for this input value.",
      resolve(inputValue) {
        const { type: type2, defaultValue } = inputValue;
        const valueAST = astFromValue(defaultValue, type2);
        return valueAST ? print2(valueAST) : null;
      }
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field2) => field2.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (obj) => obj.deprecationReason
    }
  })
});
var __EnumValue = new GraphQLObjectType({
  name: "__EnumValue",
  description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (enumValue) => enumValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.description
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (enumValue) => enumValue.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.deprecationReason
    }
  })
});
var TypeKind;
(function(TypeKind2) {
  TypeKind2["SCALAR"] = "SCALAR";
  TypeKind2["OBJECT"] = "OBJECT";
  TypeKind2["INTERFACE"] = "INTERFACE";
  TypeKind2["UNION"] = "UNION";
  TypeKind2["ENUM"] = "ENUM";
  TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
  TypeKind2["LIST"] = "LIST";
  TypeKind2["NON_NULL"] = "NON_NULL";
})(TypeKind || (TypeKind = {}));
var __TypeKind = new GraphQLEnumType({
  name: "__TypeKind",
  description: "An enum describing what kind of type a given `__Type` is.",
  values: {
    SCALAR: {
      value: TypeKind.SCALAR,
      description: "Indicates this type is a scalar."
    },
    OBJECT: {
      value: TypeKind.OBJECT,
      description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
    },
    INTERFACE: {
      value: TypeKind.INTERFACE,
      description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
    },
    UNION: {
      value: TypeKind.UNION,
      description: "Indicates this type is a union. `possibleTypes` is a valid field."
    },
    ENUM: {
      value: TypeKind.ENUM,
      description: "Indicates this type is an enum. `enumValues` is a valid field."
    },
    INPUT_OBJECT: {
      value: TypeKind.INPUT_OBJECT,
      description: "Indicates this type is an input object. `inputFields` is a valid field."
    },
    LIST: {
      value: TypeKind.LIST,
      description: "Indicates this type is a list. `ofType` is a valid field."
    },
    NON_NULL: {
      value: TypeKind.NON_NULL,
      description: "Indicates this type is a non-null. `ofType` is a valid field."
    }
  }
});
var SchemaMetaFieldDef = {
  name: "__schema",
  type: new GraphQLNonNull(__Schema),
  description: "Access the current type schema of this server.",
  args: [],
  resolve: (_source, _args, _context, { schema }) => schema,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var TypeMetaFieldDef = {
  name: "__type",
  type: __Type,
  description: "Request the type information of a single type.",
  args: [
    {
      name: "name",
      description: void 0,
      type: new GraphQLNonNull(GraphQLString),
      defaultValue: void 0,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    }
  ],
  resolve: (_source, { name: name2 }, _context, { schema }) => schema.getType(name2),
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var TypeNameMetaFieldDef = {
  name: "__typename",
  type: new GraphQLNonNull(GraphQLString),
  description: "The name of the current Object type at runtime.",
  args: [],
  resolve: (_source, _args, _context, { parentType }) => parentType.name,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var introspectionTypes = Object.freeze([
  __Schema,
  __Directive,
  __DirectiveLocation,
  __Type,
  __Field,
  __InputValue,
  __EnumValue,
  __TypeKind
]);

// node_modules/graphql/utilities/typeFromAST.mjs
function typeFromAST(schema, typeNode) {
  switch (typeNode.kind) {
    case Kind.LIST_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLList(innerType);
    }
    case Kind.NON_NULL_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLNonNull(innerType);
    }
    case Kind.NAMED_TYPE:
      return schema.getType(typeNode.name.value);
  }
}

// node_modules/graphql/language/predicates.mjs
function isExecutableDefinitionNode(node4) {
  return node4.kind === Kind.OPERATION_DEFINITION || node4.kind === Kind.FRAGMENT_DEFINITION;
}
function isTypeSystemDefinitionNode(node4) {
  return node4.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node4) || node4.kind === Kind.DIRECTIVE_DEFINITION;
}
function isTypeDefinitionNode(node4) {
  return node4.kind === Kind.SCALAR_TYPE_DEFINITION || node4.kind === Kind.OBJECT_TYPE_DEFINITION || node4.kind === Kind.INTERFACE_TYPE_DEFINITION || node4.kind === Kind.UNION_TYPE_DEFINITION || node4.kind === Kind.ENUM_TYPE_DEFINITION || node4.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;
}
function isTypeSystemExtensionNode(node4) {
  return node4.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node4);
}
function isTypeExtensionNode(node4) {
  return node4.kind === Kind.SCALAR_TYPE_EXTENSION || node4.kind === Kind.OBJECT_TYPE_EXTENSION || node4.kind === Kind.INTERFACE_TYPE_EXTENSION || node4.kind === Kind.UNION_TYPE_EXTENSION || node4.kind === Kind.ENUM_TYPE_EXTENSION || node4.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;
}

// node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs
function ExecutableDefinitionsRule(context) {
  return {
    Document(node4) {
      for (const definition2 of node4.definitions) {
        if (!isExecutableDefinitionNode(definition2)) {
          const defName = definition2.kind === Kind.SCHEMA_DEFINITION || definition2.kind === Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition2.name.value + '"';
          context.reportError(
            new GraphQLError(`The ${defName} definition is not executable.`, {
              nodes: definition2
            })
          );
        }
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs
function FieldsOnCorrectTypeRule(context) {
  return {
    Field(node4) {
      const type2 = context.getParentType();
      if (type2) {
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          const schema = context.getSchema();
          const fieldName = node4.name.value;
          let suggestion = didYouMean(
            "to use an inline fragment on",
            getSuggestedTypeNames(schema, type2, fieldName)
          );
          if (suggestion === "") {
            suggestion = didYouMean(getSuggestedFieldNames(type2, fieldName));
          }
          context.reportError(
            new GraphQLError(
              `Cannot query field "${fieldName}" on type "${type2.name}".` + suggestion,
              {
                nodes: node4
              }
            )
          );
        }
      }
    }
  };
}
function getSuggestedTypeNames(schema, type2, fieldName) {
  if (!isAbstractType(type2)) {
    return [];
  }
  const suggestedTypes = /* @__PURE__ */ new Set();
  const usageCount = /* @__PURE__ */ Object.create(null);
  for (const possibleType of schema.getPossibleTypes(type2)) {
    if (!possibleType.getFields()[fieldName]) {
      continue;
    }
    suggestedTypes.add(possibleType);
    usageCount[possibleType.name] = 1;
    for (const possibleInterface of possibleType.getInterfaces()) {
      var _usageCount$possibleI;
      if (!possibleInterface.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleInterface);
      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
    }
  }
  return [...suggestedTypes].sort((typeA, typeB) => {
    const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
    if (usageCountDiff !== 0) {
      return usageCountDiff;
    }
    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {
      return -1;
    }
    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {
      return 1;
    }
    return naturalCompare(typeA.name, typeB.name);
  }).map((x4) => x4.name);
}
function getSuggestedFieldNames(type2, fieldName) {
  if (isObjectType(type2) || isInterfaceType(type2)) {
    const possibleFieldNames = Object.keys(type2.getFields());
    return suggestionList(fieldName, possibleFieldNames);
  }
  return [];
}

// node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs
function FragmentsOnCompositeTypesRule(context) {
  return {
    InlineFragment(node4) {
      const typeCondition2 = node4.typeCondition;
      if (typeCondition2) {
        const type2 = typeFromAST(context.getSchema(), typeCondition2);
        if (type2 && !isCompositeType(type2)) {
          const typeStr = print2(typeCondition2);
          context.reportError(
            new GraphQLError(
              `Fragment cannot condition on non composite type "${typeStr}".`,
              {
                nodes: typeCondition2
              }
            )
          );
        }
      }
    },
    FragmentDefinition(node4) {
      const type2 = typeFromAST(context.getSchema(), node4.typeCondition);
      if (type2 && !isCompositeType(type2)) {
        const typeStr = print2(node4.typeCondition);
        context.reportError(
          new GraphQLError(
            `Fragment "${node4.name.value}" cannot condition on non composite type "${typeStr}".`,
            {
              nodes: node4.typeCondition
            }
          )
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs
function KnownArgumentNamesRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...KnownArgumentNamesOnDirectivesRule(context),
    Argument(argNode) {
      const argDef = context.getArgument();
      const fieldDef = context.getFieldDef();
      const parentType = context.getParentType();
      if (!argDef && fieldDef && parentType) {
        const argName = argNode.name.value;
        const knownArgsNames = fieldDef.args.map((arg) => arg.name);
        const suggestions = suggestionList(argName, knownArgsNames);
        context.reportError(
          new GraphQLError(
            `Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + didYouMean(suggestions),
            {
              nodes: argNode
            }
          )
        );
      }
    }
  };
}
function KnownArgumentNamesOnDirectivesRule(context) {
  const directiveArgs = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
    }
  }
  return {
    Directive(directiveNode) {
      const directiveName = directiveNode.name.value;
      const knownArgs = directiveArgs[directiveName];
      if (directiveNode.arguments && knownArgs) {
        for (const argNode of directiveNode.arguments) {
          const argName = argNode.name.value;
          if (!knownArgs.includes(argName)) {
            const suggestions = suggestionList(argName, knownArgs);
            context.reportError(
              new GraphQLError(
                `Unknown argument "${argName}" on directive "@${directiveName}".` + didYouMean(suggestions),
                {
                  nodes: argNode
                }
              )
            );
          }
        }
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/KnownDirectivesRule.mjs
function KnownDirectivesRule(context) {
  const locationsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    locationsMap[directive.name] = directive.locations;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      locationsMap[def.name.value] = def.locations.map((name2) => name2.value);
    }
  }
  return {
    Directive(node4, _key, _parent2, _path, ancestors) {
      const name2 = node4.name.value;
      const locations = locationsMap[name2];
      if (!locations) {
        context.reportError(
          new GraphQLError(`Unknown directive "@${name2}".`, {
            nodes: node4
          })
        );
        return;
      }
      const candidateLocation = getDirectiveLocationForASTPath(ancestors);
      if (candidateLocation && !locations.includes(candidateLocation)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${name2}" may not be used on ${candidateLocation}.`,
            {
              nodes: node4
            }
          )
        );
      }
    }
  };
}
function getDirectiveLocationForASTPath(ancestors) {
  const appliedTo = ancestors[ancestors.length - 1];
  "kind" in appliedTo || invariant(false);
  switch (appliedTo.kind) {
    case Kind.OPERATION_DEFINITION:
      return getDirectiveLocationForOperation(appliedTo.operation);
    case Kind.FIELD:
      return DirectiveLocation.FIELD;
    case Kind.FRAGMENT_SPREAD:
      return DirectiveLocation.FRAGMENT_SPREAD;
    case Kind.INLINE_FRAGMENT:
      return DirectiveLocation.INLINE_FRAGMENT;
    case Kind.FRAGMENT_DEFINITION:
      return DirectiveLocation.FRAGMENT_DEFINITION;
    case Kind.VARIABLE_DEFINITION:
      return DirectiveLocation.VARIABLE_DEFINITION;
    case Kind.SCHEMA_DEFINITION:
    case Kind.SCHEMA_EXTENSION:
      return DirectiveLocation.SCHEMA;
    case Kind.SCALAR_TYPE_DEFINITION:
    case Kind.SCALAR_TYPE_EXTENSION:
      return DirectiveLocation.SCALAR;
    case Kind.OBJECT_TYPE_DEFINITION:
    case Kind.OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.OBJECT;
    case Kind.FIELD_DEFINITION:
      return DirectiveLocation.FIELD_DEFINITION;
    case Kind.INTERFACE_TYPE_DEFINITION:
    case Kind.INTERFACE_TYPE_EXTENSION:
      return DirectiveLocation.INTERFACE;
    case Kind.UNION_TYPE_DEFINITION:
    case Kind.UNION_TYPE_EXTENSION:
      return DirectiveLocation.UNION;
    case Kind.ENUM_TYPE_DEFINITION:
    case Kind.ENUM_TYPE_EXTENSION:
      return DirectiveLocation.ENUM;
    case Kind.ENUM_VALUE_DEFINITION:
      return DirectiveLocation.ENUM_VALUE;
    case Kind.INPUT_OBJECT_TYPE_DEFINITION:
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.INPUT_OBJECT;
    case Kind.INPUT_VALUE_DEFINITION: {
      const parentNode = ancestors[ancestors.length - 3];
      "kind" in parentNode || invariant(false);
      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
    }
    default:
      invariant(false, "Unexpected kind: " + inspect(appliedTo.kind));
  }
}
function getDirectiveLocationForOperation(operation) {
  switch (operation) {
    case OperationTypeNode.QUERY:
      return DirectiveLocation.QUERY;
    case OperationTypeNode.MUTATION:
      return DirectiveLocation.MUTATION;
    case OperationTypeNode.SUBSCRIPTION:
      return DirectiveLocation.SUBSCRIPTION;
  }
}

// node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs
function KnownFragmentNamesRule(context) {
  return {
    FragmentSpread(node4) {
      const fragmentName = node4.name.value;
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        context.reportError(
          new GraphQLError(`Unknown fragment "${fragmentName}".`, {
            nodes: node4.name
          })
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs
function KnownTypeNamesRule(context) {
  const schema = context.getSchema();
  const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = true;
    }
  }
  const typeNames = [
    ...Object.keys(existingTypesMap),
    ...Object.keys(definedTypes)
  ];
  return {
    NamedType(node4, _1, parent, _2, ancestors) {
      const typeName = node4.name.value;
      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var _ancestors$;
        const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
        const isSDL = definitionNode != null && isSDLNode(definitionNode);
        if (isSDL && standardTypeNames.includes(typeName)) {
          return;
        }
        const suggestedTypes = suggestionList(
          typeName,
          isSDL ? standardTypeNames.concat(typeNames) : typeNames
        );
        context.reportError(
          new GraphQLError(
            `Unknown type "${typeName}".` + didYouMean(suggestedTypes),
            {
              nodes: node4
            }
          )
        );
      }
    }
  };
}
var standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map(
  (type2) => type2.name
);
function isSDLNode(value2) {
  return "kind" in value2 && (isTypeSystemDefinitionNode(value2) || isTypeSystemExtensionNode(value2));
}

// node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs
function LoneAnonymousOperationRule(context) {
  let operationCount = 0;
  return {
    Document(node4) {
      operationCount = node4.definitions.filter(
        (definition2) => definition2.kind === Kind.OPERATION_DEFINITION
      ).length;
    },
    OperationDefinition(node4) {
      if (!node4.name && operationCount > 1) {
        context.reportError(
          new GraphQLError(
            "This anonymous operation must be the only defined operation.",
            {
              nodes: node4
            }
          )
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs
function LoneSchemaDefinitionRule(context) {
  var _ref, _ref2, _oldSchema$astNode;
  const oldSchema = context.getSchema();
  const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
  let schemaDefinitionsCount = 0;
  return {
    SchemaDefinition(node4) {
      if (alreadyDefined) {
        context.reportError(
          new GraphQLError(
            "Cannot define a new schema within a schema extension.",
            {
              nodes: node4
            }
          )
        );
        return;
      }
      if (schemaDefinitionsCount > 0) {
        context.reportError(
          new GraphQLError("Must provide only one schema definition.", {
            nodes: node4
          })
        );
      }
      ++schemaDefinitionsCount;
    }
  };
}

// node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs
function NoFragmentCyclesRule(context) {
  const visitedFrags = /* @__PURE__ */ Object.create(null);
  const spreadPath = [];
  const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node4) {
      detectCycleRecursive(node4);
      return false;
    }
  };
  function detectCycleRecursive(fragment) {
    if (visitedFrags[fragment.name.value]) {
      return;
    }
    const fragmentName = fragment.name.value;
    visitedFrags[fragmentName] = true;
    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
    if (spreadNodes.length === 0) {
      return;
    }
    spreadPathIndexByName[fragmentName] = spreadPath.length;
    for (const spreadNode of spreadNodes) {
      const spreadName = spreadNode.name.value;
      const cycleIndex = spreadPathIndexByName[spreadName];
      spreadPath.push(spreadNode);
      if (cycleIndex === void 0) {
        const spreadFragment = context.getFragment(spreadName);
        if (spreadFragment) {
          detectCycleRecursive(spreadFragment);
        }
      } else {
        const cyclePath = spreadPath.slice(cycleIndex);
        const viaPath = cyclePath.slice(0, -1).map((s4) => '"' + s4.name.value + '"').join(", ");
        context.reportError(
          new GraphQLError(
            `Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."),
            {
              nodes: cyclePath
            }
          )
        );
      }
      spreadPath.pop();
    }
    spreadPathIndexByName[fragmentName] = void 0;
  }
}

// node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs
function NoUndefinedVariablesRule(context) {
  let variableNameDefined = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        variableNameDefined = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node: node4 } of usages) {
          const varName = node4.name.value;
          if (variableNameDefined[varName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`,
                {
                  nodes: [node4, operation]
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(node4) {
      variableNameDefined[node4.variable.name.value] = true;
    }
  };
}

// node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs
function NoUnusedFragmentsRule(context) {
  const operationDefs = [];
  const fragmentDefs = [];
  return {
    OperationDefinition(node4) {
      operationDefs.push(node4);
      return false;
    },
    FragmentDefinition(node4) {
      fragmentDefs.push(node4);
      return false;
    },
    Document: {
      leave() {
        const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
        for (const operation of operationDefs) {
          for (const fragment of context.getRecursivelyReferencedFragments(
            operation
          )) {
            fragmentNameUsed[fragment.name.value] = true;
          }
        }
        for (const fragmentDef of fragmentDefs) {
          const fragName = fragmentDef.name.value;
          if (fragmentNameUsed[fragName] !== true) {
            context.reportError(
              new GraphQLError(`Fragment "${fragName}" is never used.`, {
                nodes: fragmentDef
              })
            );
          }
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs
function NoUnusedVariablesRule(context) {
  let variableDefs = [];
  return {
    OperationDefinition: {
      enter() {
        variableDefs = [];
      },
      leave(operation) {
        const variableNameUsed = /* @__PURE__ */ Object.create(null);
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node: node4 } of usages) {
          variableNameUsed[node4.name.value] = true;
        }
        for (const variableDef of variableDefs) {
          const variableName = variableDef.variable.name.value;
          if (variableNameUsed[variableName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`,
                {
                  nodes: variableDef
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(def) {
      variableDefs.push(def);
    }
  };
}

// node_modules/graphql/utilities/sortValueNode.mjs
function sortValueNode(valueNode) {
  switch (valueNode.kind) {
    case Kind.OBJECT:
      return { ...valueNode, fields: sortFields(valueNode.fields) };
    case Kind.LIST:
      return { ...valueNode, values: valueNode.values.map(sortValueNode) };
    case Kind.INT:
    case Kind.FLOAT:
    case Kind.STRING:
    case Kind.BOOLEAN:
    case Kind.NULL:
    case Kind.ENUM:
    case Kind.VARIABLE:
      return valueNode;
  }
}
function sortFields(fields) {
  return fields.map((fieldNode) => ({
    ...fieldNode,
    value: sortValueNode(fieldNode.value)
  })).sort(
    (fieldA, fieldB) => naturalCompare(fieldA.name.value, fieldB.name.value)
  );
}

// node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs
function reasonMessage(reason) {
  if (Array.isArray(reason)) {
    return reason.map(
      ([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)
    ).join(" and ");
  }
  return reason;
}
function OverlappingFieldsCanBeMergedRule(context) {
  const comparedFragmentPairs = new PairSet();
  const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
  return {
    SelectionSet(selectionSet2) {
      const conflicts = findConflictsWithinSelectionSet(
        context,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        context.getParentType(),
        selectionSet2
      );
      for (const [[responseName, reason], fields1, fields2] of conflicts) {
        const reasonMsg = reasonMessage(reason);
        context.reportError(
          new GraphQLError(
            `Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,
            {
              nodes: fields1.concat(fields2)
            }
          )
        );
      }
    }
  };
}
function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet2) {
  const conflicts = [];
  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType,
    selectionSet2
  );
  collectConflictsWithin(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    fieldMap
  );
  if (fragmentNames.length !== 0) {
    for (let i6 = 0; i6 < fragmentNames.length; i6++) {
      collectConflictsBetweenFieldsAndFragment(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        false,
        fieldMap,
        fragmentNames[i6]
      );
      for (let j4 = i6 + 1; j4 < fragmentNames.length; j4++) {
        collectConflictsBetweenFragments(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          false,
          fragmentNames[i6],
          fragmentNames[j4]
        );
      }
    }
  }
  return conflicts;
}
function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
  const fragment = context.getFragment(fragmentName);
  if (!fragment) {
    return;
  }
  const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment
  );
  if (fieldMap === fieldMap2) {
    return;
  }
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap,
    fieldMap2
  );
  for (const referencedFragmentName of referencedFragmentNames) {
    if (comparedFragmentPairs.has(
      referencedFragmentName,
      fragmentName,
      areMutuallyExclusive
    )) {
      continue;
    }
    comparedFragmentPairs.add(
      referencedFragmentName,
      fragmentName,
      areMutuallyExclusive
    );
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap,
      referencedFragmentName
    );
  }
}
function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
  if (fragmentName1 === fragmentName2) {
    return;
  }
  if (comparedFragmentPairs.has(
    fragmentName1,
    fragmentName2,
    areMutuallyExclusive
  )) {
    return;
  }
  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
  const fragment1 = context.getFragment(fragmentName1);
  const fragment2 = context.getFragment(fragmentName2);
  if (!fragment1 || !fragment2) {
    return;
  }
  const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment1
  );
  const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const referencedFragmentName2 of referencedFragmentNames2) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fragmentName1,
      referencedFragmentName2
    );
  }
  for (const referencedFragmentName1 of referencedFragmentNames1) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      referencedFragmentName1,
      fragmentName2
    );
  }
}
function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
  const conflicts = [];
  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType1,
    selectionSet1
  );
  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType2,
    selectionSet2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const fragmentName2 of fragmentNames2) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap1,
      fragmentName2
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap2,
      fragmentName1
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    for (const fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFragments(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fragmentName1,
        fragmentName2
      );
    }
  }
  return conflicts;
}
function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
  for (const [responseName, fields] of Object.entries(fieldMap)) {
    if (fields.length > 1) {
      for (let i6 = 0; i6 < fields.length; i6++) {
        for (let j4 = i6 + 1; j4 < fields.length; j4++) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            false,
            // within one collection is never mutually exclusive
            responseName,
            fields[i6],
            fields[j4]
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
  for (const [responseName, fields1] of Object.entries(fieldMap1)) {
    const fields2 = fieldMap2[responseName];
    if (fields2) {
      for (const field1 of fields1) {
        for (const field2 of fields2) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            parentFieldsAreMutuallyExclusive,
            responseName,
            field1,
            field2
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
  const [parentType1, node1, def1] = field1;
  const [parentType2, node22, def2] = field2;
  const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);
  if (!areMutuallyExclusive) {
    const name1 = node1.name.value;
    const name2 = node22.name.value;
    if (name1 !== name2) {
      return [
        [responseName, `"${name1}" and "${name2}" are different fields`],
        [node1],
        [node22]
      ];
    }
    if (!sameArguments(node1, node22)) {
      return [
        [responseName, "they have differing arguments"],
        [node1],
        [node22]
      ];
    }
  }
  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
  if (type1 && type2 && doTypesConflict(type1, type2)) {
    return [
      [
        responseName,
        `they return conflicting types "${inspect(type1)}" and "${inspect(
          type2
        )}"`
      ],
      [node1],
      [node22]
    ];
  }
  const selectionSet1 = node1.selectionSet;
  const selectionSet2 = node22.selectionSet;
  if (selectionSet1 && selectionSet2) {
    const conflicts = findConflictsBetweenSubSelectionSets(
      context,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      getNamedType(type1),
      selectionSet1,
      getNamedType(type2),
      selectionSet2
    );
    return subfieldConflicts(conflicts, responseName, node1, node22);
  }
}
function sameArguments(node1, node22) {
  const args1 = node1.arguments;
  const args2 = node22.arguments;
  if (args1 === void 0 || args1.length === 0) {
    return args2 === void 0 || args2.length === 0;
  }
  if (args2 === void 0 || args2.length === 0) {
    return false;
  }
  if (args1.length !== args2.length) {
    return false;
  }
  const values22 = new Map(args2.map(({ name: name2, value: value2 }) => [name2.value, value2]));
  return args1.every((arg1) => {
    const value1 = arg1.value;
    const value2 = values22.get(arg1.name.value);
    if (value2 === void 0) {
      return false;
    }
    return stringifyValue(value1) === stringifyValue(value2);
  });
}
function stringifyValue(value2) {
  return print2(sortValueNode(value2));
}
function doTypesConflict(type1, type2) {
  if (isListType(type1)) {
    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isListType(type2)) {
    return true;
  }
  if (isNonNullType(type1)) {
    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isNonNullType(type2)) {
    return true;
  }
  if (isLeafType(type1) || isLeafType(type2)) {
    return type1 !== type2;
  }
  return false;
}
function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet2) {
  const cached = cachedFieldsAndFragmentNames.get(selectionSet2);
  if (cached) {
    return cached;
  }
  const nodeAndDefs = /* @__PURE__ */ Object.create(null);
  const fragmentNames = /* @__PURE__ */ Object.create(null);
  _collectFieldsAndFragmentNames(
    context,
    parentType,
    selectionSet2,
    nodeAndDefs,
    fragmentNames
  );
  const result = [nodeAndDefs, Object.keys(fragmentNames)];
  cachedFieldsAndFragmentNames.set(selectionSet2, result);
  return result;
}
function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
  if (cached) {
    return cached;
  }
  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);
  return getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragmentType,
    fragment.selectionSet
  );
}
function _collectFieldsAndFragmentNames(context, parentType, selectionSet2, nodeAndDefs, fragmentNames) {
  for (const selection of selectionSet2.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        const fieldName = selection.name.value;
        let fieldDef;
        if (isObjectType(parentType) || isInterfaceType(parentType)) {
          fieldDef = parentType.getFields()[fieldName];
        }
        const responseName = selection.alias ? selection.alias.value : fieldName;
        if (!nodeAndDefs[responseName]) {
          nodeAndDefs[responseName] = [];
        }
        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
        break;
      }
      case Kind.FRAGMENT_SPREAD:
        fragmentNames[selection.name.value] = true;
        break;
      case Kind.INLINE_FRAGMENT: {
        const typeCondition2 = selection.typeCondition;
        const inlineFragmentType = typeCondition2 ? typeFromAST(context.getSchema(), typeCondition2) : parentType;
        _collectFieldsAndFragmentNames(
          context,
          inlineFragmentType,
          selection.selectionSet,
          nodeAndDefs,
          fragmentNames
        );
        break;
      }
    }
  }
}
function subfieldConflicts(conflicts, responseName, node1, node22) {
  if (conflicts.length > 0) {
    return [
      [responseName, conflicts.map(([reason]) => reason)],
      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
      [node22, ...conflicts.map(([, , fields2]) => fields2).flat()]
    ];
  }
}
var PairSet = class {
  constructor() {
    this._data = /* @__PURE__ */ new Map();
  }
  has(a3, b2, areMutuallyExclusive) {
    var _this$_data$get;
    const [key1, key2] = a3 < b2 ? [a3, b2] : [b2, a3];
    const result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(key2);
    if (result === void 0) {
      return false;
    }
    return areMutuallyExclusive ? true : areMutuallyExclusive === result;
  }
  add(a3, b2, areMutuallyExclusive) {
    const [key1, key2] = a3 < b2 ? [a3, b2] : [b2, a3];
    const map4 = this._data.get(key1);
    if (map4 === void 0) {
      this._data.set(key1, /* @__PURE__ */ new Map([[key2, areMutuallyExclusive]]));
    } else {
      map4.set(key2, areMutuallyExclusive);
    }
  }
};

// node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs
function PossibleFragmentSpreadsRule(context) {
  return {
    InlineFragment(node4) {
      const fragType = context.getType();
      const parentType = context.getParentType();
      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node4
            }
          )
        );
      }
    },
    FragmentSpread(node4) {
      const fragName = node4.name.value;
      const fragType = getFragmentType(context, fragName);
      const parentType = context.getParentType();
      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node4
            }
          )
        );
      }
    }
  };
}
function getFragmentType(context, name2) {
  const frag = context.getFragment(name2);
  if (frag) {
    const type2 = typeFromAST(context.getSchema(), frag.typeCondition);
    if (isCompositeType(type2)) {
      return type2;
    }
  }
}

// node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs
function PossibleTypeExtensionsRule(context) {
  const schema = context.getSchema();
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = def;
    }
  }
  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension
  };
  function checkExtension(node4) {
    const typeName = node4.name.value;
    const defNode = definedTypes[typeName];
    const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
    let expectedKind;
    if (defNode) {
      expectedKind = defKindToExtKind[defNode.kind];
    } else if (existingType) {
      expectedKind = typeToExtKind(existingType);
    }
    if (expectedKind) {
      if (expectedKind !== node4.kind) {
        const kindStr = extensionKindToTypeName(node4.kind);
        context.reportError(
          new GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
            nodes: defNode ? [defNode, node4] : node4
          })
        );
      }
    } else {
      const allTypeNames = Object.keys({
        ...definedTypes,
        ...schema === null || schema === void 0 ? void 0 : schema.getTypeMap()
      });
      const suggestedTypes = suggestionList(typeName, allTypeNames);
      context.reportError(
        new GraphQLError(
          `Cannot extend type "${typeName}" because it is not defined.` + didYouMean(suggestedTypes),
          {
            nodes: node4.name
          }
        )
      );
    }
  }
}
var defKindToExtKind = {
  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,
  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,
  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,
  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,
  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,
  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION
};
function typeToExtKind(type2) {
  if (isScalarType(type2)) {
    return Kind.SCALAR_TYPE_EXTENSION;
  }
  if (isObjectType(type2)) {
    return Kind.OBJECT_TYPE_EXTENSION;
  }
  if (isInterfaceType(type2)) {
    return Kind.INTERFACE_TYPE_EXTENSION;
  }
  if (isUnionType(type2)) {
    return Kind.UNION_TYPE_EXTENSION;
  }
  if (isEnumType(type2)) {
    return Kind.ENUM_TYPE_EXTENSION;
  }
  if (isInputObjectType(type2)) {
    return Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  invariant(false, "Unexpected type: " + inspect(type2));
}
function extensionKindToTypeName(kind) {
  switch (kind) {
    case Kind.SCALAR_TYPE_EXTENSION:
      return "scalar";
    case Kind.OBJECT_TYPE_EXTENSION:
      return "object";
    case Kind.INTERFACE_TYPE_EXTENSION:
      return "interface";
    case Kind.UNION_TYPE_EXTENSION:
      return "union";
    case Kind.ENUM_TYPE_EXTENSION:
      return "enum";
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return "input object";
    default:
      invariant(false, "Unexpected kind: " + inspect(kind));
  }
}

// node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs
function ProvidedRequiredArgumentsRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...ProvidedRequiredArgumentsOnDirectivesRule(context),
    Field: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(fieldNode) {
        var _fieldNode$arguments;
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          return false;
        }
        const providedArgs = new Set(
          // FIXME: https://github.com/graphql/graphql-js/issues/2203
          /* c8 ignore next */
          (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value)
        );
        for (const argDef of fieldDef.args) {
          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {
            const argTypeStr = inspect(argDef.type);
            context.reportError(
              new GraphQLError(
                `Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,
                {
                  nodes: fieldNode
                }
              )
            );
          }
        }
      }
    }
  };
}
function ProvidedRequiredArgumentsOnDirectivesRule(context) {
  var _schema$getDirectives;
  const requiredArgsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : specifiedDirectives;
  for (const directive of definedDirectives) {
    requiredArgsMap[directive.name] = keyMap(
      directive.args.filter(isRequiredArgument),
      (arg) => arg.name
    );
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      requiredArgsMap[def.name.value] = keyMap(
        argNodes.filter(isRequiredArgumentNode),
        (arg) => arg.name.value
      );
    }
  }
  return {
    Directive: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(directiveNode) {
        const directiveName = directiveNode.name.value;
        const requiredArgs = requiredArgsMap[directiveName];
        if (requiredArgs) {
          var _directiveNode$argume;
          const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
          for (const [argName, argDef] of Object.entries(requiredArgs)) {
            if (!argNodeMap.has(argName)) {
              const argType = isType(argDef.type) ? inspect(argDef.type) : print2(argDef.type);
              context.reportError(
                new GraphQLError(
                  `Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,
                  {
                    nodes: directiveNode
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}
function isRequiredArgumentNode(arg) {
  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;
}

// node_modules/graphql/validation/rules/ScalarLeafsRule.mjs
function ScalarLeafsRule(context) {
  return {
    Field(node4) {
      const type2 = context.getType();
      const selectionSet2 = node4.selectionSet;
      if (type2) {
        if (isLeafType(getNamedType(type2))) {
          if (selectionSet2) {
            const fieldName = node4.name.value;
            const typeStr = inspect(type2);
            context.reportError(
              new GraphQLError(
                `Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,
                {
                  nodes: selectionSet2
                }
              )
            );
          }
        } else if (!selectionSet2) {
          const fieldName = node4.name.value;
          const typeStr = inspect(type2);
          context.reportError(
            new GraphQLError(
              `Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,
              {
                nodes: node4
              }
            )
          );
        }
      }
    }
  };
}

// node_modules/graphql/utilities/valueFromAST.mjs
function valueFromAST(valueNode, type2, variables) {
  if (!valueNode) {
    return;
  }
  if (valueNode.kind === Kind.VARIABLE) {
    const variableName = valueNode.name.value;
    if (variables == null || variables[variableName] === void 0) {
      return;
    }
    const variableValue = variables[variableName];
    if (variableValue === null && isNonNullType(type2)) {
      return;
    }
    return variableValue;
  }
  if (isNonNullType(type2)) {
    if (valueNode.kind === Kind.NULL) {
      return;
    }
    return valueFromAST(valueNode, type2.ofType, variables);
  }
  if (valueNode.kind === Kind.NULL) {
    return null;
  }
  if (isListType(type2)) {
    const itemType = type2.ofType;
    if (valueNode.kind === Kind.LIST) {
      const coercedValues = [];
      for (const itemNode of valueNode.values) {
        if (isMissingVariable(itemNode, variables)) {
          if (isNonNullType(itemType)) {
            return;
          }
          coercedValues.push(null);
        } else {
          const itemValue = valueFromAST(itemNode, itemType, variables);
          if (itemValue === void 0) {
            return;
          }
          coercedValues.push(itemValue);
        }
      }
      return coercedValues;
    }
    const coercedValue = valueFromAST(valueNode, itemType, variables);
    if (coercedValue === void 0) {
      return;
    }
    return [coercedValue];
  }
  if (isInputObjectType(type2)) {
    if (valueNode.kind !== Kind.OBJECT) {
      return;
    }
    const coercedObj = /* @__PURE__ */ Object.create(null);
    const fieldNodes = keyMap(valueNode.fields, (field2) => field2.name.value);
    for (const field2 of Object.values(type2.getFields())) {
      const fieldNode = fieldNodes[field2.name];
      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field2.defaultValue !== void 0) {
          coercedObj[field2.name] = field2.defaultValue;
        } else if (isNonNullType(field2.type)) {
          return;
        }
        continue;
      }
      const fieldValue = valueFromAST(fieldNode.value, field2.type, variables);
      if (fieldValue === void 0) {
        return;
      }
      coercedObj[field2.name] = fieldValue;
    }
    return coercedObj;
  }
  if (isLeafType(type2)) {
    let result;
    try {
      result = type2.parseLiteral(valueNode, variables);
    } catch (_error) {
      return;
    }
    if (result === void 0) {
      return;
    }
    return result;
  }
  invariant(false, "Unexpected input type: " + inspect(type2));
}
function isMissingVariable(valueNode, variables) {
  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
}

// node_modules/graphql/execution/values.mjs
function getArgumentValues(def, node4, variableValues) {
  var _node$arguments;
  const coercedValues = {};
  const argumentNodes = (_node$arguments = node4.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);
  for (const argDef of def.args) {
    const name2 = argDef.name;
    const argType = argDef.type;
    const argumentNode = argNodeMap[name2];
    if (!argumentNode) {
      if (argDef.defaultValue !== void 0) {
        coercedValues[name2] = argDef.defaultValue;
      } else if (isNonNullType(argType)) {
        throw new GraphQLError(
          `Argument "${name2}" of required type "${inspect(argType)}" was not provided.`,
          {
            nodes: node4
          }
        );
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull2 = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
        if (argDef.defaultValue !== void 0) {
          coercedValues[name2] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError(
            `Argument "${name2}" of required type "${inspect(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`,
            {
              nodes: valueNode
            }
          );
        }
        continue;
      }
      isNull2 = variableValues[variableName] == null;
    }
    if (isNull2 && isNonNullType(argType)) {
      throw new GraphQLError(
        `Argument "${name2}" of non-null type "${inspect(argType)}" must not be null.`,
        {
          nodes: valueNode
        }
      );
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === void 0) {
      throw new GraphQLError(
        `Argument "${name2}" has invalid value ${print2(valueNode)}.`,
        {
          nodes: valueNode
        }
      );
    }
    coercedValues[name2] = coercedValue;
  }
  return coercedValues;
}
function getDirectiveValues(directiveDef, node4, variableValues) {
  var _node$directives;
  const directiveNode = (_node$directives = node4.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(
    (directive) => directive.name.value === directiveDef.name
  );
  if (directiveNode) {
    return getArgumentValues(directiveDef, directiveNode, variableValues);
  }
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

// node_modules/graphql/execution/collectFields.mjs
function collectFields(schema, fragments, variableValues, runtimeType, selectionSet2) {
  const fields = /* @__PURE__ */ new Map();
  collectFieldsImpl(
    schema,
    fragments,
    variableValues,
    runtimeType,
    selectionSet2,
    fields,
    /* @__PURE__ */ new Set()
  );
  return fields;
}
function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = /* @__PURE__ */ new Map();
  const visitedFragmentNames = /* @__PURE__ */ new Set();
  for (const node4 of fieldNodes) {
    if (node4.selectionSet) {
      collectFieldsImpl(
        schema,
        fragments,
        variableValues,
        returnType,
        node4.selectionSet,
        subFieldNodes,
        visitedFragmentNames
      );
    }
  }
  return subFieldNodes;
}
function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet2, fields, visitedFragmentNames) {
  for (const selection of selectionSet2.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        const name2 = getFieldEntryKey(selection);
        const fieldList = fields.get(name2);
        if (fieldList !== void 0) {
          fieldList.push(selection);
        } else {
          fields.set(name2, [selection]);
        }
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          selection.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        visitedFragmentNames.add(fragName);
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          fragment.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
    }
  }
}
function shouldIncludeNode(variableValues, node4) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node4, variableValues);
  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
    return false;
  }
  const include = getDirectiveValues(
    GraphQLIncludeDirective,
    node4,
    variableValues
  );
  if ((include === null || include === void 0 ? void 0 : include.if) === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch(schema, fragment, type2) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema, typeConditionNode);
  if (conditionalType === type2) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    return schema.isSubType(conditionalType, type2);
  }
  return false;
}
function getFieldEntryKey(node4) {
  return node4.alias ? node4.alias.value : node4.name.value;
}

// node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs
function SingleFieldSubscriptionsRule(context) {
  return {
    OperationDefinition(node4) {
      if (node4.operation === "subscription") {
        const schema = context.getSchema();
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType) {
          const operationName = node4.name ? node4.name.value : null;
          const variableValues = /* @__PURE__ */ Object.create(null);
          const document5 = context.getDocument();
          const fragments = /* @__PURE__ */ Object.create(null);
          for (const definition2 of document5.definitions) {
            if (definition2.kind === Kind.FRAGMENT_DEFINITION) {
              fragments[definition2.name.value] = definition2;
            }
          }
          const fields = collectFields(
            schema,
            fragments,
            variableValues,
            subscriptionType,
            node4.selectionSet
          );
          if (fields.size > 1) {
            const fieldSelectionLists = [...fields.values()];
            const extraFieldSelectionLists = fieldSelectionLists.slice(1);
            const extraFieldSelections = extraFieldSelectionLists.flat();
            context.reportError(
              new GraphQLError(
                operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                {
                  nodes: extraFieldSelections
                }
              )
            );
          }
          for (const fieldNodes of fields.values()) {
            const field2 = fieldNodes[0];
            const fieldName = field2.name.value;
            if (fieldName.startsWith("__")) {
              context.reportError(
                new GraphQLError(
                  operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                  {
                    nodes: fieldNodes
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}

// node_modules/graphql/jsutils/groupBy.mjs
function groupBy(list3, keyFn) {
  const result = /* @__PURE__ */ new Map();
  for (const item2 of list3) {
    const key = keyFn(item2);
    const group = result.get(key);
    if (group === void 0) {
      result.set(key, [item2]);
    } else {
      group.push(item2);
    }
  }
  return result;
}

// node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs
function UniqueArgumentDefinitionNamesRule(context) {
  return {
    DirectiveDefinition(directiveNode) {
      var _directiveNode$argume;
      const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
    },
    InterfaceTypeDefinition: checkArgUniquenessPerField,
    InterfaceTypeExtension: checkArgUniquenessPerField,
    ObjectTypeDefinition: checkArgUniquenessPerField,
    ObjectTypeExtension: checkArgUniquenessPerField
  };
  function checkArgUniquenessPerField(typeNode) {
    var _typeNode$fields;
    const typeName = typeNode.name.value;
    const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
    for (const fieldDef of fieldNodes) {
      var _fieldDef$arguments;
      const fieldName = fieldDef.name.value;
      const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
    }
    return false;
  }
  function checkArgUniqueness(parentName, argumentNodes) {
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `Argument "${parentName}(${argName}:)" can only be defined once.`,
            {
              nodes: argNodes.map((node4) => node4.name)
            }
          )
        );
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs
function UniqueArgumentNamesRule(context) {
  return {
    Field: checkArgUniqueness,
    Directive: checkArgUniqueness
  };
  function checkArgUniqueness(parentNode) {
    var _parentNode$arguments;
    const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `There can be only one argument named "${argName}".`,
            {
              nodes: argNodes.map((node4) => node4.name)
            }
          )
        );
      }
    }
  }
}

// node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs
function UniqueDirectiveNamesRule(context) {
  const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    DirectiveDefinition(node4) {
      const directiveName = node4.name.value;
      if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`,
            {
              nodes: node4.name
            }
          )
        );
        return;
      }
      if (knownDirectiveNames[directiveName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one directive named "@${directiveName}".`,
            {
              nodes: [knownDirectiveNames[directiveName], node4.name]
            }
          )
        );
      } else {
        knownDirectiveNames[directiveName] = node4.name;
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs
function UniqueDirectivesPerLocationRule(context) {
  const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      uniqueDirectiveMap[def.name.value] = !def.repeatable;
    }
  }
  const schemaDirectives = /* @__PURE__ */ Object.create(null);
  const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
  return {
    // Many different AST nodes may contain directives. Rather than listing
    // them all, just listen for entering any node, and check to see if it
    // defines any directives.
    enter(node4) {
      if (!("directives" in node4) || !node4.directives) {
        return;
      }
      let seenDirectives;
      if (node4.kind === Kind.SCHEMA_DEFINITION || node4.kind === Kind.SCHEMA_EXTENSION) {
        seenDirectives = schemaDirectives;
      } else if (isTypeDefinitionNode(node4) || isTypeExtensionNode(node4)) {
        const typeName = node4.name.value;
        seenDirectives = typeDirectivesMap[typeName];
        if (seenDirectives === void 0) {
          typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
        }
      } else {
        seenDirectives = /* @__PURE__ */ Object.create(null);
      }
      for (const directive of node4.directives) {
        const directiveName = directive.name.value;
        if (uniqueDirectiveMap[directiveName]) {
          if (seenDirectives[directiveName]) {
            context.reportError(
              new GraphQLError(
                `The directive "@${directiveName}" can only be used once at this location.`,
                {
                  nodes: [seenDirectives[directiveName], directive]
                }
              )
            );
          } else {
            seenDirectives[directiveName] = directive;
          }
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs
function UniqueEnumValueNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownValueNames = /* @__PURE__ */ Object.create(null);
  return {
    EnumTypeDefinition: checkValueUniqueness,
    EnumTypeExtension: checkValueUniqueness
  };
  function checkValueUniqueness(node4) {
    var _node$values;
    const typeName = node4.name.value;
    if (!knownValueNames[typeName]) {
      knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const valueNodes = (_node$values = node4.values) !== null && _node$values !== void 0 ? _node$values : [];
    const valueNames = knownValueNames[typeName];
    for (const valueDef of valueNodes) {
      const valueName = valueDef.name.value;
      const existingType = existingTypeMap[typeName];
      if (isEnumType(existingType) && existingType.getValue(valueName)) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: valueDef.name
            }
          )
        );
      } else if (valueNames[valueName]) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" can only be defined once.`,
            {
              nodes: [valueNames[valueName], valueDef.name]
            }
          )
        );
      } else {
        valueNames[valueName] = valueDef.name;
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs
function UniqueFieldDefinitionNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownFieldNames = /* @__PURE__ */ Object.create(null);
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness
  };
  function checkFieldUniqueness(node4) {
    var _node$fields;
    const typeName = node4.name.value;
    if (!knownFieldNames[typeName]) {
      knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const fieldNodes = (_node$fields = node4.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
    const fieldNames = knownFieldNames[typeName];
    for (const fieldDef of fieldNodes) {
      const fieldName = fieldDef.name.value;
      if (hasField(existingTypeMap[typeName], fieldName)) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: fieldDef.name
            }
          )
        );
      } else if (fieldNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" can only be defined once.`,
            {
              nodes: [fieldNames[fieldName], fieldDef.name]
            }
          )
        );
      } else {
        fieldNames[fieldName] = fieldDef.name;
      }
    }
    return false;
  }
}
function hasField(type2, fieldName) {
  if (isObjectType(type2) || isInterfaceType(type2) || isInputObjectType(type2)) {
    return type2.getFields()[fieldName] != null;
  }
  return false;
}

// node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs
function UniqueFragmentNamesRule(context) {
  const knownFragmentNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node4) {
      const fragmentName = node4.name.value;
      if (knownFragmentNames[fragmentName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one fragment named "${fragmentName}".`,
            {
              nodes: [knownFragmentNames[fragmentName], node4.name]
            }
          )
        );
      } else {
        knownFragmentNames[fragmentName] = node4.name;
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs
function UniqueInputFieldNamesRule(context) {
  const knownNameStack = [];
  let knownNames = /* @__PURE__ */ Object.create(null);
  return {
    ObjectValue: {
      enter() {
        knownNameStack.push(knownNames);
        knownNames = /* @__PURE__ */ Object.create(null);
      },
      leave() {
        const prevKnownNames = knownNameStack.pop();
        prevKnownNames || invariant(false);
        knownNames = prevKnownNames;
      }
    },
    ObjectField(node4) {
      const fieldName = node4.name.value;
      if (knownNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one input field named "${fieldName}".`,
            {
              nodes: [knownNames[fieldName], node4.name]
            }
          )
        );
      } else {
        knownNames[fieldName] = node4.name;
      }
    }
  };
}

// node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs
function UniqueOperationNamesRule(context) {
  const knownOperationNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition(node4) {
      const operationName = node4.name;
      if (operationName) {
        if (knownOperationNames[operationName.value]) {
          context.reportError(
            new GraphQLError(
              `There can be only one operation named "${operationName.value}".`,
              {
                nodes: [
                  knownOperationNames[operationName.value],
                  operationName
                ]
              }
            )
          );
        } else {
          knownOperationNames[operationName.value] = operationName;
        }
      }
      return false;
    },
    FragmentDefinition: () => false
  };
}

// node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs
function UniqueOperationTypesRule(context) {
  const schema = context.getSchema();
  const definedOperationTypes = /* @__PURE__ */ Object.create(null);
  const existingOperationTypes = schema ? {
    query: schema.getQueryType(),
    mutation: schema.getMutationType(),
    subscription: schema.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: checkOperationTypes,
    SchemaExtension: checkOperationTypes
  };
  function checkOperationTypes(node4) {
    var _node$operationTypes;
    const operationTypesNodes = (_node$operationTypes = node4.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
    for (const operationType of operationTypesNodes) {
      const operation = operationType.operation;
      const alreadyDefinedOperationType = definedOperationTypes[operation];
      if (existingOperationTypes[operation]) {
        context.reportError(
          new GraphQLError(
            `Type for ${operation} already defined in the schema. It cannot be redefined.`,
            {
              nodes: operationType
            }
          )
        );
      } else if (alreadyDefinedOperationType) {
        context.reportError(
          new GraphQLError(
            `There can be only one ${operation} type in schema.`,
            {
              nodes: [alreadyDefinedOperationType, operationType]
            }
          )
        );
      } else {
        definedOperationTypes[operation] = operationType;
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs
function UniqueTypeNamesRule(context) {
  const knownTypeNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName
  };
  function checkTypeName(node4) {
    const typeName = node4.name.value;
    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
      context.reportError(
        new GraphQLError(
          `Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,
          {
            nodes: node4.name
          }
        )
      );
      return;
    }
    if (knownTypeNames[typeName]) {
      context.reportError(
        new GraphQLError(`There can be only one type named "${typeName}".`, {
          nodes: [knownTypeNames[typeName], node4.name]
        })
      );
    } else {
      knownTypeNames[typeName] = node4.name;
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs
function UniqueVariableNamesRule(context) {
  return {
    OperationDefinition(operationNode) {
      var _operationNode$variab;
      const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
      const seenVariableDefinitions = groupBy(
        variableDefinitions,
        (node4) => node4.variable.name.value
      );
      for (const [variableName, variableNodes] of seenVariableDefinitions) {
        if (variableNodes.length > 1) {
          context.reportError(
            new GraphQLError(
              `There can be only one variable named "$${variableName}".`,
              {
                nodes: variableNodes.map((node4) => node4.variable.name)
              }
            )
          );
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs
function ValuesOfCorrectTypeRule(context) {
  return {
    ListValue(node4) {
      const type2 = getNullableType(context.getParentInputType());
      if (!isListType(type2)) {
        isValidValueNode(context, node4);
        return false;
      }
    },
    ObjectValue(node4) {
      const type2 = getNamedType(context.getInputType());
      if (!isInputObjectType(type2)) {
        isValidValueNode(context, node4);
        return false;
      }
      const fieldNodeMap = keyMap(node4.fields, (field2) => field2.name.value);
      for (const fieldDef of Object.values(type2.getFields())) {
        const fieldNode = fieldNodeMap[fieldDef.name];
        if (!fieldNode && isRequiredInputField(fieldDef)) {
          const typeStr = inspect(fieldDef.type);
          context.reportError(
            new GraphQLError(
              `Field "${type2.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,
              {
                nodes: node4
              }
            )
          );
        }
      }
    },
    ObjectField(node4) {
      const parentType = getNamedType(context.getParentInputType());
      const fieldType = context.getInputType();
      if (!fieldType && isInputObjectType(parentType)) {
        const suggestions = suggestionList(
          node4.name.value,
          Object.keys(parentType.getFields())
        );
        context.reportError(
          new GraphQLError(
            `Field "${node4.name.value}" is not defined by type "${parentType.name}".` + didYouMean(suggestions),
            {
              nodes: node4
            }
          )
        );
      }
    },
    NullValue(node4) {
      const type2 = context.getInputType();
      if (isNonNullType(type2)) {
        context.reportError(
          new GraphQLError(
            `Expected value of type "${inspect(type2)}", found ${print2(node4)}.`,
            {
              nodes: node4
            }
          )
        );
      }
    },
    EnumValue: (node4) => isValidValueNode(context, node4),
    IntValue: (node4) => isValidValueNode(context, node4),
    FloatValue: (node4) => isValidValueNode(context, node4),
    StringValue: (node4) => isValidValueNode(context, node4),
    BooleanValue: (node4) => isValidValueNode(context, node4)
  };
}
function isValidValueNode(context, node4) {
  const locationType = context.getInputType();
  if (!locationType) {
    return;
  }
  const type2 = getNamedType(locationType);
  if (!isLeafType(type2)) {
    const typeStr = inspect(locationType);
    context.reportError(
      new GraphQLError(
        `Expected value of type "${typeStr}", found ${print2(node4)}.`,
        {
          nodes: node4
        }
      )
    );
    return;
  }
  try {
    const parseResult = type2.parseLiteral(
      node4,
      void 0
      /* variables */
    );
    if (parseResult === void 0) {
      const typeStr = inspect(locationType);
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print2(node4)}.`,
          {
            nodes: node4
          }
        )
      );
    }
  } catch (error3) {
    const typeStr = inspect(locationType);
    if (error3 instanceof GraphQLError) {
      context.reportError(error3);
    } else {
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print2(node4)}; ` + error3.message,
          {
            nodes: node4,
            originalError: error3
          }
        )
      );
    }
  }
}

// node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs
function VariablesAreInputTypesRule(context) {
  return {
    VariableDefinition(node4) {
      const type2 = typeFromAST(context.getSchema(), node4.type);
      if (type2 !== void 0 && !isInputType(type2)) {
        const variableName = node4.variable.name.value;
        const typeName = print2(node4.type);
        context.reportError(
          new GraphQLError(
            `Variable "$${variableName}" cannot be non-input type "${typeName}".`,
            {
              nodes: node4.type
            }
          )
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs
function VariablesInAllowedPositionRule(context) {
  let varDefMap = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        varDefMap = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node: node4, type: type2, defaultValue } of usages) {
          const varName = node4.name.value;
          const varDef = varDefMap[varName];
          if (varDef && type2) {
            const schema = context.getSchema();
            const varType = typeFromAST(schema, varDef.type);
            if (varType && !allowedVariableUsage(
              schema,
              varType,
              varDef.defaultValue,
              type2,
              defaultValue
            )) {
              const varTypeStr = inspect(varType);
              const typeStr = inspect(type2);
              context.reportError(
                new GraphQLError(
                  `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                  {
                    nodes: [varDef, node4]
                  }
                )
              );
            }
          }
        }
      }
    },
    VariableDefinition(node4) {
      varDefMap[node4.variable.name.value] = node4;
    }
  };
}
function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
  if (isNonNullType(locationType) && !isNonNullType(varType)) {
    const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;
    const hasLocationDefaultValue = locationDefaultValue !== void 0;
    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
      return false;
    }
    const nullableLocationType = locationType.ofType;
    return isTypeSubTypeOf(schema, varType, nullableLocationType);
  }
  return isTypeSubTypeOf(schema, varType, locationType);
}

// node_modules/graphql/validation/specifiedRules.mjs
var specifiedRules = Object.freeze([
  ExecutableDefinitionsRule,
  UniqueOperationNamesRule,
  LoneAnonymousOperationRule,
  SingleFieldSubscriptionsRule,
  KnownTypeNamesRule,
  FragmentsOnCompositeTypesRule,
  VariablesAreInputTypesRule,
  ScalarLeafsRule,
  FieldsOnCorrectTypeRule,
  UniqueFragmentNamesRule,
  KnownFragmentNamesRule,
  NoUnusedFragmentsRule,
  PossibleFragmentSpreadsRule,
  NoFragmentCyclesRule,
  UniqueVariableNamesRule,
  NoUndefinedVariablesRule,
  NoUnusedVariablesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  KnownArgumentNamesRule,
  UniqueArgumentNamesRule,
  ValuesOfCorrectTypeRule,
  ProvidedRequiredArgumentsRule,
  VariablesInAllowedPositionRule,
  OverlappingFieldsCanBeMergedRule,
  UniqueInputFieldNamesRule
]);
var specifiedSDLRules = Object.freeze([
  LoneSchemaDefinitionRule,
  UniqueOperationTypesRule,
  UniqueTypeNamesRule,
  UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule,
  UniqueArgumentDefinitionNamesRule,
  UniqueDirectiveNamesRule,
  KnownTypeNamesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  PossibleTypeExtensionsRule,
  KnownArgumentNamesOnDirectivesRule,
  UniqueArgumentNamesRule,
  UniqueInputFieldNamesRule,
  ProvidedRequiredArgumentsOnDirectivesRule
]);

// node_modules/graphql/jsutils/memoize3.mjs
function memoize3(fn2) {
  let cache0;
  return function memoized(a1, a22, a3) {
    if (cache0 === void 0) {
      cache0 = /* @__PURE__ */ new WeakMap();
    }
    let cache1 = cache0.get(a1);
    if (cache1 === void 0) {
      cache1 = /* @__PURE__ */ new WeakMap();
      cache0.set(a1, cache1);
    }
    let cache22 = cache1.get(a22);
    if (cache22 === void 0) {
      cache22 = /* @__PURE__ */ new WeakMap();
      cache1.set(a22, cache22);
    }
    let fnResult = cache22.get(a3);
    if (fnResult === void 0) {
      fnResult = fn2(a1, a22, a3);
      cache22.set(a3, fnResult);
    }
    return fnResult;
  };
}

// node_modules/graphql/execution/execute.mjs
var collectSubfields2 = memoize3(
  (exeContext, returnType, fieldNodes) => collectSubfields(
    exeContext.schema,
    exeContext.fragments,
    exeContext.variableValues,
    returnType,
    fieldNodes
  )
);

// node_modules/graphql/utilities/extendSchema.mjs
var stdTypeMap = keyMap(
  [...specifiedScalarTypes, ...introspectionTypes],
  (type2) => type2.name
);

// node_modules/graphql/utilities/findBreakingChanges.mjs
var BreakingChangeType;
(function(BreakingChangeType2) {
  BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
  BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
  BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
  BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
  BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
  BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
  BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
  BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
  BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
  BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
  BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
  BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
  BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
  BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
  BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
  BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
})(BreakingChangeType || (BreakingChangeType = {}));
var DangerousChangeType;
(function(DangerousChangeType2) {
  DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
  DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
  DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
  DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
  DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
  DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
})(DangerousChangeType || (DangerousChangeType = {}));

// node_modules/graphql-tag/lib/index.js
var docCache = /* @__PURE__ */ new Map();
var fragmentSourceMap = /* @__PURE__ */ new Map();
var printFragmentWarnings = true;
var experimentalFragmentVariables = false;
function normalize(string3) {
  return string3.replace(/[\s,]+/g, " ").trim();
}
function cacheKeyFromLoc(loc) {
  return normalize(loc.source.body.substring(loc.start, loc.end));
}
function processFragments(ast) {
  var seenKeys = /* @__PURE__ */ new Set();
  var definitions = [];
  ast.definitions.forEach(function(fragmentDefinition2) {
    if (fragmentDefinition2.kind === "FragmentDefinition") {
      var fragmentName = fragmentDefinition2.name.value;
      var sourceKey = cacheKeyFromLoc(fragmentDefinition2.loc);
      var sourceKeySet = fragmentSourceMap.get(fragmentName);
      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
        if (printFragmentWarnings) {
          console.warn("Warning: fragment with name " + fragmentName + " already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
        }
      } else if (!sourceKeySet) {
        fragmentSourceMap.set(fragmentName, sourceKeySet = /* @__PURE__ */ new Set());
      }
      sourceKeySet.add(sourceKey);
      if (!seenKeys.has(sourceKey)) {
        seenKeys.add(sourceKey);
        definitions.push(fragmentDefinition2);
      }
    } else {
      definitions.push(fragmentDefinition2);
    }
  });
  return __assign(__assign({}, ast), { definitions });
}
function stripLoc(doc2) {
  var workSet = new Set(doc2.definitions);
  workSet.forEach(function(node4) {
    if (node4.loc)
      delete node4.loc;
    Object.keys(node4).forEach(function(key) {
      var value2 = node4[key];
      if (value2 && typeof value2 === "object") {
        workSet.add(value2);
      }
    });
  });
  var loc = doc2.loc;
  if (loc) {
    delete loc.startToken;
    delete loc.endToken;
  }
  return doc2;
}
function parseDocument(source) {
  var cacheKey = normalize(source);
  if (!docCache.has(cacheKey)) {
    var parsed = parse4(source, {
      experimentalFragmentVariables,
      allowLegacyFragmentVariables: experimentalFragmentVariables
    });
    if (!parsed || parsed.kind !== "Document") {
      throw new Error("Not a valid GraphQL document.");
    }
    docCache.set(cacheKey, stripLoc(processFragments(parsed)));
  }
  return docCache.get(cacheKey);
}
function gql(literals) {
  var args2 = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args2[_i - 1] = arguments[_i];
  }
  if (typeof literals === "string") {
    literals = [literals];
  }
  var result = literals[0];
  args2.forEach(function(arg, i6) {
    if (arg && arg.kind === "Document") {
      result += arg.loc.source.body;
    } else {
      result += arg;
    }
    result += literals[i6 + 1];
  });
  return parseDocument(result);
}
function resetCaches() {
  docCache.clear();
  fragmentSourceMap.clear();
}
function disableFragmentWarnings() {
  printFragmentWarnings = false;
}
function enableExperimentalFragmentVariables() {
  experimentalFragmentVariables = true;
}
function disableExperimentalFragmentVariables() {
  experimentalFragmentVariables = false;
}
var extras = {
  gql,
  resetCaches,
  disableFragmentWarnings,
  enableExperimentalFragmentVariables,
  disableExperimentalFragmentVariables
};
(function(gql_1) {
  gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
})(gql || (gql = {}));
gql["default"] = gql;
var lib_default2 = gql;

// node_modules/@0no-co/graphql.web/dist/graphql.web.mjs
var e2 = {
  NAME: "Name",
  DOCUMENT: "Document",
  OPERATION_DEFINITION: "OperationDefinition",
  VARIABLE_DEFINITION: "VariableDefinition",
  SELECTION_SET: "SelectionSet",
  FIELD: "Field",
  ARGUMENT: "Argument",
  FRAGMENT_SPREAD: "FragmentSpread",
  INLINE_FRAGMENT: "InlineFragment",
  FRAGMENT_DEFINITION: "FragmentDefinition",
  VARIABLE: "Variable",
  INT: "IntValue",
  FLOAT: "FloatValue",
  STRING: "StringValue",
  BOOLEAN: "BooleanValue",
  NULL: "NullValue",
  ENUM: "EnumValue",
  LIST: "ListValue",
  OBJECT: "ObjectValue",
  OBJECT_FIELD: "ObjectField",
  DIRECTIVE: "Directive",
  NAMED_TYPE: "NamedType",
  LIST_TYPE: "ListType",
  NON_NULL_TYPE: "NonNullType"
};
var GraphQLError2 = class extends Error {
  constructor(e6, r7, i6, n6, a3, t5, o5) {
    super(e6);
    this.name = "GraphQLError";
    this.message = e6;
    if (a3) {
      this.path = a3;
    }
    if (r7) {
      this.nodes = Array.isArray(r7) ? r7 : [r7];
    }
    if (i6) {
      this.source = i6;
    }
    if (n6) {
      this.positions = n6;
    }
    if (t5) {
      this.originalError = t5;
    }
    var l7 = o5;
    if (!l7 && t5) {
      var u4 = t5.extensions;
      if (u4 && "object" == typeof u4) {
        l7 = u4;
      }
    }
    this.extensions = l7 || {};
  }
  toJSON() {
    return {
      ...this,
      message: this.message
    };
  }
  toString() {
    return this.message;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
};
var i3;
var n4;
function error2(e6) {
  return new GraphQLError2(`Syntax Error: Unexpected token at ${n4} in ${e6}`);
}
function advance(e6) {
  e6.lastIndex = n4;
  if (e6.test(i3)) {
    return i3.slice(n4, n4 = e6.lastIndex);
  }
}
var a2 = / +(?=[^\s])/y;
function blockString(e6) {
  var r7 = e6.split("\n");
  var i6 = "";
  var n6 = 0;
  var t5 = 0;
  var o5 = r7.length - 1;
  for (var l7 = 0; l7 < r7.length; l7++) {
    a2.lastIndex = 0;
    if (a2.test(r7[l7])) {
      if (l7 && (!n6 || a2.lastIndex < n6)) {
        n6 = a2.lastIndex;
      }
      t5 = t5 || l7;
      o5 = l7;
    }
  }
  for (var u4 = t5; u4 <= o5; u4++) {
    if (u4 !== t5) {
      i6 += "\n";
    }
    i6 += r7[u4].slice(n6).replace(/\\"""/g, '"""');
  }
  return i6;
}
function ignored() {
  for (var e6 = 0 | i3.charCodeAt(n4++); 9 === e6 || 10 === e6 || 13 === e6 || 32 === e6 || 35 === e6 || 44 === e6 || 65279 === e6; e6 = 0 | i3.charCodeAt(n4++)) {
    if (35 === e6) {
      while (10 !== (e6 = i3.charCodeAt(n4++)) && 13 !== e6) {
      }
    }
  }
  n4--;
}
var t3 = /[_A-Za-z]\w*/y;
function name() {
  var e6;
  if (e6 = advance(t3)) {
    return {
      kind: "Name",
      value: e6
    };
  }
}
var o2 = /(?:null|true|false)/y;
var l2 = /\$[_A-Za-z]\w*/y;
var u2 = /-?\d+/y;
var v2 = /(?:\.\d+)?[eE][+-]?\d+|\.\d+/y;
var d2 = /\\/g;
var s3 = /"""(?:"""|(?:[\s\S]*?[^\\])""")/y;
var c2 = /"(?:"|[^\r\n]*?[^\\]")/y;
function value(e6) {
  var r7;
  var a3;
  if (a3 = advance(o2)) {
    r7 = "null" === a3 ? {
      kind: "NullValue"
    } : {
      kind: "BooleanValue",
      value: "true" === a3
    };
  } else if (!e6 && (a3 = advance(l2))) {
    r7 = {
      kind: "Variable",
      name: {
        kind: "Name",
        value: a3.slice(1)
      }
    };
  } else if (a3 = advance(u2)) {
    var f6 = a3;
    if (a3 = advance(v2)) {
      r7 = {
        kind: "FloatValue",
        value: f6 + a3
      };
    } else {
      r7 = {
        kind: "IntValue",
        value: f6
      };
    }
  } else if (a3 = advance(t3)) {
    r7 = {
      kind: "EnumValue",
      value: a3
    };
  } else if (a3 = advance(s3)) {
    r7 = {
      kind: "StringValue",
      value: blockString(a3.slice(3, -3)),
      block: true
    };
  } else if (a3 = advance(c2)) {
    r7 = {
      kind: "StringValue",
      value: d2.test(a3) ? JSON.parse(a3) : a3.slice(1, -1),
      block: false
    };
  } else if (r7 = function list3(e7) {
    var r8;
    if (91 === i3.charCodeAt(n4)) {
      n4++;
      ignored();
      var a4 = [];
      while (r8 = value(e7)) {
        a4.push(r8);
      }
      if (93 !== i3.charCodeAt(n4++)) {
        throw error2("ListValue");
      }
      ignored();
      return {
        kind: "ListValue",
        values: a4
      };
    }
  }(e6) || function object2(e7) {
    if (123 === i3.charCodeAt(n4)) {
      n4++;
      ignored();
      var r8 = [];
      var a4;
      while (a4 = name()) {
        ignored();
        if (58 !== i3.charCodeAt(n4++)) {
          throw error2("ObjectField");
        }
        ignored();
        var t5 = value(e7);
        if (!t5) {
          throw error2("ObjectField");
        }
        r8.push({
          kind: "ObjectField",
          name: a4,
          value: t5
        });
      }
      if (125 !== i3.charCodeAt(n4++)) {
        throw error2("ObjectValue");
      }
      ignored();
      return {
        kind: "ObjectValue",
        fields: r8
      };
    }
  }(e6)) {
    return r7;
  }
  ignored();
  return r7;
}
function arguments_(e6) {
  var r7 = [];
  ignored();
  if (40 === i3.charCodeAt(n4)) {
    n4++;
    ignored();
    var a3;
    while (a3 = name()) {
      ignored();
      if (58 !== i3.charCodeAt(n4++)) {
        throw error2("Argument");
      }
      ignored();
      var t5 = value(e6);
      if (!t5) {
        throw error2("Argument");
      }
      r7.push({
        kind: "Argument",
        name: a3,
        value: t5
      });
    }
    if (!r7.length || 41 !== i3.charCodeAt(n4++)) {
      throw error2("Argument");
    }
    ignored();
  }
  return r7;
}
function directives(e6) {
  var r7 = [];
  ignored();
  while (64 === i3.charCodeAt(n4)) {
    n4++;
    var a3 = name();
    if (!a3) {
      throw error2("Directive");
    }
    ignored();
    r7.push({
      kind: "Directive",
      name: a3,
      arguments: arguments_(e6)
    });
  }
  return r7;
}
function field() {
  var e6 = name();
  if (e6) {
    ignored();
    var r7;
    if (58 === i3.charCodeAt(n4)) {
      n4++;
      ignored();
      r7 = e6;
      if (!(e6 = name())) {
        throw error2("Field");
      }
      ignored();
    }
    return {
      kind: "Field",
      alias: r7,
      name: e6,
      arguments: arguments_(false),
      directives: directives(false),
      selectionSet: selectionSet()
    };
  }
}
function type() {
  var e6;
  ignored();
  if (91 === i3.charCodeAt(n4)) {
    n4++;
    ignored();
    var r7 = type();
    if (!r7 || 93 !== i3.charCodeAt(n4++)) {
      throw error2("ListType");
    }
    e6 = {
      kind: "ListType",
      type: r7
    };
  } else if (e6 = name()) {
    e6 = {
      kind: "NamedType",
      name: e6
    };
  } else {
    throw error2("NamedType");
  }
  ignored();
  if (33 === i3.charCodeAt(n4)) {
    n4++;
    ignored();
    return {
      kind: "NonNullType",
      type: e6
    };
  } else {
    return e6;
  }
}
var f2 = /on/y;
function typeCondition() {
  if (advance(f2)) {
    ignored();
    var e6 = name();
    if (!e6) {
      throw error2("NamedType");
    }
    ignored();
    return {
      kind: "NamedType",
      name: e6
    };
  }
}
var p2 = /\.\.\./y;
function fragmentSpread() {
  if (advance(p2)) {
    ignored();
    var e6 = n4;
    var r7;
    if ((r7 = name()) && "on" !== r7.value) {
      return {
        kind: "FragmentSpread",
        name: r7,
        directives: directives(false)
      };
    } else {
      n4 = e6;
      var i6 = typeCondition();
      var a3 = directives(false);
      var t5 = selectionSet();
      if (!t5) {
        throw error2("InlineFragment");
      }
      return {
        kind: "InlineFragment",
        typeCondition: i6,
        directives: a3,
        selectionSet: t5
      };
    }
  }
}
function selectionSet() {
  var e6;
  ignored();
  if (123 === i3.charCodeAt(n4)) {
    n4++;
    ignored();
    var r7 = [];
    while (e6 = fragmentSpread() || field()) {
      r7.push(e6);
    }
    if (!r7.length || 125 !== i3.charCodeAt(n4++)) {
      throw error2("SelectionSet");
    }
    ignored();
    return {
      kind: "SelectionSet",
      selections: r7
    };
  }
}
var m = /fragment/y;
function fragmentDefinition() {
  if (advance(m)) {
    ignored();
    var e6 = name();
    if (!e6) {
      throw error2("FragmentDefinition");
    }
    ignored();
    var r7 = typeCondition();
    if (!r7) {
      throw error2("FragmentDefinition");
    }
    var i6 = directives(false);
    var n6 = selectionSet();
    if (!n6) {
      throw error2("FragmentDefinition");
    }
    return {
      kind: "FragmentDefinition",
      name: e6,
      typeCondition: r7,
      directives: i6,
      selectionSet: n6
    };
  }
}
var g2 = /(?:query|mutation|subscription)/y;
function operationDefinition() {
  var e6;
  var r7;
  var a3 = [];
  var t5 = [];
  if (e6 = advance(g2)) {
    ignored();
    r7 = name();
    a3 = function variableDefinitions() {
      var e7;
      var r8 = [];
      ignored();
      if (40 === i3.charCodeAt(n4)) {
        n4++;
        ignored();
        while (e7 = advance(l2)) {
          ignored();
          if (58 !== i3.charCodeAt(n4++)) {
            throw error2("VariableDefinition");
          }
          var a4 = type();
          var t6 = void 0;
          if (61 === i3.charCodeAt(n4)) {
            n4++;
            ignored();
            if (!(t6 = value(true))) {
              throw error2("VariableDefinition");
            }
          }
          ignored();
          r8.push({
            kind: "VariableDefinition",
            variable: {
              kind: "Variable",
              name: {
                kind: "Name",
                value: e7.slice(1)
              }
            },
            type: a4,
            defaultValue: t6,
            directives: directives(true)
          });
        }
        if (41 !== i3.charCodeAt(n4++)) {
          throw error2("VariableDefinition");
        }
        ignored();
      }
      return r8;
    }();
    t5 = directives(false);
  }
  var o5 = selectionSet();
  if (o5) {
    return {
      kind: "OperationDefinition",
      operation: e6 || "query",
      name: r7,
      variableDefinitions: a3,
      directives: t5,
      selectionSet: o5
    };
  }
}
function parse5(e6, r7) {
  i3 = "string" == typeof e6.body ? e6.body : e6;
  n4 = 0;
  return function document5() {
    var e7;
    ignored();
    var r8 = [];
    while (e7 = fragmentDefinition() || operationDefinition()) {
      r8.push(e7);
    }
    return {
      kind: "Document",
      definitions: r8
    };
  }();
}
function printString2(e6) {
  return JSON.stringify(e6);
}
function printBlockString2(e6) {
  return '"""\n' + e6.replace(/"""/g, '\\"""') + '\n"""';
}
var hasItems = (e6) => !(!e6 || !e6.length);
var y2 = {
  OperationDefinition(e6) {
    if ("query" === e6.operation && !e6.name && !hasItems(e6.variableDefinitions) && !hasItems(e6.directives)) {
      return y2.SelectionSet(e6.selectionSet);
    }
    var r7 = e6.operation;
    if (e6.name) {
      r7 += " " + e6.name.value;
    }
    if (hasItems(e6.variableDefinitions)) {
      if (!e6.name) {
        r7 += " ";
      }
      r7 += "(" + e6.variableDefinitions.map(y2.VariableDefinition).join(", ") + ")";
    }
    if (hasItems(e6.directives)) {
      r7 += " " + e6.directives.map(y2.Directive).join(" ");
    }
    return r7 + " " + y2.SelectionSet(e6.selectionSet);
  },
  VariableDefinition(e6) {
    var r7 = y2.Variable(e6.variable) + ": " + print3(e6.type);
    if (e6.defaultValue) {
      r7 += " = " + print3(e6.defaultValue);
    }
    if (hasItems(e6.directives)) {
      r7 += " " + e6.directives.map(y2.Directive).join(" ");
    }
    return r7;
  },
  Field(e6) {
    var r7 = (e6.alias ? e6.alias.value + ": " : "") + e6.name.value;
    if (hasItems(e6.arguments)) {
      var i6 = e6.arguments.map(y2.Argument);
      var n6 = r7 + "(" + i6.join(", ") + ")";
      r7 = n6.length > 80 ? r7 + "(\n  " + i6.join("\n").replace(/\n/g, "\n  ") + "\n)" : n6;
    }
    if (hasItems(e6.directives)) {
      r7 += " " + e6.directives.map(y2.Directive).join(" ");
    }
    return e6.selectionSet ? r7 + " " + y2.SelectionSet(e6.selectionSet) : r7;
  },
  StringValue: (e6) => e6.block ? printBlockString2(e6.value) : printString2(e6.value),
  BooleanValue: (e6) => "" + e6.value,
  NullValue: (e6) => "null",
  IntValue: (e6) => e6.value,
  FloatValue: (e6) => e6.value,
  EnumValue: (e6) => e6.value,
  Name: (e6) => e6.value,
  Variable: (e6) => "$" + e6.name.value,
  ListValue: (e6) => "[" + e6.values.map(print3).join(", ") + "]",
  ObjectValue: (e6) => "{" + e6.fields.map(y2.ObjectField).join(", ") + "}",
  ObjectField: (e6) => e6.name.value + ": " + print3(e6.value),
  Document: (e6) => hasItems(e6.definitions) ? e6.definitions.map(print3).join("\n\n") : "",
  SelectionSet: (e6) => "{\n  " + e6.selections.map(print3).join("\n").replace(/\n/g, "\n  ") + "\n}",
  Argument: (e6) => e6.name.value + ": " + print3(e6.value),
  FragmentSpread(e6) {
    var r7 = "..." + e6.name.value;
    if (hasItems(e6.directives)) {
      r7 += " " + e6.directives.map(y2.Directive).join(" ");
    }
    return r7;
  },
  InlineFragment(e6) {
    var r7 = "...";
    if (e6.typeCondition) {
      r7 += " on " + e6.typeCondition.name.value;
    }
    if (hasItems(e6.directives)) {
      r7 += " " + e6.directives.map(y2.Directive).join(" ");
    }
    return r7 + " " + print3(e6.selectionSet);
  },
  FragmentDefinition(e6) {
    var r7 = "fragment " + e6.name.value;
    r7 += " on " + e6.typeCondition.name.value;
    if (hasItems(e6.directives)) {
      r7 += " " + e6.directives.map(y2.Directive).join(" ");
    }
    return r7 + " " + print3(e6.selectionSet);
  },
  Directive(e6) {
    var r7 = "@" + e6.name.value;
    if (hasItems(e6.arguments)) {
      r7 += "(" + e6.arguments.map(y2.Argument).join(", ") + ")";
    }
    return r7;
  },
  NamedType: (e6) => e6.name.value,
  ListType: (e6) => "[" + print3(e6.type) + "]",
  NonNullType: (e6) => print3(e6.type) + "!"
};
function print3(e6) {
  return y2[e6.kind] ? y2[e6.kind](e6) : "";
}
function valueFromASTUntyped2(e6, r7) {
  switch (e6.kind) {
    case "NullValue":
      return null;
    case "IntValue":
      return parseInt(e6.value, 10);
    case "FloatValue":
      return parseFloat(e6.value);
    case "StringValue":
    case "EnumValue":
    case "BooleanValue":
      return e6.value;
    case "ListValue":
      var i6 = [];
      for (var n6 = 0, a3 = e6.values; n6 < a3.length; n6 += 1) {
        i6.push(valueFromASTUntyped2(a3[n6], r7));
      }
      return i6;
    case "ObjectValue":
      var t5 = /* @__PURE__ */ Object.create(null);
      for (var o5 = 0, l7 = e6.fields; o5 < l7.length; o5 += 1) {
        var u4 = l7[o5];
        t5[u4.name.value] = valueFromASTUntyped2(u4.value, r7);
      }
      return t5;
    case "Variable":
      return r7 && r7[e6.name.value];
  }
}

// node_modules/wonka/dist/wonka.mjs
var teardownPlaceholder = () => {
};
var e3 = teardownPlaceholder;
function start(e6) {
  return {
    tag: 0,
    0: e6
  };
}
function push(e6) {
  return {
    tag: 1,
    0: e6
  };
}
var asyncIteratorSymbol = () => "function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator";
var identity2 = (e6) => e6;
function filter2(r7) {
  return (t5) => (i6) => {
    var a3 = e3;
    t5((e6) => {
      if (0 === e6) {
        i6(0);
      } else if (0 === e6.tag) {
        a3 = e6[0];
        i6(e6);
      } else if (!r7(e6[0])) {
        a3(0);
      } else {
        i6(e6);
      }
    });
  };
}
function map3(e6) {
  return (r7) => (t5) => r7((r8) => {
    if (0 === r8 || 0 === r8.tag) {
      t5(r8);
    } else {
      t5(push(e6(r8[0])));
    }
  });
}
function mergeMap(r7) {
  return (t5) => (i6) => {
    var a3 = [];
    var f6 = e3;
    var n6 = false;
    var s4 = false;
    t5((t6) => {
      if (s4) {
      } else if (0 === t6) {
        s4 = true;
        if (!a3.length) {
          i6(0);
        }
      } else if (0 === t6.tag) {
        f6 = t6[0];
      } else {
        n6 = false;
        !function applyInnerSource(r8) {
          var t7 = e3;
          r8((e6) => {
            if (0 === e6) {
              if (a3.length) {
                var r9 = a3.indexOf(t7);
                if (r9 > -1) {
                  (a3 = a3.slice()).splice(r9, 1);
                }
                if (!a3.length) {
                  if (s4) {
                    i6(0);
                  } else if (!n6) {
                    n6 = true;
                    f6(0);
                  }
                }
              }
            } else if (0 === e6.tag) {
              a3.push(t7 = e6[0]);
              t7(0);
            } else if (a3.length) {
              i6(e6);
              t7(0);
            }
          });
        }(r7(t6[0]));
        if (!n6) {
          n6 = true;
          f6(0);
        }
      }
    });
    i6(start((e6) => {
      if (1 === e6) {
        if (!s4) {
          s4 = true;
          f6(1);
        }
        for (var r8 = 0, t6 = a3, i7 = a3.length; r8 < i7; r8++) {
          t6[r8](1);
        }
        a3.length = 0;
      } else {
        if (!s4 && !n6) {
          n6 = true;
          f6(0);
        } else {
          n6 = false;
        }
        for (var l7 = 0, u4 = a3, o5 = a3.length; l7 < o5; l7++) {
          u4[l7](0);
        }
      }
    }));
  };
}
function mergeAll(e6) {
  return mergeMap(identity2)(e6);
}
function merge3(e6) {
  return mergeAll(r4(e6));
}
function onEnd(e6) {
  return (r7) => (t5) => {
    var i6 = false;
    r7((r8) => {
      if (i6) {
      } else if (0 === r8) {
        i6 = true;
        t5(0);
        e6();
      } else if (0 === r8.tag) {
        var a3 = r8[0];
        t5(start((r9) => {
          if (1 === r9) {
            i6 = true;
            a3(1);
            e6();
          } else {
            a3(r9);
          }
        }));
      } else {
        t5(r8);
      }
    });
  };
}
function onPush(e6) {
  return (r7) => (t5) => {
    var i6 = false;
    r7((r8) => {
      if (i6) {
      } else if (0 === r8) {
        i6 = true;
        t5(0);
      } else if (0 === r8.tag) {
        var a3 = r8[0];
        t5(start((e7) => {
          if (1 === e7) {
            i6 = true;
          }
          a3(e7);
        }));
      } else {
        e6(r8[0]);
        t5(r8);
      }
    });
  };
}
function onStart(e6) {
  return (r7) => (t5) => r7((r8) => {
    if (0 === r8) {
      t5(0);
    } else if (0 === r8.tag) {
      t5(r8);
      e6();
    } else {
      t5(r8);
    }
  });
}
function share(r7) {
  var t5 = [];
  var i6 = e3;
  var a3 = false;
  return (e6) => {
    t5.push(e6);
    if (1 === t5.length) {
      r7((e7) => {
        if (0 === e7) {
          for (var r8 = 0, f6 = t5, n6 = t5.length; r8 < n6; r8++) {
            f6[r8](0);
          }
          t5.length = 0;
        } else if (0 === e7.tag) {
          i6 = e7[0];
        } else {
          a3 = false;
          for (var s4 = 0, l7 = t5, u4 = t5.length; s4 < u4; s4++) {
            l7[s4](e7);
          }
        }
      });
    }
    e6(start((r8) => {
      if (1 === r8) {
        var f6 = t5.indexOf(e6);
        if (f6 > -1) {
          (t5 = t5.slice()).splice(f6, 1);
        }
        if (!t5.length) {
          i6(1);
        }
      } else if (!a3) {
        a3 = true;
        i6(0);
      }
    }));
  };
}
function switchMap(r7) {
  return (t5) => (i6) => {
    var a3 = e3;
    var f6 = e3;
    var n6 = false;
    var s4 = false;
    var l7 = false;
    var u4 = false;
    t5((t6) => {
      if (u4) {
      } else if (0 === t6) {
        u4 = true;
        if (!l7) {
          i6(0);
        }
      } else if (0 === t6.tag) {
        a3 = t6[0];
      } else {
        if (l7) {
          f6(1);
          f6 = e3;
        }
        if (!n6) {
          n6 = true;
          a3(0);
        } else {
          n6 = false;
        }
        !function applyInnerSource(e6) {
          l7 = true;
          e6((e7) => {
            if (!l7) {
            } else if (0 === e7) {
              l7 = false;
              if (u4) {
                i6(0);
              } else if (!n6) {
                n6 = true;
                a3(0);
              }
            } else if (0 === e7.tag) {
              s4 = false;
              (f6 = e7[0])(0);
            } else {
              i6(e7);
              if (!s4) {
                f6(0);
              } else {
                s4 = false;
              }
            }
          });
        }(r7(t6[0]));
      }
    });
    i6(start((e6) => {
      if (1 === e6) {
        if (!u4) {
          u4 = true;
          a3(1);
        }
        if (l7) {
          l7 = false;
          f6(1);
        }
      } else {
        if (!u4 && !n6) {
          n6 = true;
          a3(0);
        }
        if (l7 && !s4) {
          s4 = true;
          f6(0);
        }
      }
    }));
  };
}
function take(r7) {
  return (t5) => (i6) => {
    var a3 = e3;
    var f6 = false;
    var n6 = 0;
    t5((e6) => {
      if (f6) {
      } else if (0 === e6) {
        f6 = true;
        i6(0);
      } else if (0 === e6.tag) {
        if (r7 <= 0) {
          f6 = true;
          i6(0);
          e6[0](1);
        } else {
          a3 = e6[0];
        }
      } else if (n6++ < r7) {
        i6(e6);
        if (!f6 && n6 >= r7) {
          f6 = true;
          i6(0);
          a3(1);
        }
      } else {
        i6(e6);
      }
    });
    i6(start((e6) => {
      if (1 === e6 && !f6) {
        f6 = true;
        a3(1);
      } else if (0 === e6 && !f6 && n6 < r7) {
        a3(0);
      }
    }));
  };
}
function takeUntil(r7) {
  return (t5) => (i6) => {
    var a3 = e3;
    var f6 = e3;
    var n6 = false;
    t5((e6) => {
      if (n6) {
      } else if (0 === e6) {
        n6 = true;
        f6(1);
        i6(0);
      } else if (0 === e6.tag) {
        a3 = e6[0];
        r7((e7) => {
          if (0 === e7) {
          } else if (0 === e7.tag) {
            (f6 = e7[0])(0);
          } else {
            n6 = true;
            f6(1);
            a3(1);
            i6(0);
          }
        });
      } else {
        i6(e6);
      }
    });
    i6(start((e6) => {
      if (1 === e6 && !n6) {
        n6 = true;
        a3(1);
        f6(1);
      } else if (!n6) {
        a3(0);
      }
    }));
  };
}
function takeWhile(r7, t5) {
  return (i6) => (a3) => {
    var f6 = e3;
    var n6 = false;
    i6((e6) => {
      if (n6) {
      } else if (0 === e6) {
        n6 = true;
        a3(0);
      } else if (0 === e6.tag) {
        f6 = e6[0];
        a3(e6);
      } else if (!r7(e6[0])) {
        n6 = true;
        if (t5) {
          a3(e6);
        }
        a3(0);
        f6(1);
      } else {
        a3(e6);
      }
    });
  };
}
function lazy(e6) {
  return (r7) => e6()(r7);
}
function fromAsyncIterable(e6) {
  return (r7) => {
    var t5 = e6[asyncIteratorSymbol()] && e6[asyncIteratorSymbol()]() || e6;
    var i6 = false;
    var a3 = false;
    var f6 = false;
    var n6;
    r7(start(async (e7) => {
      if (1 === e7) {
        i6 = true;
        if (t5.return) {
          t5.return();
        }
      } else if (a3) {
        f6 = true;
      } else {
        for (f6 = a3 = true; f6 && !i6; ) {
          if ((n6 = await t5.next()).done) {
            i6 = true;
            if (t5.return) {
              await t5.return();
            }
            r7(0);
          } else {
            try {
              f6 = false;
              r7(push(n6.value));
            } catch (e8) {
              if (t5.throw) {
                if (i6 = !!(await t5.throw(e8)).done) {
                  r7(0);
                }
              } else {
                throw e8;
              }
            }
          }
        }
        a3 = false;
      }
    }));
  };
}
function fromIterable(e6) {
  if (e6[Symbol.asyncIterator]) {
    return fromAsyncIterable(e6);
  }
  return (r7) => {
    var t5 = e6[Symbol.iterator]();
    var i6 = false;
    var a3 = false;
    var f6 = false;
    var n6;
    r7(start((e7) => {
      if (1 === e7) {
        i6 = true;
        if (t5.return) {
          t5.return();
        }
      } else if (a3) {
        f6 = true;
      } else {
        for (f6 = a3 = true; f6 && !i6; ) {
          if ((n6 = t5.next()).done) {
            i6 = true;
            if (t5.return) {
              t5.return();
            }
            r7(0);
          } else {
            try {
              f6 = false;
              r7(push(n6.value));
            } catch (e8) {
              if (t5.throw) {
                if (i6 = !!t5.throw(e8).done) {
                  r7(0);
                }
              } else {
                throw e8;
              }
            }
          }
        }
        a3 = false;
      }
    }));
  };
}
var r4 = fromIterable;
function fromValue(e6) {
  return (r7) => {
    var t5 = false;
    r7(start((i6) => {
      if (1 === i6) {
        t5 = true;
      } else if (!t5) {
        t5 = true;
        r7(push(e6));
        r7(0);
      }
    }));
  };
}
function make(e6) {
  return (r7) => {
    var t5 = false;
    var i6 = e6({
      next(e7) {
        if (!t5) {
          r7(push(e7));
        }
      },
      complete() {
        if (!t5) {
          t5 = true;
          r7(0);
        }
      }
    });
    r7(start((e7) => {
      if (1 === e7 && !t5) {
        t5 = true;
        i6();
      }
    }));
  };
}
function makeSubject() {
  var e6;
  var r7;
  return {
    source: share(make((t5) => {
      e6 = t5.next;
      r7 = t5.complete;
      return teardownPlaceholder;
    })),
    next(r8) {
      if (e6) {
        e6(r8);
      }
    },
    complete() {
      if (r7) {
        r7();
      }
    }
  };
}
var empty = (e6) => {
  var r7 = false;
  e6(start((t5) => {
    if (1 === t5) {
      r7 = true;
    } else if (!r7) {
      r7 = true;
      e6(0);
    }
  }));
};
function fromPromise(e6) {
  return make((r7) => {
    e6.then((e7) => {
      Promise.resolve(e7).then(() => {
        r7.next(e7);
        r7.complete();
      });
    });
    return teardownPlaceholder;
  });
}
function subscribe2(r7) {
  return (t5) => {
    var i6 = e3;
    var a3 = false;
    t5((e6) => {
      if (0 === e6) {
        a3 = true;
      } else if (0 === e6.tag) {
        (i6 = e6[0])(0);
      } else if (!a3) {
        r7(e6[0]);
        i6(0);
      }
    });
    return {
      unsubscribe() {
        if (!a3) {
          a3 = true;
          i6(1);
        }
      }
    };
  };
}
function publish(e6) {
  subscribe2((e7) => {
  })(e6);
}
function toPromise(r7) {
  return new Promise((t5) => {
    var i6 = e3;
    var a3;
    r7((e6) => {
      if (0 === e6) {
        Promise.resolve(a3).then(t5);
      } else if (0 === e6.tag) {
        (i6 = e6[0])(0);
      } else {
        a3 = e6[0];
        i6(0);
      }
    });
  });
}

// node_modules/@urql/core/dist/urql-core-chunk.mjs
var rehydrateGraphQlError = (e6) => {
  if (e6 && e6.message && (e6.extensions || "GraphQLError" === e6.name)) {
    return e6;
  } else if ("object" == typeof e6 && e6.message) {
    return new GraphQLError2(e6.message, e6.nodes, e6.source, e6.positions, e6.path, e6, e6.extensions || {});
  } else {
    return new GraphQLError2(e6);
  }
};
var CombinedError = class extends Error {
  constructor(r7) {
    var e6 = (r7.graphQLErrors || []).map(rehydrateGraphQlError);
    var t5 = ((r8, e7) => {
      var t6 = "";
      if (r8) {
        return `[Network] ${r8.message}`;
      }
      if (e7) {
        for (var a3 of e7) {
          if (t6) {
            t6 += "\n";
          }
          t6 += `[GraphQL] ${a3.message}`;
        }
      }
      return t6;
    })(r7.networkError, e6);
    super(t5);
    this.name = "CombinedError";
    this.message = t5;
    this.graphQLErrors = e6;
    this.networkError = r7.networkError;
    this.response = r7.response;
  }
  toString() {
    return this.message;
  }
};
var phash = (r7, e6) => {
  var t5 = 0 | (e6 || 5381);
  for (var a3 = 0, o5 = 0 | r7.length; a3 < o5; a3++) {
    t5 = (t5 << 5) + t5 + r7.charCodeAt(a3);
  }
  return t5;
};
var i4 = /* @__PURE__ */ new Set();
var f3 = /* @__PURE__ */ new WeakMap();
var stringify3 = (r7) => {
  if (null === r7 || i4.has(r7)) {
    return "null";
  } else if ("object" != typeof r7) {
    return JSON.stringify(r7) || "";
  } else if (r7.toJSON) {
    return stringify3(r7.toJSON());
  } else if (Array.isArray(r7)) {
    var e6 = "[";
    for (var t5 of r7) {
      if (e6.length > 1) {
        e6 += ",";
      }
      e6 += stringify3(t5) || "null";
    }
    return e6 += "]";
  } else if (v3 !== NoopConstructor && r7 instanceof v3 || l3 !== NoopConstructor && r7 instanceof l3) {
    return "null";
  }
  var a3 = Object.keys(r7).sort();
  if (!a3.length && r7.constructor && Object.getPrototypeOf(r7).constructor !== Object.prototype.constructor) {
    var o5 = f3.get(r7) || Math.random().toString(36).slice(2);
    f3.set(r7, o5);
    return stringify3({
      __key: o5
    });
  }
  i4.add(r7);
  var n6 = "{";
  for (var s4 of a3) {
    var c5 = stringify3(r7[s4]);
    if (c5) {
      if (n6.length > 1) {
        n6 += ",";
      }
      n6 += stringify3(s4) + ":" + c5;
    }
  }
  i4.delete(r7);
  return n6 += "}";
};
var extract = (r7, e6, t5) => {
  if (null == t5 || "object" != typeof t5 || t5.toJSON || i4.has(t5)) {
  } else if (Array.isArray(t5)) {
    for (var a3 = 0, o5 = t5.length; a3 < o5; a3++) {
      extract(r7, `${e6}.${a3}`, t5[a3]);
    }
  } else if (t5 instanceof v3 || t5 instanceof l3) {
    r7.set(e6, t5);
  } else {
    i4.add(t5);
    for (var n6 of Object.keys(t5)) {
      extract(r7, `${e6}.${n6}`, t5[n6]);
    }
  }
};
var stringifyVariables = (r7) => {
  i4.clear();
  return stringify3(r7);
};
var NoopConstructor = class {
};
var v3 = "undefined" != typeof File ? File : NoopConstructor;
var l3 = "undefined" != typeof Blob ? Blob : NoopConstructor;
var c3 = /("{3}[\s\S]*"{3}|"(?:\\.|[^"])*")/g;
var p3 = /(?:#[^\n\r]+)?(?:[\r\n]+|$)/g;
var replaceOutsideStrings = (r7, e6) => e6 % 2 == 0 ? r7.replace(p3, "\n") : r7;
var sanitizeDocument = (r7) => r7.split(c3).map(replaceOutsideStrings).join("").trim();
var d3 = /* @__PURE__ */ new Map();
var u3 = /* @__PURE__ */ new Map();
var stringifyDocument = (r7) => {
  var t5;
  if ("string" == typeof r7) {
    t5 = sanitizeDocument(r7);
  } else if (r7.loc && u3.get(r7.__key) === r7) {
    t5 = r7.loc.source.body;
  } else {
    t5 = d3.get(r7) || sanitizeDocument(print3(r7));
    d3.set(r7, t5);
  }
  if ("string" != typeof r7 && !r7.loc) {
    r7.loc = {
      start: 0,
      end: t5.length,
      source: {
        body: t5,
        name: "gql",
        locationOffset: {
          line: 1,
          column: 1
        }
      }
    };
  }
  return t5;
};
var hashDocument = (r7) => {
  var e6 = phash(stringifyDocument(r7));
  if (r7.definitions) {
    var t5 = getOperationName(r7);
    if (t5) {
      e6 = phash(`
# ${t5}`, e6);
    }
  }
  return e6;
};
var keyDocument = (r7) => {
  var e6;
  var a3;
  if ("string" == typeof r7) {
    e6 = hashDocument(r7);
    a3 = u3.get(e6) || parse5(r7, {
      noLocation: true
    });
  } else {
    e6 = r7.__key || hashDocument(r7);
    a3 = u3.get(e6) || r7;
  }
  if (!a3.loc) {
    stringifyDocument(a3);
  }
  a3.__key = e6;
  u3.set(e6, a3);
  return a3;
};
var createRequest = (r7, e6, t5) => {
  var a3 = e6 || {};
  var o5 = keyDocument(r7);
  var n6 = stringifyVariables(a3);
  var s4 = o5.__key;
  if ("{}" !== n6) {
    s4 = phash(n6, s4);
  }
  return {
    key: s4,
    query: o5,
    variables: a3,
    extensions: t5
  };
};
var getOperationName = (r7) => {
  for (var e6 of r7.definitions) {
    if (e6.kind === e2.OPERATION_DEFINITION) {
      return e6.name ? e6.name.value : void 0;
    }
  }
};
var getOperationType = (r7) => {
  for (var e6 of r7.definitions) {
    if (e6.kind === e2.OPERATION_DEFINITION) {
      return e6.operation;
    }
  }
};
var makeResult = (r7, e6, t5) => {
  if (!("data" in e6 || "errors" in e6 && Array.isArray(e6.errors))) {
    throw new Error("No Content");
  }
  var a3 = "subscription" === r7.kind;
  return {
    operation: r7,
    data: e6.data,
    error: Array.isArray(e6.errors) ? new CombinedError({
      graphQLErrors: e6.errors,
      response: t5
    }) : void 0,
    extensions: e6.extensions ? {
      ...e6.extensions
    } : void 0,
    hasNext: null == e6.hasNext ? a3 : e6.hasNext,
    stale: false
  };
};
var deepMerge = (r7, e6) => {
  if ("object" == typeof r7 && null != r7) {
    if (!r7.constructor || r7.constructor === Object || Array.isArray(r7)) {
      r7 = Array.isArray(r7) ? [...r7] : {
        ...r7
      };
      for (var t5 of Object.keys(e6)) {
        r7[t5] = deepMerge(r7[t5], e6[t5]);
      }
      return r7;
    }
  }
  return e6;
};
var mergeResultPatch = (r7, e6, t5, a3) => {
  var o5 = r7.error ? r7.error.graphQLErrors : [];
  var n6 = !!r7.extensions || !!e6.extensions;
  var s4 = {
    ...r7.extensions,
    ...e6.extensions
  };
  var i6 = e6.incremental;
  if ("path" in e6) {
    i6 = [e6];
  }
  var f6 = {
    data: r7.data
  };
  if (i6) {
    var _loop = function(r8) {
      if (Array.isArray(r8.errors)) {
        o5.push(...r8.errors);
      }
      if (r8.extensions) {
        Object.assign(s4, r8.extensions);
        n6 = true;
      }
      var e7 = "data";
      var t6 = f6;
      var i7 = [];
      if (r8.path) {
        i7 = r8.path;
      } else if (a3) {
        var v7 = a3.find((e8) => e8.id === r8.id);
        if (r8.subPath) {
          i7 = [...v7.path, ...r8.subPath];
        } else {
          i7 = v7.path;
        }
      }
      for (var l7 = 0, c5 = i7.length; l7 < c5; e7 = i7[l7++]) {
        t6 = t6[e7] = Array.isArray(t6[e7]) ? [...t6[e7]] : {
          ...t6[e7]
        };
      }
      if (r8.items) {
        var p5 = +e7 >= 0 ? e7 : 0;
        for (var d5 = 0, u4 = r8.items.length; d5 < u4; d5++) {
          t6[p5 + d5] = deepMerge(t6[p5 + d5], r8.items[d5]);
        }
      } else if (void 0 !== r8.data) {
        t6[e7] = deepMerge(t6[e7], r8.data);
      }
    };
    for (var v6 of i6) {
      _loop(v6);
    }
  } else {
    f6.data = e6.data || r7.data;
    o5 = e6.errors || o5;
  }
  return {
    operation: r7.operation,
    data: f6.data,
    error: o5.length ? new CombinedError({
      graphQLErrors: o5,
      response: t5
    }) : void 0,
    extensions: n6 ? s4 : void 0,
    hasNext: null != e6.hasNext ? e6.hasNext : r7.hasNext,
    stale: false
  };
};
var makeErrorResult = (r7, e6, t5) => ({
  operation: r7,
  data: void 0,
  error: new CombinedError({
    networkError: e6,
    response: t5
  }),
  extensions: void 0,
  hasNext: false,
  stale: false
});
function makeFetchBody(r7) {
  return {
    query: r7.extensions && r7.extensions.persistedQuery && !r7.extensions.persistedQuery.miss ? void 0 : stringifyDocument(r7.query),
    operationName: getOperationName(r7.query),
    variables: r7.variables || void 0,
    extensions: r7.extensions
  };
}
var makeFetchURL = (r7, e6) => {
  var t5 = "query" === r7.kind && r7.context.preferGetMethod;
  if (!t5 || !e6) {
    return r7.context.url;
  }
  var a3 = new URL(r7.context.url);
  for (var o5 in e6) {
    var n6 = e6[o5];
    if (n6) {
      a3.searchParams.set(o5, "object" == typeof n6 ? stringifyVariables(n6) : n6);
    }
  }
  var s4 = a3.toString();
  if (s4.length > 2047 && "force" !== t5) {
    r7.context.preferGetMethod = false;
    return r7.context.url;
  }
  return s4;
};
var serializeBody = (r7, e6) => {
  if (e6 && !("query" === r7.kind && !!r7.context.preferGetMethod)) {
    var t5 = stringifyVariables(e6);
    var a3 = ((r8) => {
      var e7 = /* @__PURE__ */ new Map();
      if (v3 !== NoopConstructor || l3 !== NoopConstructor) {
        i4.clear();
        extract(e7, "variables", r8);
      }
      return e7;
    })(e6.variables);
    if (a3.size) {
      var o5 = new FormData();
      o5.append("operations", t5);
      o5.append("map", stringifyVariables({
        ...[...a3.keys()].map((r8) => [r8])
      }));
      var n6 = 0;
      for (var s4 of a3.values()) {
        o5.append("" + n6++, s4);
      }
      return o5;
    }
    return t5;
  }
};
var makeFetchOptions = (r7, e6) => {
  var t5 = {
    accept: "subscription" === r7.kind ? "text/event-stream, multipart/mixed" : "application/graphql-response+json, application/graphql+json, application/json, text/event-stream, multipart/mixed"
  };
  var a3 = ("function" == typeof r7.context.fetchOptions ? r7.context.fetchOptions() : r7.context.fetchOptions) || {};
  if (a3.headers) {
    for (var o5 in a3.headers) {
      t5[o5.toLowerCase()] = a3.headers[o5];
    }
  }
  var n6 = serializeBody(r7, e6);
  if ("string" == typeof n6 && !t5["content-type"]) {
    t5["content-type"] = "application/json";
  }
  return {
    ...a3,
    method: n6 ? "POST" : "GET",
    body: n6,
    headers: t5
  };
};
var y3 = "undefined" != typeof TextDecoder ? new TextDecoder() : null;
var h2 = /boundary="?([^=";]+)"?/i;
var x2 = /data: ?([^\n]+)/;
var toString = (r7) => "Buffer" === r7.constructor.name ? r7.toString() : y3.decode(r7);
async function* streamBody(r7) {
  if (r7.body[Symbol.asyncIterator]) {
    for await (var e6 of r7.body) {
      yield toString(e6);
    }
  } else {
    var t5 = r7.body.getReader();
    var a3;
    try {
      while (!(a3 = await t5.read()).done) {
        yield toString(a3.value);
      }
    } finally {
      t5.cancel();
    }
  }
}
async function* split(r7, e6) {
  var t5 = "";
  var a3;
  for await (var o5 of r7) {
    t5 += o5;
    while ((a3 = t5.indexOf(e6)) > -1) {
      yield t5.slice(0, a3);
      t5 = t5.slice(a3 + e6.length);
    }
  }
}
async function* fetchOperation(r7, e6, t5) {
  var a3 = true;
  var o5 = null;
  var n6;
  try {
    yield await Promise.resolve();
    var s4 = (n6 = await (r7.context.fetch || fetch)(e6, t5)).headers.get("Content-Type") || "";
    var i6;
    if (/multipart\/mixed/i.test(s4)) {
      i6 = async function* parseMultipartMixed(r8, e7) {
        var t6 = r8.match(h2);
        var a4 = "--" + (t6 ? t6[1] : "-");
        var o6 = true;
        var n7;
        for await (var s5 of split(streamBody(e7), "\r\n" + a4)) {
          if (o6) {
            o6 = false;
            var i7 = s5.indexOf(a4);
            if (i7 > -1) {
              s5 = s5.slice(i7 + a4.length);
            } else {
              continue;
            }
          }
          try {
            yield n7 = JSON.parse(s5.slice(s5.indexOf("\r\n\r\n") + 4));
          } catch (r9) {
            if (!n7) {
              throw r9;
            }
          }
          if (n7 && false === n7.hasNext) {
            break;
          }
        }
        if (n7 && false !== n7.hasNext) {
          yield {
            hasNext: false
          };
        }
      }(s4, n6);
    } else if (/text\/event-stream/i.test(s4)) {
      i6 = async function* parseEventStream(r8) {
        var e7;
        for await (var t6 of split(streamBody(r8), "\n\n")) {
          var a4 = t6.match(x2);
          if (a4) {
            var o6 = a4[1];
            try {
              yield e7 = JSON.parse(o6);
            } catch (r9) {
              if (!e7) {
                throw r9;
              }
            }
            if (e7 && false === e7.hasNext) {
              break;
            }
          }
        }
        if (e7 && false !== e7.hasNext) {
          yield {
            hasNext: false
          };
        }
      }(n6);
    } else if (!/text\//i.test(s4)) {
      i6 = async function* parseJSON(r8) {
        yield JSON.parse(await r8.text());
      }(n6);
    } else {
      i6 = async function* parseMaybeJSON(r8) {
        var e7 = await r8.text();
        try {
          var t6 = JSON.parse(e7);
          if (true) {
            console.warn('Found response with content-type "text/plain" but it had a valid "application/json" response.');
          }
          yield t6;
        } catch (r9) {
          throw new Error(e7);
        }
      }(n6);
    }
    var f6;
    for await (var v6 of i6) {
      if (v6.pending && !o5) {
        f6 = v6.pending;
      } else if (v6.pending) {
        f6 = [...f6, ...v6.pending];
      }
      o5 = o5 ? mergeResultPatch(o5, v6, n6, f6) : makeResult(r7, v6, n6);
      a3 = false;
      yield o5;
      a3 = true;
    }
    if (!o5) {
      yield o5 = makeResult(r7, {}, n6);
    }
  } catch (e7) {
    if (!a3) {
      throw e7;
    }
    yield makeErrorResult(r7, n6 && (n6.status < 200 || n6.status >= 300) && n6.statusText ? new Error(n6.statusText) : e7, n6);
  }
}
function makeFetchSource(r7, e6, t5) {
  var a3;
  if ("undefined" != typeof AbortController) {
    t5.signal = (a3 = new AbortController()).signal;
  }
  return onEnd(() => {
    if (a3) {
      a3.abort();
    }
  })(filter2((r8) => !!r8)(fromAsyncIterable(fetchOperation(r7, e6, t5))));
}

// node_modules/@urql/core/dist/urql-core.mjs
var formatNode2 = (r7) => {
  if ("definitions" in r7) {
    var t5 = [];
    for (var n6 of r7.definitions) {
      var a3 = formatNode2(n6);
      t5.push(a3);
    }
    return {
      ...r7,
      definitions: t5
    };
  }
  if ("directives" in r7 && r7.directives && r7.directives.length) {
    var o5 = [];
    var i6 = {};
    for (var s4 of r7.directives) {
      var c5 = s4.name.value;
      if ("_" !== c5[0]) {
        o5.push(s4);
      } else {
        c5 = c5.slice(1);
      }
      i6[c5] = s4;
    }
    r7 = {
      ...r7,
      directives: o5,
      _directives: i6
    };
  }
  if ("selectionSet" in r7) {
    var u4 = [];
    var p5 = r7.kind === e2.OPERATION_DEFINITION;
    if (r7.selectionSet) {
      for (var d5 of r7.selectionSet.selections || []) {
        p5 = p5 || d5.kind === e2.FIELD && "__typename" === d5.name.value && !d5.alias;
        var v6 = formatNode2(d5);
        u4.push(v6);
      }
      if (!p5) {
        u4.push({
          kind: e2.FIELD,
          name: {
            kind: e2.NAME,
            value: "__typename"
          },
          _generated: true
        });
      }
      return {
        ...r7,
        selectionSet: {
          ...r7.selectionSet,
          selections: u4
        }
      };
    }
  }
  return r7;
};
var I2 = /* @__PURE__ */ new Map();
var formatDocument = (e6) => {
  var t5 = keyDocument(e6);
  var n6 = I2.get(t5.__key);
  if (!n6) {
    I2.set(t5.__key, n6 = formatNode2(t5));
    Object.defineProperty(n6, "__key", {
      value: t5.__key,
      enumerable: false
    });
  }
  return n6;
};
var maskTypename = (e6, r7) => {
  if (!e6 || "object" != typeof e6) {
    return e6;
  } else if (Array.isArray(e6)) {
    return e6.map((e7) => maskTypename(e7));
  } else if (e6 && "object" == typeof e6 && (r7 || "__typename" in e6)) {
    var t5 = {};
    for (var n6 in e6) {
      if ("__typename" === n6) {
        Object.defineProperty(t5, "__typename", {
          enumerable: false,
          value: e6.__typename
        });
      } else {
        t5[n6] = maskTypename(e6[n6]);
      }
    }
    return t5;
  } else {
    return e6;
  }
};
function withPromise(e6) {
  var source$ = (r7) => e6(r7);
  source$.toPromise = () => toPromise(take(1)(filter2((e7) => !e7.stale && !e7.hasNext)(source$)));
  source$.then = (e7, r7) => source$.toPromise().then(e7, r7);
  source$.subscribe = (e7) => subscribe2(e7)(source$);
  return source$;
}
function makeOperation(e6, r7, t5) {
  return {
    ...r7,
    kind: e6,
    context: r7.context ? {
      ...r7.context,
      ...t5
    } : t5 || r7.context
  };
}
var noop = () => {
};
var fetchExchange = ({ forward: e6, dispatchDebug: r7 }) => (t5) => {
  var n6 = mergeMap((e7) => {
    var n7 = makeFetchBody(e7);
    var a4 = makeFetchURL(e7, n7);
    var i6 = makeFetchOptions(e7, n7);
    r7({
      type: "fetchRequest",
      message: "A fetch request is being executed.",
      operation: e7,
      data: {
        url: a4,
        fetchOptions: i6
      },
      source: "fetchExchange"
    });
    var s4 = takeUntil(filter2((r8) => "teardown" === r8.kind && r8.key === e7.key)(t5))(makeFetchSource(e7, a4, i6));
    if (true) {
      return onPush((t6) => {
        var n8 = !t6.data ? t6.error : void 0;
        r7({
          type: n8 ? "fetchError" : "fetchSuccess",
          message: `A ${n8 ? "failed" : "successful"} fetch response has been returned.`,
          operation: e7,
          data: {
            url: a4,
            fetchOptions: i6,
            value: n8 || t6
          },
          source: "fetchExchange"
        });
      })(s4);
    }
    return s4;
  })(filter2((e7) => "teardown" !== e7.kind && ("subscription" !== e7.kind || !!e7.context.fetchSubscriptions))(t5));
  var a3 = e6(filter2((e7) => "teardown" === e7.kind || "subscription" === e7.kind && !e7.context.fetchSubscriptions)(t5));
  return merge3([n6, a3]);
};
var composeExchanges = (e6) => ({ client: r7, forward: t5, dispatchDebug: n6 }) => e6.reduceRight((e7, t6) => {
  var a3 = false;
  return t6({
    client: r7,
    forward(r8) {
      if (true) {
        if (a3) {
          throw new Error("forward() must only be called once in each Exchange.");
        }
        a3 = true;
      }
      return share(e7(share(r8)));
    },
    dispatchDebug(e8) {
      n6({
        timestamp: Date.now(),
        source: t6.name,
        ...e8
      });
    }
  });
}, t5);
var fallbackExchange = ({ dispatchDebug: e6 }) => (r7) => {
  if (true) {
    r7 = onPush((r8) => {
      if ("teardown" !== r8.kind && true) {
        var t5 = `No exchange has handled operations of kind "${r8.kind}". Check whether you've added an exchange responsible for these operations.`;
        e6({
          type: "fallbackCatch",
          message: t5,
          operation: r8,
          source: "fallbackExchange"
        });
        console.warn(t5);
      }
    })(r7);
  }
  return filter2((e7) => false)(r7);
};
var C = function Client(e6) {
  if (!e6.url) {
    throw new Error("You are creating an urql-client without a url.");
  }
  var r7 = 0;
  var t5 = /* @__PURE__ */ new Map();
  var n6 = /* @__PURE__ */ new Map();
  var a3 = /* @__PURE__ */ new Set();
  var o5 = [];
  var i6 = {
    url: e6.url,
    fetchSubscriptions: e6.fetchSubscriptions,
    fetchOptions: e6.fetchOptions,
    fetch: e6.fetch,
    preferGetMethod: e6.preferGetMethod,
    requestPolicy: e6.requestPolicy || "cache-first"
  };
  var s4 = makeSubject();
  function nextOperation(e7) {
    if ("mutation" === e7.kind || "teardown" === e7.kind || !a3.has(e7.key)) {
      if ("teardown" === e7.kind) {
        a3.delete(e7.key);
      } else if ("mutation" !== e7.kind) {
        a3.add(e7.key);
      }
      s4.next(e7);
    }
  }
  var c5 = false;
  function dispatchOperation(e7) {
    if (e7) {
      nextOperation(e7);
    }
    if (!c5) {
      c5 = true;
      while (c5 && (e7 = o5.shift())) {
        nextOperation(e7);
      }
      c5 = false;
    }
  }
  var makeResultSource = (r8) => {
    var i7 = takeUntil(filter2((e7) => "teardown" === e7.kind && e7.key === r8.key)(s4.source))(filter2((e7) => e7.operation.kind === r8.kind && e7.operation.key === r8.key && (!e7.operation.context._instance || e7.operation.context._instance === r8.context._instance))(O2));
    if (e6.maskTypename) {
      i7 = map3((e7) => ({
        ...e7,
        data: maskTypename(e7.data, true)
      }))(i7);
    }
    if ("query" !== r8.kind) {
      i7 = takeWhile((e7) => !!e7.hasNext, true)(i7);
    } else {
      i7 = switchMap((e7) => {
        var t6 = fromValue(e7);
        return e7.stale || e7.hasNext ? t6 : merge3([t6, map3(() => {
          e7.stale = true;
          return e7;
        })(take(1)(filter2((e8) => e8.key === r8.key)(s4.source)))]);
      })(i7);
    }
    if ("mutation" !== r8.kind) {
      i7 = onEnd(() => {
        a3.delete(r8.key);
        t5.delete(r8.key);
        n6.delete(r8.key);
        c5 = false;
        for (var e7 = o5.length - 1; e7 >= 0; e7--) {
          if (o5[e7].key === r8.key) {
            o5.splice(e7, 1);
          }
        }
        nextOperation(makeOperation("teardown", r8, r8.context));
      })(onPush((e7) => {
        if (e7.stale) {
          for (var n7 of o5) {
            if (n7.key === e7.operation.key) {
              a3.delete(n7.key);
              break;
            }
          }
        } else if (!e7.hasNext) {
          a3.delete(r8.key);
        }
        t5.set(r8.key, e7);
      })(i7));
    } else {
      i7 = onStart(() => {
        nextOperation(r8);
      })(i7);
    }
    return share(i7);
  };
  var u4 = this instanceof Client ? this : Object.create(Client.prototype);
  var p5 = Object.assign(u4, {
    suspense: !!e6.suspense,
    operations$: s4.source,
    reexecuteOperation(e7) {
      if ("teardown" === e7.kind) {
        dispatchOperation(e7);
      } else if ("mutation" === e7.kind || n6.has(e7.key)) {
        var r8 = false;
        for (var t6 = 0; t6 < o5.length; t6++) {
          r8 = r8 || o5[t6].key === e7.key;
        }
        if (!r8) {
          a3.delete(e7.key);
        }
        o5.push(e7);
        Promise.resolve().then(dispatchOperation);
      }
    },
    createRequestOperation(e7, t6, n7) {
      if (!n7) {
        n7 = {};
      }
      var a4;
      if ("teardown" !== e7 && (a4 = getOperationType(t6.query)) !== e7) {
        throw new Error(`Expected operation of type "${e7}" but found "${a4}"`);
      }
      return makeOperation(e7, t6, {
        _instance: "mutation" === e7 ? r7 = r7 + 1 | 0 : void 0,
        ...i6,
        ...n7,
        requestPolicy: n7.requestPolicy || i6.requestPolicy,
        suspense: n7.suspense || false !== n7.suspense && p5.suspense
      });
    },
    executeRequestOperation(e7) {
      if ("mutation" === e7.kind) {
        return withPromise(makeResultSource(e7));
      }
      return withPromise(lazy(() => {
        var r8 = n6.get(e7.key);
        if (!r8) {
          n6.set(e7.key, r8 = makeResultSource(e7));
        }
        r8 = onStart(() => {
          dispatchOperation(e7);
        })(r8);
        var a4 = t5.get(e7.key);
        if ("query" === e7.kind && a4 && (a4.stale || a4.hasNext)) {
          return switchMap(fromValue)(merge3([r8, filter2((r9) => r9 === t5.get(e7.key))(fromValue(a4))]));
        } else {
          return r8;
        }
      }));
    },
    executeQuery(e7, r8) {
      var t6 = p5.createRequestOperation("query", e7, r8);
      return p5.executeRequestOperation(t6);
    },
    executeSubscription(e7, r8) {
      var t6 = p5.createRequestOperation("subscription", e7, r8);
      return p5.executeRequestOperation(t6);
    },
    executeMutation(e7, r8) {
      var t6 = p5.createRequestOperation("mutation", e7, r8);
      return p5.executeRequestOperation(t6);
    },
    readQuery(e7, r8, t6) {
      var n7 = null;
      subscribe2((e8) => {
        n7 = e8;
      })(p5.query(e7, r8, t6)).unsubscribe();
      return n7;
    },
    query: (e7, r8, t6) => p5.executeQuery(createRequest(e7, r8), t6),
    subscription: (e7, r8, t6) => p5.executeSubscription(createRequest(e7, r8), t6),
    mutation: (e7, r8, t6) => p5.executeMutation(createRequest(e7, r8), t6)
  });
  var d5 = noop;
  if (true) {
    var { next: l7, source: x4 } = makeSubject();
    p5.subscribeToDebugTarget = (e7) => subscribe2(e7)(x4);
    d5 = l7;
  }
  var g4 = composeExchanges(e6.exchanges);
  var O2 = share(g4({
    client: p5,
    dispatchDebug: d5,
    forward: fallbackExchange({
      dispatchDebug: d5
    })
  })(s4.source));
  publish(O2);
  return p5;
};
var j2 = C;

// node_modules/urql/dist/urql.es.js
var r5 = __toESM(require_react());
var c4 = {};
var v4 = r5.createContext(c4);
var f4 = v4.Provider;
var l4 = v4.Consumer;
v4.displayName = "UrqlContext";
var useClient = () => {
  var e6 = r5.useContext(v4);
  if (e6 === c4 && true) {
    var t5 = "No client has been specified using urql's Provider. please create a client and add a Provider.";
    console.error(t5);
    throw new Error(t5);
  }
  return e6;
};
var d4 = {
  fetching: false,
  stale: false,
  error: void 0,
  data: void 0,
  extensions: void 0,
  operation: void 0
};
var areOperationsEqual = (e6, r7) => e6 === r7 || !(!e6 || !r7 || e6.key !== r7.key);
var computeNextState = (e6, r7) => {
  var t5 = {
    ...e6,
    ...r7,
    data: void 0 !== r7.data || r7.error ? r7.data : e6.data,
    fetching: !!r7.fetching,
    stale: !!r7.stale
  };
  return ((e7, r8) => {
    for (var t6 in e7) {
      if (!(t6 in r8)) {
        return true;
      }
    }
    for (var a3 in r8) {
      if ("operation" === a3 ? !areOperationsEqual(e7[a3], r8[a3]) : e7[a3] !== r8[a3]) {
        return true;
      }
    }
    return false;
  })(e6, t5) ? t5 : e6;
};
var hasDepsChanged = (e6, r7) => {
  for (var t5 = 0, a3 = r7.length; t5 < a3; t5++) {
    if (e6[t5] !== r7[t5]) {
      return true;
    }
  }
  return false;
};
var p4 = r5.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
function deferDispatch(e6, r7) {
  if (p4 && p4.ReactCurrentOwner && p4.ReactCurrentOwner.current) {
    Promise.resolve(r7).then(e6);
  } else {
    e6(r7);
  }
}
function useMutation(i6) {
  var s4 = r5.useRef(true);
  var o5 = useClient();
  var [c5, v6] = r5.useState(d4);
  var f6 = r5.useCallback((r7, c6) => {
    deferDispatch(v6, {
      ...d4,
      fetching: true
    });
    return toPromise(take(1)(filter2((e6) => !e6.hasNext)(onPush((e6) => {
      if (s4.current) {
        deferDispatch(v6, {
          fetching: false,
          stale: e6.stale,
          data: e6.data,
          error: e6.error,
          extensions: e6.extensions,
          operation: e6.operation
        });
      }
    })(o5.executeMutation(createRequest(i6, r7), c6 || {})))));
  }, [o5, i6, v6]);
  r5.useEffect(() => {
    s4.current = true;
    return () => {
      s4.current = false;
    };
  }, []);
  return [c5, f6];
}
function useRequest(t5, a3) {
  var n6 = r5.useRef(void 0);
  return r5.useMemo(() => {
    var r7 = createRequest(t5, a3);
    if (void 0 !== n6.current && n6.current.key === r7.key) {
      return n6.current;
    } else {
      n6.current = r7;
      return r7;
    }
  }, [t5, a3]);
}
var getCacheForClient = (e6) => {
  if (!e6._react) {
    var r7 = /* @__PURE__ */ new Set();
    var t5 = /* @__PURE__ */ new Map();
    if (e6.operations$) {
      subscribe2((e7) => {
        if ("teardown" === e7.kind && r7.has(e7.key)) {
          r7.delete(e7.key);
          t5.delete(e7.key);
        }
      })(e6.operations$);
    }
    e6._react = {
      get: (e7) => t5.get(e7),
      set(e7, a3) {
        r7.delete(e7);
        t5.set(e7, a3);
      },
      dispose(e7) {
        r7.add(e7);
      }
    };
  }
  return e6._react;
};
var isSuspense = (e6, r7) => r7 && void 0 !== r7.suspense ? !!r7.suspense : e6.suspense;
function useQuery(e6) {
  var t5 = useClient();
  var a3 = getCacheForClient(t5);
  var n6 = isSuspense(t5, e6.context);
  var c5 = useRequest(e6.query, e6.variables);
  var v6 = r5.useMemo(() => {
    if (e6.pause) {
      return null;
    }
    var r7 = t5.executeQuery(c5, {
      requestPolicy: e6.requestPolicy,
      ...e6.context
    });
    return n6 ? onPush((e7) => {
      a3.set(c5.key, e7);
    })(r7) : r7;
  }, [a3, t5, c5, n6, e6.pause, e6.requestPolicy, e6.context]);
  var f6 = r5.useCallback((e7, r7) => {
    if (!e7) {
      return {
        fetching: false
      };
    }
    var t6 = a3.get(c5.key);
    if (!t6) {
      var n7;
      var u4 = subscribe2((e8) => {
        t6 = e8;
        if (n7) {
          n7(t6);
        }
      })(takeWhile(() => r7 && !n7 || !t6)(e7));
      if (null == t6 && r7) {
        var o5 = new Promise((e8) => {
          n7 = e8;
        });
        a3.set(c5.key, o5);
        throw o5;
      } else {
        u4.unsubscribe();
      }
    } else if (r7 && null != t6 && "then" in t6) {
      throw t6;
    }
    return t6 || {
      fetching: true
    };
  }, [a3, c5]);
  var l7 = [t5, c5, e6.requestPolicy, e6.context, e6.pause];
  var [p5, h3] = r5.useState(() => [v6, computeNextState(d4, f6(v6, n6)), l7]);
  var y4 = p5[1];
  if (v6 !== p5[0] && hasDepsChanged(p5[2], l7)) {
    h3([v6, y4 = computeNextState(p5[1], f6(v6, n6)), l7]);
  }
  r5.useEffect(() => {
    var e7 = p5[0];
    var r7 = p5[2][1];
    var t6 = false;
    var updateResult = (e8) => {
      t6 = true;
      deferDispatch(h3, (r8) => {
        var t7 = computeNextState(r8[1], e8);
        return r8[1] !== t7 ? [r8[0], t7, r8[2]] : r8;
      });
    };
    if (e7) {
      var n7 = subscribe2(updateResult)(onEnd(() => {
        updateResult({
          fetching: false
        });
      })(e7));
      if (!t6) {
        updateResult({
          fetching: true
        });
      }
      return () => {
        a3.dispose(r7.key);
        n7.unsubscribe();
      };
    } else {
      updateResult({
        fetching: false
      });
    }
  }, [a3, p5[0], p5[2][1]]);
  var x4 = r5.useCallback((r7) => {
    var i6 = {
      requestPolicy: e6.requestPolicy,
      ...e6.context,
      ...r7
    };
    deferDispatch(h3, (e7) => [n6 ? onPush((e8) => {
      a3.set(c5.key, e8);
    })(t5.executeQuery(c5, i6)) : t5.executeQuery(c5, i6), e7[1], l7]);
  }, [t5, a3, c5, n6, e6.requestPolicy, e6.context, e6.pause]);
  return [y4, x4];
}

// node_modules/lru-cache/index.mjs
var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var hasAbortController = typeof AbortController === "function";
var AC = hasAbortController ? AbortController : class AbortController2 {
  constructor() {
    this.signal = new AS();
  }
  abort(reason = new Error("This operation was aborted")) {
    this.signal.reason = this.signal.reason || reason;
    this.signal.aborted = true;
    this.signal.dispatchEvent({
      type: "abort",
      target: this.signal
    });
  }
};
var hasAbortSignal = typeof AbortSignal === "function";
var hasACAbortSignal = typeof AC.AbortSignal === "function";
var AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : class AbortSignal2 {
  constructor() {
    this.reason = void 0;
    this.aborted = false;
    this._listeners = [];
  }
  dispatchEvent(e6) {
    if (e6.type === "abort") {
      this.aborted = true;
      this.onabort(e6);
      this._listeners.forEach((f6) => f6(e6), this);
    }
  }
  onabort() {
  }
  addEventListener(ev, fn2) {
    if (ev === "abort") {
      this._listeners.push(fn2);
    }
  }
  removeEventListener(ev, fn2) {
    if (ev === "abort") {
      this._listeners = this._listeners.filter((f6) => f6 !== fn2);
    }
  }
};
var warned = /* @__PURE__ */ new Set();
var deprecatedOption = (opt, instead) => {
  const code3 = `LRU_CACHE_OPTION_${opt}`;
  if (shouldWarn(code3)) {
    warn2(code3, `${opt} option`, `options.${instead}`, LRUCache);
  }
};
var deprecatedMethod = (method, instead) => {
  const code3 = `LRU_CACHE_METHOD_${method}`;
  if (shouldWarn(code3)) {
    const { prototype } = LRUCache;
    const { get: get3 } = Object.getOwnPropertyDescriptor(prototype, method);
    warn2(code3, `${method} method`, `cache.${instead}()`, get3);
  }
};
var deprecatedProperty = (field2, instead) => {
  const code3 = `LRU_CACHE_PROPERTY_${field2}`;
  if (shouldWarn(code3)) {
    const { prototype } = LRUCache;
    const { get: get3 } = Object.getOwnPropertyDescriptor(prototype, field2);
    warn2(code3, `${field2} property`, `cache.${instead}`, get3);
  }
};
var emitWarning = (...a3) => {
  typeof process === "object" && process && typeof process.emitWarning === "function" ? process.emitWarning(...a3) : console.error(...a3);
};
var shouldWarn = (code3) => !warned.has(code3);
var warn2 = (code3, what, instead, fn2) => {
  warned.add(code3);
  const msg2 = `The ${what} is deprecated. Please use ${instead} instead.`;
  emitWarning(msg2, "DeprecationWarning", code3, fn2);
};
var isPosInt = (n6) => n6 && n6 === Math.floor(n6) && n6 > 0 && isFinite(n6);
var getUintArray = (max4) => !isPosInt(max4) ? null : max4 <= Math.pow(2, 8) ? Uint8Array : max4 <= Math.pow(2, 16) ? Uint16Array : max4 <= Math.pow(2, 32) ? Uint32Array : max4 <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
var ZeroArray = class extends Array {
  constructor(size3) {
    super(size3);
    this.fill(0);
  }
};
var Stack = class {
  constructor(max4) {
    if (max4 === 0) {
      return [];
    }
    const UintArray = getUintArray(max4);
    this.heap = new UintArray(max4);
    this.length = 0;
  }
  push(n6) {
    this.heap[this.length++] = n6;
  }
  pop() {
    return this.heap[--this.length];
  }
};
var LRUCache = class _LRUCache {
  constructor(options = {}) {
    const {
      max: max4 = 0,
      ttl,
      ttlResolution = 1,
      ttlAutopurge,
      updateAgeOnGet,
      updateAgeOnHas,
      allowStale,
      dispose,
      disposeAfter,
      noDisposeOnSet,
      noUpdateTTL,
      maxSize = 0,
      maxEntrySize = 0,
      sizeCalculation,
      fetchMethod,
      fetchContext,
      noDeleteOnFetchRejection,
      noDeleteOnStaleGet,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort
    } = options;
    const { length: length4, maxAge, stale } = options instanceof _LRUCache ? {} : options;
    if (max4 !== 0 && !isPosInt(max4)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max4 ? getUintArray(max4) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max4);
    }
    this.max = max4;
    this.maxSize = maxSize;
    this.maxEntrySize = maxEntrySize || this.maxSize;
    this.sizeCalculation = sizeCalculation || length4;
    if (this.sizeCalculation) {
      if (!this.maxSize && !this.maxEntrySize) {
        throw new TypeError(
          "cannot set sizeCalculation without setting maxSize or maxEntrySize"
        );
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    this.fetchMethod = fetchMethod || null;
    if (this.fetchMethod && typeof this.fetchMethod !== "function") {
      throw new TypeError(
        "fetchMethod must be a function if specified"
      );
    }
    this.fetchContext = fetchContext;
    if (!this.fetchMethod && fetchContext !== void 0) {
      throw new TypeError(
        "cannot set fetchContext without fetchMethod"
      );
    }
    this.keyMap = /* @__PURE__ */ new Map();
    this.keyList = new Array(max4).fill(null);
    this.valList = new Array(max4).fill(null);
    this.next = new UintArray(max4);
    this.prev = new UintArray(max4);
    this.head = 0;
    this.tail = 0;
    this.free = new Stack(max4);
    this.initialFill = 1;
    this.size = 0;
    if (typeof dispose === "function") {
      this.dispose = dispose;
    }
    if (typeof disposeAfter === "function") {
      this.disposeAfter = disposeAfter;
      this.disposed = [];
    } else {
      this.disposeAfter = null;
      this.disposed = null;
    }
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (this.maxSize !== 0) {
        if (!isPosInt(this.maxSize)) {
          throw new TypeError(
            "maxSize must be a positive integer if specified"
          );
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError(
          "maxEntrySize must be a positive integer if specified"
        );
      }
      this.initializeSizeTracking();
    }
    this.allowStale = !!allowStale || !!stale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || maxAge || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError(
          "ttl must be a positive integer if specified"
        );
      }
      this.initializeTTLTracking();
    }
    if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
      throw new TypeError(
        "At least one of max, maxSize, or ttl is required"
      );
    }
    if (!this.ttlAutopurge && !this.max && !this.maxSize) {
      const code3 = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code3)) {
        warned.add(code3);
        const msg2 = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg2, "UnboundedCacheWarning", code3, _LRUCache);
      }
    }
    if (stale) {
      deprecatedOption("stale", "allowStale");
    }
    if (maxAge) {
      deprecatedOption("maxAge", "ttl");
    }
    if (length4) {
      deprecatedOption("length", "sizeCalculation");
    }
  }
  getRemainingTTL(key) {
    return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0;
  }
  initializeTTLTracking() {
    this.ttls = new ZeroArray(this.max);
    this.starts = new ZeroArray(this.max);
    this.setItemTTL = (index3, ttl, start2 = perf.now()) => {
      this.starts[index3] = ttl !== 0 ? start2 : 0;
      this.ttls[index3] = ttl;
      if (ttl !== 0 && this.ttlAutopurge) {
        const t5 = setTimeout(() => {
          if (this.isStale(index3)) {
            this.delete(this.keyList[index3]);
          }
        }, ttl + 1);
        if (t5.unref) {
          t5.unref();
        }
      }
    };
    this.updateItemAge = (index3) => {
      this.starts[index3] = this.ttls[index3] !== 0 ? perf.now() : 0;
    };
    this.statusTTL = (status, index3) => {
      if (status) {
        status.ttl = this.ttls[index3];
        status.start = this.starts[index3];
        status.now = cachedNow || getNow();
        status.remainingTTL = status.now + status.ttl - status.start;
      }
    };
    let cachedNow = 0;
    const getNow = () => {
      const n6 = perf.now();
      if (this.ttlResolution > 0) {
        cachedNow = n6;
        const t5 = setTimeout(
          () => cachedNow = 0,
          this.ttlResolution
        );
        if (t5.unref) {
          t5.unref();
        }
      }
      return n6;
    };
    this.getRemainingTTL = (key) => {
      const index3 = this.keyMap.get(key);
      if (index3 === void 0) {
        return 0;
      }
      return this.ttls[index3] === 0 || this.starts[index3] === 0 ? Infinity : this.starts[index3] + this.ttls[index3] - (cachedNow || getNow());
    };
    this.isStale = (index3) => {
      return this.ttls[index3] !== 0 && this.starts[index3] !== 0 && (cachedNow || getNow()) - this.starts[index3] > this.ttls[index3];
    };
  }
  updateItemAge(_index) {
  }
  statusTTL(_status, _index) {
  }
  setItemTTL(_index, _ttl, _start) {
  }
  isStale(_index) {
    return false;
  }
  initializeSizeTracking() {
    this.calculatedSize = 0;
    this.sizes = new ZeroArray(this.max);
    this.removeItemSize = (index3) => {
      this.calculatedSize -= this.sizes[index3];
      this.sizes[index3] = 0;
    };
    this.requireSize = (k2, v6, size3, sizeCalculation) => {
      if (this.isBackgroundFetch(v6)) {
        return 0;
      }
      if (!isPosInt(size3)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation must be a function");
          }
          size3 = sizeCalculation(v6, k2);
          if (!isPosInt(size3)) {
            throw new TypeError(
              "sizeCalculation return invalid (expect positive integer)"
            );
          }
        } else {
          throw new TypeError(
            "invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set."
          );
        }
      }
      return size3;
    };
    this.addItemSize = (index3, size3, status) => {
      this.sizes[index3] = size3;
      if (this.maxSize) {
        const maxSize = this.maxSize - this.sizes[index3];
        while (this.calculatedSize > maxSize) {
          this.evict(true);
        }
      }
      this.calculatedSize += this.sizes[index3];
      if (status) {
        status.entrySize = size3;
        status.totalCalculatedSize = this.calculatedSize;
      }
    };
  }
  removeItemSize(_index) {
  }
  addItemSize(_index, _size) {
  }
  requireSize(_k, _v, size3, sizeCalculation) {
    if (size3 || sizeCalculation) {
      throw new TypeError(
        "cannot set size without setting maxSize or maxEntrySize on cache"
      );
    }
  }
  *indexes({ allowStale = this.allowStale } = {}) {
    if (this.size) {
      for (let i6 = this.tail; true; ) {
        if (!this.isValidIndex(i6)) {
          break;
        }
        if (allowStale || !this.isStale(i6)) {
          yield i6;
        }
        if (i6 === this.head) {
          break;
        } else {
          i6 = this.prev[i6];
        }
      }
    }
  }
  *rindexes({ allowStale = this.allowStale } = {}) {
    if (this.size) {
      for (let i6 = this.head; true; ) {
        if (!this.isValidIndex(i6)) {
          break;
        }
        if (allowStale || !this.isStale(i6)) {
          yield i6;
        }
        if (i6 === this.tail) {
          break;
        } else {
          i6 = this.next[i6];
        }
      }
    }
  }
  isValidIndex(index3) {
    return index3 !== void 0 && this.keyMap.get(this.keyList[index3]) === index3;
  }
  *entries() {
    for (const i6 of this.indexes()) {
      if (this.valList[i6] !== void 0 && this.keyList[i6] !== void 0 && !this.isBackgroundFetch(this.valList[i6])) {
        yield [this.keyList[i6], this.valList[i6]];
      }
    }
  }
  *rentries() {
    for (const i6 of this.rindexes()) {
      if (this.valList[i6] !== void 0 && this.keyList[i6] !== void 0 && !this.isBackgroundFetch(this.valList[i6])) {
        yield [this.keyList[i6], this.valList[i6]];
      }
    }
  }
  *keys() {
    for (const i6 of this.indexes()) {
      if (this.keyList[i6] !== void 0 && !this.isBackgroundFetch(this.valList[i6])) {
        yield this.keyList[i6];
      }
    }
  }
  *rkeys() {
    for (const i6 of this.rindexes()) {
      if (this.keyList[i6] !== void 0 && !this.isBackgroundFetch(this.valList[i6])) {
        yield this.keyList[i6];
      }
    }
  }
  *values() {
    for (const i6 of this.indexes()) {
      if (this.valList[i6] !== void 0 && !this.isBackgroundFetch(this.valList[i6])) {
        yield this.valList[i6];
      }
    }
  }
  *rvalues() {
    for (const i6 of this.rindexes()) {
      if (this.valList[i6] !== void 0 && !this.isBackgroundFetch(this.valList[i6])) {
        yield this.valList[i6];
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  find(fn2, getOptions3) {
    for (const i6 of this.indexes()) {
      const v6 = this.valList[i6];
      const value2 = this.isBackgroundFetch(v6) ? v6.__staleWhileFetching : v6;
      if (value2 === void 0)
        continue;
      if (fn2(value2, this.keyList[i6], this)) {
        return this.get(this.keyList[i6], getOptions3);
      }
    }
  }
  forEach(fn2, thisp = this) {
    for (const i6 of this.indexes()) {
      const v6 = this.valList[i6];
      const value2 = this.isBackgroundFetch(v6) ? v6.__staleWhileFetching : v6;
      if (value2 === void 0)
        continue;
      fn2.call(thisp, value2, this.keyList[i6], this);
    }
  }
  rforEach(fn2, thisp = this) {
    for (const i6 of this.rindexes()) {
      const v6 = this.valList[i6];
      const value2 = this.isBackgroundFetch(v6) ? v6.__staleWhileFetching : v6;
      if (value2 === void 0)
        continue;
      fn2.call(thisp, value2, this.keyList[i6], this);
    }
  }
  get prune() {
    deprecatedMethod("prune", "purgeStale");
    return this.purgeStale;
  }
  purgeStale() {
    let deleted = false;
    for (const i6 of this.rindexes({ allowStale: true })) {
      if (this.isStale(i6)) {
        this.delete(this.keyList[i6]);
        deleted = true;
      }
    }
    return deleted;
  }
  dump() {
    const arr = [];
    for (const i6 of this.indexes({ allowStale: true })) {
      const key = this.keyList[i6];
      const v6 = this.valList[i6];
      const value2 = this.isBackgroundFetch(v6) ? v6.__staleWhileFetching : v6;
      if (value2 === void 0)
        continue;
      const entry = { value: value2 };
      if (this.ttls) {
        entry.ttl = this.ttls[i6];
        const age = perf.now() - this.starts[i6];
        entry.start = Math.floor(Date.now() - age);
      }
      if (this.sizes) {
        entry.size = this.sizes[i6];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  dispose(_v, _k, _reason) {
  }
  set(k2, v6, {
    ttl = this.ttl,
    start: start2,
    noDisposeOnSet = this.noDisposeOnSet,
    size: size3 = 0,
    sizeCalculation = this.sizeCalculation,
    noUpdateTTL = this.noUpdateTTL,
    status
  } = {}) {
    size3 = this.requireSize(k2, v6, size3, sizeCalculation);
    if (this.maxEntrySize && size3 > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      this.delete(k2);
      return this;
    }
    let index3 = this.size === 0 ? void 0 : this.keyMap.get(k2);
    if (index3 === void 0) {
      index3 = this.newIndex();
      this.keyList[index3] = k2;
      this.valList[index3] = v6;
      this.keyMap.set(k2, index3);
      this.next[this.tail] = index3;
      this.prev[index3] = this.tail;
      this.tail = index3;
      this.size++;
      this.addItemSize(index3, size3, status);
      if (status) {
        status.set = "add";
      }
      noUpdateTTL = false;
    } else {
      this.moveToTail(index3);
      const oldVal = this.valList[index3];
      if (v6 !== oldVal) {
        if (this.isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
        } else {
          if (!noDisposeOnSet) {
            this.dispose(oldVal, k2, "set");
            if (this.disposeAfter) {
              this.disposed.push([oldVal, k2, "set"]);
            }
          }
        }
        this.removeItemSize(index3);
        this.valList[index3] = v6;
        this.addItemSize(index3, size3, status);
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && this.isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== void 0)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
    }
    if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
      this.initializeTTLTracking();
    }
    if (!noUpdateTTL) {
      this.setItemTTL(index3, ttl, start2);
    }
    this.statusTTL(status, index3);
    if (this.disposeAfter) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift());
      }
    }
    return this;
  }
  newIndex() {
    if (this.size === 0) {
      return this.tail;
    }
    if (this.size === this.max && this.max !== 0) {
      return this.evict(false);
    }
    if (this.free.length !== 0) {
      return this.free.pop();
    }
    return this.initialFill++;
  }
  pop() {
    if (this.size) {
      const val = this.valList[this.head];
      this.evict(true);
      return val;
    }
  }
  evict(free) {
    const head = this.head;
    const k2 = this.keyList[head];
    const v6 = this.valList[head];
    if (this.isBackgroundFetch(v6)) {
      v6.__abortController.abort(new Error("evicted"));
    } else {
      this.dispose(v6, k2, "evict");
      if (this.disposeAfter) {
        this.disposed.push([v6, k2, "evict"]);
      }
    }
    this.removeItemSize(head);
    if (free) {
      this.keyList[head] = null;
      this.valList[head] = null;
      this.free.push(head);
    }
    this.head = this.next[head];
    this.keyMap.delete(k2);
    this.size--;
    return head;
  }
  has(k2, { updateAgeOnHas = this.updateAgeOnHas, status } = {}) {
    const index3 = this.keyMap.get(k2);
    if (index3 !== void 0) {
      if (!this.isStale(index3)) {
        if (updateAgeOnHas) {
          this.updateItemAge(index3);
        }
        if (status)
          status.has = "hit";
        this.statusTTL(status, index3);
        return true;
      } else if (status) {
        status.has = "stale";
        this.statusTTL(status, index3);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  // like get(), but without any LRU updating or TTL expiration
  peek(k2, { allowStale = this.allowStale } = {}) {
    const index3 = this.keyMap.get(k2);
    if (index3 !== void 0 && (allowStale || !this.isStale(index3))) {
      const v6 = this.valList[index3];
      return this.isBackgroundFetch(v6) ? v6.__staleWhileFetching : v6;
    }
  }
  backgroundFetch(k2, index3, options, context) {
    const v6 = index3 === void 0 ? void 0 : this.valList[index3];
    if (this.isBackgroundFetch(v6)) {
      return v6;
    }
    const ac = new AC();
    if (options.signal) {
      options.signal.addEventListener(
        "abort",
        () => ac.abort(options.signal.reason)
      );
    }
    const fetchOpts = {
      signal: ac.signal,
      options,
      context
    };
    const cb = (v7, updateCache = false) => {
      const { aborted } = ac.signal;
      const ignoreAbort = options.ignoreFetchAbort && v7 !== void 0;
      if (options.status) {
        if (aborted && !updateCache) {
          options.status.fetchAborted = true;
          options.status.fetchError = ac.signal.reason;
          if (ignoreAbort)
            options.status.fetchAbortIgnored = true;
        } else {
          options.status.fetchResolved = true;
        }
      }
      if (aborted && !ignoreAbort && !updateCache) {
        return fetchFail(ac.signal.reason);
      }
      if (this.valList[index3] === p5) {
        if (v7 === void 0) {
          if (p5.__staleWhileFetching) {
            this.valList[index3] = p5.__staleWhileFetching;
          } else {
            this.delete(k2);
          }
        } else {
          if (options.status)
            options.status.fetchUpdated = true;
          this.set(k2, v7, fetchOpts.options);
        }
      }
      return v7;
    };
    const eb = (er) => {
      if (options.status) {
        options.status.fetchRejected = true;
        options.status.fetchError = er;
      }
      return fetchFail(er);
    };
    const fetchFail = (er) => {
      const { aborted } = ac.signal;
      const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
      const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
      const noDelete = allowStale || options.noDeleteOnFetchRejection;
      if (this.valList[index3] === p5) {
        const del2 = !noDelete || p5.__staleWhileFetching === void 0;
        if (del2) {
          this.delete(k2);
        } else if (!allowStaleAborted) {
          this.valList[index3] = p5.__staleWhileFetching;
        }
      }
      if (allowStale) {
        if (options.status && p5.__staleWhileFetching !== void 0) {
          options.status.returnedStale = true;
        }
        return p5.__staleWhileFetching;
      } else if (p5.__returned === p5) {
        throw er;
      }
    };
    const pcall = (res, rej) => {
      this.fetchMethod(k2, v6, fetchOpts).then((v7) => res(v7), rej);
      ac.signal.addEventListener("abort", () => {
        if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
          res();
          if (options.allowStaleOnFetchAbort) {
            res = (v7) => cb(v7, true);
          }
        }
      });
    };
    if (options.status)
      options.status.fetchDispatched = true;
    const p5 = new Promise(pcall).then(cb, eb);
    p5.__abortController = ac;
    p5.__staleWhileFetching = v6;
    p5.__returned = null;
    if (index3 === void 0) {
      this.set(k2, p5, { ...fetchOpts.options, status: void 0 });
      index3 = this.keyMap.get(k2);
    } else {
      this.valList[index3] = p5;
    }
    return p5;
  }
  isBackgroundFetch(p5) {
    return p5 && typeof p5 === "object" && typeof p5.then === "function" && Object.prototype.hasOwnProperty.call(
      p5,
      "__staleWhileFetching"
    ) && Object.prototype.hasOwnProperty.call(p5, "__returned") && (p5.__returned === p5 || p5.__returned === null);
  }
  // this takes the union of get() and set() opts, because it does both
  async fetch(k2, {
    // get options
    allowStale = this.allowStale,
    updateAgeOnGet = this.updateAgeOnGet,
    noDeleteOnStaleGet = this.noDeleteOnStaleGet,
    // set options
    ttl = this.ttl,
    noDisposeOnSet = this.noDisposeOnSet,
    size: size3 = 0,
    sizeCalculation = this.sizeCalculation,
    noUpdateTTL = this.noUpdateTTL,
    // fetch exclusive options
    noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
    allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
    ignoreFetchAbort = this.ignoreFetchAbort,
    allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
    fetchContext = this.fetchContext,
    forceRefresh = false,
    status,
    signal
  } = {}) {
    if (!this.fetchMethod) {
      if (status)
        status.fetch = "get";
      return this.get(k2, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size: size3,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index3 = this.keyMap.get(k2);
    if (index3 === void 0) {
      if (status)
        status.fetch = "miss";
      const p5 = this.backgroundFetch(k2, index3, options, fetchContext);
      return p5.__returned = p5;
    } else {
      const v6 = this.valList[index3];
      if (this.isBackgroundFetch(v6)) {
        const stale = allowStale && v6.__staleWhileFetching !== void 0;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v6.__staleWhileFetching : v6.__returned = v6;
      }
      const isStale = this.isStale(index3);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        this.moveToTail(index3);
        if (updateAgeOnGet) {
          this.updateItemAge(index3);
        }
        this.statusTTL(status, index3);
        return v6;
      }
      const p5 = this.backgroundFetch(k2, index3, options, fetchContext);
      const hasStale = p5.__staleWhileFetching !== void 0;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = hasStale && isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p5.__staleWhileFetching : p5.__returned = p5;
    }
  }
  get(k2, {
    allowStale = this.allowStale,
    updateAgeOnGet = this.updateAgeOnGet,
    noDeleteOnStaleGet = this.noDeleteOnStaleGet,
    status
  } = {}) {
    const index3 = this.keyMap.get(k2);
    if (index3 !== void 0) {
      const value2 = this.valList[index3];
      const fetching = this.isBackgroundFetch(value2);
      this.statusTTL(status, index3);
      if (this.isStale(index3)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.delete(k2);
          }
          if (status)
            status.returnedStale = allowStale;
          return allowStale ? value2 : void 0;
        } else {
          if (status) {
            status.returnedStale = allowStale && value2.__staleWhileFetching !== void 0;
          }
          return allowStale ? value2.__staleWhileFetching : void 0;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value2.__staleWhileFetching;
        }
        this.moveToTail(index3);
        if (updateAgeOnGet) {
          this.updateItemAge(index3);
        }
        return value2;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  connect(p5, n6) {
    this.prev[n6] = p5;
    this.next[p5] = n6;
  }
  moveToTail(index3) {
    if (index3 !== this.tail) {
      if (index3 === this.head) {
        this.head = this.next[index3];
      } else {
        this.connect(this.prev[index3], this.next[index3]);
      }
      this.connect(this.tail, index3);
      this.tail = index3;
    }
  }
  get del() {
    deprecatedMethod("del", "delete");
    return this.delete;
  }
  delete(k2) {
    let deleted = false;
    if (this.size !== 0) {
      const index3 = this.keyMap.get(k2);
      if (index3 !== void 0) {
        deleted = true;
        if (this.size === 1) {
          this.clear();
        } else {
          this.removeItemSize(index3);
          const v6 = this.valList[index3];
          if (this.isBackgroundFetch(v6)) {
            v6.__abortController.abort(new Error("deleted"));
          } else {
            this.dispose(v6, k2, "delete");
            if (this.disposeAfter) {
              this.disposed.push([v6, k2, "delete"]);
            }
          }
          this.keyMap.delete(k2);
          this.keyList[index3] = null;
          this.valList[index3] = null;
          if (index3 === this.tail) {
            this.tail = this.prev[index3];
          } else if (index3 === this.head) {
            this.head = this.next[index3];
          } else {
            this.next[this.prev[index3]] = this.next[index3];
            this.prev[this.next[index3]] = this.prev[index3];
          }
          this.size--;
          this.free.push(index3);
        }
      }
    }
    if (this.disposed) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift());
      }
    }
    return deleted;
  }
  clear() {
    for (const index3 of this.rindexes({ allowStale: true })) {
      const v6 = this.valList[index3];
      if (this.isBackgroundFetch(v6)) {
        v6.__abortController.abort(new Error("deleted"));
      } else {
        const k2 = this.keyList[index3];
        this.dispose(v6, k2, "delete");
        if (this.disposeAfter) {
          this.disposed.push([v6, k2, "delete"]);
        }
      }
    }
    this.keyMap.clear();
    this.valList.fill(null);
    this.keyList.fill(null);
    if (this.ttls) {
      this.ttls.fill(0);
      this.starts.fill(0);
    }
    if (this.sizes) {
      this.sizes.fill(0);
    }
    this.head = 0;
    this.tail = 0;
    this.initialFill = 1;
    this.free.length = 0;
    this.calculatedSize = 0;
    this.size = 0;
    if (this.disposed) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift());
      }
    }
  }
  get reset() {
    deprecatedMethod("reset", "clear");
    return this.clear;
  }
  get length() {
    deprecatedProperty("length", "size");
    return this.size;
  }
  static get AbortController() {
    return AC;
  }
  static get AbortSignal() {
    return AS;
  }
};
var lru_cache_default = LRUCache;

// node_modules/idb-keyval/dist/index.js
function promisifyRequest(request) {
  return new Promise((resolve3, reject) => {
    request.oncomplete = request.onsuccess = () => resolve3(request.result);
    request.onabort = request.onerror = () => reject(request.error);
  });
}
function createStore(dbName, storeName) {
  const request = indexedDB.open(dbName);
  request.onupgradeneeded = () => request.result.createObjectStore(storeName);
  const dbp = promisifyRequest(request);
  return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
var defaultGetStoreFunc;
function defaultGetStore() {
  if (!defaultGetStoreFunc) {
    defaultGetStoreFunc = createStore("keyval-store", "keyval");
  }
  return defaultGetStoreFunc;
}
function get2(key, customStore = defaultGetStore()) {
  return customStore("readonly", (store2) => promisifyRequest(store2.get(key)));
}
function set(key, value2, customStore = defaultGetStore()) {
  return customStore("readwrite", (store2) => {
    store2.put(value2, key);
    return promisifyRequest(store2.transaction);
  });
}
function setMany(entries2, customStore = defaultGetStore()) {
  return customStore("readwrite", (store2) => {
    entries2.forEach((entry) => store2.put(entry[1], entry[0]));
    return promisifyRequest(store2.transaction);
  });
}
function del(key, customStore = defaultGetStore()) {
  return customStore("readwrite", (store2) => {
    store2.delete(key);
    return promisifyRequest(store2.transaction);
  });
}
function delMany(keys3, customStore = defaultGetStore()) {
  return customStore("readwrite", (store2) => {
    keys3.forEach((key) => store2.delete(key));
    return promisifyRequest(store2.transaction);
  });
}
function clear(customStore = defaultGetStore()) {
  return customStore("readwrite", (store2) => {
    store2.clear();
    return promisifyRequest(store2.transaction);
  });
}
function eachCursor(store2, callback) {
  store2.openCursor().onsuccess = function() {
    if (!this.result)
      return;
    callback(this.result);
    this.result.continue();
  };
  return promisifyRequest(store2.transaction);
}
function keys2(customStore = defaultGetStore()) {
  return customStore("readonly", (store2) => {
    if (store2.getAllKeys) {
      return promisifyRequest(store2.getAllKeys());
    }
    const items = [];
    return eachCursor(store2, (cursor2) => items.push(cursor2.key)).then(() => items);
  });
}
function entries(customStore = defaultGetStore()) {
  return customStore("readonly", (store2) => {
    if (store2.getAll && store2.getAllKeys) {
      return Promise.all([
        promisifyRequest(store2.getAllKeys()),
        promisifyRequest(store2.getAll())
      ]).then(([keys3, values3]) => keys3.map((key, i6) => [key, values3[i6]]));
    }
    const items = [];
    return customStore("readonly", (store3) => eachCursor(store3, (cursor2) => items.push([cursor2.key, cursor2.value])).then(() => items));
  });
}

// node_modules/y-protocols/awareness.js
var outdatedTimeout = 3e4;
var Awareness = class extends Observable {
  /**
   * @param {Y.Doc} doc
   */
  constructor(doc2) {
    super();
    this.doc = doc2;
    this.clientID = doc2.clientID;
    this.states = /* @__PURE__ */ new Map();
    this.meta = /* @__PURE__ */ new Map();
    this._checkInterval = /** @type {any} */
    setInterval(() => {
      const now = getUnixTime();
      if (this.getLocalState() !== null && outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */
      this.meta.get(this.clientID).lastUpdated) {
        this.setLocalState(this.getLocalState());
      }
      const remove = [];
      this.meta.forEach((meta, clientid) => {
        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {
          remove.push(clientid);
        }
      });
      if (remove.length > 0) {
        removeAwarenessStates(this, remove, "timeout");
      }
    }, floor(outdatedTimeout / 10));
    doc2.on("destroy", () => {
      this.destroy();
    });
    this.setLocalState({});
  }
  destroy() {
    this.emit("destroy", [this]);
    this.setLocalState(null);
    super.destroy();
    clearInterval(this._checkInterval);
  }
  /**
   * @return {Object<string,any>|null}
   */
  getLocalState() {
    return this.states.get(this.clientID) || null;
  }
  /**
   * @param {Object<string,any>|null} state
   */
  setLocalState(state) {
    const clientID = this.clientID;
    const currLocalMeta = this.meta.get(clientID);
    const clock = currLocalMeta === void 0 ? 0 : currLocalMeta.clock + 1;
    const prevState = this.states.get(clientID);
    if (state === null) {
      this.states.delete(clientID);
    } else {
      this.states.set(clientID, state);
    }
    this.meta.set(clientID, {
      clock,
      lastUpdated: getUnixTime()
    });
    const added = [];
    const updated = [];
    const filteredUpdated = [];
    const removed = [];
    if (state === null) {
      removed.push(clientID);
    } else if (prevState == null) {
      if (state != null) {
        added.push(clientID);
      }
    } else {
      updated.push(clientID);
      if (!equalityDeep(prevState, state)) {
        filteredUpdated.push(clientID);
      }
    }
    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
      this.emit("change", [{ added, updated: filteredUpdated, removed }, "local"]);
    }
    this.emit("update", [{ added, updated, removed }, "local"]);
  }
  /**
   * @param {string} field
   * @param {any} value
   */
  setLocalStateField(field2, value2) {
    const state = this.getLocalState();
    if (state !== null) {
      this.setLocalState({
        ...state,
        [field2]: value2
      });
    }
  }
  /**
   * @return {Map<number,Object<string,any>>}
   */
  getStates() {
    return this.states;
  }
};
var removeAwarenessStates = (awareness, clients, origin) => {
  const removed = [];
  for (let i6 = 0; i6 < clients.length; i6++) {
    const clientID = clients[i6];
    if (awareness.states.has(clientID)) {
      awareness.states.delete(clientID);
      if (clientID === awareness.clientID) {
        const curMeta = (
          /** @type {MetaClientState} */
          awareness.meta.get(clientID)
        );
        awareness.meta.set(clientID, {
          clock: curMeta.clock + 1,
          lastUpdated: getUnixTime()
        });
      }
      removed.push(clientID);
    }
  }
  if (removed.length > 0) {
    awareness.emit("change", [{ added: [], updated: [], removed }, origin]);
    awareness.emit("update", [{ added: [], updated: [], removed }, origin]);
  }
};
var encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {
  const len = clients.length;
  const encoder = createEncoder();
  writeVarUint(encoder, len);
  for (let i6 = 0; i6 < len; i6++) {
    const clientID = clients[i6];
    const state = states.get(clientID) || null;
    const clock = (
      /** @type {MetaClientState} */
      awareness.meta.get(clientID).clock
    );
    writeVarUint(encoder, clientID);
    writeVarUint(encoder, clock);
    writeVarString(encoder, JSON.stringify(state));
  }
  return toUint8Array(encoder);
};
var applyAwarenessUpdate = (awareness, update, origin) => {
  const decoder = createDecoder(update);
  const timestamp = getUnixTime();
  const added = [];
  const updated = [];
  const filteredUpdated = [];
  const removed = [];
  const len = readVarUint(decoder);
  for (let i6 = 0; i6 < len; i6++) {
    const clientID = readVarUint(decoder);
    let clock = readVarUint(decoder);
    const state = JSON.parse(readVarString(decoder));
    const clientMeta = awareness.meta.get(clientID);
    const prevState = awareness.states.get(clientID);
    const currClock = clientMeta === void 0 ? 0 : clientMeta.clock;
    if (currClock < clock || currClock === clock && state === null && awareness.states.has(clientID)) {
      if (state === null) {
        if (clientID === awareness.clientID && awareness.getLocalState() != null) {
          clock++;
        } else {
          awareness.states.delete(clientID);
        }
      } else {
        awareness.states.set(clientID, state);
      }
      awareness.meta.set(clientID, {
        clock,
        lastUpdated: timestamp
      });
      if (clientMeta === void 0 && state !== null) {
        added.push(clientID);
      } else if (clientMeta !== void 0 && state === null) {
        removed.push(clientID);
      } else if (state !== null) {
        if (!equalityDeep(state, prevState)) {
          filteredUpdated.push(clientID);
        }
        updated.push(clientID);
      }
    }
  }
  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
    awareness.emit("change", [{
      added,
      updated: filteredUpdated,
      removed
    }, origin]);
  }
  if (added.length > 0 || updated.length > 0 || removed.length > 0) {
    awareness.emit("update", [{
      added,
      updated,
      removed
    }, origin]);
  }
};

// node_modules/idb/build/wrap-idb-value.js
var instanceOfAny = (object2, constructors) => constructors.some((c5) => object2 instanceof c5);
var idbProxyableTypes;
var cursorAdvanceMethods;
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
var cursorRequestMap = /* @__PURE__ */ new WeakMap();
var transactionDoneMap = /* @__PURE__ */ new WeakMap();
var transactionStoreNamesMap = /* @__PURE__ */ new WeakMap();
var transformCache = /* @__PURE__ */ new WeakMap();
var reverseTransformCache = /* @__PURE__ */ new WeakMap();
function promisifyRequest2(request) {
  const promise = new Promise((resolve3, reject) => {
    const unlisten = () => {
      request.removeEventListener("success", success);
      request.removeEventListener("error", error3);
    };
    const success = () => {
      resolve3(wrap2(request.result));
      unlisten();
    };
    const error3 = () => {
      reject(request.error);
      unlisten();
    };
    request.addEventListener("success", success);
    request.addEventListener("error", error3);
  });
  promise.then((value2) => {
    if (value2 instanceof IDBCursor) {
      cursorRequestMap.set(value2, request);
    }
  }).catch(() => {
  });
  reverseTransformCache.set(promise, request);
  return promise;
}
function cacheDonePromiseForTransaction(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve3, reject) => {
    const unlisten = () => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error3);
      tx.removeEventListener("abort", error3);
    };
    const complete = () => {
      resolve3();
      unlisten();
    };
    const error3 = () => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error3);
    tx.addEventListener("abort", error3);
  });
  transactionDoneMap.set(tx, done);
}
var idbProxyTraps = {
  get(target, prop, receiver) {
    if (target instanceof IDBTransaction) {
      if (prop === "done")
        return transactionDoneMap.get(target);
      if (prop === "objectStoreNames") {
        return target.objectStoreNames || transactionStoreNamesMap.get(target);
      }
      if (prop === "store") {
        return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
      }
    }
    return wrap2(target[prop]);
  },
  set(target, prop, value2) {
    target[prop] = value2;
    return true;
  },
  has(target, prop) {
    if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
      return true;
    }
    return prop in target;
  }
};
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
  if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) {
    return function(storeNames, ...args2) {
      const tx = func.call(unwrap(this), storeNames, ...args2);
      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
      return wrap2(tx);
    };
  }
  if (getCursorAdvanceMethods().includes(func)) {
    return function(...args2) {
      func.apply(unwrap(this), args2);
      return wrap2(cursorRequestMap.get(this));
    };
  }
  return function(...args2) {
    return wrap2(func.apply(unwrap(this), args2));
  };
}
function transformCachableValue(value2) {
  if (typeof value2 === "function")
    return wrapFunction(value2);
  if (value2 instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value2);
  if (instanceOfAny(value2, getIdbProxyableTypes()))
    return new Proxy(value2, idbProxyTraps);
  return value2;
}
function wrap2(value2) {
  if (value2 instanceof IDBRequest)
    return promisifyRequest2(value2);
  if (transformCache.has(value2))
    return transformCache.get(value2);
  const newValue = transformCachableValue(value2);
  if (newValue !== value2) {
    transformCache.set(value2, newValue);
    reverseTransformCache.set(newValue, value2);
  }
  return newValue;
}
var unwrap = (value2) => reverseTransformCache.get(value2);

// node_modules/idb/build/index.js
function openDB(name2, version2, { blocked, upgrade, blocking, terminated } = {}) {
  const request = indexedDB.open(name2, version2);
  const openPromise = wrap2(request);
  if (upgrade) {
    request.addEventListener("upgradeneeded", (event) => {
      upgrade(wrap2(request.result), event.oldVersion, event.newVersion, wrap2(request.transaction), event);
    });
  }
  if (blocked) {
    request.addEventListener("blocked", (event) => blocked(
      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
      event.oldVersion,
      event.newVersion,
      event
    ));
  }
  openPromise.then((db) => {
    if (terminated)
      db.addEventListener("close", () => terminated());
    if (blocking) {
      db.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
    }
  }).catch(() => {
  });
  return openPromise;
}
var readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
var writeMethods = ["put", "add", "delete", "clear"];
var cachedMethods = /* @__PURE__ */ new Map();
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
  ) {
    return;
  }
  const method = async function(storeName, ...args2) {
    const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
    let target2 = tx.store;
    if (useIndex)
      target2 = target2.index(args2.shift());
    return (await Promise.all([
      target2[targetFuncName](...args2),
      isWrite && tx.done
    ]))[0];
  };
  cachedMethods.set(prop, method);
  return method;
}
replaceTraps((oldTraps) => ({
  ...oldTraps,
  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
}));

// node_modules/y-provider/dist/index.js
function A2(t5, n6 = "val does not exist") {
  if (t5 == null)
    throw n6 instanceof Error ? n6 : new Error(n6);
}
function x3(t5, n6) {
  if (t5.guid === n6)
    return t5;
  for (const r7 of t5.subdocs) {
    const a3 = x3(r7, n6);
    if (a3)
      return a3;
  }
}
var j3 = (t5, n6, r7 = {}) => {
  let a3 = false;
  const o5 = /* @__PURE__ */ new Map(), f6 = /* @__PURE__ */ new Map(), g4 = /* @__PURE__ */ new Set();
  let y4 = null;
  const { origin: h3 = "lazy-provider" } = r7;
  let b2 = {
    type: "idle"
  }, D2 = 0;
  const v6 = /* @__PURE__ */ new Set(), l7 = (e6) => {
    e6.type === "syncing" ? D2++ : (e6.type === "synced" || e6.type === "error") && D2--, D2 < 0 && console.error(
      "syncingStatus < 0, this should not happen",
      r7.origin
    ), D2 === 0 && (b2 = e6), e6.type !== "synced" && (b2 = e6), D2 === 0 && (a3 ? b2 = {
      type: "synced"
    } : b2 = {
      type: "idle"
    }), v6.forEach((s4) => s4());
  };
  async function S2(e6) {
    const s4 = e6.guid;
    {
      const c5 = s4.startsWith("space:") ? s4.slice(6) : s4, d5 = `${t5.guid}:space:${c5}`, p5 = `space:${c5}`, u4 = await n6.queryDocState(d5), w2 = await n6.queryDocState(p5);
      let U2 = false;
      u4 && u4.missing.length !== 2 && u4.missing[0] !== 0 && u4.missing[1] !== 0 && (applyUpdate(e6, u4.missing, h3), U2 = true), w2 && w2.missing.length !== 2 && w2.missing[0] !== 0 && w2.missing[1] !== 0 && (applyUpdate(e6, w2.missing, h3), U2 = true), U2 && await n6.sendDocUpdate(
        s4,
        encodeStateAsUpdate(
          e6,
          u4 ? u4.state : w2 ? w2.state : void 0
        )
      );
    }
    if (!a3)
      return;
    l7({
      type: "syncing"
    });
    const i6 = await n6.queryDocState(s4, {
      stateVector: encodeStateVector(e6)
    }).then((c5) => (l7({
      type: "synced"
    }), c5)).catch((c5) => {
      throw l7({
        type: "error",
        error: c5
      }), c5;
    });
    o5.set(s4, []), i6 && applyUpdate(e6, i6.missing, h3), a3 && (await n6.sendDocUpdate(
      s4,
      encodeStateAsUpdate(e6, i6 ? i6.state : void 0)
    ), e6.emit("sync", []));
  }
  function M2(e6) {
    const s4 = /* @__PURE__ */ new Set();
    f6.set(e6.guid, s4);
    const i6 = async (d5, p5) => {
      h3 !== p5 && (l7({
        type: "syncing"
      }), n6.sendDocUpdate(e6.guid, d5).then(() => {
        l7({
          type: "synced"
        });
      }).catch((u4) => {
        l7({
          type: "error",
          error: u4
        }), console.error(u4);
      }));
    }, c5 = (d5) => {
      d5.loaded.forEach((p5) => {
        E3(p5).catch(console.error);
      }), d5.removed.forEach((p5) => {
        L2(p5);
      });
    };
    e6.on("update", i6), e6.on("subdocs", c5), s4.add(() => {
      e6.off("update", i6), e6.off("subdocs", c5);
    });
  }
  function V() {
    var s4;
    A2(y4, "abortController should be defined");
    const e6 = (s4 = n6.onDocUpdate) == null ? void 0 : s4.call(n6, (i6, c5) => {
      var p5;
      l7({
        type: "syncing"
      });
      const d5 = x3(t5, i6);
      d5 ? (applyUpdate(d5, c5, h3), o5.has(i6) && ((p5 = o5.get(i6)) == null || p5.forEach((u4) => applyUpdate(d5, u4, h3)), o5.delete(i6))) : (console.warn("doc not found", i6), o5.set(i6, (o5.get(i6) ?? []).concat(c5))), l7({
        type: "synced"
      });
    });
    y4.signal.addEventListener("abort", () => {
      e6 == null || e6();
    });
  }
  async function E3(e6) {
    g4.has(e6.guid) || (g4.add(e6.guid), M2(e6), await S2(e6), await Promise.all(
      [...e6.subdocs].filter((s4) => s4.shouldLoad).map((s4) => E3(s4))
    ));
  }
  function L2(e6) {
    g4.delete(e6.guid);
    const s4 = f6.get(e6.guid);
    s4 && (s4.forEach((i6) => i6()), f6.delete(e6.guid)), e6.subdocs.forEach(L2);
  }
  function $() {
    f6.forEach((e6) => {
      e6.forEach((s4) => s4());
    }), f6.clear(), g4.clear();
  }
  function R2() {
    a3 = true, y4 = new AbortController(), l7({
      type: "syncing"
    }), E3(t5).then(() => {
      l7({
        type: "synced"
      });
    }).catch((e6) => {
      l7({
        type: "error",
        error: e6
      }), console.error(e6);
    }), V();
  }
  async function k2() {
    a3 = false, $(), A2(y4, "abortController should be defined"), y4.abort(), y4 = null;
  }
  const P3 = async (e6) => {
    await S2(e6), await Promise.all(
      [...e6.subdocs.values()].map((s4) => P3(s4))
    );
  };
  return {
    sync: async (e6) => {
      a3 = true;
      try {
        e6 ? await S2(t5) : await P3(t5);
      } finally {
        a3 = false;
      }
    },
    get status() {
      return b2;
    },
    subscribeStatusChange(e6) {
      return v6.add(e6), () => {
        v6.delete(e6);
      };
    },
    get connected() {
      return a3;
    },
    passive: true,
    connect: R2,
    disconnect: k2,
    datasource: n6
  };
};
var C2 = (t5) => (t5.preventDefault(), t5.returnValue = "Data is not saved. Are you sure you want to leave?");
var B2 = async (t5) => {
  window.addEventListener("beforeunload", C2, {
    capture: true
  }), await t5, window.removeEventListener("beforeunload", C2, {
    capture: true
  });
};

// node_modules/@toeverything/y-indexeddb/dist/index.js
var m2 = 1;
var l5 = "affine-local";
function f5(e6) {
  e6.createObjectStore("workspace", { keyPath: "id" }), e6.createObjectStore("milestone", { keyPath: "id" });
}
function E2(e6, n6 = "val does not exist") {
  if (e6 == null)
    throw n6 instanceof Error ? n6 : new Error(n6);
}
function g3(e6) {
  const n6 = new Doc();
  return e6.forEach((a3) => {
    applyUpdate(n6, a3);
  }), encodeStateAsUpdate(n6);
}
var v5 = 500;
var T = ({
  dbName: e6 = l5,
  mergeCount: n6
}) => {
  let a3 = null;
  const t5 = async () => (a3 === null && (a3 = openDB(e6, m2, {
    upgrade: f5
  })), a3);
  return {
    ...{
      queryDocState: async (r7, o5) => {
        var i6;
        try {
          const u4 = await (await t5()).transaction("workspace", "readonly").objectStore("workspace").get(r7);
          if (!u4)
            return false;
          const { updates: w2 } = u4, b2 = g3(w2.map(({ update: x4 }) => x4));
          return { missing: o5 != null && o5.stateVector ? diffUpdate(b2, o5 == null ? void 0 : o5.stateVector) : b2, state: encodeStateVectorFromUpdate(b2) };
        } catch (s4) {
          if (!((i6 = s4.message) != null && i6.includes("The database connection is closing.")))
            throw s4;
          return false;
        }
      },
      sendDocUpdate: async (r7, o5) => {
        var i6;
        try {
          const d5 = (await t5()).transaction("workspace", "readwrite").objectStore("workspace"), { updates: u4 } = await d5.get(r7) ?? { updates: [] };
          let w2 = [
            ...u4,
            { timestamp: Date.now(), update: o5 }
          ];
          if (n6 && w2.length >= n6) {
            const b2 = g3(w2.map(({ update: k2 }) => k2));
            w2 = [{ timestamp: Date.now(), update: b2 }];
          }
          await B2(
            d5.put({
              id: r7,
              updates: w2
            })
          );
        } catch (s4) {
          if (!((i6 = s4.message) != null && i6.includes("The database connection is closing.")))
            throw s4;
        }
      }
    },
    disconnect: () => {
      t5().then((r7) => r7.close()).then(() => {
        a3 = null;
      }).catch(console.error);
    },
    cleanup: async () => {
      await (await t5()).clear("workspace");
    }
  };
};
var W2 = (e6, n6 = l5) => {
  const a3 = T({ dbName: n6, mergeCount: v5 });
  let t5 = null;
  const c5 = {
    get status() {
      return E2(t5), t5.status;
    },
    subscribeStatusChange(r7) {
      return E2(t5), t5.subscribeStatusChange(r7);
    },
    connect: () => {
      c5.connected && c5.disconnect(), t5 = j3(e6, a3, { origin: "idb" }), t5.connect();
    },
    disconnect: () => {
      a3 == null || a3.disconnect(), t5 == null || t5.disconnect(), t5 = null;
    },
    cleanup: async () => {
      await (a3 == null ? void 0 : a3.cleanup());
    },
    get connected() {
      return (t5 == null ? void 0 : t5.connected) || false;
    },
    datasource: a3
  };
  return c5;
};

// node_modules/lib0/broadcastchannel.js
var channels = /* @__PURE__ */ new Map();
var LocalStoragePolyfill = class {
  /**
   * @param {string} room
   */
  constructor(room) {
    this.room = room;
    this.onmessage = null;
    this._onChange = (e6) => e6.key === room && this.onmessage !== null && this.onmessage({ data: fromBase64(e6.newValue || "") });
    onChange(this._onChange);
  }
  /**
   * @param {ArrayBuffer} buf
   */
  postMessage(buf) {
    varStorage.setItem(this.room, toBase64(createUint8ArrayFromArrayBuffer(buf)));
  }
  close() {
    offChange(this._onChange);
  }
};
var BC = typeof BroadcastChannel === "undefined" ? LocalStoragePolyfill : BroadcastChannel;
var getChannel = (room) => setIfUndefined(channels, room, () => {
  const subs = create();
  const bc = new BC(room);
  bc.onmessage = (e6) => subs.forEach((sub2) => sub2(e6.data, "broadcastchannel"));
  return {
    bc,
    subs
  };
});
var subscribe3 = (room, f6) => {
  getChannel(room).subs.add(f6);
  return f6;
};
var unsubscribe = (room, f6) => {
  const channel = getChannel(room);
  const unsubscribed = channel.subs.delete(f6);
  if (unsubscribed && channel.subs.size === 0) {
    channel.bc.close();
    channels.delete(room);
  }
  return unsubscribed;
};
var publish2 = (room, data, origin = null) => {
  const c5 = getChannel(room);
  c5.bc.postMessage(data);
  c5.subs.forEach((sub2) => sub2(data, origin));
};

// node_modules/y-protocols/sync.js
var messageYjsSyncStep1 = 0;
var messageYjsSyncStep2 = 1;
var messageYjsUpdate = 2;
var writeSyncStep1 = (encoder, doc2) => {
  writeVarUint(encoder, messageYjsSyncStep1);
  const sv = encodeStateVector(doc2);
  writeVarUint8Array(encoder, sv);
};
var writeSyncStep2 = (encoder, doc2, encodedStateVector) => {
  writeVarUint(encoder, messageYjsSyncStep2);
  writeVarUint8Array(encoder, encodeStateAsUpdate(doc2, encodedStateVector));
};
var readSyncStep1 = (decoder, encoder, doc2) => writeSyncStep2(encoder, doc2, readVarUint8Array(decoder));
var readSyncStep2 = (decoder, doc2, transactionOrigin) => {
  try {
    applyUpdate(doc2, readVarUint8Array(decoder), transactionOrigin);
  } catch (error3) {
    console.error("Caught error while handling a Yjs update", error3);
  }
};
var writeUpdate = (encoder, update) => {
  writeVarUint(encoder, messageYjsUpdate);
  writeVarUint8Array(encoder, update);
};
var readUpdate = readSyncStep2;
var readSyncMessage = (decoder, encoder, doc2, transactionOrigin) => {
  const messageType = readVarUint(decoder);
  switch (messageType) {
    case messageYjsSyncStep1:
      readSyncStep1(decoder, encoder, doc2);
      break;
    case messageYjsSyncStep2:
      readSyncStep2(decoder, doc2, transactionOrigin);
      break;
    case messageYjsUpdate:
      readUpdate(decoder, doc2, transactionOrigin);
      break;
    default:
      throw new Error("Unknown message type");
  }
  return messageType;
};

// node_modules/y-protocols/auth.js
var messagePermissionDenied = 0;
var readAuthMessage = (decoder, y4, permissionDeniedHandler2) => {
  switch (readVarUint(decoder)) {
    case messagePermissionDenied:
      permissionDeniedHandler2(y4, readVarString(decoder));
  }
};

// node_modules/lib0/mutex.js
var createMutex = () => {
  let token2 = true;
  return (f6, g4) => {
    if (token2) {
      token2 = false;
      try {
        f6();
      } finally {
        token2 = true;
      }
    } else if (g4 !== void 0) {
      g4();
    }
  };
};

// node_modules/partysocket/dist/chunk-TPTC3KUF.mjs
if (!globalThis.EventTarget || !globalThis.Event) {
  console.error(`
  PartySocket requires a global 'EventTarget' class to be available!
  You can polyfill this global by adding this to your code before any partysocket imports: 
  
  \`\`\`
  import 'partysocket/event-target-polyfill';
  \`\`\`
  Please file an issue at https://github.com/partykit/partykit if you're still having trouble.
`);
}
var ErrorEvent2 = class extends Event {
  constructor(error3, target) {
    super("error", target);
    __publicField(this, "message");
    __publicField(this, "error");
    this.message = error3.message;
    this.error = error3;
  }
};
var CloseEvent = class extends Event {
  constructor(code3 = 1e3, reason = "", target) {
    super("close", target);
    __publicField(this, "code");
    __publicField(this, "reason");
    __publicField(this, "wasClean", true);
    this.code = code3;
    this.reason = reason;
  }
};
var Events = {
  Event,
  ErrorEvent: ErrorEvent2,
  CloseEvent
};
function assert2(condition, msg2) {
  if (!condition) {
    throw new Error(msg2);
  }
}
function cloneEventBrowser(e6) {
  return new e6.constructor(e6.type, e6);
}
function cloneEventNode(e6) {
  if ("data" in e6) {
    const evt2 = new MessageEvent(e6.type, e6);
    return evt2;
  }
  if ("code" in e6 || "reason" in e6) {
    const evt2 = new CloseEvent(
      // @ts-expect-error we need to fix event/listener types
      e6.code || 1999,
      // @ts-expect-error we need to fix event/listener types
      e6.reason || "unknown reason",
      e6
    );
    return evt2;
  }
  if ("error" in e6) {
    const evt2 = new ErrorEvent2(e6.error, e6);
    return evt2;
  }
  const evt = new Event(e6.type, e6);
  return evt;
}
var _a2;
var isNode3 = typeof process !== "undefined" && typeof ((_a2 = process.versions) == null ? void 0 : _a2.node) !== "undefined" && typeof document === "undefined";
var cloneEvent = isNode3 ? cloneEventNode : cloneEventBrowser;
var DEFAULT = {
  maxReconnectionDelay: 1e4,
  minReconnectionDelay: 1e3 + Math.random() * 4e3,
  minUptime: 5e3,
  reconnectionDelayGrowFactor: 1.3,
  connectionTimeout: 4e3,
  maxRetries: Infinity,
  maxEnqueuedMessages: Infinity,
  startClosed: false,
  debug: false
};
var didWarnAboutMissingWebSocket = false;
var ReconnectingWebSocket = class _ReconnectingWebSocket extends EventTarget {
  constructor(url, protocols, options = {}) {
    super();
    __publicField(this, "_ws");
    __publicField(this, "_retryCount", -1);
    __publicField(this, "_uptimeTimeout");
    __publicField(this, "_connectTimeout");
    __publicField(this, "_shouldReconnect", true);
    __publicField(this, "_connectLock", false);
    __publicField(this, "_binaryType", "blob");
    __publicField(this, "_closeCalled", false);
    __publicField(this, "_messageQueue", []);
    __publicField(this, "_url");
    __publicField(this, "_protocols");
    __publicField(this, "_options");
    /**
     * An event listener to be called when the WebSocket connection's readyState changes to CLOSED
     */
    __publicField(this, "onclose", null);
    /**
     * An event listener to be called when an error occurs
     */
    __publicField(this, "onerror", null);
    /**
     * An event listener to be called when a message is received from the server
     */
    __publicField(this, "onmessage", null);
    /**
     * An event listener to be called when the WebSocket connection's readyState changes to OPEN;
     * this indicates that the connection is ready to send and receive data
     */
    __publicField(this, "onopen", null);
    __publicField(this, "_handleOpen", (event) => {
      this._debug("open event");
      const { minUptime = DEFAULT.minUptime } = this._options;
      clearTimeout(this._connectTimeout);
      this._uptimeTimeout = setTimeout(() => this._acceptOpen(), minUptime);
      assert2(this._ws, "WebSocket is not defined");
      this._ws.binaryType = this._binaryType;
      this._messageQueue.forEach((message) => {
        var _a3;
        return (_a3 = this._ws) == null ? void 0 : _a3.send(message);
      });
      this._messageQueue = [];
      if (this.onopen) {
        this.onopen(event);
      }
      this.dispatchEvent(cloneEvent(event));
    });
    __publicField(this, "_handleMessage", (event) => {
      this._debug("message event");
      if (this.onmessage) {
        this.onmessage(event);
      }
      this.dispatchEvent(cloneEvent(event));
    });
    __publicField(this, "_handleError", (event) => {
      this._debug("error event", event.message);
      this._disconnect(
        void 0,
        event.message === "TIMEOUT" ? "timeout" : void 0
      );
      if (this.onerror) {
        this.onerror(event);
      }
      this._debug("exec error listeners");
      this.dispatchEvent(cloneEvent(event));
      this._connect();
    });
    __publicField(this, "_handleClose", (event) => {
      this._debug("close event");
      this._clearTimeouts();
      if (this._shouldReconnect) {
        this._connect();
      }
      if (this.onclose) {
        this.onclose(event);
      }
      this.dispatchEvent(cloneEvent(event));
    });
    this._url = url;
    this._protocols = protocols;
    this._options = options;
    if (this._options.startClosed) {
      this._shouldReconnect = false;
    }
    this._connect();
  }
  static get CONNECTING() {
    return 0;
  }
  static get OPEN() {
    return 1;
  }
  static get CLOSING() {
    return 2;
  }
  static get CLOSED() {
    return 3;
  }
  get CONNECTING() {
    return _ReconnectingWebSocket.CONNECTING;
  }
  get OPEN() {
    return _ReconnectingWebSocket.OPEN;
  }
  get CLOSING() {
    return _ReconnectingWebSocket.CLOSING;
  }
  get CLOSED() {
    return _ReconnectingWebSocket.CLOSED;
  }
  get binaryType() {
    return this._ws ? this._ws.binaryType : this._binaryType;
  }
  set binaryType(value2) {
    this._binaryType = value2;
    if (this._ws) {
      this._ws.binaryType = value2;
    }
  }
  /**
   * Returns the number or connection retries
   */
  get retryCount() {
    return Math.max(this._retryCount, 0);
  }
  /**
   * The number of bytes of data that have been queued using calls to send() but not yet
   * transmitted to the network. This value resets to zero once all queued data has been sent.
   * This value does not reset to zero when the connection is closed; if you keep calling send(),
   * this will continue to climb. Read only
   */
  get bufferedAmount() {
    const bytes = this._messageQueue.reduce((acc, message) => {
      if (typeof message === "string") {
        acc += message.length;
      } else if (message instanceof Blob) {
        acc += message.size;
      } else {
        acc += message.byteLength;
      }
      return acc;
    }, 0);
    return bytes + (this._ws ? this._ws.bufferedAmount : 0);
  }
  /**
   * The extensions selected by the server. This is currently only the empty string or a list of
   * extensions as negotiated by the connection
   */
  get extensions() {
    return this._ws ? this._ws.extensions : "";
  }
  /**
   * A string indicating the name of the sub-protocol the server selected;
   * this will be one of the strings specified in the protocols parameter when creating the
   * WebSocket object
   */
  get protocol() {
    return this._ws ? this._ws.protocol : "";
  }
  /**
   * The current state of the connection; this is one of the Ready state constants
   */
  get readyState() {
    if (this._ws) {
      return this._ws.readyState;
    }
    return this._options.startClosed ? _ReconnectingWebSocket.CLOSED : _ReconnectingWebSocket.CONNECTING;
  }
  /**
   * The URL as resolved by the constructor
   */
  get url() {
    return this._ws ? this._ws.url : "";
  }
  /**
   * Whether the websocket object is now in reconnectable state
   */
  get shouldReconnect() {
    return this._shouldReconnect;
  }
  /**
   * Closes the WebSocket connection or connection attempt, if any. If the connection is already
   * CLOSED, this method does nothing
   */
  close(code3 = 1e3, reason) {
    this._closeCalled = true;
    this._shouldReconnect = false;
    this._clearTimeouts();
    if (!this._ws) {
      this._debug("close enqueued: no ws instance");
      return;
    }
    if (this._ws.readyState === this.CLOSED) {
      this._debug("close: already closed");
      return;
    }
    this._ws.close(code3, reason);
  }
  /**
   * Closes the WebSocket connection or connection attempt and connects again.
   * Resets retry counter;
   */
  reconnect(code3, reason) {
    this._shouldReconnect = true;
    this._closeCalled = false;
    this._retryCount = -1;
    if (!this._ws || this._ws.readyState === this.CLOSED) {
      this._connect();
    } else {
      this._disconnect(code3, reason);
      this._connect();
    }
  }
  /**
   * Enqueue specified data to be transmitted to the server over the WebSocket connection
   */
  send(data) {
    if (this._ws && this._ws.readyState === this.OPEN) {
      this._debug("send", data);
      this._ws.send(data);
    } else {
      const { maxEnqueuedMessages = DEFAULT.maxEnqueuedMessages } = this._options;
      if (this._messageQueue.length < maxEnqueuedMessages) {
        this._debug("enqueue", data);
        this._messageQueue.push(data);
      }
    }
  }
  _debug(...args2) {
    if (this._options.debug) {
      console.log.apply(console, ["RWS>", ...args2]);
    }
  }
  _getNextDelay() {
    const {
      reconnectionDelayGrowFactor = DEFAULT.reconnectionDelayGrowFactor,
      minReconnectionDelay = DEFAULT.minReconnectionDelay,
      maxReconnectionDelay = DEFAULT.maxReconnectionDelay
    } = this._options;
    let delay = 0;
    if (this._retryCount > 0) {
      delay = minReconnectionDelay * Math.pow(reconnectionDelayGrowFactor, this._retryCount - 1);
      if (delay > maxReconnectionDelay) {
        delay = maxReconnectionDelay;
      }
    }
    this._debug("next delay", delay);
    return delay;
  }
  _wait() {
    return new Promise((resolve3) => {
      setTimeout(resolve3, this._getNextDelay());
    });
  }
  _getNextProtocols(protocolsProvider) {
    if (!protocolsProvider)
      return Promise.resolve(null);
    if (typeof protocolsProvider === "string" || Array.isArray(protocolsProvider)) {
      return Promise.resolve(protocolsProvider);
    }
    if (typeof protocolsProvider === "function") {
      const protocols = protocolsProvider();
      if (!protocols)
        return Promise.resolve(null);
      if (typeof protocols === "string" || Array.isArray(protocols)) {
        return Promise.resolve(protocols);
      }
      if (protocols.then) {
        return protocols;
      }
    }
    throw Error("Invalid protocols");
  }
  _getNextUrl(urlProvider) {
    if (typeof urlProvider === "string") {
      return Promise.resolve(urlProvider);
    }
    if (typeof urlProvider === "function") {
      const url = urlProvider();
      if (typeof url === "string") {
        return Promise.resolve(url);
      }
      if (url.then) {
        return url;
      }
    }
    throw Error("Invalid URL");
  }
  _connect() {
    if (this._connectLock || !this._shouldReconnect) {
      return;
    }
    this._connectLock = true;
    const {
      maxRetries = DEFAULT.maxRetries,
      connectionTimeout = DEFAULT.connectionTimeout
    } = this._options;
    if (this._retryCount >= maxRetries) {
      this._debug("max retries reached", this._retryCount, ">=", maxRetries);
      return;
    }
    this._retryCount++;
    this._debug("connect", this._retryCount);
    this._removeListeners();
    this._wait().then(
      () => Promise.all([
        this._getNextUrl(this._url),
        this._getNextProtocols(this._protocols || null)
      ])
    ).then(([url, protocols]) => {
      if (this._closeCalled) {
        this._connectLock = false;
        return;
      }
      if (!this._options.WebSocket && typeof WebSocket === "undefined" && !didWarnAboutMissingWebSocket) {
        console.error(`‼️ No WebSocket implementation available. You should define options.WebSocket. 

For example, if you're using node.js, run \`npm install ws\`, and then in your code:

import PartySocket from 'partysocket';
import WS from 'ws';

const partysocket = new PartySocket({
  host: "127.0.0.1:1999",
  room: "test-room",
  WebSocket: WS
});

`);
        didWarnAboutMissingWebSocket = true;
      }
      const WS = this._options.WebSocket || WebSocket;
      this._debug("connect", { url, protocols });
      this._ws = protocols ? new WS(url, protocols) : new WS(url);
      this._ws.binaryType = this._binaryType;
      this._connectLock = false;
      this._addListeners();
      this._connectTimeout = setTimeout(
        () => this._handleTimeout(),
        connectionTimeout
      );
    }).catch((err) => {
      this._connectLock = false;
      this._handleError(new Events.ErrorEvent(Error(err.message), this));
    });
  }
  _handleTimeout() {
    this._debug("timeout event");
    this._handleError(new Events.ErrorEvent(Error("TIMEOUT"), this));
  }
  _disconnect(code3 = 1e3, reason) {
    this._clearTimeouts();
    if (!this._ws) {
      return;
    }
    this._removeListeners();
    try {
      this._ws.close(code3, reason);
      this._handleClose(new Events.CloseEvent(code3, reason, this));
    } catch (error3) {
    }
  }
  _acceptOpen() {
    this._debug("accept open");
    this._retryCount = 0;
  }
  _removeListeners() {
    if (!this._ws) {
      return;
    }
    this._debug("removeListeners");
    this._ws.removeEventListener("open", this._handleOpen);
    this._ws.removeEventListener("close", this._handleClose);
    this._ws.removeEventListener("message", this._handleMessage);
    this._ws.removeEventListener("error", this._handleError);
  }
  _addListeners() {
    if (!this._ws) {
      return;
    }
    this._debug("addListeners");
    this._ws.addEventListener("open", this._handleOpen);
    this._ws.addEventListener("close", this._handleClose);
    this._ws.addEventListener("message", this._handleMessage);
    this._ws.addEventListener("error", this._handleError);
  }
  _clearTimeouts() {
    clearTimeout(this._connectTimeout);
    clearTimeout(this._uptimeTimeout);
  }
};

// node_modules/@keystar/ui/dist/keystar-ui-link.js
var import_react68 = __toESM(require_react());
var import_jsx_runtime63 = __toESM(require_jsx_runtime());
function useTextLink({
  autoFocus,
  prominence = "default"
}) {
  const headingContext = useHeadingContext();
  const textContext = useTextContext();
  const {
    focusProps,
    isFocusVisible
  } = $f7dceffc5ad7768b$export$4e328f61c538687f({
    autoFocus
  });
  const {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({});
  const fontWeight = headingContext ? void 0 : tokenSchema.typography.fontWeight.medium;
  const dataOptions = {
    prominence,
    hover: isHovered ? "true" : void 0,
    focus: isFocusVisible ? "visible" : void 0
  };
  return {
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(hoverProps, focusProps),
    ...toDataAttributes(dataOptions),
    Wrapper: !textContext && !headingContext ? Text2 : import_react68.Fragment,
    className: classNames(css({
      color: tokenSchema.color.foreground.neutral,
      cursor: "pointer",
      fontWeight,
      outline: 0,
      textDecoration: "underline",
      textDecorationColor: tokenSchema.color.border.emphasis,
      textDecorationThickness: tokenSchema.size.border.regular,
      textUnderlineOffset: tokenSchema.size.border.medium,
      '&[data-hover="true"], &[data-focus="visible"]': {
        color: tokenSchema.color.foreground.neutralEmphasis,
        textDecorationColor: tokenSchema.color.foreground.neutral
      },
      '&[data-focus="visible"]': {
        textDecorationStyle: "double"
      },
      '&[data-prominence="high"]': {
        color: tokenSchema.color.foreground.accent,
        textDecorationColor: tokenSchema.color.border.accent,
        '&[data-hover="true"], &[data-focus="visible"]': {
          textDecorationColor: tokenSchema.color.foreground.accent
        }
      }
    }))
  };
}
var TextLinkAnchor = (0, import_react68.forwardRef)(function TextLink(props, forwardedRef) {
  const {
    children,
    download,
    href,
    hrefLang,
    ping,
    referrerPolicy,
    rel,
    target,
    ...otherProps
  } = props;
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const {
    Wrapper,
    ...styleProps
  } = useTextLink(props);
  const {
    linkProps
  } = $298d61e98472621b$export$dcf14c9974fe2767(otherProps, domRef);
  return (0, import_jsx_runtime63.jsx)(Wrapper, {
    children: (0, import_jsx_runtime63.jsx)("a", {
      ref: domRef,
      download,
      href,
      hrefLang,
      ping,
      referrerPolicy,
      rel,
      target,
      ...$3ef42575df84b30b$export$9d1611c77c2fe928(linkProps, styleProps),
      children
    })
  });
});
var TextLinkButton = (0, import_react68.forwardRef)(function TextLink2(props, forwardedRef) {
  const {
    children,
    ...otherProps
  } = props;
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const {
    Wrapper,
    ...styleProps
  } = useTextLink(otherProps);
  const {
    buttonProps
  } = $701a24aa0da5b062$export$ea18c227d4417cc3({
    elementType: "span",
    ...otherProps
  }, domRef);
  return (0, import_jsx_runtime63.jsx)(Wrapper, {
    children: (0, import_jsx_runtime63.jsx)("span", {
      ref: domRef,
      ...$3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, styleProps),
      children
    })
  });
});
var TextLink3 = (0, import_react68.forwardRef)(function TextLink4(props, forwardedRef) {
  if ("href" in props) {
    return (0, import_jsx_runtime63.jsx)(TextLinkAnchor, {
      ...props,
      ref: forwardedRef
    });
  }
  return (0, import_jsx_runtime63.jsx)(TextLinkButton, {
    ...props,
    ref: forwardedRef
  });
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-link2Icon.js
var import_jsx_runtime64 = __toESM(require_jsx_runtime());
var link2Icon = (0, import_jsx_runtime64.jsx)("path", {
  d: "M9 17H7A5 5 0 0 1 7 7h2M15 7h2a5 5 0 1 1 0 10h-2M8 12h8"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-link2OffIcon.js
var import_jsx_runtime65 = __toESM(require_jsx_runtime());
var link2OffIcon = (0, import_jsx_runtime65.jsx)("path", {
  d: "M9 17H7A5 5 0 0 1 7 7M15 7h2a5 5 0 0 1 4 8M8 12h4M2 2l20 20"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-pencilIcon.js
var import_jsx_runtime66 = __toESM(require_jsx_runtime());
var pencilIcon = (0, import_jsx_runtime66.jsx)("path", {
  d: "M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5ZM15 5l4 4"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-undo2Icon.js
var import_jsx_runtime67 = __toESM(require_jsx_runtime());
var undo2Icon = (0, import_jsx_runtime67.jsxs)(import_jsx_runtime67.Fragment, {
  children: [(0, import_jsx_runtime67.jsx)("path", {
    d: "M9 14 4 9l5-5"
  }), (0, import_jsx_runtime67.jsx)("path", {
    d: "M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-sheetIcon.js
var import_jsx_runtime68 = __toESM(require_jsx_runtime());
var sheetIcon = (0, import_jsx_runtime68.jsxs)(import_jsx_runtime68.Fragment, {
  children: [(0, import_jsx_runtime68.jsx)("rect", {
    width: 18,
    height: 18,
    x: 3,
    y: 3,
    rx: 2,
    ry: 2
  }), (0, import_jsx_runtime68.jsx)("path", {
    d: "M3 9h18M3 15h18M9 9v12M15 9v12"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-tableIcon.js
var import_jsx_runtime69 = __toESM(require_jsx_runtime());
var tableIcon = (0, import_jsx_runtime69.jsxs)(import_jsx_runtime69.Fragment, {
  children: [(0, import_jsx_runtime69.jsx)("path", {
    d: "M12 3v18"
  }), (0, import_jsx_runtime69.jsx)("rect", {
    width: 18,
    height: 18,
    x: 3,
    y: 3,
    rx: 2
  }), (0, import_jsx_runtime69.jsx)("path", {
    d: "M3 9h18M3 15h18"
  })]
});

// node_modules/compute-scroll-into-view/dist/index.js
var t4 = (t5) => "object" == typeof t5 && null != t5 && 1 === t5.nodeType;
var e4 = (t5, e6) => (!e6 || "hidden" !== t5) && ("visible" !== t5 && "clip" !== t5);
var n5 = (t5, n6) => {
  if (t5.clientHeight < t5.scrollHeight || t5.clientWidth < t5.scrollWidth) {
    const o5 = getComputedStyle(t5, null);
    return e4(o5.overflowY, n6) || e4(o5.overflowX, n6) || ((t6) => {
      const e6 = ((t7) => {
        if (!t7.ownerDocument || !t7.ownerDocument.defaultView)
          return null;
        try {
          return t7.ownerDocument.defaultView.frameElement;
        } catch (t8) {
          return null;
        }
      })(t6);
      return !!e6 && (e6.clientHeight < t6.scrollHeight || e6.clientWidth < t6.scrollWidth);
    })(t5);
  }
  return false;
};
var o3 = (t5, e6, n6, o5, l7, r7, i6, s4) => r7 < t5 && i6 > e6 || r7 > t5 && i6 < e6 ? 0 : r7 <= t5 && s4 <= n6 || i6 >= e6 && s4 >= n6 ? r7 - t5 - o5 : i6 > e6 && s4 < n6 || r7 < t5 && s4 > n6 ? i6 - e6 + l7 : 0;
var l6 = (t5) => {
  const e6 = t5.parentElement;
  return null == e6 ? t5.getRootNode().host || null : e6;
};
var r6 = (e6, r7) => {
  var i6, s4, d5, h3;
  if ("undefined" == typeof document)
    return [];
  const { scrollMode: c5, block: f6, inline: u4, boundary: a3, skipOverflowHiddenElements: g4 } = r7, p5 = "function" == typeof a3 ? a3 : (t5) => t5 !== a3;
  if (!t4(e6))
    throw new TypeError("Invalid target");
  const m3 = document.scrollingElement || document.documentElement, w2 = [];
  let W3 = e6;
  for (; t4(W3) && p5(W3); ) {
    if (W3 = l6(W3), W3 === m3) {
      w2.push(W3);
      break;
    }
    null != W3 && W3 === document.body && n5(W3) && !n5(document.documentElement) || null != W3 && n5(W3, g4) && w2.push(W3);
  }
  const b2 = null != (s4 = null == (i6 = window.visualViewport) ? void 0 : i6.width) ? s4 : innerWidth, H2 = null != (h3 = null == (d5 = window.visualViewport) ? void 0 : d5.height) ? h3 : innerHeight, { scrollX: y4, scrollY: M2 } = window, { height: v6, width: E3, top: x4, right: C3, bottom: I3, left: R2 } = e6.getBoundingClientRect(), { top: T2, right: B3, bottom: F, left: V } = ((t5) => {
    const e7 = window.getComputedStyle(t5);
    return { top: parseFloat(e7.scrollMarginTop) || 0, right: parseFloat(e7.scrollMarginRight) || 0, bottom: parseFloat(e7.scrollMarginBottom) || 0, left: parseFloat(e7.scrollMarginLeft) || 0 };
  })(e6);
  let k2 = "start" === f6 || "nearest" === f6 ? x4 - T2 : "end" === f6 ? I3 + F : x4 + v6 / 2 - T2 + F, D2 = "center" === u4 ? R2 + E3 / 2 - V + B3 : "end" === u4 ? C3 + B3 : R2 - V;
  const L2 = [];
  for (let t5 = 0; t5 < w2.length; t5++) {
    const e7 = w2[t5], { height: n6, width: l7, top: r8, right: i7, bottom: s5, left: d6 } = e7.getBoundingClientRect();
    if ("if-needed" === c5 && x4 >= 0 && R2 >= 0 && I3 <= H2 && C3 <= b2 && x4 >= r8 && I3 <= s5 && R2 >= d6 && C3 <= i7)
      return L2;
    const h4 = getComputedStyle(e7), a4 = parseInt(h4.borderLeftWidth, 10), g5 = parseInt(h4.borderTopWidth, 10), p6 = parseInt(h4.borderRightWidth, 10), W4 = parseInt(h4.borderBottomWidth, 10);
    let T3 = 0, B4 = 0;
    const F2 = "offsetWidth" in e7 ? e7.offsetWidth - e7.clientWidth - a4 - p6 : 0, V2 = "offsetHeight" in e7 ? e7.offsetHeight - e7.clientHeight - g5 - W4 : 0, S2 = "offsetWidth" in e7 ? 0 === e7.offsetWidth ? 0 : l7 / e7.offsetWidth : 0, X2 = "offsetHeight" in e7 ? 0 === e7.offsetHeight ? 0 : n6 / e7.offsetHeight : 0;
    if (m3 === e7)
      T3 = "start" === f6 ? k2 : "end" === f6 ? k2 - H2 : "nearest" === f6 ? o3(M2, M2 + H2, H2, g5, W4, M2 + k2, M2 + k2 + v6, v6) : k2 - H2 / 2, B4 = "start" === u4 ? D2 : "center" === u4 ? D2 - b2 / 2 : "end" === u4 ? D2 - b2 : o3(y4, y4 + b2, b2, a4, p6, y4 + D2, y4 + D2 + E3, E3), T3 = Math.max(0, T3 + M2), B4 = Math.max(0, B4 + y4);
    else {
      T3 = "start" === f6 ? k2 - r8 - g5 : "end" === f6 ? k2 - s5 + W4 + V2 : "nearest" === f6 ? o3(r8, s5, n6, g5, W4 + V2, k2, k2 + v6, v6) : k2 - (r8 + n6 / 2) + V2 / 2, B4 = "start" === u4 ? D2 - d6 - a4 : "center" === u4 ? D2 - (d6 + l7 / 2) + F2 / 2 : "end" === u4 ? D2 - i7 + p6 + F2 : o3(d6, i7, l7, a4, p6 + F2, D2, D2 + E3, E3);
      const { scrollLeft: t6, scrollTop: h5 } = e7;
      T3 = 0 === X2 ? 0 : Math.max(0, Math.min(h5 + T3 / X2, e7.scrollHeight - n6 / X2 + V2)), B4 = 0 === S2 ? 0 : Math.max(0, Math.min(t6 + B4 / S2, e7.scrollWidth - l7 / S2 + F2)), k2 += h5 - T3, D2 += t6 - B4;
    }
    L2.push({ el: e7, top: T3, left: B4 });
  }
  return L2;
};

// node_modules/scroll-into-view-if-needed/dist/index.js
var o4 = (t5) => false === t5 ? { block: "end", inline: "nearest" } : ((t6) => t6 === Object(t6) && 0 !== Object.keys(t6).length)(t5) ? t5 : { block: "start", inline: "nearest" };
function e5(e6, r7) {
  if (!e6.isConnected || !((t5) => {
    let o5 = t5;
    for (; o5 && o5.parentNode; ) {
      if (o5.parentNode === document)
        return true;
      o5 = o5.parentNode instanceof ShadowRoot ? o5.parentNode.host : o5.parentNode;
    }
    return false;
  })(e6))
    return;
  const n6 = ((t5) => {
    const o5 = window.getComputedStyle(t5);
    return { top: parseFloat(o5.scrollMarginTop) || 0, right: parseFloat(o5.scrollMarginRight) || 0, bottom: parseFloat(o5.scrollMarginBottom) || 0, left: parseFloat(o5.scrollMarginLeft) || 0 };
  })(e6);
  if (((t5) => "object" == typeof t5 && "function" == typeof t5.behavior)(r7))
    return r7.behavior(r6(e6, r7));
  const l7 = "boolean" == typeof r7 || null == r7 ? void 0 : r7.behavior;
  for (const { el: a3, top: i6, left: s4 } of r6(e6, o4(r7))) {
    const t5 = i6 - n6.top + n6.bottom, o5 = s4 - n6.left + n6.right;
    a3.scroll({ top: t5, left: o5, behavior: l7 });
  }
}

// node_modules/slate-history/dist/index.es.js
var History = {
  /**
   * Check if a value is a `History` object.
   */
  isHistory(value2) {
    return isPlainObject(value2) && Array.isArray(value2.redos) && Array.isArray(value2.undos) && (value2.redos.length === 0 || Operation.isOperationList(value2.redos[0].operations)) && (value2.undos.length === 0 || Operation.isOperationList(value2.undos[0].operations));
  }
};
var SAVING = /* @__PURE__ */ new WeakMap();
var MERGING = /* @__PURE__ */ new WeakMap();
var HistoryEditor = {
  /**
   * Check if a value is a `HistoryEditor` object.
   */
  isHistoryEditor(value2) {
    return History.isHistory(value2.history) && Editor.isEditor(value2);
  },
  /**
   * Get the merge flag's current value.
   */
  isMerging(editor) {
    return MERGING.get(editor);
  },
  /**
   * Get the saving flag's current value.
   */
  isSaving(editor) {
    return SAVING.get(editor);
  },
  /**
   * Redo to the previous saved state.
   */
  redo(editor) {
    editor.redo();
  },
  /**
   * Undo to the previous saved state.
   */
  undo(editor) {
    editor.undo();
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without merging any of
   * the new operations into previous save point in the history.
   */
  withoutMerging(editor, fn2) {
    var prev2 = HistoryEditor.isMerging(editor);
    MERGING.set(editor, false);
    fn2();
    MERGING.set(editor, prev2);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without saving any of
   * their operations into the history.
   */
  withoutSaving(editor, fn2) {
    var prev2 = HistoryEditor.isSaving(editor);
    SAVING.set(editor, false);
    fn2();
    SAVING.set(editor, prev2);
  }
};
var withHistory = (editor) => {
  var e6 = editor;
  var {
    apply
  } = e6;
  e6.history = {
    undos: [],
    redos: []
  };
  e6.redo = () => {
    var {
      history
    } = e6;
    var {
      redos
    } = history;
    if (redos.length > 0) {
      var batch = redos[redos.length - 1];
      if (batch.selectionBefore) {
        Transforms.setSelection(e6, batch.selectionBefore);
      }
      HistoryEditor.withoutSaving(e6, () => {
        Editor.withoutNormalizing(e6, () => {
          for (var op of batch.operations) {
            e6.apply(op);
          }
        });
      });
      history.redos.pop();
      history.undos.push(batch);
    }
  };
  e6.undo = () => {
    var {
      history
    } = e6;
    var {
      undos
    } = history;
    if (undos.length > 0) {
      var batch = undos[undos.length - 1];
      HistoryEditor.withoutSaving(e6, () => {
        Editor.withoutNormalizing(e6, () => {
          var inverseOps = batch.operations.map(Operation.inverse).reverse();
          for (var op of inverseOps) {
            e6.apply(op);
          }
          if (batch.selectionBefore) {
            Transforms.setSelection(e6, batch.selectionBefore);
          }
        });
      });
      history.redos.push(batch);
      history.undos.pop();
    }
  };
  e6.apply = (op) => {
    var {
      operations,
      history
    } = e6;
    var {
      undos
    } = history;
    var lastBatch = undos[undos.length - 1];
    var lastOp = lastBatch && lastBatch.operations[lastBatch.operations.length - 1];
    var save = HistoryEditor.isSaving(e6);
    var merge4 = HistoryEditor.isMerging(e6);
    if (save == null) {
      save = shouldSave(op);
    }
    if (save) {
      if (merge4 == null) {
        if (lastBatch == null) {
          merge4 = false;
        } else if (operations.length !== 0) {
          merge4 = true;
        } else {
          merge4 = shouldMerge(op, lastOp);
        }
      }
      if (lastBatch && merge4) {
        lastBatch.operations.push(op);
      } else {
        var batch = {
          operations: [op],
          selectionBefore: e6.selection
        };
        undos.push(batch);
      }
      while (undos.length > 100) {
        undos.shift();
      }
      history.redos = [];
    }
    apply(op);
  };
  return e6;
};
var shouldMerge = (op, prev2) => {
  if (prev2 && op.type === "insert_text" && prev2.type === "insert_text" && op.offset === prev2.offset + prev2.text.length && Path.equals(op.path, prev2.path)) {
    return true;
  }
  if (prev2 && op.type === "remove_text" && prev2.type === "remove_text" && op.offset + op.text.length === prev2.offset && Path.equals(op.path, prev2.path)) {
    return true;
  }
  return false;
};
var shouldSave = (op, prev2) => {
  if (op.type === "set_selection") {
    return false;
  }
  return true;
};

// node_modules/devlop/lib/development.js
var AssertionError = class extends Error {
  /**
   * Create an assertion error.
   *
   * @param {string} message
   *   Message explaining error.
   * @param {unknown} actual
   *   Value.
   * @param {unknown} expected
   *   Baseline.
   * @param {string} operator
   *   Name of equality operation.
   * @param {boolean} generated
   *   Whether `message` is a custom message or not
   * @returns
   *   Instance.
   */
  // eslint-disable-next-line max-params
  constructor(message, actual, expected, operator, generated) {
    super(message);
    __publicField(
      this,
      "name",
      /** @type {const} */
      "Assertion"
    );
    __publicField(
      this,
      "code",
      /** @type {const} */
      "ERR_ASSERTION"
    );
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.actual = actual;
    this.expected = expected;
    this.generated = generated;
    this.operator = operator;
  }
};
function ok(value2, message) {
  assert3(
    Boolean(value2),
    false,
    true,
    "ok",
    "Expected value to be truthy",
    message
  );
}
function assert3(bool, actual, expected, operator, defaultMessage, userMessage) {
  if (!bool) {
    throw userMessage instanceof Error ? userMessage : new AssertionError(
      userMessage || defaultMessage,
      actual,
      expected,
      operator,
      !userMessage
    );
  }
}

// node_modules/mdast-util-to-string/lib/index.js
var emptyOptions = {};
function toString2(value2, options) {
  const settings = options || emptyOptions;
  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
  return one(value2, includeImageAlt, includeHtml);
}
function one(value2, includeImageAlt, includeHtml) {
  if (node3(value2)) {
    if ("value" in value2) {
      return value2.type === "html" && !includeHtml ? "" : value2.value;
    }
    if (includeImageAlt && "alt" in value2 && value2.alt) {
      return value2.alt;
    }
    if ("children" in value2) {
      return all2(value2.children, includeImageAlt, includeHtml);
    }
  }
  if (Array.isArray(value2)) {
    return all2(value2, includeImageAlt, includeHtml);
  }
  return "";
}
function all2(values3, includeImageAlt, includeHtml) {
  const result = [];
  let index3 = -1;
  while (++index3 < values3.length) {
    result[index3] = one(values3[index3], includeImageAlt, includeHtml);
  }
  return result.join("");
}
function node3(value2) {
  return Boolean(value2 && typeof value2 === "object");
}

// node_modules/decode-named-character-reference/index.dom.js
var element3 = document.createElement("i");
function decodeNamedCharacterReference(value2) {
  const characterReference2 = "&" + value2 + ";";
  element3.innerHTML = characterReference2;
  const char2 = element3.textContent;
  if (char2.charCodeAt(char2.length - 1) === 59 && value2 !== "semi") {
    return false;
  }
  return char2 === characterReference2 ? false : char2;
}

// node_modules/micromark-util-symbol/lib/codes.js
var codes = (
  /** @type {const} */
  {
    carriageReturn: -5,
    lineFeed: -4,
    carriageReturnLineFeed: -3,
    horizontalTab: -2,
    virtualSpace: -1,
    eof: null,
    nul: 0,
    soh: 1,
    stx: 2,
    etx: 3,
    eot: 4,
    enq: 5,
    ack: 6,
    bel: 7,
    bs: 8,
    ht: 9,
    // `\t`
    lf: 10,
    // `\n`
    vt: 11,
    // `\v`
    ff: 12,
    // `\f`
    cr: 13,
    // `\r`
    so: 14,
    si: 15,
    dle: 16,
    dc1: 17,
    dc2: 18,
    dc3: 19,
    dc4: 20,
    nak: 21,
    syn: 22,
    etb: 23,
    can: 24,
    em: 25,
    sub: 26,
    esc: 27,
    fs: 28,
    gs: 29,
    rs: 30,
    us: 31,
    space: 32,
    exclamationMark: 33,
    // `!`
    quotationMark: 34,
    // `"`
    numberSign: 35,
    // `#`
    dollarSign: 36,
    // `$`
    percentSign: 37,
    // `%`
    ampersand: 38,
    // `&`
    apostrophe: 39,
    // `'`
    leftParenthesis: 40,
    // `(`
    rightParenthesis: 41,
    // `)`
    asterisk: 42,
    // `*`
    plusSign: 43,
    // `+`
    comma: 44,
    // `,`
    dash: 45,
    // `-`
    dot: 46,
    // `.`
    slash: 47,
    // `/`
    digit0: 48,
    // `0`
    digit1: 49,
    // `1`
    digit2: 50,
    // `2`
    digit3: 51,
    // `3`
    digit4: 52,
    // `4`
    digit5: 53,
    // `5`
    digit6: 54,
    // `6`
    digit7: 55,
    // `7`
    digit8: 56,
    // `8`
    digit9: 57,
    // `9`
    colon: 58,
    // `:`
    semicolon: 59,
    // `;`
    lessThan: 60,
    // `<`
    equalsTo: 61,
    // `=`
    greaterThan: 62,
    // `>`
    questionMark: 63,
    // `?`
    atSign: 64,
    // `@`
    uppercaseA: 65,
    // `A`
    uppercaseB: 66,
    // `B`
    uppercaseC: 67,
    // `C`
    uppercaseD: 68,
    // `D`
    uppercaseE: 69,
    // `E`
    uppercaseF: 70,
    // `F`
    uppercaseG: 71,
    // `G`
    uppercaseH: 72,
    // `H`
    uppercaseI: 73,
    // `I`
    uppercaseJ: 74,
    // `J`
    uppercaseK: 75,
    // `K`
    uppercaseL: 76,
    // `L`
    uppercaseM: 77,
    // `M`
    uppercaseN: 78,
    // `N`
    uppercaseO: 79,
    // `O`
    uppercaseP: 80,
    // `P`
    uppercaseQ: 81,
    // `Q`
    uppercaseR: 82,
    // `R`
    uppercaseS: 83,
    // `S`
    uppercaseT: 84,
    // `T`
    uppercaseU: 85,
    // `U`
    uppercaseV: 86,
    // `V`
    uppercaseW: 87,
    // `W`
    uppercaseX: 88,
    // `X`
    uppercaseY: 89,
    // `Y`
    uppercaseZ: 90,
    // `Z`
    leftSquareBracket: 91,
    // `[`
    backslash: 92,
    // `\`
    rightSquareBracket: 93,
    // `]`
    caret: 94,
    // `^`
    underscore: 95,
    // `_`
    graveAccent: 96,
    // `` ` ``
    lowercaseA: 97,
    // `a`
    lowercaseB: 98,
    // `b`
    lowercaseC: 99,
    // `c`
    lowercaseD: 100,
    // `d`
    lowercaseE: 101,
    // `e`
    lowercaseF: 102,
    // `f`
    lowercaseG: 103,
    // `g`
    lowercaseH: 104,
    // `h`
    lowercaseI: 105,
    // `i`
    lowercaseJ: 106,
    // `j`
    lowercaseK: 107,
    // `k`
    lowercaseL: 108,
    // `l`
    lowercaseM: 109,
    // `m`
    lowercaseN: 110,
    // `n`
    lowercaseO: 111,
    // `o`
    lowercaseP: 112,
    // `p`
    lowercaseQ: 113,
    // `q`
    lowercaseR: 114,
    // `r`
    lowercaseS: 115,
    // `s`
    lowercaseT: 116,
    // `t`
    lowercaseU: 117,
    // `u`
    lowercaseV: 118,
    // `v`
    lowercaseW: 119,
    // `w`
    lowercaseX: 120,
    // `x`
    lowercaseY: 121,
    // `y`
    lowercaseZ: 122,
    // `z`
    leftCurlyBrace: 123,
    // `{`
    verticalBar: 124,
    // `|`
    rightCurlyBrace: 125,
    // `}`
    tilde: 126,
    // `~`
    del: 127,
    // Unicode Specials block.
    byteOrderMarker: 65279,
    // Unicode Specials block.
    replacementCharacter: 65533
    // `�`
  }
);

// node_modules/micromark-util-symbol/lib/constants.js
var constants = (
  /** @type {const} */
  {
    attentionSideBefore: 1,
    // Symbol to mark an attention sequence as before content: `*a`
    attentionSideAfter: 2,
    // Symbol to mark an attention sequence as after content: `a*`
    atxHeadingOpeningFenceSizeMax: 6,
    // 6 number signs is fine, 7 isn’t.
    autolinkDomainSizeMax: 63,
    // 63 characters is fine, 64 is too many.
    autolinkSchemeSizeMax: 32,
    // 32 characters is fine, 33 is too many.
    cdataOpeningString: "CDATA[",
    // And preceded by `<![`.
    characterGroupWhitespace: 1,
    // Symbol used to indicate a character is whitespace
    characterGroupPunctuation: 2,
    // Symbol used to indicate a character is punctuation
    characterReferenceDecimalSizeMax: 7,
    // `&#9999999;`.
    characterReferenceHexadecimalSizeMax: 6,
    // `&#xff9999;`.
    characterReferenceNamedSizeMax: 31,
    // `&CounterClockwiseContourIntegral;`.
    codeFencedSequenceSizeMin: 3,
    // At least 3 ticks or tildes are needed.
    contentTypeDocument: "document",
    contentTypeFlow: "flow",
    contentTypeContent: "content",
    contentTypeString: "string",
    contentTypeText: "text",
    hardBreakPrefixSizeMin: 2,
    // At least 2 trailing spaces are needed.
    htmlRaw: 1,
    // Symbol for `<script>`
    htmlComment: 2,
    // Symbol for `<!---->`
    htmlInstruction: 3,
    // Symbol for `<?php?>`
    htmlDeclaration: 4,
    // Symbol for `<!doctype>`
    htmlCdata: 5,
    // Symbol for `<![CDATA[]]>`
    htmlBasic: 6,
    // Symbol for `<div`
    htmlComplete: 7,
    // Symbol for `<x>`
    htmlRawSizeMax: 8,
    // Length of `textarea`.
    linkResourceDestinationBalanceMax: 32,
    // See: <https://spec.commonmark.org/0.30/#link-destination>, <https://github.com/remarkjs/react-markdown/issues/658#issuecomment-984345577>
    linkReferenceSizeMax: 999,
    // See: <https://spec.commonmark.org/0.30/#link-label>
    listItemValueSizeMax: 10,
    // See: <https://spec.commonmark.org/0.30/#ordered-list-marker>
    numericBaseDecimal: 10,
    numericBaseHexadecimal: 16,
    tabSize: 4,
    // Tabs have a hard-coded size of 4, per CommonMark.
    thematicBreakMarkerCountMin: 3,
    // At least 3 asterisks, dashes, or underscores are needed.
    v8MaxSafeChunkSize: 1e4
    // V8 (and potentially others) have problems injecting giant arrays into other arrays, hence we operate in chunks.
  }
);

// node_modules/micromark-util-symbol/lib/types.js
var types2 = (
  /** @type {const} */
  {
    // Generic type for data, such as in a title, a destination, etc.
    data: "data",
    // Generic type for syntactic whitespace (tabs, virtual spaces, spaces).
    // Such as, between a fenced code fence and an info string.
    whitespace: "whitespace",
    // Generic type for line endings (line feed, carriage return, carriage return +
    // line feed).
    lineEnding: "lineEnding",
    // A line ending, but ending a blank line.
    lineEndingBlank: "lineEndingBlank",
    // Generic type for whitespace (tabs, virtual spaces, spaces) at the start of a
    // line.
    linePrefix: "linePrefix",
    // Generic type for whitespace (tabs, virtual spaces, spaces) at the end of a
    // line.
    lineSuffix: "lineSuffix",
    // Whole ATX heading:
    //
    // ```markdown
    // #
    // ## Alpha
    // ### Bravo ###
    // ```
    //
    // Includes `atxHeadingSequence`, `whitespace`, `atxHeadingText`.
    atxHeading: "atxHeading",
    // Sequence of number signs in an ATX heading (`###`).
    atxHeadingSequence: "atxHeadingSequence",
    // Content in an ATX heading (`alpha`).
    // Includes text.
    atxHeadingText: "atxHeadingText",
    // Whole autolink (`<https://example.com>` or `<admin@example.com>`)
    // Includes `autolinkMarker` and `autolinkProtocol` or `autolinkEmail`.
    autolink: "autolink",
    // Email autolink w/o markers (`admin@example.com`)
    autolinkEmail: "autolinkEmail",
    // Marker around an `autolinkProtocol` or `autolinkEmail` (`<` or `>`).
    autolinkMarker: "autolinkMarker",
    // Protocol autolink w/o markers (`https://example.com`)
    autolinkProtocol: "autolinkProtocol",
    // A whole character escape (`\-`).
    // Includes `escapeMarker` and `characterEscapeValue`.
    characterEscape: "characterEscape",
    // The escaped character (`-`).
    characterEscapeValue: "characterEscapeValue",
    // A whole character reference (`&amp;`, `&#8800;`, or `&#x1D306;`).
    // Includes `characterReferenceMarker`, an optional
    // `characterReferenceMarkerNumeric`, in which case an optional
    // `characterReferenceMarkerHexadecimal`, and a `characterReferenceValue`.
    characterReference: "characterReference",
    // The start or end marker (`&` or `;`).
    characterReferenceMarker: "characterReferenceMarker",
    // Mark reference as numeric (`#`).
    characterReferenceMarkerNumeric: "characterReferenceMarkerNumeric",
    // Mark reference as numeric (`x` or `X`).
    characterReferenceMarkerHexadecimal: "characterReferenceMarkerHexadecimal",
    // Value of character reference w/o markers (`amp`, `8800`, or `1D306`).
    characterReferenceValue: "characterReferenceValue",
    // Whole fenced code:
    //
    // ````markdown
    // ```js
    // alert(1)
    // ```
    // ````
    codeFenced: "codeFenced",
    // A fenced code fence, including whitespace, sequence, info, and meta
    // (` ```js `).
    codeFencedFence: "codeFencedFence",
    // Sequence of grave accent or tilde characters (` ``` `) in a fence.
    codeFencedFenceSequence: "codeFencedFenceSequence",
    // Info word (`js`) in a fence.
    // Includes string.
    codeFencedFenceInfo: "codeFencedFenceInfo",
    // Meta words (`highlight="1"`) in a fence.
    // Includes string.
    codeFencedFenceMeta: "codeFencedFenceMeta",
    // A line of code.
    codeFlowValue: "codeFlowValue",
    // Whole indented code:
    //
    // ```markdown
    //     alert(1)
    // ```
    //
    // Includes `lineEnding`, `linePrefix`, and `codeFlowValue`.
    codeIndented: "codeIndented",
    // A text code (``` `alpha` ```).
    // Includes `codeTextSequence`, `codeTextData`, `lineEnding`, and can include
    // `codeTextPadding`.
    codeText: "codeText",
    codeTextData: "codeTextData",
    // A space or line ending right after or before a tick.
    codeTextPadding: "codeTextPadding",
    // A text code fence (` `` `).
    codeTextSequence: "codeTextSequence",
    // Whole content:
    //
    // ```markdown
    // [a]: b
    // c
    // =
    // d
    // ```
    //
    // Includes `paragraph` and `definition`.
    content: "content",
    // Whole definition:
    //
    // ```markdown
    // [micromark]: https://github.com/micromark/micromark
    // ```
    //
    // Includes `definitionLabel`, `definitionMarker`, `whitespace`,
    // `definitionDestination`, and optionally `lineEnding` and `definitionTitle`.
    definition: "definition",
    // Destination of a definition (`https://github.com/micromark/micromark` or
    // `<https://github.com/micromark/micromark>`).
    // Includes `definitionDestinationLiteral` or `definitionDestinationRaw`.
    definitionDestination: "definitionDestination",
    // Enclosed destination of a definition
    // (`<https://github.com/micromark/micromark>`).
    // Includes `definitionDestinationLiteralMarker` and optionally
    // `definitionDestinationString`.
    definitionDestinationLiteral: "definitionDestinationLiteral",
    // Markers of an enclosed definition destination (`<` or `>`).
    definitionDestinationLiteralMarker: "definitionDestinationLiteralMarker",
    // Unenclosed destination of a definition
    // (`https://github.com/micromark/micromark`).
    // Includes `definitionDestinationString`.
    definitionDestinationRaw: "definitionDestinationRaw",
    // Text in an destination (`https://github.com/micromark/micromark`).
    // Includes string.
    definitionDestinationString: "definitionDestinationString",
    // Label of a definition (`[micromark]`).
    // Includes `definitionLabelMarker` and `definitionLabelString`.
    definitionLabel: "definitionLabel",
    // Markers of a definition label (`[` or `]`).
    definitionLabelMarker: "definitionLabelMarker",
    // Value of a definition label (`micromark`).
    // Includes string.
    definitionLabelString: "definitionLabelString",
    // Marker between a label and a destination (`:`).
    definitionMarker: "definitionMarker",
    // Title of a definition (`"x"`, `'y'`, or `(z)`).
    // Includes `definitionTitleMarker` and optionally `definitionTitleString`.
    definitionTitle: "definitionTitle",
    // Marker around a title of a definition (`"`, `'`, `(`, or `)`).
    definitionTitleMarker: "definitionTitleMarker",
    // Data without markers in a title (`z`).
    // Includes string.
    definitionTitleString: "definitionTitleString",
    // Emphasis (`*alpha*`).
    // Includes `emphasisSequence` and `emphasisText`.
    emphasis: "emphasis",
    // Sequence of emphasis markers (`*` or `_`).
    emphasisSequence: "emphasisSequence",
    // Emphasis text (`alpha`).
    // Includes text.
    emphasisText: "emphasisText",
    // The character escape marker (`\`).
    escapeMarker: "escapeMarker",
    // A hard break created with a backslash (`\\n`).
    // Note: does not include the line ending.
    hardBreakEscape: "hardBreakEscape",
    // A hard break created with trailing spaces (`  \n`).
    // Does not include the line ending.
    hardBreakTrailing: "hardBreakTrailing",
    // Flow HTML:
    //
    // ```markdown
    // <div
    // ```
    //
    // Inlcudes `lineEnding`, `htmlFlowData`.
    htmlFlow: "htmlFlow",
    htmlFlowData: "htmlFlowData",
    // HTML in text (the tag in `a <i> b`).
    // Includes `lineEnding`, `htmlTextData`.
    htmlText: "htmlText",
    htmlTextData: "htmlTextData",
    // Whole image (`![alpha](bravo)`, `![alpha][bravo]`, `![alpha][]`, or
    // `![alpha]`).
    // Includes `label` and an optional `resource` or `reference`.
    image: "image",
    // Whole link label (`[*alpha*]`).
    // Includes `labelLink` or `labelImage`, `labelText`, and `labelEnd`.
    label: "label",
    // Text in an label (`*alpha*`).
    // Includes text.
    labelText: "labelText",
    // Start a link label (`[`).
    // Includes a `labelMarker`.
    labelLink: "labelLink",
    // Start an image label (`![`).
    // Includes `labelImageMarker` and `labelMarker`.
    labelImage: "labelImage",
    // Marker of a label (`[` or `]`).
    labelMarker: "labelMarker",
    // Marker to start an image (`!`).
    labelImageMarker: "labelImageMarker",
    // End a label (`]`).
    // Includes `labelMarker`.
    labelEnd: "labelEnd",
    // Whole link (`[alpha](bravo)`, `[alpha][bravo]`, `[alpha][]`, or `[alpha]`).
    // Includes `label` and an optional `resource` or `reference`.
    link: "link",
    // Whole paragraph:
    //
    // ```markdown
    // alpha
    // bravo.
    // ```
    //
    // Includes text.
    paragraph: "paragraph",
    // A reference (`[alpha]` or `[]`).
    // Includes `referenceMarker` and an optional `referenceString`.
    reference: "reference",
    // A reference marker (`[` or `]`).
    referenceMarker: "referenceMarker",
    // Reference text (`alpha`).
    // Includes string.
    referenceString: "referenceString",
    // A resource (`(https://example.com "alpha")`).
    // Includes `resourceMarker`, an optional `resourceDestination` with an optional
    // `whitespace` and `resourceTitle`.
    resource: "resource",
    // A resource destination (`https://example.com`).
    // Includes `resourceDestinationLiteral` or `resourceDestinationRaw`.
    resourceDestination: "resourceDestination",
    // A literal resource destination (`<https://example.com>`).
    // Includes `resourceDestinationLiteralMarker` and optionally
    // `resourceDestinationString`.
    resourceDestinationLiteral: "resourceDestinationLiteral",
    // A resource destination marker (`<` or `>`).
    resourceDestinationLiteralMarker: "resourceDestinationLiteralMarker",
    // A raw resource destination (`https://example.com`).
    // Includes `resourceDestinationString`.
    resourceDestinationRaw: "resourceDestinationRaw",
    // Resource destination text (`https://example.com`).
    // Includes string.
    resourceDestinationString: "resourceDestinationString",
    // A resource marker (`(` or `)`).
    resourceMarker: "resourceMarker",
    // A resource title (`"alpha"`, `'alpha'`, or `(alpha)`).
    // Includes `resourceTitleMarker` and optionally `resourceTitleString`.
    resourceTitle: "resourceTitle",
    // A resource title marker (`"`, `'`, `(`, or `)`).
    resourceTitleMarker: "resourceTitleMarker",
    // Resource destination title (`alpha`).
    // Includes string.
    resourceTitleString: "resourceTitleString",
    // Whole setext heading:
    //
    // ```markdown
    // alpha
    // bravo
    // =====
    // ```
    //
    // Includes `setextHeadingText`, `lineEnding`, `linePrefix`, and
    // `setextHeadingLine`.
    setextHeading: "setextHeading",
    // Content in a setext heading (`alpha\nbravo`).
    // Includes text.
    setextHeadingText: "setextHeadingText",
    // Underline in a setext heading, including whitespace suffix (`==`).
    // Includes `setextHeadingLineSequence`.
    setextHeadingLine: "setextHeadingLine",
    // Sequence of equals or dash characters in underline in a setext heading (`-`).
    setextHeadingLineSequence: "setextHeadingLineSequence",
    // Strong (`**alpha**`).
    // Includes `strongSequence` and `strongText`.
    strong: "strong",
    // Sequence of strong markers (`**` or `__`).
    strongSequence: "strongSequence",
    // Strong text (`alpha`).
    // Includes text.
    strongText: "strongText",
    // Whole thematic break:
    //
    // ```markdown
    // * * *
    // ```
    //
    // Includes `thematicBreakSequence` and `whitespace`.
    thematicBreak: "thematicBreak",
    // A sequence of one or more thematic break markers (`***`).
    thematicBreakSequence: "thematicBreakSequence",
    // Whole block quote:
    //
    // ```markdown
    // > a
    // >
    // > b
    // ```
    //
    // Includes `blockQuotePrefix` and flow.
    blockQuote: "blockQuote",
    // The `>` or `> ` of a block quote.
    blockQuotePrefix: "blockQuotePrefix",
    // The `>` of a block quote prefix.
    blockQuoteMarker: "blockQuoteMarker",
    // The optional ` ` of a block quote prefix.
    blockQuotePrefixWhitespace: "blockQuotePrefixWhitespace",
    // Whole unordered list:
    //
    // ```markdown
    // - a
    //   b
    // ```
    //
    // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
    // lines.
    listOrdered: "listOrdered",
    // Whole ordered list:
    //
    // ```markdown
    // 1. a
    //    b
    // ```
    //
    // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
    // lines.
    listUnordered: "listUnordered",
    // The indent of further list item lines.
    listItemIndent: "listItemIndent",
    // A marker, as in, `*`, `+`, `-`, `.`, or `)`.
    listItemMarker: "listItemMarker",
    // The thing that starts a list item, such as `1. `.
    // Includes `listItemValue` if ordered, `listItemMarker`, and
    // `listItemPrefixWhitespace` (unless followed by a line ending).
    listItemPrefix: "listItemPrefix",
    // The whitespace after a marker.
    listItemPrefixWhitespace: "listItemPrefixWhitespace",
    // The numerical value of an ordered item.
    listItemValue: "listItemValue",
    // Internal types used for subtokenizers, compiled away
    chunkDocument: "chunkDocument",
    chunkContent: "chunkContent",
    chunkFlow: "chunkFlow",
    chunkText: "chunkText",
    chunkString: "chunkString"
  }
);

// node_modules/micromark-util-symbol/lib/values.js
var values = (
  /** @type {const} */
  {
    ht: "	",
    lf: "\n",
    cr: "\r",
    space: " ",
    exclamationMark: "!",
    quotationMark: '"',
    numberSign: "#",
    dollarSign: "$",
    percentSign: "%",
    ampersand: "&",
    apostrophe: "'",
    leftParenthesis: "(",
    rightParenthesis: ")",
    asterisk: "*",
    plusSign: "+",
    comma: ",",
    dash: "-",
    dot: ".",
    slash: "/",
    digit0: "0",
    digit1: "1",
    digit2: "2",
    digit3: "3",
    digit4: "4",
    digit5: "5",
    digit6: "6",
    digit7: "7",
    digit8: "8",
    digit9: "9",
    colon: ":",
    semicolon: ";",
    lessThan: "<",
    equalsTo: "=",
    greaterThan: ">",
    questionMark: "?",
    atSign: "@",
    uppercaseA: "A",
    uppercaseB: "B",
    uppercaseC: "C",
    uppercaseD: "D",
    uppercaseE: "E",
    uppercaseF: "F",
    uppercaseG: "G",
    uppercaseH: "H",
    uppercaseI: "I",
    uppercaseJ: "J",
    uppercaseK: "K",
    uppercaseL: "L",
    uppercaseM: "M",
    uppercaseN: "N",
    uppercaseO: "O",
    uppercaseP: "P",
    uppercaseQ: "Q",
    uppercaseR: "R",
    uppercaseS: "S",
    uppercaseT: "T",
    uppercaseU: "U",
    uppercaseV: "V",
    uppercaseW: "W",
    uppercaseX: "X",
    uppercaseY: "Y",
    uppercaseZ: "Z",
    leftSquareBracket: "[",
    backslash: "\\",
    rightSquareBracket: "]",
    caret: "^",
    underscore: "_",
    graveAccent: "`",
    lowercaseA: "a",
    lowercaseB: "b",
    lowercaseC: "c",
    lowercaseD: "d",
    lowercaseE: "e",
    lowercaseF: "f",
    lowercaseG: "g",
    lowercaseH: "h",
    lowercaseI: "i",
    lowercaseJ: "j",
    lowercaseK: "k",
    lowercaseL: "l",
    lowercaseM: "m",
    lowercaseN: "n",
    lowercaseO: "o",
    lowercaseP: "p",
    lowercaseQ: "q",
    lowercaseR: "r",
    lowercaseS: "s",
    lowercaseT: "t",
    lowercaseU: "u",
    lowercaseV: "v",
    lowercaseW: "w",
    lowercaseX: "x",
    lowercaseY: "y",
    lowercaseZ: "z",
    leftCurlyBrace: "{",
    verticalBar: "|",
    rightCurlyBrace: "}",
    tilde: "~",
    replacementCharacter: "�"
  }
);

// node_modules/micromark-util-chunked/dev/index.js
function splice(list3, start2, remove, items) {
  const end = list3.length;
  let chunkStart = 0;
  let parameters;
  if (start2 < 0) {
    start2 = -start2 > end ? 0 : end + start2;
  } else {
    start2 = start2 > end ? end : start2;
  }
  remove = remove > 0 ? remove : 0;
  if (items.length < constants.v8MaxSafeChunkSize) {
    parameters = Array.from(items);
    parameters.unshift(start2, remove);
    list3.splice(...parameters);
  } else {
    if (remove)
      list3.splice(start2, remove);
    while (chunkStart < items.length) {
      parameters = items.slice(
        chunkStart,
        chunkStart + constants.v8MaxSafeChunkSize
      );
      parameters.unshift(start2, 0);
      list3.splice(...parameters);
      chunkStart += constants.v8MaxSafeChunkSize;
      start2 += constants.v8MaxSafeChunkSize;
    }
  }
}
function push2(list3, items) {
  if (list3.length > 0) {
    splice(list3, list3.length, 0, items);
    return list3;
  }
  return items;
}

// node_modules/micromark-util-combine-extensions/index.js
var hasOwnProperty2 = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all3 = {};
  let index3 = -1;
  while (++index3 < extensions.length) {
    syntaxExtension(all3, extensions[index3]);
  }
  return all3;
}
function syntaxExtension(all3, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty2.call(all3, hook) ? all3[hook] : void 0;
    const left = maybe || (all3[hook] = {});
    const right = extension2[hook];
    let code3;
    if (right) {
      for (code3 in right) {
        if (!hasOwnProperty2.call(left, code3))
          left[code3] = [];
        const value2 = right[code3];
        constructs(
          // @ts-expect-error Looks like a list.
          left[code3],
          Array.isArray(value2) ? value2 : value2 ? [value2] : []
        );
      }
    }
  }
}
function constructs(existing, list3) {
  let index3 = -1;
  const before = [];
  while (++index3 < list3.length) {
    ;
    (list3[index3].add === "after" ? existing : before).push(list3[index3]);
  }
  splice(existing, 0, 0, before);
}

// node_modules/micromark-util-decode-numeric-character-reference/dev/index.js
function decodeNumericCharacterReference(value2, base) {
  const code3 = Number.parseInt(value2, base);
  if (
    // C0 except for HT, LF, FF, CR, space.
    code3 < codes.ht || code3 === codes.vt || code3 > codes.cr && code3 < codes.space || // Control character (DEL) of C0, and C1 controls.
    code3 > codes.tilde && code3 < 160 || // Lone high surrogates and low surrogates.
    code3 > 55295 && code3 < 57344 || // Noncharacters.
    code3 > 64975 && code3 < 65008 || /* eslint-disable no-bitwise */
    (code3 & 65535) === 65535 || (code3 & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    code3 > 1114111
  ) {
    return values.replacementCharacter;
  }
  return String.fromCodePoint(code3);
}

// node_modules/micromark-util-normalize-identifier/dev/index.js
function normalizeIdentifier(value2) {
  return value2.replace(/[\t\n\r ]+/g, values.space).replace(/^ | $/g, "").toLowerCase().toUpperCase();
}

// node_modules/micromark-util-character/dev/index.js
var asciiAlpha = regexCheck(/[A-Za-z]/);
var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code3) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code3 !== null && (code3 < codes.space || code3 === codes.del)
  );
}
var asciiDigit = regexCheck(/\d/);
var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding(code3) {
  return code3 !== null && code3 < codes.horizontalTab;
}
function markdownLineEndingOrSpace(code3) {
  return code3 !== null && (code3 < codes.nul || code3 === codes.space);
}
function markdownSpace(code3) {
  return code3 === codes.horizontalTab || code3 === codes.virtualSpace || code3 === codes.space;
}
var unicodePunctuation = regexCheck(new RegExp("\\p{P}|\\p{S}", "u"));
var unicodeWhitespace = regexCheck(/\s/);
function regexCheck(regex) {
  return check;
  function check(code3) {
    return code3 !== null && code3 > -1 && regex.test(String.fromCharCode(code3));
  }
}

// node_modules/micromark/dev/lib/compile.js
var hasOwnProperty3 = {}.hasOwnProperty;

// node_modules/micromark-factory-space/dev/index.js
function factorySpace(effects, ok3, type2, max4) {
  const limit = max4 ? max4 - 1 : Number.POSITIVE_INFINITY;
  let size3 = 0;
  return start2;
  function start2(code3) {
    if (markdownSpace(code3)) {
      effects.enter(type2);
      return prefix4(code3);
    }
    return ok3(code3);
  }
  function prefix4(code3) {
    if (markdownSpace(code3) && size3++ < limit) {
      effects.consume(code3);
      return prefix4;
    }
    effects.exit(type2);
    return ok3(code3);
  }
}

// node_modules/micromark/dev/lib/initialize/content.js
var content = { tokenize: initializeContent };
function initializeContent(effects) {
  const contentStart = effects.attempt(
    this.parser.constructs.contentInitial,
    afterContentStartConstruct,
    paragraphInitial
  );
  let previous3;
  return contentStart;
  function afterContentStartConstruct(code3) {
    ok(
      code3 === codes.eof || markdownLineEnding(code3),
      "expected eol or eof"
    );
    if (code3 === codes.eof) {
      effects.consume(code3);
      return;
    }
    effects.enter(types2.lineEnding);
    effects.consume(code3);
    effects.exit(types2.lineEnding);
    return factorySpace(effects, contentStart, types2.linePrefix);
  }
  function paragraphInitial(code3) {
    ok(
      code3 !== codes.eof && !markdownLineEnding(code3),
      "expected anything other than a line ending or EOF"
    );
    effects.enter(types2.paragraph);
    return lineStart(code3);
  }
  function lineStart(code3) {
    const token2 = effects.enter(types2.chunkText, {
      contentType: constants.contentTypeText,
      previous: previous3
    });
    if (previous3) {
      previous3.next = token2;
    }
    previous3 = token2;
    return data(code3);
  }
  function data(code3) {
    if (code3 === codes.eof) {
      effects.exit(types2.chunkText);
      effects.exit(types2.paragraph);
      effects.consume(code3);
      return;
    }
    if (markdownLineEnding(code3)) {
      effects.consume(code3);
      effects.exit(types2.chunkText);
      return lineStart;
    }
    effects.consume(code3);
    return data;
  }
}

// node_modules/micromark/dev/lib/initialize/document.js
var document3 = { tokenize: initializeDocument };
var containerConstruct = { tokenize: tokenizeContainer };
function initializeDocument(effects) {
  const self2 = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start2;
  function start2(code3) {
    if (continued < stack.length) {
      const item2 = stack[continued];
      self2.containerState = item2[1];
      ok(
        item2[0].continuation,
        "expected `continuation` to be defined on container construct"
      );
      return effects.attempt(
        item2[0].continuation,
        documentContinue,
        checkNewContainers
      )(code3);
    }
    return checkNewContainers(code3);
  }
  function documentContinue(code3) {
    ok(
      self2.containerState,
      "expected `containerState` to be defined after continuation"
    );
    continued++;
    if (self2.containerState._closeFlow) {
      self2.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point3;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === types2.chunkFlow) {
          point3 = self2.events[indexBeforeFlow][1].end;
          break;
        }
      }
      ok(point3, "could not find previous flow chunk");
      exitContainers(continued);
      let index3 = indexBeforeExits;
      while (index3 < self2.events.length) {
        self2.events[index3][1].end = Object.assign({}, point3);
        index3++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index3;
      return checkNewContainers(code3);
    }
    return start2(code3);
  }
  function checkNewContainers(code3) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code3);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code3);
      }
      self2.interrupt = Boolean(
        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
      );
    }
    self2.containerState = {};
    return effects.check(
      containerConstruct,
      thereIsANewContainer,
      thereIsNoNewContainer
    )(code3);
  }
  function thereIsANewContainer(code3) {
    if (childFlow)
      closeFlow();
    exitContainers(continued);
    return documentContinued(code3);
  }
  function thereIsNoNewContainer(code3) {
    self2.parser.lazy[self2.now().line] = continued !== stack.length;
    lineStartOffset = self2.now().offset;
    return flowStart(code3);
  }
  function documentContinued(code3) {
    self2.containerState = {};
    return effects.attempt(
      containerConstruct,
      containerContinue,
      flowStart
    )(code3);
  }
  function containerContinue(code3) {
    ok(
      self2.currentConstruct,
      "expected `currentConstruct` to be defined on tokenizer"
    );
    ok(
      self2.containerState,
      "expected `containerState` to be defined on tokenizer"
    );
    continued++;
    stack.push([self2.currentConstruct, self2.containerState]);
    return documentContinued(code3);
  }
  function flowStart(code3) {
    if (code3 === codes.eof) {
      if (childFlow)
        closeFlow();
      exitContainers(0);
      effects.consume(code3);
      return;
    }
    childFlow = childFlow || self2.parser.flow(self2.now());
    effects.enter(types2.chunkFlow, {
      contentType: constants.contentTypeFlow,
      previous: childToken,
      _tokenizer: childFlow
    });
    return flowContinue(code3);
  }
  function flowContinue(code3) {
    if (code3 === codes.eof) {
      writeToChild(effects.exit(types2.chunkFlow), true);
      exitContainers(0);
      effects.consume(code3);
      return;
    }
    if (markdownLineEnding(code3)) {
      effects.consume(code3);
      writeToChild(effects.exit(types2.chunkFlow));
      continued = 0;
      self2.interrupt = void 0;
      return start2;
    }
    effects.consume(code3);
    return flowContinue;
  }
  function writeToChild(token2, eof) {
    ok(childFlow, "expected `childFlow` to be defined when continuing");
    const stream = self2.sliceStream(token2);
    if (eof)
      stream.push(null);
    token2.previous = childToken;
    if (childToken)
      childToken.next = token2;
    childToken = token2;
    childFlow.defineSkip(token2.start);
    childFlow.write(stream);
    if (self2.parser.lazy[token2.start.line]) {
      let index3 = childFlow.events.length;
      while (index3--) {
        if (
          // The token starts before the line ending…
          childFlow.events[index3][1].start.offset < lineStartOffset && // …and either is not ended yet…
          (!childFlow.events[index3][1].end || // …or ends after it.
          childFlow.events[index3][1].end.offset > lineStartOffset)
        ) {
          return;
        }
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen;
      let point3;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === types2.chunkFlow) {
          if (seen) {
            point3 = self2.events[indexBeforeFlow][1].end;
            break;
          }
          seen = true;
        }
      }
      ok(point3, "could not find previous flow chunk");
      exitContainers(continued);
      index3 = indexBeforeExits;
      while (index3 < self2.events.length) {
        self2.events[index3][1].end = Object.assign({}, point3);
        index3++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index3;
    }
  }
  function exitContainers(size3) {
    let index3 = stack.length;
    while (index3-- > size3) {
      const entry = stack[index3];
      self2.containerState = entry[1];
      ok(
        entry[0].exit,
        "expected `exit` to be defined on container construct"
      );
      entry[0].exit.call(self2, effects);
    }
    stack.length = size3;
  }
  function closeFlow() {
    ok(
      self2.containerState,
      "expected `containerState` to be defined when closing flow"
    );
    ok(childFlow, "expected `childFlow` to be defined when closing it");
    childFlow.write([codes.eof]);
    childToken = void 0;
    childFlow = void 0;
    self2.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok3, nok) {
  ok(
    this.parser.constructs.disable.null,
    "expected `disable.null` to be populated"
  );
  return factorySpace(
    effects,
    effects.attempt(this.parser.constructs.document, ok3, nok),
    types2.linePrefix,
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
  );
}

// node_modules/micromark-util-classify-character/dev/index.js
function classifyCharacter(code3) {
  if (code3 === codes.eof || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
    return constants.characterGroupWhitespace;
  }
  if (unicodePunctuation(code3)) {
    return constants.characterGroupPunctuation;
  }
}

// node_modules/micromark-util-resolve-all/index.js
function resolveAll(constructs2, events2, context) {
  const called = [];
  let index3 = -1;
  while (++index3 < constructs2.length) {
    const resolve3 = constructs2[index3].resolveAll;
    if (resolve3 && !called.includes(resolve3)) {
      events2 = resolve3(events2, context);
      called.push(resolve3);
    }
  }
  return events2;
}

// node_modules/micromark-core-commonmark/dev/lib/attention.js
var attention = {
  name: "attention",
  tokenize: tokenizeAttention,
  resolveAll: resolveAllAttention
};
function resolveAllAttention(events2, context) {
  let index3 = -1;
  let open;
  let group;
  let text7;
  let openingSequence;
  let closingSequence;
  let use;
  let nextEvents;
  let offset;
  while (++index3 < events2.length) {
    if (events2[index3][0] === "enter" && events2[index3][1].type === "attentionSequence" && events2[index3][1]._close) {
      open = index3;
      while (open--) {
        if (events2[open][0] === "exit" && events2[open][1].type === "attentionSequence" && events2[open][1]._open && // If the markers are the same:
        context.sliceSerialize(events2[open][1]).charCodeAt(0) === context.sliceSerialize(events2[index3][1]).charCodeAt(0)) {
          if ((events2[open][1]._close || events2[index3][1]._open) && (events2[index3][1].end.offset - events2[index3][1].start.offset) % 3 && !((events2[open][1].end.offset - events2[open][1].start.offset + events2[index3][1].end.offset - events2[index3][1].start.offset) % 3)) {
            continue;
          }
          use = events2[open][1].end.offset - events2[open][1].start.offset > 1 && events2[index3][1].end.offset - events2[index3][1].start.offset > 1 ? 2 : 1;
          const start2 = Object.assign({}, events2[open][1].end);
          const end = Object.assign({}, events2[index3][1].start);
          movePoint(start2, -use);
          movePoint(end, use);
          openingSequence = {
            type: use > 1 ? types2.strongSequence : types2.emphasisSequence,
            start: start2,
            end: Object.assign({}, events2[open][1].end)
          };
          closingSequence = {
            type: use > 1 ? types2.strongSequence : types2.emphasisSequence,
            start: Object.assign({}, events2[index3][1].start),
            end
          };
          text7 = {
            type: use > 1 ? types2.strongText : types2.emphasisText,
            start: Object.assign({}, events2[open][1].end),
            end: Object.assign({}, events2[index3][1].start)
          };
          group = {
            type: use > 1 ? types2.strong : types2.emphasis,
            start: Object.assign({}, openingSequence.start),
            end: Object.assign({}, closingSequence.end)
          };
          events2[open][1].end = Object.assign({}, openingSequence.start);
          events2[index3][1].start = Object.assign({}, closingSequence.end);
          nextEvents = [];
          if (events2[open][1].end.offset - events2[open][1].start.offset) {
            nextEvents = push2(nextEvents, [
              ["enter", events2[open][1], context],
              ["exit", events2[open][1], context]
            ]);
          }
          nextEvents = push2(nextEvents, [
            ["enter", group, context],
            ["enter", openingSequence, context],
            ["exit", openingSequence, context],
            ["enter", text7, context]
          ]);
          ok(
            context.parser.constructs.insideSpan.null,
            "expected `insideSpan` to be populated"
          );
          nextEvents = push2(
            nextEvents,
            resolveAll(
              context.parser.constructs.insideSpan.null,
              events2.slice(open + 1, index3),
              context
            )
          );
          nextEvents = push2(nextEvents, [
            ["exit", text7, context],
            ["enter", closingSequence, context],
            ["exit", closingSequence, context],
            ["exit", group, context]
          ]);
          if (events2[index3][1].end.offset - events2[index3][1].start.offset) {
            offset = 2;
            nextEvents = push2(nextEvents, [
              ["enter", events2[index3][1], context],
              ["exit", events2[index3][1], context]
            ]);
          } else {
            offset = 0;
          }
          splice(events2, open - 1, index3 - open + 3, nextEvents);
          index3 = open + nextEvents.length - offset - 2;
          break;
        }
      }
    }
  }
  index3 = -1;
  while (++index3 < events2.length) {
    if (events2[index3][1].type === "attentionSequence") {
      events2[index3][1].type = "data";
    }
  }
  return events2;
}
function tokenizeAttention(effects, ok3) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous3 = this.previous;
  const before = classifyCharacter(previous3);
  let marker;
  return start2;
  function start2(code3) {
    ok(
      code3 === codes.asterisk || code3 === codes.underscore,
      "expected asterisk or underscore"
    );
    marker = code3;
    effects.enter("attentionSequence");
    return inside(code3);
  }
  function inside(code3) {
    if (code3 === marker) {
      effects.consume(code3);
      return inside;
    }
    const token2 = effects.exit("attentionSequence");
    const after = classifyCharacter(code3);
    ok(attentionMarkers2, "expected `attentionMarkers` to be populated");
    const open = !after || after === constants.characterGroupPunctuation && before || attentionMarkers2.includes(code3);
    const close = !before || before === constants.characterGroupPunctuation && after || attentionMarkers2.includes(previous3);
    token2._open = Boolean(
      marker === codes.asterisk ? open : open && (before || !close)
    );
    token2._close = Boolean(
      marker === codes.asterisk ? close : close && (after || !open)
    );
    return ok3(code3);
  }
}
function movePoint(point3, offset) {
  point3.column += offset;
  point3.offset += offset;
  point3._bufferIndex += offset;
}

// node_modules/micromark-core-commonmark/dev/lib/autolink.js
var autolink = { name: "autolink", tokenize: tokenizeAutolink };
function tokenizeAutolink(effects, ok3, nok) {
  let size3 = 0;
  return start2;
  function start2(code3) {
    ok(code3 === codes.lessThan, "expected `<`");
    effects.enter(types2.autolink);
    effects.enter(types2.autolinkMarker);
    effects.consume(code3);
    effects.exit(types2.autolinkMarker);
    effects.enter(types2.autolinkProtocol);
    return open;
  }
  function open(code3) {
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      return schemeOrEmailAtext;
    }
    return emailAtext(code3);
  }
  function schemeOrEmailAtext(code3) {
    if (code3 === codes.plusSign || code3 === codes.dash || code3 === codes.dot || asciiAlphanumeric(code3)) {
      size3 = 1;
      return schemeInsideOrEmailAtext(code3);
    }
    return emailAtext(code3);
  }
  function schemeInsideOrEmailAtext(code3) {
    if (code3 === codes.colon) {
      effects.consume(code3);
      size3 = 0;
      return urlInside;
    }
    if ((code3 === codes.plusSign || code3 === codes.dash || code3 === codes.dot || asciiAlphanumeric(code3)) && size3++ < constants.autolinkSchemeSizeMax) {
      effects.consume(code3);
      return schemeInsideOrEmailAtext;
    }
    size3 = 0;
    return emailAtext(code3);
  }
  function urlInside(code3) {
    if (code3 === codes.greaterThan) {
      effects.exit(types2.autolinkProtocol);
      effects.enter(types2.autolinkMarker);
      effects.consume(code3);
      effects.exit(types2.autolinkMarker);
      effects.exit(types2.autolink);
      return ok3;
    }
    if (code3 === codes.eof || code3 === codes.space || code3 === codes.lessThan || asciiControl(code3)) {
      return nok(code3);
    }
    effects.consume(code3);
    return urlInside;
  }
  function emailAtext(code3) {
    if (code3 === codes.atSign) {
      effects.consume(code3);
      return emailAtSignOrDot;
    }
    if (asciiAtext(code3)) {
      effects.consume(code3);
      return emailAtext;
    }
    return nok(code3);
  }
  function emailAtSignOrDot(code3) {
    return asciiAlphanumeric(code3) ? emailLabel(code3) : nok(code3);
  }
  function emailLabel(code3) {
    if (code3 === codes.dot) {
      effects.consume(code3);
      size3 = 0;
      return emailAtSignOrDot;
    }
    if (code3 === codes.greaterThan) {
      effects.exit(types2.autolinkProtocol).type = types2.autolinkEmail;
      effects.enter(types2.autolinkMarker);
      effects.consume(code3);
      effects.exit(types2.autolinkMarker);
      effects.exit(types2.autolink);
      return ok3;
    }
    return emailValue(code3);
  }
  function emailValue(code3) {
    if ((code3 === codes.dash || asciiAlphanumeric(code3)) && size3++ < constants.autolinkDomainSizeMax) {
      const next2 = code3 === codes.dash ? emailValue : emailLabel;
      effects.consume(code3);
      return next2;
    }
    return nok(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/blank-line.js
var blankLine = { tokenize: tokenizeBlankLine, partial: true };
function tokenizeBlankLine(effects, ok3, nok) {
  return start2;
  function start2(code3) {
    return markdownSpace(code3) ? factorySpace(effects, after, types2.linePrefix)(code3) : after(code3);
  }
  function after(code3) {
    return code3 === codes.eof || markdownLineEnding(code3) ? ok3(code3) : nok(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/block-quote.js
var blockQuote = {
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart,
  continuation: { tokenize: tokenizeBlockQuoteContinuation },
  exit
};
function tokenizeBlockQuoteStart(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code3) {
    if (code3 === codes.greaterThan) {
      const state = self2.containerState;
      ok(state, "expected `containerState` to be defined in container");
      if (!state.open) {
        effects.enter(types2.blockQuote, { _container: true });
        state.open = true;
      }
      effects.enter(types2.blockQuotePrefix);
      effects.enter(types2.blockQuoteMarker);
      effects.consume(code3);
      effects.exit(types2.blockQuoteMarker);
      return after;
    }
    return nok(code3);
  }
  function after(code3) {
    if (markdownSpace(code3)) {
      effects.enter(types2.blockQuotePrefixWhitespace);
      effects.consume(code3);
      effects.exit(types2.blockQuotePrefixWhitespace);
      effects.exit(types2.blockQuotePrefix);
      return ok3;
    }
    effects.exit(types2.blockQuotePrefix);
    return ok3(code3);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok3, nok) {
  const self2 = this;
  return contStart;
  function contStart(code3) {
    if (markdownSpace(code3)) {
      ok(
        self2.parser.constructs.disable.null,
        "expected `disable.null` to be populated"
      );
      return factorySpace(
        effects,
        contBefore,
        types2.linePrefix,
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
      )(code3);
    }
    return contBefore(code3);
  }
  function contBefore(code3) {
    return effects.attempt(blockQuote, ok3, nok)(code3);
  }
}
function exit(effects) {
  effects.exit(types2.blockQuote);
}

// node_modules/micromark-core-commonmark/dev/lib/character-escape.js
var characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok3, nok) {
  return start2;
  function start2(code3) {
    ok(code3 === codes.backslash, "expected `\\`");
    effects.enter(types2.characterEscape);
    effects.enter(types2.escapeMarker);
    effects.consume(code3);
    effects.exit(types2.escapeMarker);
    return inside;
  }
  function inside(code3) {
    if (asciiPunctuation(code3)) {
      effects.enter(types2.characterEscapeValue);
      effects.consume(code3);
      effects.exit(types2.characterEscapeValue);
      effects.exit(types2.characterEscape);
      return ok3;
    }
    return nok(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/character-reference.js
var characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok3, nok) {
  const self2 = this;
  let size3 = 0;
  let max4;
  let test;
  return start2;
  function start2(code3) {
    ok(code3 === codes.ampersand, "expected `&`");
    effects.enter(types2.characterReference);
    effects.enter(types2.characterReferenceMarker);
    effects.consume(code3);
    effects.exit(types2.characterReferenceMarker);
    return open;
  }
  function open(code3) {
    if (code3 === codes.numberSign) {
      effects.enter(types2.characterReferenceMarkerNumeric);
      effects.consume(code3);
      effects.exit(types2.characterReferenceMarkerNumeric);
      return numeric;
    }
    effects.enter(types2.characterReferenceValue);
    max4 = constants.characterReferenceNamedSizeMax;
    test = asciiAlphanumeric;
    return value2(code3);
  }
  function numeric(code3) {
    if (code3 === codes.uppercaseX || code3 === codes.lowercaseX) {
      effects.enter(types2.characterReferenceMarkerHexadecimal);
      effects.consume(code3);
      effects.exit(types2.characterReferenceMarkerHexadecimal);
      effects.enter(types2.characterReferenceValue);
      max4 = constants.characterReferenceHexadecimalSizeMax;
      test = asciiHexDigit;
      return value2;
    }
    effects.enter(types2.characterReferenceValue);
    max4 = constants.characterReferenceDecimalSizeMax;
    test = asciiDigit;
    return value2(code3);
  }
  function value2(code3) {
    if (code3 === codes.semicolon && size3) {
      const token2 = effects.exit(types2.characterReferenceValue);
      if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token2))) {
        return nok(code3);
      }
      effects.enter(types2.characterReferenceMarker);
      effects.consume(code3);
      effects.exit(types2.characterReferenceMarker);
      effects.exit(types2.characterReference);
      return ok3;
    }
    if (test(code3) && size3++ < max4) {
      effects.consume(code3);
      return value2;
    }
    return nok(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/code-fenced.js
var nonLazyContinuation = {
  tokenize: tokenizeNonLazyContinuation,
  partial: true
};
var codeFenced = {
  name: "codeFenced",
  tokenize: tokenizeCodeFenced,
  concrete: true
};
function tokenizeCodeFenced(effects, ok3, nok) {
  const self2 = this;
  const closeStart = { tokenize: tokenizeCloseStart, partial: true };
  let initialPrefix = 0;
  let sizeOpen = 0;
  let marker;
  return start2;
  function start2(code3) {
    return beforeSequenceOpen(code3);
  }
  function beforeSequenceOpen(code3) {
    ok(
      code3 === codes.graveAccent || code3 === codes.tilde,
      "expected `` ` `` or `~`"
    );
    const tail = self2.events[self2.events.length - 1];
    initialPrefix = tail && tail[1].type === types2.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;
    marker = code3;
    effects.enter(types2.codeFenced);
    effects.enter(types2.codeFencedFence);
    effects.enter(types2.codeFencedFenceSequence);
    return sequenceOpen(code3);
  }
  function sequenceOpen(code3) {
    if (code3 === marker) {
      sizeOpen++;
      effects.consume(code3);
      return sequenceOpen;
    }
    if (sizeOpen < constants.codeFencedSequenceSizeMin) {
      return nok(code3);
    }
    effects.exit(types2.codeFencedFenceSequence);
    return markdownSpace(code3) ? factorySpace(effects, infoBefore, types2.whitespace)(code3) : infoBefore(code3);
  }
  function infoBefore(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types2.codeFencedFence);
      return self2.interrupt ? ok3(code3) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code3);
    }
    effects.enter(types2.codeFencedFenceInfo);
    effects.enter(types2.chunkString, { contentType: constants.contentTypeString });
    return info(code3);
  }
  function info(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types2.chunkString);
      effects.exit(types2.codeFencedFenceInfo);
      return infoBefore(code3);
    }
    if (markdownSpace(code3)) {
      effects.exit(types2.chunkString);
      effects.exit(types2.codeFencedFenceInfo);
      return factorySpace(effects, metaBefore, types2.whitespace)(code3);
    }
    if (code3 === codes.graveAccent && code3 === marker) {
      return nok(code3);
    }
    effects.consume(code3);
    return info;
  }
  function metaBefore(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      return infoBefore(code3);
    }
    effects.enter(types2.codeFencedFenceMeta);
    effects.enter(types2.chunkString, { contentType: constants.contentTypeString });
    return meta(code3);
  }
  function meta(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types2.chunkString);
      effects.exit(types2.codeFencedFenceMeta);
      return infoBefore(code3);
    }
    if (code3 === codes.graveAccent && code3 === marker) {
      return nok(code3);
    }
    effects.consume(code3);
    return meta;
  }
  function atNonLazyBreak(code3) {
    ok(markdownLineEnding(code3), "expected eol");
    return effects.attempt(closeStart, after, contentBefore)(code3);
  }
  function contentBefore(code3) {
    ok(markdownLineEnding(code3), "expected eol");
    effects.enter(types2.lineEnding);
    effects.consume(code3);
    effects.exit(types2.lineEnding);
    return contentStart;
  }
  function contentStart(code3) {
    return initialPrefix > 0 && markdownSpace(code3) ? factorySpace(
      effects,
      beforeContentChunk,
      types2.linePrefix,
      initialPrefix + 1
    )(code3) : beforeContentChunk(code3);
  }
  function beforeContentChunk(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code3);
    }
    effects.enter(types2.codeFlowValue);
    return contentChunk(code3);
  }
  function contentChunk(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types2.codeFlowValue);
      return beforeContentChunk(code3);
    }
    effects.consume(code3);
    return contentChunk;
  }
  function after(code3) {
    effects.exit(types2.codeFenced);
    return ok3(code3);
  }
  function tokenizeCloseStart(effects2, ok4, nok2) {
    let size3 = 0;
    return startBefore;
    function startBefore(code3) {
      ok(markdownLineEnding(code3), "expected eol");
      effects2.enter(types2.lineEnding);
      effects2.consume(code3);
      effects2.exit(types2.lineEnding);
      return start3;
    }
    function start3(code3) {
      ok(
        self2.parser.constructs.disable.null,
        "expected `disable.null` to be populated"
      );
      effects2.enter(types2.codeFencedFence);
      return markdownSpace(code3) ? factorySpace(
        effects2,
        beforeSequenceClose,
        types2.linePrefix,
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
      )(code3) : beforeSequenceClose(code3);
    }
    function beforeSequenceClose(code3) {
      if (code3 === marker) {
        effects2.enter(types2.codeFencedFenceSequence);
        return sequenceClose(code3);
      }
      return nok2(code3);
    }
    function sequenceClose(code3) {
      if (code3 === marker) {
        size3++;
        effects2.consume(code3);
        return sequenceClose;
      }
      if (size3 >= sizeOpen) {
        effects2.exit(types2.codeFencedFenceSequence);
        return markdownSpace(code3) ? factorySpace(effects2, sequenceCloseAfter, types2.whitespace)(code3) : sequenceCloseAfter(code3);
      }
      return nok2(code3);
    }
    function sequenceCloseAfter(code3) {
      if (code3 === codes.eof || markdownLineEnding(code3)) {
        effects2.exit(types2.codeFencedFence);
        return ok4(code3);
      }
      return nok2(code3);
    }
  }
}
function tokenizeNonLazyContinuation(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code3) {
    if (code3 === codes.eof) {
      return nok(code3);
    }
    ok(markdownLineEnding(code3), "expected eol");
    effects.enter(types2.lineEnding);
    effects.consume(code3);
    effects.exit(types2.lineEnding);
    return lineStart;
  }
  function lineStart(code3) {
    return self2.parser.lazy[self2.now().line] ? nok(code3) : ok3(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/code-indented.js
var codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
var furtherStart = { tokenize: tokenizeFurtherStart, partial: true };
function tokenizeCodeIndented(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code3) {
    ok(markdownSpace(code3));
    effects.enter(types2.codeIndented);
    return factorySpace(
      effects,
      afterPrefix,
      types2.linePrefix,
      constants.tabSize + 1
    )(code3);
  }
  function afterPrefix(code3) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types2.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize ? atBreak(code3) : nok(code3);
  }
  function atBreak(code3) {
    if (code3 === codes.eof) {
      return after(code3);
    }
    if (markdownLineEnding(code3)) {
      return effects.attempt(furtherStart, atBreak, after)(code3);
    }
    effects.enter(types2.codeFlowValue);
    return inside(code3);
  }
  function inside(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types2.codeFlowValue);
      return atBreak(code3);
    }
    effects.consume(code3);
    return inside;
  }
  function after(code3) {
    effects.exit(types2.codeIndented);
    return ok3(code3);
  }
}
function tokenizeFurtherStart(effects, ok3, nok) {
  const self2 = this;
  return furtherStart2;
  function furtherStart2(code3) {
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code3);
    }
    if (markdownLineEnding(code3)) {
      effects.enter(types2.lineEnding);
      effects.consume(code3);
      effects.exit(types2.lineEnding);
      return furtherStart2;
    }
    return factorySpace(
      effects,
      afterPrefix,
      types2.linePrefix,
      constants.tabSize + 1
    )(code3);
  }
  function afterPrefix(code3) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types2.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize ? ok3(code3) : markdownLineEnding(code3) ? furtherStart2(code3) : nok(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/code-text.js
var codeText = {
  name: "codeText",
  tokenize: tokenizeCodeText,
  resolve: resolveCodeText,
  previous
};
function resolveCodeText(events2) {
  let tailExitIndex = events2.length - 4;
  let headEnterIndex = 3;
  let index3;
  let enter;
  if ((events2[headEnterIndex][1].type === types2.lineEnding || events2[headEnterIndex][1].type === "space") && (events2[tailExitIndex][1].type === types2.lineEnding || events2[tailExitIndex][1].type === "space")) {
    index3 = headEnterIndex;
    while (++index3 < tailExitIndex) {
      if (events2[index3][1].type === types2.codeTextData) {
        events2[headEnterIndex][1].type = types2.codeTextPadding;
        events2[tailExitIndex][1].type = types2.codeTextPadding;
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index3 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index3 <= tailExitIndex) {
    if (enter === void 0) {
      if (index3 !== tailExitIndex && events2[index3][1].type !== types2.lineEnding) {
        enter = index3;
      }
    } else if (index3 === tailExitIndex || events2[index3][1].type === types2.lineEnding) {
      events2[enter][1].type = types2.codeTextData;
      if (index3 !== enter + 2) {
        events2[enter][1].end = events2[index3 - 1][1].end;
        events2.splice(enter + 2, index3 - enter - 2);
        tailExitIndex -= index3 - enter - 2;
        index3 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events2;
}
function previous(code3) {
  return code3 !== codes.graveAccent || this.events[this.events.length - 1][1].type === types2.characterEscape;
}
function tokenizeCodeText(effects, ok3, nok) {
  const self2 = this;
  let sizeOpen = 0;
  let size3;
  let token2;
  return start2;
  function start2(code3) {
    ok(code3 === codes.graveAccent, "expected `` ` ``");
    ok(previous.call(self2, self2.previous), "expected correct previous");
    effects.enter(types2.codeText);
    effects.enter(types2.codeTextSequence);
    return sequenceOpen(code3);
  }
  function sequenceOpen(code3) {
    if (code3 === codes.graveAccent) {
      effects.consume(code3);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit(types2.codeTextSequence);
    return between(code3);
  }
  function between(code3) {
    if (code3 === codes.eof) {
      return nok(code3);
    }
    if (code3 === codes.space) {
      effects.enter("space");
      effects.consume(code3);
      effects.exit("space");
      return between;
    }
    if (code3 === codes.graveAccent) {
      token2 = effects.enter(types2.codeTextSequence);
      size3 = 0;
      return sequenceClose(code3);
    }
    if (markdownLineEnding(code3)) {
      effects.enter(types2.lineEnding);
      effects.consume(code3);
      effects.exit(types2.lineEnding);
      return between;
    }
    effects.enter(types2.codeTextData);
    return data(code3);
  }
  function data(code3) {
    if (code3 === codes.eof || code3 === codes.space || code3 === codes.graveAccent || markdownLineEnding(code3)) {
      effects.exit(types2.codeTextData);
      return between(code3);
    }
    effects.consume(code3);
    return data;
  }
  function sequenceClose(code3) {
    if (code3 === codes.graveAccent) {
      effects.consume(code3);
      size3++;
      return sequenceClose;
    }
    if (size3 === sizeOpen) {
      effects.exit(types2.codeTextSequence);
      effects.exit(types2.codeText);
      return ok3(code3);
    }
    token2.type = types2.codeTextData;
    return data(code3);
  }
}

// node_modules/micromark-util-subtokenize/dev/index.js
function subtokenize(events2) {
  const jumps = {};
  let index3 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  while (++index3 < events2.length) {
    while (index3 in jumps) {
      index3 = jumps[index3];
    }
    event = events2[index3];
    if (index3 && event[1].type === types2.chunkFlow && events2[index3 - 1][1].type === types2.listItemPrefix) {
      ok(event[1]._tokenizer, "expected `_tokenizer` on subtokens");
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === types2.lineEndingBlank) {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === types2.content) {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === types2.content) {
            break;
          }
          if (subevents[otherIndex][1].type === types2.chunkText) {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events2, index3));
        index3 = jumps[index3];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index3;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events2[otherIndex];
        if (otherEvent[1].type === types2.lineEnding || otherEvent[1].type === types2.lineEndingBlank) {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events2[lineIndex][1].type = types2.lineEndingBlank;
            }
            otherEvent[1].type = types2.lineEnding;
            lineIndex = otherIndex;
          }
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = Object.assign({}, events2[lineIndex][1].start);
        parameters = events2.slice(lineIndex, index3);
        parameters.unshift(event);
        splice(events2, lineIndex, index3 - lineIndex + 1, parameters);
      }
    }
  }
  return !more;
}
function subcontent(events2, eventIndex) {
  const token2 = events2[eventIndex][1];
  const context = events2[eventIndex][2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  ok(token2.contentType, "expected `contentType` on subtokens");
  const tokenizer2 = token2._tokenizer || context.parser[token2.contentType](token2.start);
  const childEvents = tokenizer2.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous3;
  let index3 = -1;
  let current = token2;
  let adjust = 0;
  let start2 = 0;
  const breaks = [start2];
  while (current) {
    while (events2[++startPosition][1] !== current) {
    }
    ok(
      !previous3 || current.previous === previous3,
      "expected previous to match"
    );
    ok(!previous3 || previous3.next === current, "expected next to match");
    startPositions.push(startPosition);
    if (!current._tokenizer) {
      stream = context.sliceStream(current);
      if (!current.next) {
        stream.push(codes.eof);
      }
      if (previous3) {
        tokenizer2.defineSkip(current.start);
      }
      if (current._isInFirstContentOfListItem) {
        tokenizer2._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer2.write(stream);
      if (current._isInFirstContentOfListItem) {
        tokenizer2._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous3 = current;
    current = current.next;
  }
  current = token2;
  while (++index3 < childEvents.length) {
    if (
      // Find a void token that includes a break.
      childEvents[index3][0] === "exit" && childEvents[index3 - 1][0] === "enter" && childEvents[index3][1].type === childEvents[index3 - 1][1].type && childEvents[index3][1].start.line !== childEvents[index3][1].end.line
    ) {
      ok(current, "expected a current token");
      start2 = index3 + 1;
      breaks.push(start2);
      current._tokenizer = void 0;
      current.previous = void 0;
      current = current.next;
    }
  }
  tokenizer2.events = [];
  if (current) {
    current._tokenizer = void 0;
    current.previous = void 0;
    ok(!current.next, "expected no next token");
  } else {
    breaks.pop();
  }
  index3 = breaks.length;
  while (index3--) {
    const slice2 = childEvents.slice(breaks[index3], breaks[index3 + 1]);
    const start3 = startPositions.pop();
    ok(start3 !== void 0, "expected a start position when splicing");
    jumps.unshift([start3, start3 + slice2.length - 1]);
    splice(events2, start3, 2, slice2);
  }
  index3 = -1;
  while (++index3 < jumps.length) {
    gaps[adjust + jumps[index3][0]] = adjust + jumps[index3][1];
    adjust += jumps[index3][1] - jumps[index3][0] - 1;
  }
  return gaps;
}

// node_modules/micromark-core-commonmark/dev/lib/content.js
var content2 = { tokenize: tokenizeContent, resolve: resolveContent };
var continuationConstruct = { tokenize: tokenizeContinuation, partial: true };
function resolveContent(events2) {
  subtokenize(events2);
  return events2;
}
function tokenizeContent(effects, ok3) {
  let previous3;
  return chunkStart;
  function chunkStart(code3) {
    ok(
      code3 !== codes.eof && !markdownLineEnding(code3),
      "expected no eof or eol"
    );
    effects.enter(types2.content);
    previous3 = effects.enter(types2.chunkContent, {
      contentType: constants.contentTypeContent
    });
    return chunkInside(code3);
  }
  function chunkInside(code3) {
    if (code3 === codes.eof) {
      return contentEnd(code3);
    }
    if (markdownLineEnding(code3)) {
      return effects.check(
        continuationConstruct,
        contentContinue,
        contentEnd
      )(code3);
    }
    effects.consume(code3);
    return chunkInside;
  }
  function contentEnd(code3) {
    effects.exit(types2.chunkContent);
    effects.exit(types2.content);
    return ok3(code3);
  }
  function contentContinue(code3) {
    ok(markdownLineEnding(code3), "expected eol");
    effects.consume(code3);
    effects.exit(types2.chunkContent);
    ok(previous3, "expected previous token");
    previous3.next = effects.enter(types2.chunkContent, {
      contentType: constants.contentTypeContent,
      previous: previous3
    });
    previous3 = previous3.next;
    return chunkInside;
  }
}
function tokenizeContinuation(effects, ok3, nok) {
  const self2 = this;
  return startLookahead;
  function startLookahead(code3) {
    ok(markdownLineEnding(code3), "expected a line ending");
    effects.exit(types2.chunkContent);
    effects.enter(types2.lineEnding);
    effects.consume(code3);
    effects.exit(types2.lineEnding);
    return factorySpace(effects, prefixed, types2.linePrefix);
  }
  function prefixed(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      return nok(code3);
    }
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    const tail = self2.events[self2.events.length - 1];
    if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === types2.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize) {
      return ok3(code3);
    }
    return effects.interrupt(self2.parser.constructs.flow, nok, ok3)(code3);
  }
}

// node_modules/micromark-factory-destination/dev/index.js
function factoryDestination(effects, ok3, nok, type2, literalType, literalMarkerType, rawType, stringType, max4) {
  const limit = max4 || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start2;
  function start2(code3) {
    if (code3 === codes.lessThan) {
      effects.enter(type2);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code3);
      effects.exit(literalMarkerType);
      return enclosedBefore;
    }
    if (code3 === codes.eof || code3 === codes.space || code3 === codes.rightParenthesis || asciiControl(code3)) {
      return nok(code3);
    }
    effects.enter(type2);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter(types2.chunkString, { contentType: constants.contentTypeString });
    return raw(code3);
  }
  function enclosedBefore(code3) {
    if (code3 === codes.greaterThan) {
      effects.enter(literalMarkerType);
      effects.consume(code3);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type2);
      return ok3;
    }
    effects.enter(stringType);
    effects.enter(types2.chunkString, { contentType: constants.contentTypeString });
    return enclosed(code3);
  }
  function enclosed(code3) {
    if (code3 === codes.greaterThan) {
      effects.exit(types2.chunkString);
      effects.exit(stringType);
      return enclosedBefore(code3);
    }
    if (code3 === codes.eof || code3 === codes.lessThan || markdownLineEnding(code3)) {
      return nok(code3);
    }
    effects.consume(code3);
    return code3 === codes.backslash ? enclosedEscape : enclosed;
  }
  function enclosedEscape(code3) {
    if (code3 === codes.lessThan || code3 === codes.greaterThan || code3 === codes.backslash) {
      effects.consume(code3);
      return enclosed;
    }
    return enclosed(code3);
  }
  function raw(code3) {
    if (!balance && (code3 === codes.eof || code3 === codes.rightParenthesis || markdownLineEndingOrSpace(code3))) {
      effects.exit(types2.chunkString);
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type2);
      return ok3(code3);
    }
    if (balance < limit && code3 === codes.leftParenthesis) {
      effects.consume(code3);
      balance++;
      return raw;
    }
    if (code3 === codes.rightParenthesis) {
      effects.consume(code3);
      balance--;
      return raw;
    }
    if (code3 === codes.eof || code3 === codes.space || code3 === codes.leftParenthesis || asciiControl(code3)) {
      return nok(code3);
    }
    effects.consume(code3);
    return code3 === codes.backslash ? rawEscape : raw;
  }
  function rawEscape(code3) {
    if (code3 === codes.leftParenthesis || code3 === codes.rightParenthesis || code3 === codes.backslash) {
      effects.consume(code3);
      return raw;
    }
    return raw(code3);
  }
}

// node_modules/micromark-factory-label/dev/index.js
function factoryLabel(effects, ok3, nok, type2, markerType, stringType) {
  const self2 = this;
  let size3 = 0;
  let seen;
  return start2;
  function start2(code3) {
    ok(code3 === codes.leftSquareBracket, "expected `[`");
    effects.enter(type2);
    effects.enter(markerType);
    effects.consume(code3);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code3) {
    if (size3 > constants.linkReferenceSizeMax || code3 === codes.eof || code3 === codes.leftSquareBracket || code3 === codes.rightSquareBracket && !seen || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    code3 === codes.caret && !size3 && "_hiddenFootnoteSupport" in self2.parser.constructs) {
      return nok(code3);
    }
    if (code3 === codes.rightSquareBracket) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code3);
      effects.exit(markerType);
      effects.exit(type2);
      return ok3;
    }
    if (markdownLineEnding(code3)) {
      effects.enter(types2.lineEnding);
      effects.consume(code3);
      effects.exit(types2.lineEnding);
      return atBreak;
    }
    effects.enter(types2.chunkString, { contentType: constants.contentTypeString });
    return labelInside(code3);
  }
  function labelInside(code3) {
    if (code3 === codes.eof || code3 === codes.leftSquareBracket || code3 === codes.rightSquareBracket || markdownLineEnding(code3) || size3++ > constants.linkReferenceSizeMax) {
      effects.exit(types2.chunkString);
      return atBreak(code3);
    }
    effects.consume(code3);
    if (!seen)
      seen = !markdownSpace(code3);
    return code3 === codes.backslash ? labelEscape : labelInside;
  }
  function labelEscape(code3) {
    if (code3 === codes.leftSquareBracket || code3 === codes.backslash || code3 === codes.rightSquareBracket) {
      effects.consume(code3);
      size3++;
      return labelInside;
    }
    return labelInside(code3);
  }
}

// node_modules/micromark-factory-title/dev/index.js
function factoryTitle(effects, ok3, nok, type2, markerType, stringType) {
  let marker;
  return start2;
  function start2(code3) {
    if (code3 === codes.quotationMark || code3 === codes.apostrophe || code3 === codes.leftParenthesis) {
      effects.enter(type2);
      effects.enter(markerType);
      effects.consume(code3);
      effects.exit(markerType);
      marker = code3 === codes.leftParenthesis ? codes.rightParenthesis : code3;
      return begin;
    }
    return nok(code3);
  }
  function begin(code3) {
    if (code3 === marker) {
      effects.enter(markerType);
      effects.consume(code3);
      effects.exit(markerType);
      effects.exit(type2);
      return ok3;
    }
    effects.enter(stringType);
    return atBreak(code3);
  }
  function atBreak(code3) {
    if (code3 === marker) {
      effects.exit(stringType);
      return begin(marker);
    }
    if (code3 === codes.eof) {
      return nok(code3);
    }
    if (markdownLineEnding(code3)) {
      effects.enter(types2.lineEnding);
      effects.consume(code3);
      effects.exit(types2.lineEnding);
      return factorySpace(effects, atBreak, types2.linePrefix);
    }
    effects.enter(types2.chunkString, { contentType: constants.contentTypeString });
    return inside(code3);
  }
  function inside(code3) {
    if (code3 === marker || code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types2.chunkString);
      return atBreak(code3);
    }
    effects.consume(code3);
    return code3 === codes.backslash ? escape3 : inside;
  }
  function escape3(code3) {
    if (code3 === marker || code3 === codes.backslash) {
      effects.consume(code3);
      return inside;
    }
    return inside(code3);
  }
}

// node_modules/micromark-factory-whitespace/dev/index.js
function factoryWhitespace(effects, ok3) {
  let seen;
  return start2;
  function start2(code3) {
    if (markdownLineEnding(code3)) {
      effects.enter(types2.lineEnding);
      effects.consume(code3);
      effects.exit(types2.lineEnding);
      seen = true;
      return start2;
    }
    if (markdownSpace(code3)) {
      return factorySpace(
        effects,
        start2,
        seen ? types2.linePrefix : types2.lineSuffix
      )(code3);
    }
    return ok3(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/definition.js
var definition = { name: "definition", tokenize: tokenizeDefinition };
var titleBefore = { tokenize: tokenizeTitleBefore, partial: true };
function tokenizeDefinition(effects, ok3, nok) {
  const self2 = this;
  let identifier2;
  return start2;
  function start2(code3) {
    effects.enter(types2.definition);
    return before(code3);
  }
  function before(code3) {
    ok(code3 === codes.leftSquareBracket, "expected `[`");
    return factoryLabel.call(
      self2,
      effects,
      labelAfter,
      // Note: we don’t need to reset the way `markdown-rs` does.
      nok,
      types2.definitionLabel,
      types2.definitionLabelMarker,
      types2.definitionLabelString
    )(code3);
  }
  function labelAfter(code3) {
    identifier2 = normalizeIdentifier(
      self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
    );
    if (code3 === codes.colon) {
      effects.enter(types2.definitionMarker);
      effects.consume(code3);
      effects.exit(types2.definitionMarker);
      return markerAfter;
    }
    return nok(code3);
  }
  function markerAfter(code3) {
    return markdownLineEndingOrSpace(code3) ? factoryWhitespace(effects, destinationBefore)(code3) : destinationBefore(code3);
  }
  function destinationBefore(code3) {
    return factoryDestination(
      effects,
      destinationAfter,
      // Note: we don’t need to reset the way `markdown-rs` does.
      nok,
      types2.definitionDestination,
      types2.definitionDestinationLiteral,
      types2.definitionDestinationLiteralMarker,
      types2.definitionDestinationRaw,
      types2.definitionDestinationString
    )(code3);
  }
  function destinationAfter(code3) {
    return effects.attempt(titleBefore, after, after)(code3);
  }
  function after(code3) {
    return markdownSpace(code3) ? factorySpace(effects, afterWhitespace, types2.whitespace)(code3) : afterWhitespace(code3);
  }
  function afterWhitespace(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types2.definition);
      self2.parser.defined.push(identifier2);
      return ok3(code3);
    }
    return nok(code3);
  }
}
function tokenizeTitleBefore(effects, ok3, nok) {
  return titleBefore2;
  function titleBefore2(code3) {
    return markdownLineEndingOrSpace(code3) ? factoryWhitespace(effects, beforeMarker)(code3) : nok(code3);
  }
  function beforeMarker(code3) {
    return factoryTitle(
      effects,
      titleAfter,
      nok,
      types2.definitionTitle,
      types2.definitionTitleMarker,
      types2.definitionTitleString
    )(code3);
  }
  function titleAfter(code3) {
    return markdownSpace(code3) ? factorySpace(
      effects,
      titleAfterOptionalWhitespace,
      types2.whitespace
    )(code3) : titleAfterOptionalWhitespace(code3);
  }
  function titleAfterOptionalWhitespace(code3) {
    return code3 === codes.eof || markdownLineEnding(code3) ? ok3(code3) : nok(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/hard-break-escape.js
var hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok3, nok) {
  return start2;
  function start2(code3) {
    ok(code3 === codes.backslash, "expected `\\`");
    effects.enter(types2.hardBreakEscape);
    effects.consume(code3);
    return after;
  }
  function after(code3) {
    if (markdownLineEnding(code3)) {
      effects.exit(types2.hardBreakEscape);
      return ok3(code3);
    }
    return nok(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/heading-atx.js
var headingAtx = {
  name: "headingAtx",
  tokenize: tokenizeHeadingAtx,
  resolve: resolveHeadingAtx
};
function resolveHeadingAtx(events2, context) {
  let contentEnd = events2.length - 2;
  let contentStart = 3;
  let content3;
  let text7;
  if (events2[contentStart][1].type === types2.whitespace) {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events2[contentEnd][1].type === types2.whitespace) {
    contentEnd -= 2;
  }
  if (events2[contentEnd][1].type === types2.atxHeadingSequence && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events2[contentEnd - 2][1].type === types2.whitespace)) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content3 = {
      type: types2.atxHeadingText,
      start: events2[contentStart][1].start,
      end: events2[contentEnd][1].end
    };
    text7 = {
      type: types2.chunkText,
      start: events2[contentStart][1].start,
      end: events2[contentEnd][1].end,
      contentType: constants.contentTypeText
    };
    splice(events2, contentStart, contentEnd - contentStart + 1, [
      ["enter", content3, context],
      ["enter", text7, context],
      ["exit", text7, context],
      ["exit", content3, context]
    ]);
  }
  return events2;
}
function tokenizeHeadingAtx(effects, ok3, nok) {
  let size3 = 0;
  return start2;
  function start2(code3) {
    effects.enter(types2.atxHeading);
    return before(code3);
  }
  function before(code3) {
    ok(code3 === codes.numberSign, "expected `#`");
    effects.enter(types2.atxHeadingSequence);
    return sequenceOpen(code3);
  }
  function sequenceOpen(code3) {
    if (code3 === codes.numberSign && size3++ < constants.atxHeadingOpeningFenceSizeMax) {
      effects.consume(code3);
      return sequenceOpen;
    }
    if (code3 === codes.eof || markdownLineEndingOrSpace(code3)) {
      effects.exit(types2.atxHeadingSequence);
      return atBreak(code3);
    }
    return nok(code3);
  }
  function atBreak(code3) {
    if (code3 === codes.numberSign) {
      effects.enter(types2.atxHeadingSequence);
      return sequenceFurther(code3);
    }
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types2.atxHeading);
      return ok3(code3);
    }
    if (markdownSpace(code3)) {
      return factorySpace(effects, atBreak, types2.whitespace)(code3);
    }
    effects.enter(types2.atxHeadingText);
    return data(code3);
  }
  function sequenceFurther(code3) {
    if (code3 === codes.numberSign) {
      effects.consume(code3);
      return sequenceFurther;
    }
    effects.exit(types2.atxHeadingSequence);
    return atBreak(code3);
  }
  function data(code3) {
    if (code3 === codes.eof || code3 === codes.numberSign || markdownLineEndingOrSpace(code3)) {
      effects.exit(types2.atxHeadingText);
      return atBreak(code3);
    }
    effects.consume(code3);
    return data;
  }
}

// node_modules/micromark-util-html-tag-name/index.js
var htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var htmlRawNames = ["pre", "script", "style", "textarea"];

// node_modules/micromark-core-commonmark/dev/lib/html-flow.js
var htmlFlow = {
  name: "htmlFlow",
  tokenize: tokenizeHtmlFlow,
  resolveTo: resolveToHtmlFlow,
  concrete: true
};
var blankLineBefore = { tokenize: tokenizeBlankLineBefore, partial: true };
var nonLazyContinuationStart = {
  tokenize: tokenizeNonLazyContinuationStart,
  partial: true
};
function resolveToHtmlFlow(events2) {
  let index3 = events2.length;
  while (index3--) {
    if (events2[index3][0] === "enter" && events2[index3][1].type === types2.htmlFlow) {
      break;
    }
  }
  if (index3 > 1 && events2[index3 - 2][1].type === types2.linePrefix) {
    events2[index3][1].start = events2[index3 - 2][1].start;
    events2[index3 + 1][1].start = events2[index3 - 2][1].start;
    events2.splice(index3 - 2, 2);
  }
  return events2;
}
function tokenizeHtmlFlow(effects, ok3, nok) {
  const self2 = this;
  let marker;
  let closingTag;
  let buffer;
  let index3;
  let markerB;
  return start2;
  function start2(code3) {
    return before(code3);
  }
  function before(code3) {
    ok(code3 === codes.lessThan, "expected `<`");
    effects.enter(types2.htmlFlow);
    effects.enter(types2.htmlFlowData);
    effects.consume(code3);
    return open;
  }
  function open(code3) {
    if (code3 === codes.exclamationMark) {
      effects.consume(code3);
      return declarationOpen;
    }
    if (code3 === codes.slash) {
      effects.consume(code3);
      closingTag = true;
      return tagCloseStart;
    }
    if (code3 === codes.questionMark) {
      effects.consume(code3);
      marker = constants.htmlInstruction;
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      buffer = String.fromCharCode(code3);
      return tagName3;
    }
    return nok(code3);
  }
  function declarationOpen(code3) {
    if (code3 === codes.dash) {
      effects.consume(code3);
      marker = constants.htmlComment;
      return commentOpenInside;
    }
    if (code3 === codes.leftSquareBracket) {
      effects.consume(code3);
      marker = constants.htmlCdata;
      index3 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      marker = constants.htmlDeclaration;
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code3);
  }
  function commentOpenInside(code3) {
    if (code3 === codes.dash) {
      effects.consume(code3);
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code3);
  }
  function cdataOpenInside(code3) {
    const value2 = constants.cdataOpeningString;
    if (code3 === value2.charCodeAt(index3++)) {
      effects.consume(code3);
      if (index3 === value2.length) {
        return self2.interrupt ? ok3 : continuation;
      }
      return cdataOpenInside;
    }
    return nok(code3);
  }
  function tagCloseStart(code3) {
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      buffer = String.fromCharCode(code3);
      return tagName3;
    }
    return nok(code3);
  }
  function tagName3(code3) {
    if (code3 === codes.eof || code3 === codes.slash || code3 === codes.greaterThan || markdownLineEndingOrSpace(code3)) {
      const slash = code3 === codes.slash;
      const name2 = buffer.toLowerCase();
      if (!slash && !closingTag && htmlRawNames.includes(name2)) {
        marker = constants.htmlRaw;
        return self2.interrupt ? ok3(code3) : continuation(code3);
      }
      if (htmlBlockNames.includes(buffer.toLowerCase())) {
        marker = constants.htmlBasic;
        if (slash) {
          effects.consume(code3);
          return basicSelfClosing;
        }
        return self2.interrupt ? ok3(code3) : continuation(code3);
      }
      marker = constants.htmlComplete;
      return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code3) : closingTag ? completeClosingTagAfter(code3) : completeAttributeNameBefore(code3);
    }
    if (code3 === codes.dash || asciiAlphanumeric(code3)) {
      effects.consume(code3);
      buffer += String.fromCharCode(code3);
      return tagName3;
    }
    return nok(code3);
  }
  function basicSelfClosing(code3) {
    if (code3 === codes.greaterThan) {
      effects.consume(code3);
      return self2.interrupt ? ok3 : continuation;
    }
    return nok(code3);
  }
  function completeClosingTagAfter(code3) {
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return completeClosingTagAfter;
    }
    return completeEnd(code3);
  }
  function completeAttributeNameBefore(code3) {
    if (code3 === codes.slash) {
      effects.consume(code3);
      return completeEnd;
    }
    if (code3 === codes.colon || code3 === codes.underscore || asciiAlpha(code3)) {
      effects.consume(code3);
      return completeAttributeName;
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return completeAttributeNameBefore;
    }
    return completeEnd(code3);
  }
  function completeAttributeName(code3) {
    if (code3 === codes.dash || code3 === codes.dot || code3 === codes.colon || code3 === codes.underscore || asciiAlphanumeric(code3)) {
      effects.consume(code3);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code3);
  }
  function completeAttributeNameAfter(code3) {
    if (code3 === codes.equalsTo) {
      effects.consume(code3);
      return completeAttributeValueBefore;
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code3);
  }
  function completeAttributeValueBefore(code3) {
    if (code3 === codes.eof || code3 === codes.lessThan || code3 === codes.equalsTo || code3 === codes.greaterThan || code3 === codes.graveAccent) {
      return nok(code3);
    }
    if (code3 === codes.quotationMark || code3 === codes.apostrophe) {
      effects.consume(code3);
      markerB = code3;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return completeAttributeValueBefore;
    }
    return completeAttributeValueUnquoted(code3);
  }
  function completeAttributeValueQuoted(code3) {
    if (code3 === markerB) {
      effects.consume(code3);
      markerB = null;
      return completeAttributeValueQuotedAfter;
    }
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      return nok(code3);
    }
    effects.consume(code3);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code3) {
    if (code3 === codes.eof || code3 === codes.quotationMark || code3 === codes.apostrophe || code3 === codes.slash || code3 === codes.lessThan || code3 === codes.equalsTo || code3 === codes.greaterThan || code3 === codes.graveAccent || markdownLineEndingOrSpace(code3)) {
      return completeAttributeNameAfter(code3);
    }
    effects.consume(code3);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code3) {
    if (code3 === codes.slash || code3 === codes.greaterThan || markdownSpace(code3)) {
      return completeAttributeNameBefore(code3);
    }
    return nok(code3);
  }
  function completeEnd(code3) {
    if (code3 === codes.greaterThan) {
      effects.consume(code3);
      return completeAfter;
    }
    return nok(code3);
  }
  function completeAfter(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      return continuation(code3);
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return completeAfter;
    }
    return nok(code3);
  }
  function continuation(code3) {
    if (code3 === codes.dash && marker === constants.htmlComment) {
      effects.consume(code3);
      return continuationCommentInside;
    }
    if (code3 === codes.lessThan && marker === constants.htmlRaw) {
      effects.consume(code3);
      return continuationRawTagOpen;
    }
    if (code3 === codes.greaterThan && marker === constants.htmlDeclaration) {
      effects.consume(code3);
      return continuationClose;
    }
    if (code3 === codes.questionMark && marker === constants.htmlInstruction) {
      effects.consume(code3);
      return continuationDeclarationInside;
    }
    if (code3 === codes.rightSquareBracket && marker === constants.htmlCdata) {
      effects.consume(code3);
      return continuationCdataInside;
    }
    if (markdownLineEnding(code3) && (marker === constants.htmlBasic || marker === constants.htmlComplete)) {
      effects.exit(types2.htmlFlowData);
      return effects.check(
        blankLineBefore,
        continuationAfter,
        continuationStart
      )(code3);
    }
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types2.htmlFlowData);
      return continuationStart(code3);
    }
    effects.consume(code3);
    return continuation;
  }
  function continuationStart(code3) {
    return effects.check(
      nonLazyContinuationStart,
      continuationStartNonLazy,
      continuationAfter
    )(code3);
  }
  function continuationStartNonLazy(code3) {
    ok(markdownLineEnding(code3));
    effects.enter(types2.lineEnding);
    effects.consume(code3);
    effects.exit(types2.lineEnding);
    return continuationBefore;
  }
  function continuationBefore(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      return continuationStart(code3);
    }
    effects.enter(types2.htmlFlowData);
    return continuation(code3);
  }
  function continuationCommentInside(code3) {
    if (code3 === codes.dash) {
      effects.consume(code3);
      return continuationDeclarationInside;
    }
    return continuation(code3);
  }
  function continuationRawTagOpen(code3) {
    if (code3 === codes.slash) {
      effects.consume(code3);
      buffer = "";
      return continuationRawEndTag;
    }
    return continuation(code3);
  }
  function continuationRawEndTag(code3) {
    if (code3 === codes.greaterThan) {
      const name2 = buffer.toLowerCase();
      if (htmlRawNames.includes(name2)) {
        effects.consume(code3);
        return continuationClose;
      }
      return continuation(code3);
    }
    if (asciiAlpha(code3) && buffer.length < constants.htmlRawSizeMax) {
      effects.consume(code3);
      buffer += String.fromCharCode(code3);
      return continuationRawEndTag;
    }
    return continuation(code3);
  }
  function continuationCdataInside(code3) {
    if (code3 === codes.rightSquareBracket) {
      effects.consume(code3);
      return continuationDeclarationInside;
    }
    return continuation(code3);
  }
  function continuationDeclarationInside(code3) {
    if (code3 === codes.greaterThan) {
      effects.consume(code3);
      return continuationClose;
    }
    if (code3 === codes.dash && marker === constants.htmlComment) {
      effects.consume(code3);
      return continuationDeclarationInside;
    }
    return continuation(code3);
  }
  function continuationClose(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types2.htmlFlowData);
      return continuationAfter(code3);
    }
    effects.consume(code3);
    return continuationClose;
  }
  function continuationAfter(code3) {
    effects.exit(types2.htmlFlow);
    return ok3(code3);
  }
}
function tokenizeNonLazyContinuationStart(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code3) {
    if (markdownLineEnding(code3)) {
      effects.enter(types2.lineEnding);
      effects.consume(code3);
      effects.exit(types2.lineEnding);
      return after;
    }
    return nok(code3);
  }
  function after(code3) {
    return self2.parser.lazy[self2.now().line] ? nok(code3) : ok3(code3);
  }
}
function tokenizeBlankLineBefore(effects, ok3, nok) {
  return start2;
  function start2(code3) {
    ok(markdownLineEnding(code3), "expected a line ending");
    effects.enter(types2.lineEnding);
    effects.consume(code3);
    effects.exit(types2.lineEnding);
    return effects.attempt(blankLine, ok3, nok);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/html-text.js
var htmlText = { name: "htmlText", tokenize: tokenizeHtmlText };
function tokenizeHtmlText(effects, ok3, nok) {
  const self2 = this;
  let marker;
  let index3;
  let returnState;
  return start2;
  function start2(code3) {
    ok(code3 === codes.lessThan, "expected `<`");
    effects.enter(types2.htmlText);
    effects.enter(types2.htmlTextData);
    effects.consume(code3);
    return open;
  }
  function open(code3) {
    if (code3 === codes.exclamationMark) {
      effects.consume(code3);
      return declarationOpen;
    }
    if (code3 === codes.slash) {
      effects.consume(code3);
      return tagCloseStart;
    }
    if (code3 === codes.questionMark) {
      effects.consume(code3);
      return instruction;
    }
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      return tagOpen;
    }
    return nok(code3);
  }
  function declarationOpen(code3) {
    if (code3 === codes.dash) {
      effects.consume(code3);
      return commentOpenInside;
    }
    if (code3 === codes.leftSquareBracket) {
      effects.consume(code3);
      index3 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      return declaration2;
    }
    return nok(code3);
  }
  function commentOpenInside(code3) {
    if (code3 === codes.dash) {
      effects.consume(code3);
      return commentEnd;
    }
    return nok(code3);
  }
  function comment3(code3) {
    if (code3 === codes.eof) {
      return nok(code3);
    }
    if (code3 === codes.dash) {
      effects.consume(code3);
      return commentClose;
    }
    if (markdownLineEnding(code3)) {
      returnState = comment3;
      return lineEndingBefore(code3);
    }
    effects.consume(code3);
    return comment3;
  }
  function commentClose(code3) {
    if (code3 === codes.dash) {
      effects.consume(code3);
      return commentEnd;
    }
    return comment3(code3);
  }
  function commentEnd(code3) {
    return code3 === codes.greaterThan ? end(code3) : code3 === codes.dash ? commentClose(code3) : comment3(code3);
  }
  function cdataOpenInside(code3) {
    const value2 = constants.cdataOpeningString;
    if (code3 === value2.charCodeAt(index3++)) {
      effects.consume(code3);
      return index3 === value2.length ? cdata : cdataOpenInside;
    }
    return nok(code3);
  }
  function cdata(code3) {
    if (code3 === codes.eof) {
      return nok(code3);
    }
    if (code3 === codes.rightSquareBracket) {
      effects.consume(code3);
      return cdataClose;
    }
    if (markdownLineEnding(code3)) {
      returnState = cdata;
      return lineEndingBefore(code3);
    }
    effects.consume(code3);
    return cdata;
  }
  function cdataClose(code3) {
    if (code3 === codes.rightSquareBracket) {
      effects.consume(code3);
      return cdataEnd;
    }
    return cdata(code3);
  }
  function cdataEnd(code3) {
    if (code3 === codes.greaterThan) {
      return end(code3);
    }
    if (code3 === codes.rightSquareBracket) {
      effects.consume(code3);
      return cdataEnd;
    }
    return cdata(code3);
  }
  function declaration2(code3) {
    if (code3 === codes.eof || code3 === codes.greaterThan) {
      return end(code3);
    }
    if (markdownLineEnding(code3)) {
      returnState = declaration2;
      return lineEndingBefore(code3);
    }
    effects.consume(code3);
    return declaration2;
  }
  function instruction(code3) {
    if (code3 === codes.eof) {
      return nok(code3);
    }
    if (code3 === codes.questionMark) {
      effects.consume(code3);
      return instructionClose;
    }
    if (markdownLineEnding(code3)) {
      returnState = instruction;
      return lineEndingBefore(code3);
    }
    effects.consume(code3);
    return instruction;
  }
  function instructionClose(code3) {
    return code3 === codes.greaterThan ? end(code3) : instruction(code3);
  }
  function tagCloseStart(code3) {
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      return tagClose;
    }
    return nok(code3);
  }
  function tagClose(code3) {
    if (code3 === codes.dash || asciiAlphanumeric(code3)) {
      effects.consume(code3);
      return tagClose;
    }
    return tagCloseBetween(code3);
  }
  function tagCloseBetween(code3) {
    if (markdownLineEnding(code3)) {
      returnState = tagCloseBetween;
      return lineEndingBefore(code3);
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return tagCloseBetween;
    }
    return end(code3);
  }
  function tagOpen(code3) {
    if (code3 === codes.dash || asciiAlphanumeric(code3)) {
      effects.consume(code3);
      return tagOpen;
    }
    if (code3 === codes.slash || code3 === codes.greaterThan || markdownLineEndingOrSpace(code3)) {
      return tagOpenBetween(code3);
    }
    return nok(code3);
  }
  function tagOpenBetween(code3) {
    if (code3 === codes.slash) {
      effects.consume(code3);
      return end;
    }
    if (code3 === codes.colon || code3 === codes.underscore || asciiAlpha(code3)) {
      effects.consume(code3);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding(code3)) {
      returnState = tagOpenBetween;
      return lineEndingBefore(code3);
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return tagOpenBetween;
    }
    return end(code3);
  }
  function tagOpenAttributeName(code3) {
    if (code3 === codes.dash || code3 === codes.dot || code3 === codes.colon || code3 === codes.underscore || asciiAlphanumeric(code3)) {
      effects.consume(code3);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code3);
  }
  function tagOpenAttributeNameAfter(code3) {
    if (code3 === codes.equalsTo) {
      effects.consume(code3);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding(code3)) {
      returnState = tagOpenAttributeNameAfter;
      return lineEndingBefore(code3);
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code3);
  }
  function tagOpenAttributeValueBefore(code3) {
    if (code3 === codes.eof || code3 === codes.lessThan || code3 === codes.equalsTo || code3 === codes.greaterThan || code3 === codes.graveAccent) {
      return nok(code3);
    }
    if (code3 === codes.quotationMark || code3 === codes.apostrophe) {
      effects.consume(code3);
      marker = code3;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding(code3)) {
      returnState = tagOpenAttributeValueBefore;
      return lineEndingBefore(code3);
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code3);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code3) {
    if (code3 === marker) {
      effects.consume(code3);
      marker = void 0;
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code3 === codes.eof) {
      return nok(code3);
    }
    if (markdownLineEnding(code3)) {
      returnState = tagOpenAttributeValueQuoted;
      return lineEndingBefore(code3);
    }
    effects.consume(code3);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueUnquoted(code3) {
    if (code3 === codes.eof || code3 === codes.quotationMark || code3 === codes.apostrophe || code3 === codes.lessThan || code3 === codes.equalsTo || code3 === codes.graveAccent) {
      return nok(code3);
    }
    if (code3 === codes.slash || code3 === codes.greaterThan || markdownLineEndingOrSpace(code3)) {
      return tagOpenBetween(code3);
    }
    effects.consume(code3);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuotedAfter(code3) {
    if (code3 === codes.slash || code3 === codes.greaterThan || markdownLineEndingOrSpace(code3)) {
      return tagOpenBetween(code3);
    }
    return nok(code3);
  }
  function end(code3) {
    if (code3 === codes.greaterThan) {
      effects.consume(code3);
      effects.exit(types2.htmlTextData);
      effects.exit(types2.htmlText);
      return ok3;
    }
    return nok(code3);
  }
  function lineEndingBefore(code3) {
    ok(returnState, "expected return state");
    ok(markdownLineEnding(code3), "expected eol");
    effects.exit(types2.htmlTextData);
    effects.enter(types2.lineEnding);
    effects.consume(code3);
    effects.exit(types2.lineEnding);
    return lineEndingAfter;
  }
  function lineEndingAfter(code3) {
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    return markdownSpace(code3) ? factorySpace(
      effects,
      lineEndingAfterPrefix,
      types2.linePrefix,
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
    )(code3) : lineEndingAfterPrefix(code3);
  }
  function lineEndingAfterPrefix(code3) {
    effects.enter(types2.htmlTextData);
    return returnState(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/label-end.js
var labelEnd = {
  name: "labelEnd",
  tokenize: tokenizeLabelEnd,
  resolveTo: resolveToLabelEnd,
  resolveAll: resolveAllLabelEnd
};
var resourceConstruct = { tokenize: tokenizeResource };
var referenceFullConstruct = { tokenize: tokenizeReferenceFull };
var referenceCollapsedConstruct = { tokenize: tokenizeReferenceCollapsed };
function resolveAllLabelEnd(events2) {
  let index3 = -1;
  while (++index3 < events2.length) {
    const token2 = events2[index3][1];
    if (token2.type === types2.labelImage || token2.type === types2.labelLink || token2.type === types2.labelEnd) {
      events2.splice(index3 + 1, token2.type === types2.labelImage ? 4 : 2);
      token2.type = types2.data;
      index3++;
    }
  }
  return events2;
}
function resolveToLabelEnd(events2, context) {
  let index3 = events2.length;
  let offset = 0;
  let token2;
  let open;
  let close;
  let media;
  while (index3--) {
    token2 = events2[index3][1];
    if (open) {
      if (token2.type === types2.link || token2.type === types2.labelLink && token2._inactive) {
        break;
      }
      if (events2[index3][0] === "enter" && token2.type === types2.labelLink) {
        token2._inactive = true;
      }
    } else if (close) {
      if (events2[index3][0] === "enter" && (token2.type === types2.labelImage || token2.type === types2.labelLink) && !token2._balanced) {
        open = index3;
        if (token2.type !== types2.labelLink) {
          offset = 2;
          break;
        }
      }
    } else if (token2.type === types2.labelEnd) {
      close = index3;
    }
  }
  ok(open !== void 0, "`open` is supposed to be found");
  ok(close !== void 0, "`close` is supposed to be found");
  const group = {
    type: events2[open][1].type === types2.labelLink ? types2.link : types2.image,
    start: Object.assign({}, events2[open][1].start),
    end: Object.assign({}, events2[events2.length - 1][1].end)
  };
  const label = {
    type: types2.label,
    start: Object.assign({}, events2[open][1].start),
    end: Object.assign({}, events2[close][1].end)
  };
  const text7 = {
    type: types2.labelText,
    start: Object.assign({}, events2[open + offset + 2][1].end),
    end: Object.assign({}, events2[close - 2][1].start)
  };
  media = [
    ["enter", group, context],
    ["enter", label, context]
  ];
  media = push2(media, events2.slice(open + 1, open + offset + 3));
  media = push2(media, [["enter", text7, context]]);
  ok(
    context.parser.constructs.insideSpan.null,
    "expected `insideSpan.null` to be populated"
  );
  media = push2(
    media,
    resolveAll(
      context.parser.constructs.insideSpan.null,
      events2.slice(open + offset + 4, close - 3),
      context
    )
  );
  media = push2(media, [
    ["exit", text7, context],
    events2[close - 2],
    events2[close - 1],
    ["exit", label, context]
  ]);
  media = push2(media, events2.slice(close + 1));
  media = push2(media, [["exit", group, context]]);
  splice(events2, open, events2.length, media);
  return events2;
}
function tokenizeLabelEnd(effects, ok3, nok) {
  const self2 = this;
  let index3 = self2.events.length;
  let labelStart;
  let defined;
  while (index3--) {
    if ((self2.events[index3][1].type === types2.labelImage || self2.events[index3][1].type === types2.labelLink) && !self2.events[index3][1]._balanced) {
      labelStart = self2.events[index3][1];
      break;
    }
  }
  return start2;
  function start2(code3) {
    ok(code3 === codes.rightSquareBracket, "expected `]`");
    if (!labelStart) {
      return nok(code3);
    }
    if (labelStart._inactive) {
      return labelEndNok(code3);
    }
    defined = self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize({ start: labelStart.end, end: self2.now() })
      )
    );
    effects.enter(types2.labelEnd);
    effects.enter(types2.labelMarker);
    effects.consume(code3);
    effects.exit(types2.labelMarker);
    effects.exit(types2.labelEnd);
    return after;
  }
  function after(code3) {
    if (code3 === codes.leftParenthesis) {
      return effects.attempt(
        resourceConstruct,
        labelEndOk,
        defined ? labelEndOk : labelEndNok
      )(code3);
    }
    if (code3 === codes.leftSquareBracket) {
      return effects.attempt(
        referenceFullConstruct,
        labelEndOk,
        defined ? referenceNotFull : labelEndNok
      )(code3);
    }
    return defined ? labelEndOk(code3) : labelEndNok(code3);
  }
  function referenceNotFull(code3) {
    return effects.attempt(
      referenceCollapsedConstruct,
      labelEndOk,
      labelEndNok
    )(code3);
  }
  function labelEndOk(code3) {
    return ok3(code3);
  }
  function labelEndNok(code3) {
    labelStart._balanced = true;
    return nok(code3);
  }
}
function tokenizeResource(effects, ok3, nok) {
  return resourceStart;
  function resourceStart(code3) {
    ok(code3 === codes.leftParenthesis, "expected left paren");
    effects.enter(types2.resource);
    effects.enter(types2.resourceMarker);
    effects.consume(code3);
    effects.exit(types2.resourceMarker);
    return resourceBefore;
  }
  function resourceBefore(code3) {
    return markdownLineEndingOrSpace(code3) ? factoryWhitespace(effects, resourceOpen)(code3) : resourceOpen(code3);
  }
  function resourceOpen(code3) {
    if (code3 === codes.rightParenthesis) {
      return resourceEnd(code3);
    }
    return factoryDestination(
      effects,
      resourceDestinationAfter,
      resourceDestinationMissing,
      types2.resourceDestination,
      types2.resourceDestinationLiteral,
      types2.resourceDestinationLiteralMarker,
      types2.resourceDestinationRaw,
      types2.resourceDestinationString,
      constants.linkResourceDestinationBalanceMax
    )(code3);
  }
  function resourceDestinationAfter(code3) {
    return markdownLineEndingOrSpace(code3) ? factoryWhitespace(effects, resourceBetween)(code3) : resourceEnd(code3);
  }
  function resourceDestinationMissing(code3) {
    return nok(code3);
  }
  function resourceBetween(code3) {
    if (code3 === codes.quotationMark || code3 === codes.apostrophe || code3 === codes.leftParenthesis) {
      return factoryTitle(
        effects,
        resourceTitleAfter,
        nok,
        types2.resourceTitle,
        types2.resourceTitleMarker,
        types2.resourceTitleString
      )(code3);
    }
    return resourceEnd(code3);
  }
  function resourceTitleAfter(code3) {
    return markdownLineEndingOrSpace(code3) ? factoryWhitespace(effects, resourceEnd)(code3) : resourceEnd(code3);
  }
  function resourceEnd(code3) {
    if (code3 === codes.rightParenthesis) {
      effects.enter(types2.resourceMarker);
      effects.consume(code3);
      effects.exit(types2.resourceMarker);
      effects.exit(types2.resource);
      return ok3;
    }
    return nok(code3);
  }
}
function tokenizeReferenceFull(effects, ok3, nok) {
  const self2 = this;
  return referenceFull;
  function referenceFull(code3) {
    ok(code3 === codes.leftSquareBracket, "expected left bracket");
    return factoryLabel.call(
      self2,
      effects,
      referenceFullAfter,
      referenceFullMissing,
      types2.reference,
      types2.referenceMarker,
      types2.referenceString
    )(code3);
  }
  function referenceFullAfter(code3) {
    return self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
      )
    ) ? ok3(code3) : nok(code3);
  }
  function referenceFullMissing(code3) {
    return nok(code3);
  }
}
function tokenizeReferenceCollapsed(effects, ok3, nok) {
  return referenceCollapsedStart;
  function referenceCollapsedStart(code3) {
    ok(code3 === codes.leftSquareBracket, "expected left bracket");
    effects.enter(types2.reference);
    effects.enter(types2.referenceMarker);
    effects.consume(code3);
    effects.exit(types2.referenceMarker);
    return referenceCollapsedOpen;
  }
  function referenceCollapsedOpen(code3) {
    if (code3 === codes.rightSquareBracket) {
      effects.enter(types2.referenceMarker);
      effects.consume(code3);
      effects.exit(types2.referenceMarker);
      effects.exit(types2.reference);
      return ok3;
    }
    return nok(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/label-start-image.js
var labelStartImage = {
  name: "labelStartImage",
  tokenize: tokenizeLabelStartImage,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartImage(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code3) {
    ok(code3 === codes.exclamationMark, "expected `!`");
    effects.enter(types2.labelImage);
    effects.enter(types2.labelImageMarker);
    effects.consume(code3);
    effects.exit(types2.labelImageMarker);
    return open;
  }
  function open(code3) {
    if (code3 === codes.leftSquareBracket) {
      effects.enter(types2.labelMarker);
      effects.consume(code3);
      effects.exit(types2.labelMarker);
      effects.exit(types2.labelImage);
      return after;
    }
    return nok(code3);
  }
  function after(code3) {
    return code3 === codes.caret && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code3) : ok3(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/label-start-link.js
var labelStartLink = {
  name: "labelStartLink",
  tokenize: tokenizeLabelStartLink,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartLink(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code3) {
    ok(code3 === codes.leftSquareBracket, "expected `[`");
    effects.enter(types2.labelLink);
    effects.enter(types2.labelMarker);
    effects.consume(code3);
    effects.exit(types2.labelMarker);
    effects.exit(types2.labelLink);
    return after;
  }
  function after(code3) {
    return code3 === codes.caret && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code3) : ok3(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/line-ending.js
var lineEnding = { name: "lineEnding", tokenize: tokenizeLineEnding };
function tokenizeLineEnding(effects, ok3) {
  return start2;
  function start2(code3) {
    ok(markdownLineEnding(code3), "expected eol");
    effects.enter(types2.lineEnding);
    effects.consume(code3);
    effects.exit(types2.lineEnding);
    return factorySpace(effects, ok3, types2.linePrefix);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/thematic-break.js
var thematicBreak = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok3, nok) {
  let size3 = 0;
  let marker;
  return start2;
  function start2(code3) {
    effects.enter(types2.thematicBreak);
    return before(code3);
  }
  function before(code3) {
    ok(
      code3 === codes.asterisk || code3 === codes.dash || code3 === codes.underscore,
      "expected `*`, `-`, or `_`"
    );
    marker = code3;
    return atBreak(code3);
  }
  function atBreak(code3) {
    if (code3 === marker) {
      effects.enter(types2.thematicBreakSequence);
      return sequence(code3);
    }
    if (size3 >= constants.thematicBreakMarkerCountMin && (code3 === codes.eof || markdownLineEnding(code3))) {
      effects.exit(types2.thematicBreak);
      return ok3(code3);
    }
    return nok(code3);
  }
  function sequence(code3) {
    if (code3 === marker) {
      effects.consume(code3);
      size3++;
      return sequence;
    }
    effects.exit(types2.thematicBreakSequence);
    return markdownSpace(code3) ? factorySpace(effects, atBreak, types2.whitespace)(code3) : atBreak(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/list.js
var list2 = {
  name: "list",
  tokenize: tokenizeListStart,
  continuation: { tokenize: tokenizeListContinuation },
  exit: tokenizeListEnd
};
var listItemPrefixWhitespaceConstruct = {
  tokenize: tokenizeListItemPrefixWhitespace,
  partial: true
};
var indentConstruct = { tokenize: tokenizeIndent, partial: true };
function tokenizeListStart(effects, ok3, nok) {
  const self2 = this;
  const tail = self2.events[self2.events.length - 1];
  let initialSize = tail && tail[1].type === types2.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size3 = 0;
  return start2;
  function start2(code3) {
    ok(self2.containerState, "expected state");
    const kind = self2.containerState.type || (code3 === codes.asterisk || code3 === codes.plusSign || code3 === codes.dash ? types2.listUnordered : types2.listOrdered);
    if (kind === types2.listUnordered ? !self2.containerState.marker || code3 === self2.containerState.marker : asciiDigit(code3)) {
      if (!self2.containerState.type) {
        self2.containerState.type = kind;
        effects.enter(kind, { _container: true });
      }
      if (kind === types2.listUnordered) {
        effects.enter(types2.listItemPrefix);
        return code3 === codes.asterisk || code3 === codes.dash ? effects.check(thematicBreak, nok, atMarker)(code3) : atMarker(code3);
      }
      if (!self2.interrupt || code3 === codes.digit1) {
        effects.enter(types2.listItemPrefix);
        effects.enter(types2.listItemValue);
        return inside(code3);
      }
    }
    return nok(code3);
  }
  function inside(code3) {
    ok(self2.containerState, "expected state");
    if (asciiDigit(code3) && ++size3 < constants.listItemValueSizeMax) {
      effects.consume(code3);
      return inside;
    }
    if ((!self2.interrupt || size3 < 2) && (self2.containerState.marker ? code3 === self2.containerState.marker : code3 === codes.rightParenthesis || code3 === codes.dot)) {
      effects.exit(types2.listItemValue);
      return atMarker(code3);
    }
    return nok(code3);
  }
  function atMarker(code3) {
    ok(self2.containerState, "expected state");
    ok(code3 !== codes.eof, "eof (`null`) is not a marker");
    effects.enter(types2.listItemMarker);
    effects.consume(code3);
    effects.exit(types2.listItemMarker);
    self2.containerState.marker = self2.containerState.marker || code3;
    return effects.check(
      blankLine,
      // Can’t be empty when interrupting.
      self2.interrupt ? nok : onBlank,
      effects.attempt(
        listItemPrefixWhitespaceConstruct,
        endOfPrefix,
        otherPrefix
      )
    );
  }
  function onBlank(code3) {
    ok(self2.containerState, "expected state");
    self2.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code3);
  }
  function otherPrefix(code3) {
    if (markdownSpace(code3)) {
      effects.enter(types2.listItemPrefixWhitespace);
      effects.consume(code3);
      effects.exit(types2.listItemPrefixWhitespace);
      return endOfPrefix;
    }
    return nok(code3);
  }
  function endOfPrefix(code3) {
    ok(self2.containerState, "expected state");
    self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit(types2.listItemPrefix), true).length;
    return ok3(code3);
  }
}
function tokenizeListContinuation(effects, ok3, nok) {
  const self2 = this;
  ok(self2.containerState, "expected state");
  self2.containerState._closeFlow = void 0;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code3) {
    ok(self2.containerState, "expected state");
    ok(typeof self2.containerState.size === "number", "expected size");
    self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
    return factorySpace(
      effects,
      ok3,
      types2.listItemIndent,
      self2.containerState.size + 1
    )(code3);
  }
  function notBlank(code3) {
    ok(self2.containerState, "expected state");
    if (self2.containerState.furtherBlankLines || !markdownSpace(code3)) {
      self2.containerState.furtherBlankLines = void 0;
      self2.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code3);
    }
    self2.containerState.furtherBlankLines = void 0;
    self2.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok3, notInCurrentItem)(code3);
  }
  function notInCurrentItem(code3) {
    ok(self2.containerState, "expected state");
    self2.containerState._closeFlow = true;
    self2.interrupt = void 0;
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    return factorySpace(
      effects,
      effects.attempt(list2, ok3, nok),
      types2.linePrefix,
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
    )(code3);
  }
}
function tokenizeIndent(effects, ok3, nok) {
  const self2 = this;
  ok(self2.containerState, "expected state");
  ok(typeof self2.containerState.size === "number", "expected size");
  return factorySpace(
    effects,
    afterPrefix,
    types2.listItemIndent,
    self2.containerState.size + 1
  );
  function afterPrefix(code3) {
    ok(self2.containerState, "expected state");
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types2.listItemIndent && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok3(code3) : nok(code3);
  }
}
function tokenizeListEnd(effects) {
  ok(this.containerState, "expected state");
  ok(typeof this.containerState.type === "string", "expected type");
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok3, nok) {
  const self2 = this;
  ok(
    self2.parser.constructs.disable.null,
    "expected `disable.null` to be populated"
  );
  return factorySpace(
    effects,
    afterPrefix,
    types2.listItemPrefixWhitespace,
    self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize + 1
  );
  function afterPrefix(code3) {
    const tail = self2.events[self2.events.length - 1];
    return !markdownSpace(code3) && tail && tail[1].type === types2.listItemPrefixWhitespace ? ok3(code3) : nok(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/setext-underline.js
var setextUnderline = {
  name: "setextUnderline",
  tokenize: tokenizeSetextUnderline,
  resolveTo: resolveToSetextUnderline
};
function resolveToSetextUnderline(events2, context) {
  let index3 = events2.length;
  let content3;
  let text7;
  let definition2;
  while (index3--) {
    if (events2[index3][0] === "enter") {
      if (events2[index3][1].type === types2.content) {
        content3 = index3;
        break;
      }
      if (events2[index3][1].type === types2.paragraph) {
        text7 = index3;
      }
    } else {
      if (events2[index3][1].type === types2.content) {
        events2.splice(index3, 1);
      }
      if (!definition2 && events2[index3][1].type === types2.definition) {
        definition2 = index3;
      }
    }
  }
  ok(text7 !== void 0, "expected a `text` index to be found");
  ok(content3 !== void 0, "expected a `text` index to be found");
  const heading2 = {
    type: types2.setextHeading,
    start: Object.assign({}, events2[text7][1].start),
    end: Object.assign({}, events2[events2.length - 1][1].end)
  };
  events2[text7][1].type = types2.setextHeadingText;
  if (definition2) {
    events2.splice(text7, 0, ["enter", heading2, context]);
    events2.splice(definition2 + 1, 0, ["exit", events2[content3][1], context]);
    events2[content3][1].end = Object.assign({}, events2[definition2][1].end);
  } else {
    events2[content3][1] = heading2;
  }
  events2.push(["exit", heading2, context]);
  return events2;
}
function tokenizeSetextUnderline(effects, ok3, nok) {
  const self2 = this;
  let marker;
  return start2;
  function start2(code3) {
    let index3 = self2.events.length;
    let paragraph2;
    ok(
      code3 === codes.dash || code3 === codes.equalsTo,
      "expected `=` or `-`"
    );
    while (index3--) {
      if (self2.events[index3][1].type !== types2.lineEnding && self2.events[index3][1].type !== types2.linePrefix && self2.events[index3][1].type !== types2.content) {
        paragraph2 = self2.events[index3][1].type === types2.paragraph;
        break;
      }
    }
    if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph2)) {
      effects.enter(types2.setextHeadingLine);
      marker = code3;
      return before(code3);
    }
    return nok(code3);
  }
  function before(code3) {
    effects.enter(types2.setextHeadingLineSequence);
    return inside(code3);
  }
  function inside(code3) {
    if (code3 === marker) {
      effects.consume(code3);
      return inside;
    }
    effects.exit(types2.setextHeadingLineSequence);
    return markdownSpace(code3) ? factorySpace(effects, after, types2.lineSuffix)(code3) : after(code3);
  }
  function after(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types2.setextHeadingLine);
      return ok3(code3);
    }
    return nok(code3);
  }
}

// node_modules/micromark/dev/lib/initialize/flow.js
var flow = { tokenize: initializeFlow };
function initializeFlow(effects) {
  const self2 = this;
  const initial = effects.attempt(
    // Try to parse a blank line.
    blankLine,
    atBlankEnding,
    // Try to parse initial flow (essentially, only code).
    effects.attempt(
      this.parser.constructs.flowInitial,
      afterConstruct,
      factorySpace(
        effects,
        effects.attempt(
          this.parser.constructs.flow,
          afterConstruct,
          effects.attempt(content2, afterConstruct)
        ),
        types2.linePrefix
      )
    )
  );
  return initial;
  function atBlankEnding(code3) {
    ok(
      code3 === codes.eof || markdownLineEnding(code3),
      "expected eol or eof"
    );
    if (code3 === codes.eof) {
      effects.consume(code3);
      return;
    }
    effects.enter(types2.lineEndingBlank);
    effects.consume(code3);
    effects.exit(types2.lineEndingBlank);
    self2.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code3) {
    ok(
      code3 === codes.eof || markdownLineEnding(code3),
      "expected eol or eof"
    );
    if (code3 === codes.eof) {
      effects.consume(code3);
      return;
    }
    effects.enter(types2.lineEnding);
    effects.consume(code3);
    effects.exit(types2.lineEnding);
    self2.currentConstruct = void 0;
    return initial;
  }
}

// node_modules/micromark/dev/lib/initialize/text.js
var resolver = { resolveAll: createResolver() };
var string = initializeFactory("string");
var text3 = initializeFactory("text");
function initializeFactory(field2) {
  return {
    tokenize: initializeText,
    resolveAll: createResolver(
      field2 === "text" ? resolveAllLineSuffixes : void 0
    )
  };
  function initializeText(effects) {
    const self2 = this;
    const constructs2 = this.parser.constructs[field2];
    const text7 = effects.attempt(constructs2, start2, notText);
    return start2;
    function start2(code3) {
      return atBreak(code3) ? text7(code3) : notText(code3);
    }
    function notText(code3) {
      if (code3 === codes.eof) {
        effects.consume(code3);
        return;
      }
      effects.enter(types2.data);
      effects.consume(code3);
      return data;
    }
    function data(code3) {
      if (atBreak(code3)) {
        effects.exit(types2.data);
        return text7(code3);
      }
      effects.consume(code3);
      return data;
    }
    function atBreak(code3) {
      if (code3 === codes.eof) {
        return true;
      }
      const list3 = constructs2[code3];
      let index3 = -1;
      if (list3) {
        ok(Array.isArray(list3), "expected `disable.null` to be populated");
        while (++index3 < list3.length) {
          const item2 = list3[index3];
          if (!item2.previous || item2.previous.call(self2, self2.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events2, context) {
    let index3 = -1;
    let enter;
    while (++index3 <= events2.length) {
      if (enter === void 0) {
        if (events2[index3] && events2[index3][1].type === types2.data) {
          enter = index3;
          index3++;
        }
      } else if (!events2[index3] || events2[index3][1].type !== types2.data) {
        if (index3 !== enter + 2) {
          events2[enter][1].end = events2[index3 - 1][1].end;
          events2.splice(enter + 2, index3 - enter - 2);
          index3 = enter + 2;
        }
        enter = void 0;
      }
    }
    return extraResolver ? extraResolver(events2, context) : events2;
  }
}
function resolveAllLineSuffixes(events2, context) {
  let eventIndex = 0;
  while (++eventIndex <= events2.length) {
    if ((eventIndex === events2.length || events2[eventIndex][1].type === types2.lineEnding) && events2[eventIndex - 1][1].type === types2.data) {
      const data = events2[eventIndex - 1][1];
      const chunks = context.sliceStream(data);
      let index3 = chunks.length;
      let bufferIndex = -1;
      let size3 = 0;
      let tabs;
      while (index3--) {
        const chunk = chunks[index3];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === codes.space) {
            size3++;
            bufferIndex--;
          }
          if (bufferIndex)
            break;
          bufferIndex = -1;
        } else if (chunk === codes.horizontalTab) {
          tabs = true;
          size3++;
        } else if (chunk === codes.virtualSpace) {
        } else {
          index3++;
          break;
        }
      }
      if (size3) {
        const token2 = {
          type: eventIndex === events2.length || tabs || size3 < constants.hardBreakPrefixSizeMin ? types2.lineSuffix : types2.hardBreakTrailing,
          start: {
            line: data.end.line,
            column: data.end.column - size3,
            offset: data.end.offset - size3,
            _index: data.start._index + index3,
            _bufferIndex: index3 ? bufferIndex : data.start._bufferIndex + bufferIndex
          },
          end: Object.assign({}, data.end)
        };
        data.end = Object.assign({}, token2.start);
        if (data.start.offset === data.end.offset) {
          Object.assign(data, token2);
        } else {
          events2.splice(
            eventIndex,
            0,
            ["enter", token2, context],
            ["exit", token2, context]
          );
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events2;
}

// node_modules/micromark/dev/lib/create-tokenizer.js
var import_debug = __toESM(require_browser(), 1);
var debug4 = (0, import_debug.default)("micromark");
function createTokenizer(parser2, initialize, from4) {
  let point3 = Object.assign(
    from4 ? Object.assign({}, from4) : { line: 1, column: 1, offset: 0 },
    { _index: 0, _bufferIndex: -1 }
  );
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  let consumed = true;
  const effects = {
    consume,
    enter,
    exit: exit2,
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    interrupt: constructFactory(onsuccessfulcheck, { interrupt: true })
  };
  const context = {
    previous: codes.eof,
    code: codes.eof,
    containerState: {},
    events: [],
    parser: parser2,
    sliceStream,
    sliceSerialize,
    now,
    defineSkip,
    write: write2
  };
  let state = initialize.tokenize.call(context, effects);
  let expectedCode;
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write2(slice2) {
    chunks = push2(chunks, slice2);
    main();
    if (chunks[chunks.length - 1] !== codes.eof) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token2, expandTabs) {
    return serializeChunks(sliceStream(token2), expandTabs);
  }
  function sliceStream(token2) {
    return sliceChunks(chunks, token2);
  }
  function now() {
    const { line: line2, column: column2, offset, _index, _bufferIndex } = point3;
    return { line: line2, column: column2, offset, _index, _bufferIndex };
  }
  function defineSkip(value2) {
    columnStart[value2.line] = value2.column;
    accountForPotentialSkip();
    debug4("position: define skip: `%j`", point3);
  }
  function main() {
    let chunkIndex;
    while (point3._index < chunks.length) {
      const chunk = chunks[point3._index];
      if (typeof chunk === "string") {
        chunkIndex = point3._index;
        if (point3._bufferIndex < 0) {
          point3._bufferIndex = 0;
        }
        while (point3._index === chunkIndex && point3._bufferIndex < chunk.length) {
          go(chunk.charCodeAt(point3._bufferIndex));
        }
      } else {
        go(chunk);
      }
    }
  }
  function go(code3) {
    ok(consumed === true, "expected character to be consumed");
    consumed = void 0;
    debug4("main: passing `%s` to %s", code3, state && state.name);
    expectedCode = code3;
    ok(typeof state === "function", "expected state");
    state = state(code3);
  }
  function consume(code3) {
    ok(code3 === expectedCode, "expected given code to equal expected code");
    debug4("consume: `%s`", code3);
    ok(
      consumed === void 0,
      "expected code to not have been consumed: this might be because `return x(code)` instead of `return x` was used"
    );
    ok(
      code3 === null ? context.events.length === 0 || context.events[context.events.length - 1][0] === "exit" : context.events[context.events.length - 1][0] === "enter",
      "expected last token to be open"
    );
    if (markdownLineEnding(code3)) {
      point3.line++;
      point3.column = 1;
      point3.offset += code3 === codes.carriageReturnLineFeed ? 2 : 1;
      accountForPotentialSkip();
      debug4("position: after eol: `%j`", point3);
    } else if (code3 !== codes.virtualSpace) {
      point3.column++;
      point3.offset++;
    }
    if (point3._bufferIndex < 0) {
      point3._index++;
    } else {
      point3._bufferIndex++;
      if (point3._bufferIndex === chunks[point3._index].length) {
        point3._bufferIndex = -1;
        point3._index++;
      }
    }
    context.previous = code3;
    consumed = true;
  }
  function enter(type2, fields) {
    const token2 = fields || {};
    token2.type = type2;
    token2.start = now();
    ok(typeof type2 === "string", "expected string type");
    ok(type2.length > 0, "expected non-empty string");
    debug4("enter: `%s`", type2);
    context.events.push(["enter", token2, context]);
    stack.push(token2);
    return token2;
  }
  function exit2(type2) {
    ok(typeof type2 === "string", "expected string type");
    ok(type2.length > 0, "expected non-empty string");
    const token2 = stack.pop();
    ok(token2, "cannot close w/o open tokens");
    token2.end = now();
    ok(type2 === token2.type, "expected exit token to match current token");
    ok(
      !(token2.start._index === token2.end._index && token2.start._bufferIndex === token2.end._bufferIndex),
      "expected non-empty token (`" + type2 + "`)"
    );
    debug4("exit: `%s`", token2.type);
    context.events.push(["exit", token2, context]);
    return token2;
  }
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }
  function onsuccessfulcheck(_2, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info;
      return Array.isArray(constructs2) ? (
        /* c8 ignore next 1 */
        handleListOfConstructs(constructs2)
      ) : "tokenize" in constructs2 ? (
        // @ts-expect-error Looks like a construct.
        handleListOfConstructs([constructs2])
      ) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map4) {
        return start2;
        function start2(code3) {
          const def = code3 !== null && map4[code3];
          const all3 = code3 !== null && map4.null;
          const list3 = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(def) ? def : def ? [def] : [],
            ...Array.isArray(all3) ? all3 : all3 ? [all3] : []
          ];
          return handleListOfConstructs(list3)(code3);
        }
      }
      function handleListOfConstructs(list3) {
        listOfConstructs = list3;
        constructIndex = 0;
        if (list3.length === 0) {
          ok(bogusState, "expected `bogusState` to be given");
          return bogusState;
        }
        return handleConstruct(list3[constructIndex]);
      }
      function handleConstruct(construct) {
        return start2;
        function start2(code3) {
          info = store2();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }
          ok(
            context.parser.constructs.disable.null,
            "expected `disable.null` to be populated"
          );
          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
            return nok(code3);
          }
          return construct.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            fields ? Object.assign(Object.create(context), fields) : context,
            effects,
            ok3,
            nok
          )(code3);
        }
      }
      function ok3(code3) {
        ok(code3 === expectedCode, "expected code");
        consumed = true;
        onreturn(currentConstruct, info);
        return returnState;
      }
      function nok(code3) {
        ok(code3 === expectedCode, "expected code");
        consumed = true;
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from5) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice(
        context.events,
        from5,
        context.events.length - from5,
        construct.resolve(context.events.slice(from5), context)
      );
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
    ok(
      construct.partial || context.events.length === 0 || context.events[context.events.length - 1][0] === "exit",
      "expected last token to end"
    );
  }
  function store2() {
    const startPoint = now();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return { restore, from: startEventsIndex };
    function restore() {
      point3 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
      debug4("position: restore: `%j`", point3);
    }
  }
  function accountForPotentialSkip() {
    if (point3.line in columnStart && point3.column < 2) {
      point3.column = columnStart[point3.line];
      point3.offset += columnStart[point3.line] - 1;
    }
  }
}
function sliceChunks(chunks, token2) {
  const startIndex = token2.start._index;
  const startBufferIndex = token2.start._bufferIndex;
  const endIndex = token2.end._index;
  const endBufferIndex = token2.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    ok(endBufferIndex > -1, "expected non-negative end buffer index");
    ok(startBufferIndex > -1, "expected non-negative start buffer index");
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      const head = view[0];
      if (typeof head === "string") {
        view[0] = head.slice(startBufferIndex);
      } else {
        ok(startBufferIndex === 0, "expected `startBufferIndex` to be `0`");
        view.shift();
      }
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index3 = -1;
  const result = [];
  let atTab;
  while (++index3 < chunks.length) {
    const chunk = chunks[index3];
    let value2;
    if (typeof chunk === "string") {
      value2 = chunk;
    } else
      switch (chunk) {
        case codes.carriageReturn: {
          value2 = values.cr;
          break;
        }
        case codes.lineFeed: {
          value2 = values.lf;
          break;
        }
        case codes.carriageReturnLineFeed: {
          value2 = values.cr + values.lf;
          break;
        }
        case codes.horizontalTab: {
          value2 = expandTabs ? values.space : values.ht;
          break;
        }
        case codes.virtualSpace: {
          if (!expandTabs && atTab)
            continue;
          value2 = values.space;
          break;
        }
        default: {
          ok(typeof chunk === "number", "expected number");
          value2 = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === codes.horizontalTab;
    result.push(value2);
  }
  return result.join("");
}

// node_modules/micromark/dev/lib/constructs.js
var constructs_exports = {};
__export(constructs_exports, {
  attentionMarkers: () => attentionMarkers,
  contentInitial: () => contentInitial,
  disable: () => disable,
  document: () => document4,
  flow: () => flow2,
  flowInitial: () => flowInitial,
  insideSpan: () => insideSpan,
  string: () => string2,
  text: () => text4
});
var document4 = {
  [codes.asterisk]: list2,
  [codes.plusSign]: list2,
  [codes.dash]: list2,
  [codes.digit0]: list2,
  [codes.digit1]: list2,
  [codes.digit2]: list2,
  [codes.digit3]: list2,
  [codes.digit4]: list2,
  [codes.digit5]: list2,
  [codes.digit6]: list2,
  [codes.digit7]: list2,
  [codes.digit8]: list2,
  [codes.digit9]: list2,
  [codes.greaterThan]: blockQuote
};
var contentInitial = {
  [codes.leftSquareBracket]: definition
};
var flowInitial = {
  [codes.horizontalTab]: codeIndented,
  [codes.virtualSpace]: codeIndented,
  [codes.space]: codeIndented
};
var flow2 = {
  [codes.numberSign]: headingAtx,
  [codes.asterisk]: thematicBreak,
  [codes.dash]: [setextUnderline, thematicBreak],
  [codes.lessThan]: htmlFlow,
  [codes.equalsTo]: setextUnderline,
  [codes.underscore]: thematicBreak,
  [codes.graveAccent]: codeFenced,
  [codes.tilde]: codeFenced
};
var string2 = {
  [codes.ampersand]: characterReference,
  [codes.backslash]: characterEscape
};
var text4 = {
  [codes.carriageReturn]: lineEnding,
  [codes.lineFeed]: lineEnding,
  [codes.carriageReturnLineFeed]: lineEnding,
  [codes.exclamationMark]: labelStartImage,
  [codes.ampersand]: characterReference,
  [codes.asterisk]: attention,
  [codes.lessThan]: [autolink, htmlText],
  [codes.leftSquareBracket]: labelStartLink,
  [codes.backslash]: [hardBreakEscape, characterEscape],
  [codes.rightSquareBracket]: labelEnd,
  [codes.underscore]: attention,
  [codes.graveAccent]: codeText
};
var insideSpan = { null: [attention, resolver] };
var attentionMarkers = { null: [codes.asterisk, codes.underscore] };
var disable = { null: [] };

// node_modules/micromark/dev/lib/parse.js
function parse6(options) {
  const settings = options || {};
  const constructs2 = (
    /** @type {FullNormalizedExtension} */
    combineExtensions([constructs_exports, ...settings.extensions || []])
  );
  const parser2 = {
    defined: [],
    lazy: {},
    constructs: constructs2,
    content: create9(content),
    document: create9(document3),
    flow: create9(flow),
    string: create9(string),
    text: create9(text3)
  };
  return parser2;
  function create9(initial) {
    return creator;
    function creator(from4) {
      return createTokenizer(parser2, initial, from4);
    }
  }
}

// node_modules/micromark/dev/lib/postprocess.js
function postprocess(events2) {
  while (!subtokenize(events2)) {
  }
  return events2;
}

// node_modules/micromark/dev/lib/preprocess.js
var search = /[\0\t\n\r]/g;
function preprocess() {
  let column2 = 1;
  let buffer = "";
  let start2 = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value2, encoding, end) {
    const chunks = [];
    let match3;
    let next2;
    let startPosition;
    let endPosition;
    let code3;
    value2 = buffer + (typeof value2 === "string" ? value2.toString() : new TextDecoder(encoding || void 0).decode(value2));
    startPosition = 0;
    buffer = "";
    if (start2) {
      if (value2.charCodeAt(0) === codes.byteOrderMarker) {
        startPosition++;
      }
      start2 = void 0;
    }
    while (startPosition < value2.length) {
      search.lastIndex = startPosition;
      match3 = search.exec(value2);
      endPosition = match3 && match3.index !== void 0 ? match3.index : value2.length;
      code3 = value2.charCodeAt(endPosition);
      if (!match3) {
        buffer = value2.slice(startPosition);
        break;
      }
      if (code3 === codes.lf && startPosition === endPosition && atCarriageReturn) {
        chunks.push(codes.carriageReturnLineFeed);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(codes.carriageReturn);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value2.slice(startPosition, endPosition));
          column2 += endPosition - startPosition;
        }
        switch (code3) {
          case codes.nul: {
            chunks.push(codes.replacementCharacter);
            column2++;
            break;
          }
          case codes.ht: {
            next2 = Math.ceil(column2 / constants.tabSize) * constants.tabSize;
            chunks.push(codes.horizontalTab);
            while (column2++ < next2)
              chunks.push(codes.virtualSpace);
            break;
          }
          case codes.lf: {
            chunks.push(codes.lineFeed);
            column2 = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column2 = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn)
        chunks.push(codes.carriageReturn);
      if (buffer)
        chunks.push(buffer);
      chunks.push(codes.eof);
    }
    return chunks;
  }
}

// node_modules/micromark-util-decode-string/dev/index.js
var characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value2) {
  return value2.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $2) {
  if ($1) {
    return $1;
  }
  const head = $2.charCodeAt(0);
  if (head === codes.numberSign) {
    const head2 = $2.charCodeAt(1);
    const hex = head2 === codes.lowercaseX || head2 === codes.uppercaseX;
    return decodeNumericCharacterReference(
      $2.slice(hex ? 2 : 1),
      hex ? constants.numericBaseHexadecimal : constants.numericBaseDecimal
    );
  }
  return decodeNamedCharacterReference($2) || $0;
}

// node_modules/unist-util-stringify-position/lib/index.js
function stringifyPosition(value2) {
  if (!value2 || typeof value2 !== "object") {
    return "";
  }
  if ("position" in value2 || "type" in value2) {
    return position2(value2.position);
  }
  if ("start" in value2 || "end" in value2) {
    return position2(value2);
  }
  if ("line" in value2 || "column" in value2) {
    return point(value2);
  }
  return "";
}
function point(point3) {
  return index2(point3 && point3.line) + ":" + index2(point3 && point3.column);
}
function position2(pos) {
  return point(pos && pos.start) + "-" + point(pos && pos.end);
}
function index2(value2) {
  return value2 && typeof value2 === "number" ? value2 : 1;
}

// node_modules/mdast-util-from-markdown/dev/lib/index.js
var own = {}.hasOwnProperty;
function fromMarkdown(value2, encoding, options) {
  if (typeof encoding !== "string") {
    options = encoding;
    encoding = void 0;
  }
  return compiler(options)(
    postprocess(
      parse6(options).document().write(preprocess()(value2, encoding, true))
    )
  );
}
function compiler(options) {
  const config3 = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: opener(link2),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading2),
      blockQuote: opener(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer,
      codeFencedFenceMeta: buffer,
      codeIndented: opener(codeFlow, buffer),
      codeText: opener(codeText2, buffer),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition2),
      definitionDestinationString: buffer,
      definitionLabelString: buffer,
      definitionTitleString: buffer,
      emphasis: opener(emphasis),
      hardBreakEscape: opener(hardBreak),
      hardBreakTrailing: opener(hardBreak),
      htmlFlow: opener(html, buffer),
      htmlFlowData: onenterdata,
      htmlText: opener(html, buffer),
      htmlTextData: onenterdata,
      image: opener(image2),
      label: buffer,
      link: opener(link2),
      listItem: opener(listItem),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list3, onenterlistordered),
      listUnordered: opener(list3),
      paragraph: opener(paragraph2),
      reference: onenterreference,
      referenceString: buffer,
      resourceDestinationString: buffer,
      resourceTitleString: buffer,
      setextHeading: opener(heading2),
      strong: opener(strong2),
      thematicBreak: opener(thematicBreak2)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  };
  configure(config3, (options || {}).mdastExtensions || []);
  const data = {};
  return compile3;
  function compile3(events2) {
    let tree2 = { type: "root", children: [] };
    const context = {
      stack: [tree2],
      tokenStack: [],
      config: config3,
      enter,
      exit: exit2,
      buffer,
      resume,
      data
    };
    const listStack = [];
    let index3 = -1;
    while (++index3 < events2.length) {
      if (events2[index3][1].type === types2.listOrdered || events2[index3][1].type === types2.listUnordered) {
        if (events2[index3][0] === "enter") {
          listStack.push(index3);
        } else {
          const tail = listStack.pop();
          ok(typeof tail === "number", "expected list ot be open");
          index3 = prepareList(events2, tail, index3);
        }
      }
    }
    index3 = -1;
    while (++index3 < events2.length) {
      const handler = config3[events2[index3][0]];
      if (own.call(handler, events2[index3][1].type)) {
        handler[events2[index3][1].type].call(
          Object.assign(
            { sliceSerialize: events2[index3][2].sliceSerialize },
            context
          ),
          events2[index3][1]
        );
      }
    }
    if (context.tokenStack.length > 0) {
      const tail = context.tokenStack[context.tokenStack.length - 1];
      const handler = tail[1] || defaultOnError;
      handler.call(context, void 0, tail[0]);
    }
    tree2.position = {
      start: point2(
        events2.length > 0 ? events2[0][1].start : { line: 1, column: 1, offset: 0 }
      ),
      end: point2(
        events2.length > 0 ? events2[events2.length - 2][1].end : { line: 1, column: 1, offset: 0 }
      )
    };
    index3 = -1;
    while (++index3 < config3.transforms.length) {
      tree2 = config3.transforms[index3](tree2) || tree2;
    }
    return tree2;
  }
  function prepareList(events2, start2, length4) {
    let index3 = start2 - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem2;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index3 <= length4) {
      const event = events2[index3];
      switch (event[1].type) {
        case types2.listUnordered:
        case types2.listOrdered:
        case types2.blockQuote: {
          if (event[0] === "enter") {
            containerBalance++;
          } else {
            containerBalance--;
          }
          atMarker = void 0;
          break;
        }
        case types2.lineEndingBlank: {
          if (event[0] === "enter") {
            if (listItem2 && !atMarker && !containerBalance && !firstBlankLineIndex) {
              firstBlankLineIndex = index3;
            }
            atMarker = void 0;
          }
          break;
        }
        case types2.linePrefix:
        case types2.listItemValue:
        case types2.listItemMarker:
        case types2.listItemPrefix:
        case types2.listItemPrefixWhitespace: {
          break;
        }
        default: {
          atMarker = void 0;
        }
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === types2.listItemPrefix || containerBalance === -1 && event[0] === "exit" && (event[1].type === types2.listUnordered || event[1].type === types2.listOrdered)) {
        if (listItem2) {
          let tailIndex = index3;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events2[tailIndex];
            if (tailEvent[1].type === types2.lineEnding || tailEvent[1].type === types2.lineEndingBlank) {
              if (tailEvent[0] === "exit")
                continue;
              if (lineIndex) {
                events2[lineIndex][1].type = types2.lineEndingBlank;
                listSpread = true;
              }
              tailEvent[1].type = types2.lineEnding;
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === types2.linePrefix || tailEvent[1].type === types2.blockQuotePrefix || tailEvent[1].type === types2.blockQuotePrefixWhitespace || tailEvent[1].type === types2.blockQuoteMarker || tailEvent[1].type === types2.listItemIndent) {
            } else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem2._spread = true;
          }
          listItem2.end = Object.assign(
            {},
            lineIndex ? events2[lineIndex][1].start : event[1].end
          );
          events2.splice(lineIndex || index3, 0, ["exit", listItem2, event[2]]);
          index3++;
          length4++;
        }
        if (event[1].type === types2.listItemPrefix) {
          const item2 = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, event[1].start),
            // @ts-expect-error: we’ll add `end` in a second.
            end: void 0
          };
          listItem2 = item2;
          events2.splice(index3, 0, ["enter", item2, event[2]]);
          index3++;
          length4++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events2[start2][1]._spread = listSpread;
    return length4;
  }
  function opener(create9, and2) {
    return open;
    function open(token2) {
      enter.call(this, create9(token2), token2);
      if (and2)
        and2.call(this, token2);
    }
  }
  function buffer() {
    this.stack.push({ type: "fragment", children: [] });
  }
  function enter(node4, token2, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    ok(parent, "expected `parent`");
    ok("children" in parent, "expected `parent`");
    const siblings = parent.children;
    siblings.push(node4);
    this.stack.push(node4);
    this.tokenStack.push([token2, errorHandler]);
    node4.position = {
      start: point2(token2.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function closer(and2) {
    return close;
    function close(token2) {
      if (and2)
        and2.call(this, token2);
      exit2.call(this, token2);
    }
  }
  function exit2(token2, onExitError) {
    const node4 = this.stack.pop();
    ok(node4, "expected `node`");
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error(
        "Cannot close `" + token2.type + "` (" + stringifyPosition({ start: token2.start, end: token2.end }) + "): it’s not open"
      );
    } else if (open[0].type !== token2.type) {
      if (onExitError) {
        onExitError.call(this, token2, open[0]);
      } else {
        const handler = open[1] || defaultOnError;
        handler.call(this, token2, open[0]);
      }
    }
    ok(node4.type !== "fragment", "unexpected fragment `exit`ed");
    ok(node4.position, "expected `position` to be defined");
    node4.position.end = point2(token2.end);
  }
  function resume() {
    return toString2(this.stack.pop());
  }
  function onenterlistordered() {
    this.data.expectingFirstListItemValue = true;
  }
  function onenterlistitemvalue(token2) {
    if (this.data.expectingFirstListItemValue) {
      const ancestor = this.stack[this.stack.length - 2];
      ok(ancestor, "expected nodes on stack");
      ok(ancestor.type === "list", "expected list on stack");
      ancestor.start = Number.parseInt(
        this.sliceSerialize(token2),
        constants.numericBaseDecimal
      );
      this.data.expectingFirstListItemValue = void 0;
    }
  }
  function onexitcodefencedfenceinfo() {
    const data2 = this.resume();
    const node4 = this.stack[this.stack.length - 1];
    ok(node4, "expected node on stack");
    ok(node4.type === "code", "expected code on stack");
    node4.lang = data2;
  }
  function onexitcodefencedfencemeta() {
    const data2 = this.resume();
    const node4 = this.stack[this.stack.length - 1];
    ok(node4, "expected node on stack");
    ok(node4.type === "code", "expected code on stack");
    node4.meta = data2;
  }
  function onexitcodefencedfence() {
    if (this.data.flowCodeInside)
      return;
    this.buffer();
    this.data.flowCodeInside = true;
  }
  function onexitcodefenced() {
    const data2 = this.resume();
    const node4 = this.stack[this.stack.length - 1];
    ok(node4, "expected node on stack");
    ok(node4.type === "code", "expected code on stack");
    node4.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    this.data.flowCodeInside = void 0;
  }
  function onexitcodeindented() {
    const data2 = this.resume();
    const node4 = this.stack[this.stack.length - 1];
    ok(node4, "expected node on stack");
    ok(node4.type === "code", "expected code on stack");
    node4.value = data2.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token2) {
    const label = this.resume();
    const node4 = this.stack[this.stack.length - 1];
    ok(node4, "expected node on stack");
    ok(node4.type === "definition", "expected definition on stack");
    node4.label = label;
    node4.identifier = normalizeIdentifier(
      this.sliceSerialize(token2)
    ).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data2 = this.resume();
    const node4 = this.stack[this.stack.length - 1];
    ok(node4, "expected node on stack");
    ok(node4.type === "definition", "expected definition on stack");
    node4.title = data2;
  }
  function onexitdefinitiondestinationstring() {
    const data2 = this.resume();
    const node4 = this.stack[this.stack.length - 1];
    ok(node4, "expected node on stack");
    ok(node4.type === "definition", "expected definition on stack");
    node4.url = data2;
  }
  function onexitatxheadingsequence(token2) {
    const node4 = this.stack[this.stack.length - 1];
    ok(node4, "expected node on stack");
    ok(node4.type === "heading", "expected heading on stack");
    if (!node4.depth) {
      const depth = this.sliceSerialize(token2).length;
      ok(
        depth === 1 || depth === 2 || depth === 3 || depth === 4 || depth === 5 || depth === 6,
        "expected `depth` between `1` and `6`"
      );
      node4.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    this.data.setextHeadingSlurpLineEnding = true;
  }
  function onexitsetextheadinglinesequence(token2) {
    const node4 = this.stack[this.stack.length - 1];
    ok(node4, "expected node on stack");
    ok(node4.type === "heading", "expected heading on stack");
    node4.depth = this.sliceSerialize(token2).codePointAt(0) === codes.equalsTo ? 1 : 2;
  }
  function onexitsetextheading() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function onenterdata(token2) {
    const node4 = this.stack[this.stack.length - 1];
    ok(node4, "expected node on stack");
    ok("children" in node4, "expected parent on stack");
    const siblings = node4.children;
    let tail = siblings[siblings.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text7();
      tail.position = {
        start: point2(token2.start),
        // @ts-expect-error: we’ll add `end` later.
        end: void 0
      };
      siblings.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token2) {
    const tail = this.stack.pop();
    ok(tail, "expected a `node` to be on the stack");
    ok("value" in tail, "expected a `literal` to be on the stack");
    ok(tail.position, "expected `node` to have an open position");
    tail.value += this.sliceSerialize(token2);
    tail.position.end = point2(token2.end);
  }
  function onexitlineending(token2) {
    const context = this.stack[this.stack.length - 1];
    ok(context, "expected `node`");
    if (this.data.atHardBreak) {
      ok("children" in context, "expected `parent`");
      const tail = context.children[context.children.length - 1];
      ok(tail.position, "expected tail to have a starting position");
      tail.position.end = point2(token2.end);
      this.data.atHardBreak = void 0;
      return;
    }
    if (!this.data.setextHeadingSlurpLineEnding && config3.canContainEols.includes(context.type)) {
      onenterdata.call(this, token2);
      onexitdata.call(this, token2);
    }
  }
  function onexithardbreak() {
    this.data.atHardBreak = true;
  }
  function onexithtmlflow() {
    const data2 = this.resume();
    const node4 = this.stack[this.stack.length - 1];
    ok(node4, "expected node on stack");
    ok(node4.type === "html", "expected html on stack");
    node4.value = data2;
  }
  function onexithtmltext() {
    const data2 = this.resume();
    const node4 = this.stack[this.stack.length - 1];
    ok(node4, "expected node on stack");
    ok(node4.type === "html", "expected html on stack");
    node4.value = data2;
  }
  function onexitcodetext() {
    const data2 = this.resume();
    const node4 = this.stack[this.stack.length - 1];
    ok(node4, "expected node on stack");
    ok(node4.type === "inlineCode", "expected inline code on stack");
    node4.value = data2;
  }
  function onexitlink() {
    const node4 = this.stack[this.stack.length - 1];
    ok(node4, "expected node on stack");
    ok(node4.type === "link", "expected link on stack");
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node4.type += "Reference";
      node4.referenceType = referenceType;
      delete node4.url;
      delete node4.title;
    } else {
      delete node4.identifier;
      delete node4.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitimage() {
    const node4 = this.stack[this.stack.length - 1];
    ok(node4, "expected node on stack");
    ok(node4.type === "image", "expected image on stack");
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node4.type += "Reference";
      node4.referenceType = referenceType;
      delete node4.url;
      delete node4.title;
    } else {
      delete node4.identifier;
      delete node4.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitlabeltext(token2) {
    const string3 = this.sliceSerialize(token2);
    const ancestor = this.stack[this.stack.length - 2];
    ok(ancestor, "expected ancestor on stack");
    ok(
      ancestor.type === "image" || ancestor.type === "link",
      "expected image or link on stack"
    );
    ancestor.label = decodeString(string3);
    ancestor.identifier = normalizeIdentifier(string3).toLowerCase();
  }
  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1];
    ok(fragment, "expected node on stack");
    ok(fragment.type === "fragment", "expected fragment on stack");
    const value2 = this.resume();
    const node4 = this.stack[this.stack.length - 1];
    ok(node4, "expected node on stack");
    ok(
      node4.type === "image" || node4.type === "link",
      "expected image or link on stack"
    );
    this.data.inReference = true;
    if (node4.type === "link") {
      const children = fragment.children;
      node4.children = children;
    } else {
      node4.alt = value2;
    }
  }
  function onexitresourcedestinationstring() {
    const data2 = this.resume();
    const node4 = this.stack[this.stack.length - 1];
    ok(node4, "expected node on stack");
    ok(
      node4.type === "image" || node4.type === "link",
      "expected image or link on stack"
    );
    node4.url = data2;
  }
  function onexitresourcetitlestring() {
    const data2 = this.resume();
    const node4 = this.stack[this.stack.length - 1];
    ok(node4, "expected node on stack");
    ok(
      node4.type === "image" || node4.type === "link",
      "expected image or link on stack"
    );
    node4.title = data2;
  }
  function onexitresource() {
    this.data.inReference = void 0;
  }
  function onenterreference() {
    this.data.referenceType = "collapsed";
  }
  function onexitreferencestring(token2) {
    const label = this.resume();
    const node4 = this.stack[this.stack.length - 1];
    ok(node4, "expected node on stack");
    ok(
      node4.type === "image" || node4.type === "link",
      "expected image reference or link reference on stack"
    );
    node4.label = label;
    node4.identifier = normalizeIdentifier(
      this.sliceSerialize(token2)
    ).toLowerCase();
    this.data.referenceType = "full";
  }
  function onexitcharacterreferencemarker(token2) {
    ok(
      token2.type === "characterReferenceMarkerNumeric" || token2.type === "characterReferenceMarkerHexadecimal"
    );
    this.data.characterReferenceType = token2.type;
  }
  function onexitcharacterreferencevalue(token2) {
    const data2 = this.sliceSerialize(token2);
    const type2 = this.data.characterReferenceType;
    let value2;
    if (type2) {
      value2 = decodeNumericCharacterReference(
        data2,
        type2 === types2.characterReferenceMarkerNumeric ? constants.numericBaseDecimal : constants.numericBaseHexadecimal
      );
      this.data.characterReferenceType = void 0;
    } else {
      const result = decodeNamedCharacterReference(data2);
      ok(result !== false, "expected reference to decode");
      value2 = result;
    }
    const tail = this.stack.pop();
    ok(tail, "expected `node`");
    ok(tail.position, "expected `node.position`");
    ok("value" in tail, "expected `node.value`");
    tail.value += value2;
    tail.position.end = point2(token2.end);
  }
  function onexitautolinkprotocol(token2) {
    onexitdata.call(this, token2);
    const node4 = this.stack[this.stack.length - 1];
    ok(node4, "expected node on stack");
    ok(node4.type === "link", "expected link on stack");
    node4.url = this.sliceSerialize(token2);
  }
  function onexitautolinkemail(token2) {
    onexitdata.call(this, token2);
    const node4 = this.stack[this.stack.length - 1];
    ok(node4, "expected node on stack");
    ok(node4.type === "link", "expected link on stack");
    node4.url = "mailto:" + this.sliceSerialize(token2);
  }
  function blockQuote2() {
    return { type: "blockquote", children: [] };
  }
  function codeFlow() {
    return { type: "code", lang: null, meta: null, value: "" };
  }
  function codeText2() {
    return { type: "inlineCode", value: "" };
  }
  function definition2() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis() {
    return { type: "emphasis", children: [] };
  }
  function heading2() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function hardBreak() {
    return { type: "break" };
  }
  function html() {
    return { type: "html", value: "" };
  }
  function image2() {
    return { type: "image", title: null, url: "", alt: null };
  }
  function link2() {
    return { type: "link", title: null, url: "", children: [] };
  }
  function list3(token2) {
    return {
      type: "list",
      ordered: token2.type === "listOrdered",
      start: null,
      spread: token2._spread,
      children: []
    };
  }
  function listItem(token2) {
    return {
      type: "listItem",
      spread: token2._spread,
      checked: null,
      children: []
    };
  }
  function paragraph2() {
    return { type: "paragraph", children: [] };
  }
  function strong2() {
    return { type: "strong", children: [] };
  }
  function text7() {
    return { type: "text", value: "" };
  }
  function thematicBreak2() {
    return { type: "thematicBreak" };
  }
}
function point2(d5) {
  return { line: d5.line, column: d5.column, offset: d5.offset };
}
function configure(combined, extensions) {
  let index3 = -1;
  while (++index3 < extensions.length) {
    const value2 = extensions[index3];
    if (Array.isArray(value2)) {
      configure(combined, value2);
    } else {
      extension(combined, value2);
    }
  }
}
function extension(combined, extension2) {
  let key;
  for (key in extension2) {
    if (own.call(extension2, key)) {
      switch (key) {
        case "canContainEols": {
          const right = extension2[key];
          if (right) {
            combined[key].push(...right);
          }
          break;
        }
        case "transforms": {
          const right = extension2[key];
          if (right) {
            combined[key].push(...right);
          }
          break;
        }
        case "enter":
        case "exit": {
          const right = extension2[key];
          if (right) {
            Object.assign(combined[key], right);
          }
          break;
        }
      }
    }
  }
}
function defaultOnError(left, right) {
  if (left) {
    throw new Error(
      "Cannot close `" + left.type + "` (" + stringifyPosition({ start: left.start, end: left.end }) + "): a different token (`" + right.type + "`, " + stringifyPosition({ start: right.start, end: right.end }) + ") is open"
    );
  } else {
    throw new Error(
      "Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({ start: right.start, end: right.end }) + ") is still open"
    );
  }
}

// node_modules/ccount/index.js
function ccount(value2, character2) {
  const source = String(value2);
  if (typeof character2 !== "string") {
    throw new TypeError("Expected character");
  }
  let count = 0;
  let index3 = source.indexOf(character2);
  while (index3 !== -1) {
    count++;
    index3 = source.indexOf(character2, index3 + character2.length);
  }
  return count;
}

// node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js
function escapeStringRegexp(string3) {
  if (typeof string3 !== "string") {
    throw new TypeError("Expected a string");
  }
  return string3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}

// node_modules/unist-util-is/lib/index.js
var convert = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(test) {
    if (test === null || test === void 0) {
      return ok2;
    }
    if (typeof test === "function") {
      return castFactory(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
    }
    if (typeof test === "string") {
      return typeFactory(test);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(tests) {
  const checks = [];
  let index3 = -1;
  while (++index3 < tests.length) {
    checks[index3] = convert(tests[index3]);
  }
  return castFactory(any2);
  function any2(...parameters) {
    let index4 = -1;
    while (++index4 < checks.length) {
      if (checks[index4].apply(this, parameters))
        return true;
    }
    return false;
  }
}
function propsFactory(check) {
  const checkAsRecord = (
    /** @type {Record<string, unknown>} */
    check
  );
  return castFactory(all3);
  function all3(node4) {
    const nodeAsRecord = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      node4
    );
    let key;
    for (key in check) {
      if (nodeAsRecord[key] !== checkAsRecord[key])
        return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type2);
  function type2(node4) {
    return node4 && node4.type === check;
  }
}
function castFactory(testFunction) {
  return check;
  function check(value2, index3, parent) {
    return Boolean(
      looksLikeANode(value2) && testFunction.call(
        this,
        value2,
        typeof index3 === "number" ? index3 : void 0,
        parent || void 0
      )
    );
  }
}
function ok2() {
  return true;
}
function looksLikeANode(value2) {
  return value2 !== null && typeof value2 === "object" && "type" in value2;
}

// node_modules/unist-util-visit-parents/lib/color.js
function color(d5) {
  return d5;
}

// node_modules/unist-util-visit-parents/lib/index.js
var empty2 = [];
var CONTINUE = true;
var EXIT = false;
var SKIP = "skip";
function visitParents(tree2, test, visitor, reverse) {
  let check;
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
  } else {
    check = test;
  }
  const is2 = convert(check);
  const step = reverse ? -1 : 1;
  factory(tree2, void 0, [])();
  function factory(node4, index3, parents) {
    const value2 = (
      /** @type {Record<string, unknown>} */
      node4 && typeof node4 === "object" ? node4 : {}
    );
    if (typeof value2.type === "string") {
      const name2 = (
        // `hast`
        typeof value2.tagName === "string" ? value2.tagName : (
          // `xast`
          typeof value2.name === "string" ? value2.name : void 0
        )
      );
      Object.defineProperty(visit2, "name", {
        value: "node (" + color(node4.type + (name2 ? "<" + name2 + ">" : "")) + ")"
      });
    }
    return visit2;
    function visit2() {
      let result = empty2;
      let subresult;
      let offset;
      let grandparents;
      if (!test || is2(node4, index3, parents[parents.length - 1] || void 0)) {
        result = toResult(visitor(node4, parents));
        if (result[0] === EXIT) {
          return result;
        }
      }
      if ("children" in node4 && node4.children) {
        const nodeAsParent = (
          /** @type {UnistParent} */
          node4
        );
        if (nodeAsParent.children && result[0] !== SKIP) {
          offset = (reverse ? nodeAsParent.children.length : -1) + step;
          grandparents = parents.concat(nodeAsParent);
          while (offset > -1 && offset < nodeAsParent.children.length) {
            const child = nodeAsParent.children[offset];
            subresult = factory(child, offset, grandparents)();
            if (subresult[0] === EXIT) {
              return subresult;
            }
            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
          }
        }
      }
      return result;
    }
  }
}
function toResult(value2) {
  if (Array.isArray(value2)) {
    return value2;
  }
  if (typeof value2 === "number") {
    return [CONTINUE, value2];
  }
  return value2 === null || value2 === void 0 ? empty2 : [value2];
}

// node_modules/mdast-util-find-and-replace/lib/index.js
function findAndReplace(tree2, list3, options) {
  const settings = options || {};
  const ignored2 = convert(settings.ignore || []);
  const pairs = toPairs(list3);
  let pairIndex = -1;
  while (++pairIndex < pairs.length) {
    visitParents(tree2, "text", visitor);
  }
  function visitor(node4, parents) {
    let index3 = -1;
    let grandparent;
    while (++index3 < parents.length) {
      const parent = parents[index3];
      const siblings = grandparent ? grandparent.children : void 0;
      if (ignored2(
        parent,
        siblings ? siblings.indexOf(parent) : void 0,
        grandparent
      )) {
        return;
      }
      grandparent = parent;
    }
    if (grandparent) {
      return handler(node4, parents);
    }
  }
  function handler(node4, parents) {
    const parent = parents[parents.length - 1];
    const find2 = pairs[pairIndex][0];
    const replace2 = pairs[pairIndex][1];
    let start2 = 0;
    const siblings = parent.children;
    const index3 = siblings.indexOf(node4);
    let change = false;
    let nodes = [];
    find2.lastIndex = 0;
    let match3 = find2.exec(node4.value);
    while (match3) {
      const position3 = match3.index;
      const matchObject = {
        index: match3.index,
        input: match3.input,
        stack: [...parents, node4]
      };
      let value2 = replace2(...match3, matchObject);
      if (typeof value2 === "string") {
        value2 = value2.length > 0 ? { type: "text", value: value2 } : void 0;
      }
      if (value2 === false) {
        find2.lastIndex = position3 + 1;
      } else {
        if (start2 !== position3) {
          nodes.push({
            type: "text",
            value: node4.value.slice(start2, position3)
          });
        }
        if (Array.isArray(value2)) {
          nodes.push(...value2);
        } else if (value2) {
          nodes.push(value2);
        }
        start2 = position3 + match3[0].length;
        change = true;
      }
      if (!find2.global) {
        break;
      }
      match3 = find2.exec(node4.value);
    }
    if (change) {
      if (start2 < node4.value.length) {
        nodes.push({ type: "text", value: node4.value.slice(start2) });
      }
      parent.children.splice(index3, 1, ...nodes);
    } else {
      nodes = [node4];
    }
    return index3 + nodes.length;
  }
}
function toPairs(tupleOrList) {
  const result = [];
  if (!Array.isArray(tupleOrList)) {
    throw new TypeError("Expected find and replace tuple or list of tuples");
  }
  const list3 = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList];
  let index3 = -1;
  while (++index3 < list3.length) {
    const tuple = list3[index3];
    result.push([toExpression(tuple[0]), toFunction(tuple[1])]);
  }
  return result;
}
function toExpression(find2) {
  return typeof find2 === "string" ? new RegExp(escapeStringRegexp(find2), "g") : find2;
}
function toFunction(replace2) {
  return typeof replace2 === "function" ? replace2 : function() {
    return replace2;
  };
}

// node_modules/mdast-util-gfm-autolink-literal/lib/index.js
function gfmAutolinkLiteralFromMarkdown() {
  return {
    transforms: [transformGfmAutolinkLiterals],
    enter: {
      literalAutolink: enterLiteralAutolink,
      literalAutolinkEmail: enterLiteralAutolinkValue,
      literalAutolinkHttp: enterLiteralAutolinkValue,
      literalAutolinkWww: enterLiteralAutolinkValue
    },
    exit: {
      literalAutolink: exitLiteralAutolink,
      literalAutolinkEmail: exitLiteralAutolinkEmail,
      literalAutolinkHttp: exitLiteralAutolinkHttp,
      literalAutolinkWww: exitLiteralAutolinkWww
    }
  };
}
function enterLiteralAutolink(token2) {
  this.enter({ type: "link", title: null, url: "", children: [] }, token2);
}
function enterLiteralAutolinkValue(token2) {
  this.config.enter.autolinkProtocol.call(this, token2);
}
function exitLiteralAutolinkHttp(token2) {
  this.config.exit.autolinkProtocol.call(this, token2);
}
function exitLiteralAutolinkWww(token2) {
  this.config.exit.data.call(this, token2);
  const node4 = this.stack[this.stack.length - 1];
  ok(node4.type === "link");
  node4.url = "http://" + this.sliceSerialize(token2);
}
function exitLiteralAutolinkEmail(token2) {
  this.config.exit.autolinkEmail.call(this, token2);
}
function exitLiteralAutolink(token2) {
  this.exit(token2);
}
function transformGfmAutolinkLiterals(tree2) {
  findAndReplace(
    tree2,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
      [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, findEmail]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function findUrl(_2, protocol, domain2, path3, match3) {
  let prefix4 = "";
  if (!previous2(match3)) {
    return false;
  }
  if (/^w/i.test(protocol)) {
    domain2 = protocol + domain2;
    protocol = "";
    prefix4 = "http://";
  }
  if (!isCorrectDomain(domain2)) {
    return false;
  }
  const parts = splitUrl(domain2 + path3);
  if (!parts[0])
    return false;
  const result = {
    type: "link",
    title: null,
    url: prefix4 + protocol + parts[0],
    children: [{ type: "text", value: protocol + parts[0] }]
  };
  if (parts[1]) {
    return [result, { type: "text", value: parts[1] }];
  }
  return result;
}
function findEmail(_2, atext, label, match3) {
  if (
    // Not an expected previous character.
    !previous2(match3, true) || // Label ends in not allowed character.
    /[-\d_]$/.test(label)
  ) {
    return false;
  }
  return {
    type: "link",
    title: null,
    url: "mailto:" + atext + "@" + label,
    children: [{ type: "text", value: atext + "@" + label }]
  };
}
function isCorrectDomain(domain2) {
  const parts = domain2.split(".");
  if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
    return false;
  }
  return true;
}
function splitUrl(url) {
  const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
  if (!trailExec) {
    return [url, void 0];
  }
  url = url.slice(0, trailExec.index);
  let trail2 = trailExec[0];
  let closingParenIndex = trail2.indexOf(")");
  const openingParens = ccount(url, "(");
  let closingParens = ccount(url, ")");
  while (closingParenIndex !== -1 && openingParens > closingParens) {
    url += trail2.slice(0, closingParenIndex + 1);
    trail2 = trail2.slice(closingParenIndex + 1);
    closingParenIndex = trail2.indexOf(")");
    closingParens++;
  }
  return [url, trail2];
}
function previous2(match3, email) {
  const code3 = match3.input.charCodeAt(match3.index - 1);
  return (match3.index === 0 || unicodeWhitespace(code3) || unicodePunctuation(code3)) && (!email || code3 !== 47);
}

// node_modules/micromark-extension-gfm-autolink-literal/dev/lib/syntax.js
var wwwPrefix = { tokenize: tokenizeWwwPrefix, partial: true };
var domain = { tokenize: tokenizeDomain, partial: true };
var path2 = { tokenize: tokenizePath, partial: true };
var trail = { tokenize: tokenizeTrail, partial: true };
var emailDomainDotTrail = {
  tokenize: tokenizeEmailDomainDotTrail,
  partial: true
};
var wwwAutolink = { tokenize: tokenizeWwwAutolink, previous: previousWww };
var protocolAutolink = {
  tokenize: tokenizeProtocolAutolink,
  previous: previousProtocol
};
var emailAutolink = { tokenize: tokenizeEmailAutolink, previous: previousEmail };
var text5 = {};
function gfmAutolinkLiteral() {
  return { text: text5 };
}
var code2 = codes.digit0;
while (code2 < codes.leftCurlyBrace) {
  text5[code2] = emailAutolink;
  code2++;
  if (code2 === codes.colon)
    code2 = codes.uppercaseA;
  else if (code2 === codes.leftSquareBracket)
    code2 = codes.lowercaseA;
}
text5[codes.plusSign] = emailAutolink;
text5[codes.dash] = emailAutolink;
text5[codes.dot] = emailAutolink;
text5[codes.underscore] = emailAutolink;
text5[codes.uppercaseH] = [emailAutolink, protocolAutolink];
text5[codes.lowercaseH] = [emailAutolink, protocolAutolink];
text5[codes.uppercaseW] = [emailAutolink, wwwAutolink];
text5[codes.lowercaseW] = [emailAutolink, wwwAutolink];
function tokenizeEmailAutolink(effects, ok3, nok) {
  const self2 = this;
  let dot;
  let data;
  return start2;
  function start2(code3) {
    if (!gfmAtext(code3) || !previousEmail.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
      return nok(code3);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkEmail");
    return atext(code3);
  }
  function atext(code3) {
    if (gfmAtext(code3)) {
      effects.consume(code3);
      return atext;
    }
    if (code3 === codes.atSign) {
      effects.consume(code3);
      return emailDomain;
    }
    return nok(code3);
  }
  function emailDomain(code3) {
    if (code3 === codes.dot) {
      return effects.check(
        emailDomainDotTrail,
        emailDomainAfter,
        emailDomainDot
      )(code3);
    }
    if (code3 === codes.dash || code3 === codes.underscore || asciiAlphanumeric(code3)) {
      data = true;
      effects.consume(code3);
      return emailDomain;
    }
    return emailDomainAfter(code3);
  }
  function emailDomainDot(code3) {
    effects.consume(code3);
    dot = true;
    return emailDomain;
  }
  function emailDomainAfter(code3) {
    if (data && dot && asciiAlpha(self2.previous)) {
      effects.exit("literalAutolinkEmail");
      effects.exit("literalAutolink");
      return ok3(code3);
    }
    return nok(code3);
  }
}
function tokenizeWwwAutolink(effects, ok3, nok) {
  const self2 = this;
  return wwwStart;
  function wwwStart(code3) {
    if (code3 !== codes.uppercaseW && code3 !== codes.lowercaseW || !previousWww.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
      return nok(code3);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkWww");
    return effects.check(
      wwwPrefix,
      effects.attempt(domain, effects.attempt(path2, wwwAfter), nok),
      nok
    )(code3);
  }
  function wwwAfter(code3) {
    effects.exit("literalAutolinkWww");
    effects.exit("literalAutolink");
    return ok3(code3);
  }
}
function tokenizeProtocolAutolink(effects, ok3, nok) {
  const self2 = this;
  let buffer = "";
  let seen = false;
  return protocolStart;
  function protocolStart(code3) {
    if ((code3 === codes.uppercaseH || code3 === codes.lowercaseH) && previousProtocol.call(self2, self2.previous) && !previousUnbalanced(self2.events)) {
      effects.enter("literalAutolink");
      effects.enter("literalAutolinkHttp");
      buffer += String.fromCodePoint(code3);
      effects.consume(code3);
      return protocolPrefixInside;
    }
    return nok(code3);
  }
  function protocolPrefixInside(code3) {
    if (asciiAlpha(code3) && buffer.length < 5) {
      buffer += String.fromCodePoint(code3);
      effects.consume(code3);
      return protocolPrefixInside;
    }
    if (code3 === codes.colon) {
      const protocol = buffer.toLowerCase();
      if (protocol === "http" || protocol === "https") {
        effects.consume(code3);
        return protocolSlashesInside;
      }
    }
    return nok(code3);
  }
  function protocolSlashesInside(code3) {
    if (code3 === codes.slash) {
      effects.consume(code3);
      if (seen) {
        return afterProtocol;
      }
      seen = true;
      return protocolSlashesInside;
    }
    return nok(code3);
  }
  function afterProtocol(code3) {
    return code3 === codes.eof || asciiControl(code3) || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3) || unicodePunctuation(code3) ? nok(code3) : effects.attempt(domain, effects.attempt(path2, protocolAfter), nok)(code3);
  }
  function protocolAfter(code3) {
    effects.exit("literalAutolinkHttp");
    effects.exit("literalAutolink");
    return ok3(code3);
  }
}
function tokenizeWwwPrefix(effects, ok3, nok) {
  let size3 = 0;
  return wwwPrefixInside;
  function wwwPrefixInside(code3) {
    if ((code3 === codes.uppercaseW || code3 === codes.lowercaseW) && size3 < 3) {
      size3++;
      effects.consume(code3);
      return wwwPrefixInside;
    }
    if (code3 === codes.dot && size3 === 3) {
      effects.consume(code3);
      return wwwPrefixAfter;
    }
    return nok(code3);
  }
  function wwwPrefixAfter(code3) {
    return code3 === codes.eof ? nok(code3) : ok3(code3);
  }
}
function tokenizeDomain(effects, ok3, nok) {
  let underscoreInLastSegment;
  let underscoreInLastLastSegment;
  let seen;
  return domainInside;
  function domainInside(code3) {
    if (code3 === codes.dot || code3 === codes.underscore) {
      return effects.check(trail, domainAfter, domainAtPunctuation)(code3);
    }
    if (code3 === codes.eof || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3) || code3 !== codes.dash && unicodePunctuation(code3)) {
      return domainAfter(code3);
    }
    seen = true;
    effects.consume(code3);
    return domainInside;
  }
  function domainAtPunctuation(code3) {
    if (code3 === codes.underscore) {
      underscoreInLastSegment = true;
    } else {
      underscoreInLastLastSegment = underscoreInLastSegment;
      underscoreInLastSegment = void 0;
    }
    effects.consume(code3);
    return domainInside;
  }
  function domainAfter(code3) {
    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {
      return nok(code3);
    }
    return ok3(code3);
  }
}
function tokenizePath(effects, ok3) {
  let sizeOpen = 0;
  let sizeClose = 0;
  return pathInside;
  function pathInside(code3) {
    if (code3 === codes.leftParenthesis) {
      sizeOpen++;
      effects.consume(code3);
      return pathInside;
    }
    if (code3 === codes.rightParenthesis && sizeClose < sizeOpen) {
      return pathAtPunctuation(code3);
    }
    if (code3 === codes.exclamationMark || code3 === codes.quotationMark || code3 === codes.ampersand || code3 === codes.apostrophe || code3 === codes.rightParenthesis || code3 === codes.asterisk || code3 === codes.comma || code3 === codes.dot || code3 === codes.colon || code3 === codes.semicolon || code3 === codes.lessThan || code3 === codes.questionMark || code3 === codes.rightSquareBracket || code3 === codes.underscore || code3 === codes.tilde) {
      return effects.check(trail, ok3, pathAtPunctuation)(code3);
    }
    if (code3 === codes.eof || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
      return ok3(code3);
    }
    effects.consume(code3);
    return pathInside;
  }
  function pathAtPunctuation(code3) {
    if (code3 === codes.rightParenthesis) {
      sizeClose++;
    }
    effects.consume(code3);
    return pathInside;
  }
}
function tokenizeTrail(effects, ok3, nok) {
  return trail2;
  function trail2(code3) {
    if (code3 === codes.exclamationMark || code3 === codes.quotationMark || code3 === codes.apostrophe || code3 === codes.rightParenthesis || code3 === codes.asterisk || code3 === codes.comma || code3 === codes.dot || code3 === codes.colon || code3 === codes.semicolon || code3 === codes.questionMark || code3 === codes.underscore || code3 === codes.tilde) {
      effects.consume(code3);
      return trail2;
    }
    if (code3 === codes.ampersand) {
      effects.consume(code3);
      return trailCharRefStart;
    }
    if (code3 === codes.rightSquareBracket) {
      effects.consume(code3);
      return trailBracketAfter;
    }
    if (
      // `<` is an end.
      code3 === codes.lessThan || // So is whitespace.
      code3 === codes.eof || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)
    ) {
      return ok3(code3);
    }
    return nok(code3);
  }
  function trailBracketAfter(code3) {
    if (code3 === codes.eof || code3 === codes.leftParenthesis || code3 === codes.leftSquareBracket || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
      return ok3(code3);
    }
    return trail2(code3);
  }
  function trailCharRefStart(code3) {
    return asciiAlpha(code3) ? trailCharRefInside(code3) : nok(code3);
  }
  function trailCharRefInside(code3) {
    if (code3 === codes.semicolon) {
      effects.consume(code3);
      return trail2;
    }
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      return trailCharRefInside;
    }
    return nok(code3);
  }
}
function tokenizeEmailDomainDotTrail(effects, ok3, nok) {
  return start2;
  function start2(code3) {
    effects.consume(code3);
    return after;
  }
  function after(code3) {
    return asciiAlphanumeric(code3) ? nok(code3) : ok3(code3);
  }
}
function previousWww(code3) {
  return code3 === codes.eof || code3 === codes.leftParenthesis || code3 === codes.asterisk || code3 === codes.underscore || code3 === codes.leftSquareBracket || code3 === codes.rightSquareBracket || code3 === codes.tilde || markdownLineEndingOrSpace(code3);
}
function previousProtocol(code3) {
  return !asciiAlpha(code3);
}
function previousEmail(code3) {
  return !(code3 === codes.slash || gfmAtext(code3));
}
function gfmAtext(code3) {
  return code3 === codes.plusSign || code3 === codes.dash || code3 === codes.dot || code3 === codes.underscore || asciiAlphanumeric(code3);
}
function previousUnbalanced(events2) {
  let index3 = events2.length;
  let result = false;
  while (index3--) {
    const token2 = events2[index3][1];
    if ((token2.type === "labelLink" || token2.type === "labelImage") && !token2._balanced) {
      result = true;
      break;
    }
    if (token2._gfmAutolinkLiteralWalkedInto) {
      result = false;
      break;
    }
  }
  if (events2.length > 0 && !result) {
    events2[events2.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
  }
  return result;
}

// node_modules/mdast-util-gfm-strikethrough/lib/index.js
handleDelete.peek = peekDelete;
function gfmStrikethroughFromMarkdown() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: enterStrikethrough },
    exit: { strikethrough: exitStrikethrough }
  };
}
function enterStrikethrough(token2) {
  this.enter({ type: "delete", children: [] }, token2);
}
function exitStrikethrough(token2) {
  this.exit(token2);
}
function handleDelete(node4, _2, state, info) {
  const tracker = state.createTracker(info);
  const exit2 = state.enter("strikethrough");
  let value2 = tracker.move("~~");
  value2 += state.containerPhrasing(node4, {
    ...tracker.current(),
    before: value2,
    after: "~"
  });
  value2 += tracker.move("~~");
  exit2();
  return value2;
}
function peekDelete() {
  return "~";
}

// node_modules/micromark-extension-gfm-strikethrough/dev/lib/syntax.js
function gfmStrikethrough(options) {
  const options_ = options || {};
  let single = options_.singleTilde;
  const tokenizer2 = {
    tokenize: tokenizeStrikethrough,
    resolveAll: resolveAllStrikethrough
  };
  if (single === null || single === void 0) {
    single = true;
  }
  return {
    text: { [codes.tilde]: tokenizer2 },
    insideSpan: { null: [tokenizer2] },
    attentionMarkers: { null: [codes.tilde] }
  };
  function resolveAllStrikethrough(events2, context) {
    let index3 = -1;
    while (++index3 < events2.length) {
      if (events2[index3][0] === "enter" && events2[index3][1].type === "strikethroughSequenceTemporary" && events2[index3][1]._close) {
        let open = index3;
        while (open--) {
          if (events2[open][0] === "exit" && events2[open][1].type === "strikethroughSequenceTemporary" && events2[open][1]._open && // If the sizes are the same:
          events2[index3][1].end.offset - events2[index3][1].start.offset === events2[open][1].end.offset - events2[open][1].start.offset) {
            events2[index3][1].type = "strikethroughSequence";
            events2[open][1].type = "strikethroughSequence";
            const strikethrough = {
              type: "strikethrough",
              start: Object.assign({}, events2[open][1].start),
              end: Object.assign({}, events2[index3][1].end)
            };
            const text7 = {
              type: "strikethroughText",
              start: Object.assign({}, events2[open][1].end),
              end: Object.assign({}, events2[index3][1].start)
            };
            const nextEvents = [
              ["enter", strikethrough, context],
              ["enter", events2[open][1], context],
              ["exit", events2[open][1], context],
              ["enter", text7, context]
            ];
            const insideSpan2 = context.parser.constructs.insideSpan.null;
            if (insideSpan2) {
              splice(
                nextEvents,
                nextEvents.length,
                0,
                resolveAll(insideSpan2, events2.slice(open + 1, index3), context)
              );
            }
            splice(nextEvents, nextEvents.length, 0, [
              ["exit", text7, context],
              ["enter", events2[index3][1], context],
              ["exit", events2[index3][1], context],
              ["exit", strikethrough, context]
            ]);
            splice(events2, open - 1, index3 - open + 3, nextEvents);
            index3 = open + nextEvents.length - 2;
            break;
          }
        }
      }
    }
    index3 = -1;
    while (++index3 < events2.length) {
      if (events2[index3][1].type === "strikethroughSequenceTemporary") {
        events2[index3][1].type = types2.data;
      }
    }
    return events2;
  }
  function tokenizeStrikethrough(effects, ok3, nok) {
    const previous3 = this.previous;
    const events2 = this.events;
    let size3 = 0;
    return start2;
    function start2(code3) {
      ok(code3 === codes.tilde, "expected `~`");
      if (previous3 === codes.tilde && events2[events2.length - 1][1].type !== types2.characterEscape) {
        return nok(code3);
      }
      effects.enter("strikethroughSequenceTemporary");
      return more(code3);
    }
    function more(code3) {
      const before = classifyCharacter(previous3);
      if (code3 === codes.tilde) {
        if (size3 > 1)
          return nok(code3);
        effects.consume(code3);
        size3++;
        return more;
      }
      if (size3 < 2 && !single)
        return nok(code3);
      const token2 = effects.exit("strikethroughSequenceTemporary");
      const after = classifyCharacter(code3);
      token2._open = !after || after === constants.attentionSideAfter && Boolean(before);
      token2._close = !before || before === constants.attentionSideAfter && Boolean(after);
      return ok3(code3);
    }
  }
}

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-panelLeftOpenIcon.js
var import_jsx_runtime70 = __toESM(require_jsx_runtime());
var panelLeftOpenIcon = (0, import_jsx_runtime70.jsxs)(import_jsx_runtime70.Fragment, {
  children: [(0, import_jsx_runtime70.jsx)("rect", {
    width: 18,
    height: 18,
    x: 3,
    y: 3,
    rx: 2
  }), (0, import_jsx_runtime70.jsx)("path", {
    d: "M9 3v18M14 9l3 3-3 3"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-panelLeftCloseIcon.js
var import_jsx_runtime71 = __toESM(require_jsx_runtime());
var panelLeftCloseIcon = (0, import_jsx_runtime71.jsxs)(import_jsx_runtime71.Fragment, {
  children: [(0, import_jsx_runtime71.jsx)("rect", {
    width: 18,
    height: 18,
    x: 3,
    y: 3,
    rx: 2
  }), (0, import_jsx_runtime71.jsx)("path", {
    d: "M9 3v18M16 15l-3-3 3-3"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-panelRightOpenIcon.js
var import_jsx_runtime72 = __toESM(require_jsx_runtime());
var panelRightOpenIcon = (0, import_jsx_runtime72.jsxs)(import_jsx_runtime72.Fragment, {
  children: [(0, import_jsx_runtime72.jsx)("rect", {
    width: 18,
    height: 18,
    x: 3,
    y: 3,
    rx: 2
  }), (0, import_jsx_runtime72.jsx)("path", {
    d: "M15 3v18M10 15l-3-3 3-3"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-panelRightCloseIcon.js
var import_jsx_runtime73 = __toESM(require_jsx_runtime());
var panelRightCloseIcon = (0, import_jsx_runtime73.jsxs)(import_jsx_runtime73.Fragment, {
  children: [(0, import_jsx_runtime73.jsx)("rect", {
    width: 18,
    height: 18,
    x: 3,
    y: 3,
    rx: 2
  }), (0, import_jsx_runtime73.jsx)("path", {
    d: "M15 3v18M8 9l3 3-3 3"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-badge.js
var import_react69 = __toESM(require_react());
var import_jsx_runtime74 = __toESM(require_jsx_runtime());
var Badge = (0, import_react69.forwardRef)(function Badge2(props, forwardedRef) {
  const {
    children,
    tone = "neutral",
    ...otherProps
  } = props;
  const styleProps = useStyleProps(otherProps);
  const bg = tone === "neutral" ? "surfaceSecondary" : tone;
  const fg = tone === "neutral" ? void 0 : tone;
  const slots = (0, import_react69.useMemo)(() => ({
    icon: {
      color: fg
    },
    text: {
      trim: false,
      color: fg,
      weight: "medium"
    }
  }), [fg]);
  return (0, import_jsx_runtime74.jsx)(Flex, {
    UNSAFE_className: styleProps.className,
    UNSAFE_style: styleProps.style,
    ref: forwardedRef,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps, {
      labelable: true
    }),
    // appearance
    backgroundColor: bg,
    borderRadius: "full",
    height: "element.small",
    minWidth: 0,
    paddingX: "regular",
    alignItems: "center",
    flexShrink: 0,
    gap: "small",
    inline: true,
    children: (0, import_jsx_runtime74.jsx)(SlotProvider, {
      slots,
      children: isReactText(children) ? (0, import_jsx_runtime74.jsx)(Text2, {
        children
      }) : children
    })
  });
});

// node_modules/@keystar/ui/dist/keystar-ui-nav-list.js
var import_react70 = __toESM(require_react());
var import_jsx_runtime75 = __toESM(require_jsx_runtime());
var listBlockGutter = tokenSchema.size.space.large;
var itemIndicatorGutter = tokenSchema.size.space.regular;
var itemIndicatorWidth = tokenSchema.size.space.small;
var itemContentGutter = tokenSchema.size.space.medium;
var textInsetStart = `calc(${itemIndicatorWidth} + ${itemIndicatorGutter} + ${itemContentGutter})`;
var NavList = (0, import_react70.forwardRef)(function NavList2(props, forwardedRef) {
  const {
    children,
    ...otherProps
  } = props;
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const styleProps = useStyleProps(otherProps);
  const dividerStyles = useDividerStyles();
  const currentItem = useCurrentItem(domRef);
  (0, import_react70.useEffect)(() => {
    if (currentItem) {
      currentItem.scrollIntoView({
        block: "center"
      });
    }
  }, [currentItem]);
  const slots = (0, import_react70.useMemo)(() => ({
    divider: {
      "aria-hidden": true,
      elementType: "li",
      size: "medium",
      UNSAFE_className: dividerStyles
    }
  }), [dividerStyles]);
  return (0, import_jsx_runtime75.jsx)(Flex, {
    elementType: "nav",
    ref: domRef,
    direction: "column",
    UNSAFE_className: styleProps.className,
    UNSAFE_style: styleProps.style,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps, {
      labelable: true
    }),
    children: (0, import_jsx_runtime75.jsx)(Flex, {
      direction: "column",
      elementType: "ul",
      flex: "1 0 0",
      children: (0, import_jsx_runtime75.jsx)(SlotProvider, {
        slots,
        children
      })
    })
  });
});
function useDividerStyles() {
  return css({
    marginBlock: listBlockGutter,
    marginInlineStart: textInsetStart,
    width: `calc(40% - ${textInsetStart} - ${itemContentGutter})`,
    // FIXME: magic numbers
    minWidth: 80,
    maxWidth: 240
  });
}
function useCurrentItem(ref) {
  let [currentItem, setCurrentItem] = (0, import_react70.useState)(null);
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    let el = ref.current && ref.current.querySelector("[aria-current]");
    if (el) {
      setCurrentItem(el);
    }
  }, [ref]);
  return currentItem;
}
var NavItem = (0, import_react70.forwardRef)(function NavItem2(props, forwardedRef) {
  const {
    "aria-current": ariaCurrent,
    children,
    href,
    ...otherProps
  } = props;
  const styles2 = useStyles();
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const {
    linkProps
  } = $298d61e98472621b$export$dcf14c9974fe2767(props, domRef);
  const slots = (0, import_react70.useMemo)(() => ({
    text: {
      color: "inherit",
      UNSAFE_className: styles2.text
    }
  }), [styles2.text]);
  return (0, import_jsx_runtime75.jsx)("li", {
    children: (0, import_jsx_runtime75.jsx)(FocusRing, {
      children: (0, import_jsx_runtime75.jsx)("a", {
        ref: domRef,
        "aria-current": ariaCurrent,
        href,
        className: classNames(styles2.anchor),
        ...linkProps,
        ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
        children: (0, import_jsx_runtime75.jsx)("div", {
          className: classNames(styles2.content),
          children: (0, import_jsx_runtime75.jsx)(SlotProvider, {
            slots,
            children: isReactText(children) ? (0, import_jsx_runtime75.jsx)(Text2, {
              children
            }) : children
          })
        })
      })
    })
  });
});
function useStyles() {
  const ringColor = tokenSchema.color.alias.focusRing;
  const ringWidth = tokenSchema.size.alias.focusRing;
  const anchor = css({
    color: tokenSchema.color.foreground.neutral,
    display: "flex",
    gap: itemIndicatorGutter,
    paddingBlock: tokenSchema.size.space.xsmall,
    outline: 0,
    // selected indicator
    "&::before": {
      borderRadius: itemIndicatorWidth,
      content: '""',
      insetInlineStart: tokenSchema.size.space.xsmall,
      marginBlock: tokenSchema.size.space.xsmall,
      position: "relative",
      width: itemIndicatorWidth
    },
    // interaction
    "&:hover": {
      color: tokenSchema.color.foreground.neutralEmphasis
    },
    // selection
    "&[aria-current]": {
      color: tokenSchema.color.foreground.neutralEmphasis,
      "&::before": {
        backgroundColor: tokenSchema.color.background.accentEmphasis
      }
    }
  });
  const content3 = css({
    alignItems: "center",
    borderRadius: tokenSchema.size.radius.regular,
    display: "flex",
    flex: 1,
    flexShrink: 0,
    gap: tokenSchema.size.space.regular,
    minHeight: tokenSchema.size.element.regular,
    minWidth: 0,
    paddingInline: tokenSchema.size.space.medium,
    paddingBlock: tokenSchema.size.space.small,
    position: "relative",
    // focus ring
    [`&::after`]: {
      borderRadius: tokenSchema.size.radius.regular,
      content: '""',
      insetBlock: 1,
      insetInline: -1,
      margin: 1,
      position: "absolute",
      transition: transition(["box-shadow", "margin"], {
        easing: "easeOut"
      })
    },
    [`.${anchor}[data-focus=visible] &::after`]: {
      boxShadow: `0 0 0 ${ringWidth} ${ringColor}`,
      margin: 0
    },
    [`.${anchor}[aria-current] &`]: {
      backgroundColor: tokenSchema.color.alias.backgroundHovered
    },
    [`.${anchor}:hover &`]: {
      backgroundColor: tokenSchema.color.alias.backgroundHovered
    },
    [`.${anchor}:active &`]: {
      backgroundColor: tokenSchema.color.alias.backgroundPressed
    }
  });
  const text7 = css({
    fontWeight: tokenSchema.typography.fontWeight.medium,
    [`.${anchor}[aria-current] &`]: {
      fontWeight: tokenSchema.typography.fontWeight.semibold
    }
  });
  return {
    anchor,
    content: content3,
    text: text7
  };
}
function NavGroup(props) {
  const {
    children,
    id: id2,
    title,
    ...otherProps
  } = props;
  const headingId = $bdb11010cef70236$export$f680877a34711e37(id2);
  const groupStyles = useGroupStyles();
  const headingStyles = useHeadingStyles2();
  return (0, import_jsx_runtime75.jsxs)("li", {
    className: classNames(groupStyles),
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
    children: [(0, import_jsx_runtime75.jsx)(Text2, {
      elementType: "h3",
      id: headingId,
      UNSAFE_className: headingStyles,
      children: title
    }), (0, import_jsx_runtime75.jsx)(Box, {
      elementType: "ul",
      flexShrink: 0,
      "aria-labelledby": headingId,
      children
    })]
  });
}
function useGroupStyles() {
  return css({
    "&:not(:first-child)": {
      marginBlockStart: listBlockGutter
    },
    "&:not(:last-child)": {
      marginBlockEnd: listBlockGutter
    }
  });
}
function useHeadingStyles2() {
  return css({
    color: tokenSchema.color.foreground.neutralSecondary,
    fontSize: tokenSchema.typography.text.small.size,
    fontWeight: tokenSchema.typography.fontWeight.medium,
    paddingBlock: tokenSchema.size.space.regular,
    paddingInlineEnd: itemContentGutter,
    paddingInlineStart: textInsetStart,
    textTransform: "uppercase"
  });
}

// node_modules/@keystar/ui/dist/keystar-ui-status-light.js
var import_react71 = __toESM(require_react());
var import_jsx_runtime76 = __toESM(require_jsx_runtime());
var StatusLight = (0, import_react71.forwardRef)(function StatusLight2(props, forwardedRef) {
  let {
    children,
    role,
    tone = "neutral"
  } = props;
  const styleProps = useStyleProps(props);
  if (!children && !props["aria-label"]) {
    console.warn("If no children are provided, an aria-label must be specified");
  }
  if (!role && (props["aria-label"] || props["aria-labelledby"])) {
    console.warn("A labelled StatusLight must have a role.");
  }
  return (0, import_jsx_runtime76.jsx)("div", {
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(props, {
      labelable: true
    }),
    ...styleProps,
    ref: forwardedRef,
    "data-tone": tone,
    className: classNames(css({
      alignItems: "center",
      color: tokenSchema.color.foreground.neutral,
      display: "flex",
      gap: tokenSchema.size.space.regular,
      height: tokenSchema.size.element.small,
      // indicator
      "&::before": {
        content: '""',
        backgroundColor: tokenSchema.color.foreground.neutralTertiary,
        borderRadius: tokenSchema.size.radius.full,
        height: tokenSchema.size.scale[100],
        width: tokenSchema.size.scale[100]
      },
      // special case for neutral
      "&[data-tone=neutral]": {
        color: tokenSchema.color.foreground.neutralSecondary
      },
      "&[data-tone=accent]::before": {
        backgroundColor: tokenSchema.color.background.accentEmphasis
      },
      "&[data-tone=caution]::before": {
        backgroundColor: tokenSchema.color.background.cautionEmphasis
      },
      "&[data-tone=critical]::before": {
        backgroundColor: tokenSchema.color.background.criticalEmphasis
      },
      "&[data-tone=pending]::before": {
        backgroundColor: tokenSchema.color.background.pendingEmphasis
      },
      "&[data-tone=positive]::before": {
        backgroundColor: tokenSchema.color.background.positiveEmphasis
      }
    }), styleProps.className),
    children: isReactText(children) ? (0, import_jsx_runtime76.jsx)(Text2, {
      color: "inherit",
      children
    }) : children
  });
});

// node_modules/@keystar/ui/dist/keystar-ui-avatar.js
var import_react72 = __toESM(require_react());
var import_jsx_runtime77 = __toESM(require_jsx_runtime());
var Avatar = (0, import_react72.forwardRef)(function Avatar2(props, forwardedRef) {
  const {
    alt,
    size: size3 = "regular",
    ...otherProps
  } = props;
  const styleProps = useStyleProps(otherProps);
  return (0, import_jsx_runtime77.jsx)("div", {
    ref: forwardedRef,
    role: "img",
    "aria-label": alt,
    "data-size": size3 === "regular" ? void 0 : size3,
    ...styleProps,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
    className: classNames(styleProps.className, css({
      alignItems: "center",
      backgroundColor: tokenSchema.color.background.surfaceTertiary,
      borderRadius: "50%",
      display: "inline-flex",
      flexShrink: 0,
      fontSize: "var(--avatar-text-size)",
      height: "var(--avatar-size)",
      justifyContent: "center",
      overflow: "hidden",
      width: "var(--avatar-size)",
      userSelect: "none",
      // sizes
      "--avatar-size": tokenSchema.size.element.regular,
      "--avatar-text-size": tokenSchema.typography.text.regular.size,
      "&[data-size=xsmall]": {
        "--avatar-size": tokenSchema.size.element.xsmall,
        "--avatar-text-size": tokenSchema.typography.text.small.size
      },
      "&[data-size=small]": {
        "--avatar-size": tokenSchema.size.element.small,
        "--avatar-text-size": tokenSchema.typography.text.small.size
      },
      "&[data-size=medium]": {
        "--avatar-size": tokenSchema.size.element.medium,
        "--avatar-text-size": tokenSchema.typography.text.medium.size
      },
      "&[data-size=large]": {
        "--avatar-size": tokenSchema.size.element.large,
        "--avatar-text-size": tokenSchema.typography.text.large.size
      },
      "&[data-size=xlarge]": {
        "--avatar-size": tokenSchema.size.element.xlarge,
        "--avatar-text-size": tokenSchema.typography.text.large.size
      }
    })),
    children: "src" in props ? (0, import_jsx_runtime77.jsx)("div", {
      className: css({
        height: "100%",
        width: "100%"
      }),
      style: {
        backgroundImage: `url(${props.src})`,
        backgroundPosition: "center",
        backgroundRepeat: "no-repeat",
        backgroundSize: "cover"
      }
    }) : (0, import_jsx_runtime77.jsx)(Text2, {
      "aria-hidden": true,
      color: "neutralSecondary",
      weight: "medium",
      UNSAFE_className: css({
        fontSize: "inherit"
      }),
      children: getInitials(props.name, size3)
    })
  });
});
function getInitials(name2, size3) {
  const words = name2.split(" ");
  const first = words[0].charAt(0);
  const last2 = words[words.length - 1].charAt(0);
  if (size3 === "xsmall") {
    return `${first}`.toUpperCase();
  }
  return `${first}${last2}`.toUpperCase();
}

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-logOutIcon.js
var import_jsx_runtime78 = __toESM(require_jsx_runtime());
var logOutIcon = (0, import_jsx_runtime78.jsx)("path", {
  d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4M16 17l5-5-5-5M21 12H9"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-gitPullRequestIcon.js
var import_jsx_runtime79 = __toESM(require_jsx_runtime());
var gitPullRequestIcon = (0, import_jsx_runtime79.jsxs)(import_jsx_runtime79.Fragment, {
  children: [(0, import_jsx_runtime79.jsx)("circle", {
    cx: 18,
    cy: 18,
    r: 3
  }), (0, import_jsx_runtime79.jsx)("circle", {
    cx: 6,
    cy: 6,
    r: 3
  }), (0, import_jsx_runtime79.jsx)("path", {
    d: "M13 6h3a2 2 0 0 1 2 2v7M6 9v12"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-gitBranchPlusIcon.js
var import_jsx_runtime80 = __toESM(require_jsx_runtime());
var gitBranchPlusIcon = (0, import_jsx_runtime80.jsxs)(import_jsx_runtime80.Fragment, {
  children: [(0, import_jsx_runtime80.jsx)("path", {
    d: "M6 3v12M18 9a3 3 0 1 0 0-6 3 3 0 0 0 0 6zM6 21a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"
  }), (0, import_jsx_runtime80.jsx)("path", {
    d: "M15 6a9 9 0 0 0-9 9M18 15v6M21 18h-6"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-githubIcon.js
var import_jsx_runtime81 = __toESM(require_jsx_runtime());
var githubIcon = (0, import_jsx_runtime81.jsxs)(import_jsx_runtime81.Fragment, {
  children: [(0, import_jsx_runtime81.jsx)("path", {
    d: "M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"
  }), (0, import_jsx_runtime81.jsx)("path", {
    d: "M9 18c-4.51 2-5-2-7-2"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-gitForkIcon.js
var import_jsx_runtime82 = __toESM(require_jsx_runtime());
var gitForkIcon = (0, import_jsx_runtime82.jsxs)(import_jsx_runtime82.Fragment, {
  children: [(0, import_jsx_runtime82.jsx)("circle", {
    cx: 12,
    cy: 18,
    r: 3
  }), (0, import_jsx_runtime82.jsx)("circle", {
    cx: 6,
    cy: 6,
    r: 3
  }), (0, import_jsx_runtime82.jsx)("circle", {
    cx: 18,
    cy: 6,
    r: 3
  }), (0, import_jsx_runtime82.jsx)("path", {
    d: "M18 9v2c0 .6-.4 1-1 1H7c-.6 0-1-.4-1-1V9M12 12v3"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-monitorIcon.js
var import_jsx_runtime83 = __toESM(require_jsx_runtime());
var monitorIcon = (0, import_jsx_runtime83.jsxs)(import_jsx_runtime83.Fragment, {
  children: [(0, import_jsx_runtime83.jsx)("rect", {
    width: 20,
    height: 14,
    x: 2,
    y: 3,
    rx: 2
  }), (0, import_jsx_runtime83.jsx)("path", {
    d: "M8 21h8M12 17v4"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-moonIcon.js
var import_jsx_runtime84 = __toESM(require_jsx_runtime());
var moonIcon = (0, import_jsx_runtime84.jsx)("path", {
  d: "M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-sunIcon.js
var import_jsx_runtime85 = __toESM(require_jsx_runtime());
var sunIcon = (0, import_jsx_runtime85.jsxs)(import_jsx_runtime85.Fragment, {
  children: [(0, import_jsx_runtime85.jsx)("circle", {
    cx: 12,
    cy: 12,
    r: 4
  }), (0, import_jsx_runtime85.jsx)("path", {
    d: "M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M6.34 17.66l-1.41 1.41M19.07 4.93l-1.41 1.41"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-userIcon.js
var import_jsx_runtime86 = __toESM(require_jsx_runtime());
var userIcon = (0, import_jsx_runtime86.jsxs)(import_jsx_runtime86.Fragment, {
  children: [(0, import_jsx_runtime86.jsx)("path", {
    d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"
  }), (0, import_jsx_runtime86.jsx)("circle", {
    cx: 12,
    cy: 7,
    r: 4
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-gitBranchIcon.js
var import_jsx_runtime87 = __toESM(require_jsx_runtime());
var gitBranchIcon = (0, import_jsx_runtime87.jsxs)(import_jsx_runtime87.Fragment, {
  children: [(0, import_jsx_runtime87.jsx)("path", {
    d: "M6 3v12"
  }), (0, import_jsx_runtime87.jsx)("circle", {
    cx: 18,
    cy: 6,
    r: 3
  }), (0, import_jsx_runtime87.jsx)("circle", {
    cx: 6,
    cy: 18,
    r: 3
  }), (0, import_jsx_runtime87.jsx)("path", {
    d: "M18 9a9 9 0 0 1-9 9"
  })]
});

// node_modules/@react-aria/radio/dist/import.mjs
var $884aeceb3d67f00f$export$37b65e5b5444d35c = /* @__PURE__ */ new WeakMap();
function $0d5c49892c1215da$export$37b0961d2f4751e2(props, state, ref) {
  let { value: value2, children, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledby } = props;
  const isDisabled = props.isDisabled || state.isDisabled;
  let hasChildren = children != null;
  let hasAriaLabel = ariaLabel != null || ariaLabelledby != null;
  if (!hasChildren && !hasAriaLabel)
    console.warn("If you do not provide children, you must specify an aria-label for accessibility");
  let checked = state.selectedValue === value2;
  let onChange2 = (e6) => {
    e6.stopPropagation();
    state.setSelectedValue(value2);
  };
  let { pressProps, isPressed } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    isDisabled
  });
  let { pressProps: labelProps, isPressed: isLabelPressed } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    isDisabled,
    onPress() {
      state.setSelectedValue(value2);
    }
  });
  let { focusableProps } = (0, $e6afbd83fe6ebbd2$export$4c014de7c8940b4c)((0, $3ef42575df84b30b$export$9d1611c77c2fe928)(props, {
    onFocus: () => state.setLastFocusedValue(value2)
  }), ref);
  let interactions = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(pressProps, focusableProps);
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let tabIndex = -1;
  if (state.selectedValue != null) {
    if (state.selectedValue === value2)
      tabIndex = 0;
  } else if (state.lastFocusedValue === value2 || state.lastFocusedValue == null)
    tabIndex = 0;
  if (isDisabled)
    tabIndex = void 0;
  let { name: name2, descriptionId, errorMessageId, validationBehavior } = (0, $884aeceb3d67f00f$export$37b65e5b5444d35c).get(state);
  (0, $99facab73266f662$export$5add1d006293d136)(ref, state.selectedValue, state.setSelectedValue);
  (0, $e93e671b31057976$export$b8473d3665f3a75a)({
    validationBehavior
  }, state, ref);
  return {
    labelProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(labelProps, {
      onClick: (e6) => e6.preventDefault()
    }),
    inputProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, {
      ...interactions,
      type: "radio",
      name: name2,
      tabIndex,
      disabled: isDisabled,
      required: state.isRequired && validationBehavior === "native",
      checked,
      value: value2,
      onChange: onChange2,
      "aria-describedby": [
        props["aria-describedby"],
        state.isInvalid ? errorMessageId : null,
        descriptionId
      ].filter(Boolean).join(" ") || void 0
    }),
    isDisabled,
    isSelected: checked,
    isPressed: isPressed || isLabelPressed
  };
}
function $430f30ed08ec25fa$export$62b9571f283ff5c2(props, state) {
  let { name: name2, isReadOnly, isRequired, isDisabled, orientation = "vertical", validationBehavior = "aria" } = props;
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let { isInvalid, validationErrors, validationDetails } = state.displayValidation;
  let { labelProps, fieldProps, descriptionProps, errorMessageProps } = (0, $2baaea4c71418dea$export$294aa081a6c6f55d)({
    ...props,
    // Radio group is not an HTML input element so it
    // shouldn't be labeled by a <label> element.
    labelElementType: "span",
    isInvalid: state.isInvalid,
    errorMessage: props.errorMessage || validationErrors
  });
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let { focusWithinProps } = (0, $9ab94262bd0047c7$export$420e68273165f4ec)({
    onBlurWithin(e6) {
      var _props_onBlur;
      (_props_onBlur = props.onBlur) === null || _props_onBlur === void 0 ? void 0 : _props_onBlur.call(props, e6);
      if (!state.selectedValue)
        state.setLastFocusedValue(null);
    },
    onFocusWithin: props.onFocus,
    onFocusWithinChange: props.onFocusChange
  });
  let onKeyDown = (e6) => {
    let nextDir;
    switch (e6.key) {
      case "ArrowRight":
        if (direction === "rtl" && orientation !== "vertical")
          nextDir = "prev";
        else
          nextDir = "next";
        break;
      case "ArrowLeft":
        if (direction === "rtl" && orientation !== "vertical")
          nextDir = "next";
        else
          nextDir = "prev";
        break;
      case "ArrowDown":
        nextDir = "next";
        break;
      case "ArrowUp":
        nextDir = "prev";
        break;
      default:
        return;
    }
    e6.preventDefault();
    let walker = (0, $9bf71ea28793e738$export$2d6ec8fc375ceafa)(e6.currentTarget, {
      from: e6.target
    });
    let nextElem;
    if (nextDir === "next") {
      nextElem = walker.nextNode();
      if (!nextElem) {
        walker.currentNode = e6.currentTarget;
        nextElem = walker.firstChild();
      }
    } else {
      nextElem = walker.previousNode();
      if (!nextElem) {
        walker.currentNode = e6.currentTarget;
        nextElem = walker.lastChild();
      }
    }
    if (nextElem) {
      nextElem.focus();
      state.setSelectedValue(nextElem.value);
    }
  };
  let groupName = (0, $bdb11010cef70236$export$f680877a34711e37)(name2);
  (0, $884aeceb3d67f00f$export$37b65e5b5444d35c).set(state, {
    name: groupName,
    descriptionId: descriptionProps.id,
    errorMessageId: errorMessageProps.id,
    validationBehavior
  });
  return {
    radioGroupProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, {
      // https://www.w3.org/TR/wai-aria-1.2/#radiogroup
      role: "radiogroup",
      onKeyDown,
      "aria-invalid": state.isInvalid || void 0,
      "aria-errormessage": props["aria-errormessage"],
      "aria-readonly": isReadOnly || void 0,
      "aria-required": isRequired || void 0,
      "aria-disabled": isDisabled || void 0,
      "aria-orientation": orientation,
      ...fieldProps,
      ...focusWithinProps
    }),
    labelProps,
    descriptionProps,
    errorMessageProps,
    isInvalid,
    validationErrors,
    validationDetails
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-radio.js
var import_react74 = __toESM(require_react());
var import_jsx_runtime88 = __toESM(require_jsx_runtime());

// node_modules/@react-stately/radio/dist/import.mjs
var import_react73 = __toESM(require_react(), 1);
var $a54cdc5c1942b639$var$instance = Math.round(Math.random() * 1e10);
var $a54cdc5c1942b639$var$i = 0;
function $a54cdc5c1942b639$export$bca9d026f8e704eb(props) {
  let name2 = (0, import_react73.useMemo)(() => props.name || `radio-group-${$a54cdc5c1942b639$var$instance}-${++$a54cdc5c1942b639$var$i}`, [
    props.name
  ]);
  var _props_defaultValue;
  let [selectedValue, setSelected] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(props.value, (_props_defaultValue = props.defaultValue) !== null && _props_defaultValue !== void 0 ? _props_defaultValue : null, props.onChange);
  let [lastFocusedValue, setLastFocusedValue] = (0, import_react73.useState)(null);
  let validation = (0, $e5be200c675c3b3a$export$fc1a364ae1f3ff10)({
    ...props,
    value: selectedValue
  });
  let setSelectedValue = (value2) => {
    if (!props.isReadOnly && !props.isDisabled) {
      setSelected(value2);
      validation.commitValidation();
    }
  };
  let isInvalid = validation.displayValidation.isInvalid;
  return {
    ...validation,
    name: name2,
    selectedValue,
    setSelectedValue,
    lastFocusedValue,
    setLastFocusedValue,
    isDisabled: props.isDisabled || false,
    isReadOnly: props.isReadOnly || false,
    isRequired: props.isRequired || false,
    validationState: props.validationState || (isInvalid ? "invalid" : null),
    isInvalid
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-radio.js
var RadioContext = import_react74.default.createContext(null);
function useRadioProvider() {
  const context = import_react74.default.useContext(RadioContext);
  if (!context) {
    throw new Error("useRadioProvider must be used within a RadioGroupProvider");
  }
  return context;
}
var radioClassList = new ClassList("Radio", ["indicator"]);
function Radio(props) {
  let {
    children,
    autoFocus,
    ...otherProps
  } = props;
  let styleProps = useStyleProps(otherProps);
  let inputRef = (0, import_react74.useRef)(null);
  let radioGroupProps = useRadioProvider();
  let {
    state
  } = radioGroupProps;
  let {
    inputProps
  } = $0d5c49892c1215da$export$37b0961d2f4751e2({
    ...props,
    ...radioGroupProps
  }, state, inputRef);
  const inputClassName = css({
    position: "absolute",
    zIndex: 1,
    inset: 0,
    opacity: 1e-4
  });
  const labelClassName = css({
    alignItems: "flex-start",
    display: "inline-flex",
    gap: tokenSchema.size.space.regular,
    position: "relative",
    userSelect: "none"
  });
  const slots = (0, import_react74.useMemo)(() => ({
    text: {
      color: "inherit"
    },
    description: {
      color: "neutralTertiary"
    }
  }), []);
  return (0, import_jsx_runtime88.jsxs)("label", {
    className: classNames(styleProps.className, labelClassName),
    style: styleProps.style,
    children: [(0, import_jsx_runtime88.jsx)(FocusRing, {
      autoFocus,
      children: (0, import_jsx_runtime88.jsx)("input", {
        ...inputProps,
        ref: inputRef,
        className: classNames(inputClassName)
      })
    }), (0, import_jsx_runtime88.jsx)(Indicator2, {
      inputClassName
    }), (0, import_jsx_runtime88.jsx)(SlotProvider, {
      slots,
      children: children && (0, import_jsx_runtime88.jsx)(Content3, {
        children: isReactText(children) ? (0, import_jsx_runtime88.jsx)(Text2, {
          children
        }) : children
      })
    })]
  });
}
var sizeToken2 = tokenSchema.size.element.xsmall;
var Indicator2 = (props) => {
  let {
    inputClassName
  } = props;
  return (0, import_jsx_runtime88.jsx)("span", {
    className: classNames(css({
      backgroundColor: tokenSchema.color.background.canvas,
      borderRadius: tokenSchema.size.radius.full,
      color: tokenSchema.color.foreground.onEmphasis,
      display: "flex",
      flexShrink: 0,
      justifyContent: "center",
      alignItems: "center",
      position: "relative",
      height: sizeToken2,
      width: sizeToken2,
      // indicator icons
      [radioClassList.selector("indicator")]: {
        opacity: 0,
        transform: `scale(0) translate3d(0, 0, 0)`,
        transition: transition(["opacity", "transform"]),
        willChange: "opacity, transform"
      },
      // focus ring
      "::after": {
        borderRadius: tokenSchema.size.radius.full,
        content: '""',
        inset: 0,
        margin: 0,
        position: "absolute",
        transition: transition(["box-shadow", "margin"], {
          easing: "easeOut"
        })
      },
      [`.${inputClassName}[data-focus=visible] + &::after`]: {
        boxShadow: `0 0 0 ${tokenSchema.size.alias.focusRing} ${tokenSchema.color.alias.focusRing}`,
        margin: `calc(${tokenSchema.size.alias.focusRingGap} * -1)`
      },
      // border / background
      "&::before": {
        border: `${tokenSchema.size.border.medium} solid ${tokenSchema.color.alias.borderIdle}`,
        borderRadius: `inherit`,
        content: '""',
        inset: 0,
        margin: 0,
        position: "absolute",
        transition: transition(["border-color", "border-width"], {
          duration: "regular"
        })
      },
      [`.${inputClassName}:disabled + &`]: {
        color: tokenSchema.color.alias.foregroundDisabled,
        "&::before": {
          borderColor: tokenSchema.color.alias.borderDisabled
        }
      },
      [`.${inputClassName}:enabled:hover + &::before`]: {
        borderColor: tokenSchema.color.alias.borderHovered
      },
      [`.${inputClassName}:enabled:active + &::before`]: {
        borderColor: tokenSchema.color.alias.borderPressed
      },
      // checked states
      [`.${inputClassName}:checked + &`]: {
        "&::before": {
          borderWidth: `calc(${sizeToken2} / 2)`
        },
        [radioClassList.selector("indicator")]: {
          opacity: 1,
          transform: `scale(1)`
        }
      },
      [`.${inputClassName}:enabled:checked + &::before`]: {
        borderColor: tokenSchema.color.scale.indigo9
      },
      [`.${inputClassName}:enabled:checked:hover + &::before`]: {
        borderColor: tokenSchema.color.scale.indigo10
      },
      [`.${inputClassName}:enabled:checked:active + &::before`]: {
        borderColor: tokenSchema.color.scale.indigo11
      }
    })),
    children: (0, import_jsx_runtime88.jsx)("span", {
      className: radioClassList.element("indicator"),
      children: (0, import_jsx_runtime88.jsx)("svg", {
        className: resetClassName,
        fill: "currentColor",
        height: 12,
        viewBox: "0 0 24 24",
        width: 12,
        children: (0, import_jsx_runtime88.jsx)("circle", {
          cx: "12",
          cy: "12",
          r: "6"
        })
      })
    })
  });
};
var Content3 = (props) => {
  return (0, import_jsx_runtime88.jsx)("div", {
    className: classNames(css({
      color: tokenSchema.color.alias.foregroundIdle,
      display: "grid",
      paddingTop: `calc((${sizeToken2} - ${tokenSchema.typography.text.regular.capheight}) / 2)`,
      gap: tokenSchema.size.space.large,
      'input[type="radio"]:hover ~ &': {
        color: tokenSchema.color.alias.foregroundHovered
      },
      'input[type="radio"]:disabled ~ &': {
        color: tokenSchema.color.alias.foregroundDisabled
      }
    })),
    ...props
  });
};
var RadioGroup = (0, import_react74.forwardRef)(function RadioGroup2(props, forwardedRef) {
  props = useProviderProps(props);
  props = validateFieldProps(props);
  let {
    validationState,
    children,
    orientation = "vertical"
  } = props;
  let state = $a54cdc5c1942b639$export$bca9d026f8e704eb(props);
  let {
    radioGroupProps,
    labelProps,
    descriptionProps,
    errorMessageProps
  } = $430f30ed08ec25fa$export$62b9571f283ff5c2(props, state);
  return (0, import_jsx_runtime88.jsx)(FieldPrimitive, {
    ...props,
    ref: forwardedRef,
    labelProps,
    descriptionProps,
    errorMessageProps,
    children: (0, import_jsx_runtime88.jsx)("div", {
      ...radioGroupProps,
      ...toDataAttributes({
        orientation
      }),
      className: classNames(css({
        display: "flex",
        gap: tokenSchema.size.space.large,
        '&[data-orientation="vertical"]': {
          flexDirection: "column"
        }
      })),
      children: (0, import_jsx_runtime88.jsx)(RadioContext.Provider, {
        value: {
          validationState,
          state
        },
        children
      })
    })
  });
});

// node_modules/@react-stately/toast/dist/import.mjs
var import_react75 = __toESM(require_react(), 1);
var import_shim = __toESM(require_shim(), 1);
function $77b352cf12efcf73$export$84726ef35ca2129a(queue) {
  let subscribe5 = (0, import_react75.useCallback)((fn2) => queue.subscribe(fn2), [
    queue
  ]);
  let getSnapshot = (0, import_react75.useCallback)(() => queue.visibleToasts, [
    queue
  ]);
  let visibleToasts = (0, import_shim.useSyncExternalStore)(subscribe5, getSnapshot, getSnapshot);
  return {
    visibleToasts,
    add: (content3, options) => queue.add(content3, options),
    close: (key) => queue.close(key),
    remove: (key) => queue.remove(key),
    pauseAll: () => queue.pauseAll(),
    resumeAll: () => queue.resumeAll()
  };
}
var $77b352cf12efcf73$export$f1f8569633bbbec4 = class {
  /** Subscribes to updates to the visible toasts. */
  subscribe(fn2) {
    this.subscriptions.add(fn2);
    return () => this.subscriptions.delete(fn2);
  }
  /** Adds a new toast to the queue. */
  add(content3, options = {}) {
    let toastKey = Math.random().toString(36);
    let toast = {
      ...options,
      content: content3,
      key: toastKey,
      timer: options.timeout ? new $77b352cf12efcf73$var$Timer(() => this.close(toastKey), options.timeout) : null
    };
    let low = 0;
    let high = this.queue.length;
    while (low < high) {
      let mid = Math.floor((low + high) / 2);
      if ((toast.priority || 0) > (this.queue[mid].priority || 0))
        high = mid;
      else
        low = mid + 1;
    }
    this.queue.splice(low, 0, toast);
    toast.animation = low < this.maxVisibleToasts ? "entering" : "queued";
    let i6 = this.maxVisibleToasts;
    while (i6 < this.queue.length)
      this.queue[i6++].animation = "queued";
    this.updateVisibleToasts();
    return toastKey;
  }
  /**
  * Closes a toast. If `hasExitAnimation` is true, the toast
  * transitions to an "exiting" state instead of being removed immediately.
  */
  close(key) {
    let index3 = this.queue.findIndex((t5) => t5.key === key);
    if (index3 >= 0) {
      var _this_queue_index, _this_queue_index_onClose;
      (_this_queue_index_onClose = (_this_queue_index = this.queue[index3]).onClose) === null || _this_queue_index_onClose === void 0 ? void 0 : _this_queue_index_onClose.call(_this_queue_index);
      this.queue.splice(index3, 1);
    }
    this.updateVisibleToasts();
  }
  /** Removes a toast from the visible toasts after an exiting animation. */
  remove(key) {
    this.visibleToasts = this.visibleToasts.filter((t5) => t5.key !== key);
    this.updateVisibleToasts();
  }
  updateVisibleToasts() {
    let toasts = this.queue.slice(0, this.maxVisibleToasts);
    if (this.hasExitAnimation) {
      let prevToasts = this.visibleToasts.filter((t5) => !toasts.some((t22) => t5.key === t22.key)).map((t5) => ({
        ...t5,
        animation: "exiting"
      }));
      this.visibleToasts = prevToasts.concat(toasts).sort((a3, b2) => b2.priority - a3.priority);
    } else
      this.visibleToasts = toasts;
    for (let fn2 of this.subscriptions)
      fn2();
  }
  /** Pauses the timers for all visible toasts. */
  pauseAll() {
    for (let toast of this.visibleToasts)
      if (toast.timer)
        toast.timer.pause();
  }
  /** Resumes the timers for all visible toasts. */
  resumeAll() {
    for (let toast of this.visibleToasts)
      if (toast.timer)
        toast.timer.resume();
  }
  constructor(options) {
    this.queue = [];
    this.subscriptions = /* @__PURE__ */ new Set();
    this.visibleToasts = [];
    var _options_maxVisibleToasts;
    this.maxVisibleToasts = (_options_maxVisibleToasts = options === null || options === void 0 ? void 0 : options.maxVisibleToasts) !== null && _options_maxVisibleToasts !== void 0 ? _options_maxVisibleToasts : 1;
    var _options_hasExitAnimation;
    this.hasExitAnimation = (_options_hasExitAnimation = options === null || options === void 0 ? void 0 : options.hasExitAnimation) !== null && _options_hasExitAnimation !== void 0 ? _options_hasExitAnimation : false;
  }
};
var $77b352cf12efcf73$var$Timer = class {
  reset(delay) {
    this.remaining = delay;
    this.resume();
  }
  pause() {
    if (this.timerId == null)
      return;
    clearTimeout(this.timerId);
    this.timerId = null;
    this.remaining -= Date.now() - this.startTime;
  }
  resume() {
    if (this.remaining <= 0)
      return;
    this.startTime = Date.now();
    this.timerId = setTimeout(() => {
      this.timerId = null;
      this.remaining = 0;
      this.callback();
    }, this.remaining);
  }
  constructor(callback, delay) {
    this.remaining = delay;
    this.callback = callback;
  }
};

// node_modules/@keystar/ui/dist/keystar-ui-toast.js
var import_react78 = __toESM(require_react());

// node_modules/@react-aria/toast/dist/import.mjs
var import_react77 = __toESM(require_react(), 1);

// node_modules/@react-aria/landmark/dist/import.mjs
var import_react76 = __toESM(require_react(), 1);
var import_shim2 = __toESM(require_shim(), 1);
var $a86207c5d7f7e1fb$var$LANDMARK_API_VERSION = 1;
var $a86207c5d7f7e1fb$var$landmarkSymbol = Symbol.for("react-aria-landmark-manager");
function $a86207c5d7f7e1fb$var$subscribe(fn2) {
  document.addEventListener("react-aria-landmark-manager-change", fn2);
  return () => document.removeEventListener("react-aria-landmark-manager-change", fn2);
}
function $a86207c5d7f7e1fb$var$getLandmarkManager() {
  if (typeof document === "undefined")
    return null;
  let instance = document[$a86207c5d7f7e1fb$var$landmarkSymbol];
  if (instance && instance.version >= $a86207c5d7f7e1fb$var$LANDMARK_API_VERSION)
    return instance;
  document[$a86207c5d7f7e1fb$var$landmarkSymbol] = new $a86207c5d7f7e1fb$var$LandmarkManager();
  document.dispatchEvent(new CustomEvent("react-aria-landmark-manager-change"));
  return document[$a86207c5d7f7e1fb$var$landmarkSymbol];
}
function $a86207c5d7f7e1fb$var$useLandmarkManager() {
  return (0, import_shim2.useSyncExternalStore)($a86207c5d7f7e1fb$var$subscribe, $a86207c5d7f7e1fb$var$getLandmarkManager, $a86207c5d7f7e1fb$var$getLandmarkManager);
}
var $a86207c5d7f7e1fb$var$LandmarkManager = class {
  setupIfNeeded() {
    if (this.isListening)
      return;
    document.addEventListener("keydown", this.f6Handler, {
      capture: true
    });
    document.addEventListener("focusin", this.focusinHandler, {
      capture: true
    });
    document.addEventListener("focusout", this.focusoutHandler, {
      capture: true
    });
    this.isListening = true;
  }
  teardownIfNeeded() {
    if (!this.isListening || this.landmarks.length > 0 || this.refCount > 0)
      return;
    document.removeEventListener("keydown", this.f6Handler, {
      capture: true
    });
    document.removeEventListener("focusin", this.focusinHandler, {
      capture: true
    });
    document.removeEventListener("focusout", this.focusoutHandler, {
      capture: true
    });
    this.isListening = false;
  }
  focusLandmark(landmark, direction) {
    var _this_landmarks_find, _this_landmarks_find_focus;
    (_this_landmarks_find = this.landmarks.find((l7) => l7.ref.current === landmark)) === null || _this_landmarks_find === void 0 ? void 0 : (_this_landmarks_find_focus = _this_landmarks_find.focus) === null || _this_landmarks_find_focus === void 0 ? void 0 : _this_landmarks_find_focus.call(_this_landmarks_find, direction);
  }
  /**
  * Return set of landmarks with a specific role.
  */
  getLandmarksByRole(role) {
    return new Set(this.landmarks.filter((l7) => l7.role === role));
  }
  /**
  * Return first landmark with a specific role.
  */
  getLandmarkByRole(role) {
    return this.landmarks.find((l7) => l7.role === role);
  }
  addLandmark(newLandmark) {
    this.setupIfNeeded();
    if (this.landmarks.find((landmark) => landmark.ref === newLandmark.ref) || !newLandmark.ref.current)
      return;
    if (this.landmarks.filter((landmark) => landmark.role === "main").length > 1)
      console.error('Page can contain no more than one landmark with the role "main".');
    if (this.landmarks.length === 0) {
      this.landmarks = [
        newLandmark
      ];
      this.checkLabels(newLandmark.role);
      return;
    }
    let start2 = 0;
    let end = this.landmarks.length - 1;
    while (start2 <= end) {
      let mid = Math.floor((start2 + end) / 2);
      let comparedPosition = newLandmark.ref.current.compareDocumentPosition(this.landmarks[mid].ref.current);
      let isNewAfterExisting = Boolean(comparedPosition & Node.DOCUMENT_POSITION_PRECEDING || comparedPosition & Node.DOCUMENT_POSITION_CONTAINS);
      if (isNewAfterExisting)
        start2 = mid + 1;
      else
        end = mid - 1;
    }
    this.landmarks.splice(start2, 0, newLandmark);
    this.checkLabels(newLandmark.role);
  }
  updateLandmark(landmark) {
    let index3 = this.landmarks.findIndex((l7) => l7.ref === landmark.ref);
    if (index3 >= 0) {
      this.landmarks[index3] = {
        ...this.landmarks[index3],
        ...landmark
      };
      this.checkLabels(this.landmarks[index3].role);
    }
  }
  removeLandmark(ref) {
    this.landmarks = this.landmarks.filter((landmark) => landmark.ref !== ref);
    this.teardownIfNeeded();
  }
  /**
  * Warn if there are 2+ landmarks with the same role but no label.
  * Labels for landmarks with the same role must also be unique.
  *
  * See https://www.w3.org/WAI/ARIA/apg/practices/landmark-regions/.
  */
  checkLabels(role) {
    let landmarksWithRole = this.getLandmarksByRole(role);
    if (landmarksWithRole.size > 1) {
      let duplicatesWithoutLabel = [
        ...landmarksWithRole
      ].filter((landmark) => !landmark.label);
      if (duplicatesWithoutLabel.length > 0)
        console.warn(`Page contains more than one landmark with the '${role}' role. If two or more landmarks on a page share the same role, all must be labeled with an aria-label or aria-labelledby attribute: `, duplicatesWithoutLabel.map((landmark) => landmark.ref.current));
      else {
        let labels = [
          ...landmarksWithRole
        ].map((landmark) => landmark.label);
        let duplicateLabels = labels.filter((item2, index3) => labels.indexOf(item2) !== index3);
        duplicateLabels.forEach((label) => {
          console.warn(`Page contains more than one landmark with the '${role}' role and '${label}' label. If two or more landmarks on a page share the same role, they must have unique labels: `, [
            ...landmarksWithRole
          ].filter((landmark) => landmark.label === label).map((landmark) => landmark.ref.current));
        });
      }
    }
  }
  /**
  * Get the landmark that is the closest parent in the DOM.
  * Returns undefined if no parent is a landmark.
  */
  closestLandmark(element4) {
    let landmarkMap = new Map(this.landmarks.map((l7) => [
      l7.ref.current,
      l7
    ]));
    let currentElement = element4;
    while (currentElement && !landmarkMap.has(currentElement) && currentElement !== document.body && currentElement.parentElement)
      currentElement = currentElement.parentElement;
    return landmarkMap.get(currentElement);
  }
  /**
  * Gets the next landmark, in DOM focus order, or previous if backwards is specified.
  * If last landmark, next should be the first landmark.
  * If not inside a landmark, will return first landmark.
  * Returns undefined if there are no landmarks.
  */
  getNextLandmark(element4, { backward }) {
    var _this_landmarks_nextLandmarkIndex_ref_current;
    let currentLandmark = this.closestLandmark(element4);
    let nextLandmarkIndex = backward ? this.landmarks.length - 1 : 0;
    if (currentLandmark)
      nextLandmarkIndex = this.landmarks.indexOf(currentLandmark) + (backward ? -1 : 1);
    let wrapIfNeeded = () => {
      if (nextLandmarkIndex < 0) {
        if (!element4.dispatchEvent(new CustomEvent("react-aria-landmark-navigation", {
          detail: {
            direction: "backward"
          },
          bubbles: true,
          cancelable: true
        })))
          return true;
        nextLandmarkIndex = this.landmarks.length - 1;
      } else if (nextLandmarkIndex >= this.landmarks.length) {
        if (!element4.dispatchEvent(new CustomEvent("react-aria-landmark-navigation", {
          detail: {
            direction: "forward"
          },
          bubbles: true,
          cancelable: true
        })))
          return true;
        nextLandmarkIndex = 0;
      }
      if (nextLandmarkIndex < 0 || nextLandmarkIndex >= this.landmarks.length)
        return true;
      return false;
    };
    if (wrapIfNeeded())
      return void 0;
    let i6 = nextLandmarkIndex;
    while ((_this_landmarks_nextLandmarkIndex_ref_current = this.landmarks[nextLandmarkIndex].ref.current) === null || _this_landmarks_nextLandmarkIndex_ref_current === void 0 ? void 0 : _this_landmarks_nextLandmarkIndex_ref_current.closest("[aria-hidden=true]")) {
      nextLandmarkIndex += backward ? -1 : 1;
      if (wrapIfNeeded())
        return void 0;
      if (nextLandmarkIndex === i6)
        break;
    }
    return this.landmarks[nextLandmarkIndex];
  }
  /**
  * Look at next landmark. If an element was previously focused inside, restore focus there.
  * If not, focus the landmark itself.
  * If no landmarks at all, or none with focusable elements, don't move focus.
  */
  f6Handler(e6) {
    if (e6.key === "F6") {
      let handled = e6.altKey ? this.focusMain() : this.navigate(e6.target, e6.shiftKey);
      if (handled) {
        e6.preventDefault();
        e6.stopPropagation();
      }
    }
  }
  focusMain() {
    let main = this.getLandmarkByRole("main");
    if (main && main.ref.current && document.contains(main.ref.current)) {
      this.focusLandmark(main.ref.current, "forward");
      return true;
    }
    return false;
  }
  navigate(from4, backward) {
    let nextLandmark = this.getNextLandmark(from4, {
      backward
    });
    if (!nextLandmark)
      return false;
    if (nextLandmark.lastFocused) {
      let lastFocused = nextLandmark.lastFocused;
      if (document.body.contains(lastFocused)) {
        lastFocused.focus();
        return true;
      }
    }
    if (nextLandmark.ref.current && document.contains(nextLandmark.ref.current)) {
      this.focusLandmark(nextLandmark.ref.current, backward ? "backward" : "forward");
      return true;
    }
    return false;
  }
  /**
  * Sets lastFocused for a landmark, if focus is moved within that landmark.
  * Lets the last focused landmark know it was blurred if something else is focused.
  */
  focusinHandler(e6) {
    let currentLandmark = this.closestLandmark(e6.target);
    if (currentLandmark && currentLandmark.ref.current !== e6.target)
      this.updateLandmark({
        ref: currentLandmark.ref,
        lastFocused: e6.target
      });
    let previousFocusedElement = e6.relatedTarget;
    if (previousFocusedElement) {
      let closestPreviousLandmark = this.closestLandmark(previousFocusedElement);
      if (closestPreviousLandmark && closestPreviousLandmark.ref.current === previousFocusedElement)
        closestPreviousLandmark.blur();
    }
  }
  /**
  * Track if the focus is lost to the body. If it is, do cleanup on the landmark that last had focus.
  */
  focusoutHandler(e6) {
    let previousFocusedElement = e6.target;
    let nextFocusedElement = e6.relatedTarget;
    if (!nextFocusedElement || nextFocusedElement === document) {
      let closestPreviousLandmark = this.closestLandmark(previousFocusedElement);
      if (closestPreviousLandmark && closestPreviousLandmark.ref.current === previousFocusedElement)
        closestPreviousLandmark.blur();
    }
  }
  createLandmarkController() {
    let instance = this;
    instance.refCount++;
    instance.setupIfNeeded();
    return {
      navigate(direction, opts) {
        let element4 = (opts === null || opts === void 0 ? void 0 : opts.from) || document.activeElement;
        return instance.navigate(element4, direction === "backward");
      },
      focusNext(opts) {
        let element4 = (opts === null || opts === void 0 ? void 0 : opts.from) || document.activeElement;
        return instance.navigate(element4, false);
      },
      focusPrevious(opts) {
        let element4 = (opts === null || opts === void 0 ? void 0 : opts.from) || document.activeElement;
        return instance.navigate(element4, true);
      },
      focusMain() {
        return instance.focusMain();
      },
      dispose() {
        if (instance) {
          instance.refCount--;
          instance.teardownIfNeeded();
          instance = null;
        }
      }
    };
  }
  registerLandmark(landmark) {
    if (this.landmarks.find((l7) => l7.ref === landmark.ref))
      this.updateLandmark(landmark);
    else
      this.addLandmark(landmark);
    return () => this.removeLandmark(landmark.ref);
  }
  constructor() {
    this.landmarks = [];
    this.isListening = false;
    this.refCount = 0;
    this.version = $a86207c5d7f7e1fb$var$LANDMARK_API_VERSION;
    this.f6Handler = this.f6Handler.bind(this);
    this.focusinHandler = this.focusinHandler.bind(this);
    this.focusoutHandler = this.focusoutHandler.bind(this);
  }
};
function $a86207c5d7f7e1fb$export$4cc632584fd87fae(props, ref) {
  const { role, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledby, focus } = props;
  let manager = $a86207c5d7f7e1fb$var$useLandmarkManager();
  let label = ariaLabel || ariaLabelledby;
  let [isLandmarkFocused, setIsLandmarkFocused] = (0, import_react76.useState)(false);
  let defaultFocus = (0, import_react76.useCallback)(() => {
    setIsLandmarkFocused(true);
  }, [
    setIsLandmarkFocused
  ]);
  let blur = (0, import_react76.useCallback)(() => {
    setIsLandmarkFocused(false);
  }, [
    setIsLandmarkFocused
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (manager)
      return manager.registerLandmark({
        ref,
        label,
        role,
        focus: focus || defaultFocus,
        blur
      });
  }, [
    manager,
    label,
    ref,
    role,
    focus,
    defaultFocus,
    blur
  ]);
  (0, import_react76.useEffect)(() => {
    var _ref_current;
    if (isLandmarkFocused)
      (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.focus();
  }, [
    isLandmarkFocused,
    ref
  ]);
  return {
    landmarkProps: {
      role,
      tabIndex: isLandmarkFocused ? -1 : void 0,
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabelledby
    }
  };
}

// node_modules/@react-aria/toast/dist/import.mjs
function $parcel$interopDefault8(a3) {
  return a3 && a3.__esModule ? a3.default : a3;
}
var $7853651519a70071$exports = {};
var $ff9177efc58547ad$exports = {};
$ff9177efc58547ad$exports = {
  "close": `إغلاق`,
  "notifications": `إشعارات`
};
var $25eb7c0c0c45e544$exports = {};
$25eb7c0c0c45e544$exports = {
  "close": `Затвори`,
  "notifications": `Известия`
};
var $28feffc3d61a8691$exports = {};
$28feffc3d61a8691$exports = {
  "close": `Zavřít`,
  "notifications": `Upozornění`
};
var $390d441203d25ff4$exports = {};
$390d441203d25ff4$exports = {
  "close": `Luk`,
  "notifications": `Påmindelser`
};
var $7063c2d0f14f979a$exports = {};
$7063c2d0f14f979a$exports = {
  "close": `Schließen`,
  "notifications": `Benachrichtigungen`
};
var $2dfc1dbb6590af88$exports = {};
$2dfc1dbb6590af88$exports = {
  "close": `Κλείσιμο`,
  "notifications": `Ειδοποιήσεις`
};
var $9a12ff1caae5a7a5$exports = {};
$9a12ff1caae5a7a5$exports = {
  "close": `Close`,
  "notifications": `Notifications`
};
var $f4095fb5a72adbe6$exports = {};
$f4095fb5a72adbe6$exports = {
  "close": `Cerrar`,
  "notifications": `Notificaciones`
};
var $75bc5191b9d7826a$exports = {};
$75bc5191b9d7826a$exports = {
  "close": `Sule`,
  "notifications": `Teated`
};
var $e4b9aef18b0db8dc$exports = {};
$e4b9aef18b0db8dc$exports = {
  "close": `Sulje`,
  "notifications": `Ilmoitukset`
};
var $888756784d832bd7$exports = {};
$888756784d832bd7$exports = {
  "close": `Fermer`,
  "notifications": `Notifications`
};
var $6835949b68a1fabf$exports = {};
$6835949b68a1fabf$exports = {
  "close": `סגור`,
  "notifications": `התראות`
};
var $87ffcbc0b651e40b$exports = {};
$87ffcbc0b651e40b$exports = {
  "close": `Zatvori`,
  "notifications": `Obavijesti`
};
var $dc6e3b2813600d69$exports = {};
$dc6e3b2813600d69$exports = {
  "close": `Bezárás`,
  "notifications": `Értesítések`
};
var $fe136bcbacfcfa14$exports = {};
$fe136bcbacfcfa14$exports = {
  "close": `Chiudi`,
  "notifications": `Notifiche`
};
var $8fb53a929b46df83$exports = {};
$8fb53a929b46df83$exports = {
  "close": `閉じる`,
  "notifications": `通知`
};
var $2c38dbfaf041a865$exports = {};
$2c38dbfaf041a865$exports = {
  "close": `닫기`,
  "notifications": `알림`
};
var $48f3f33a29908d4c$exports = {};
$48f3f33a29908d4c$exports = {
  "close": `Uždaryti`,
  "notifications": `Pranešimai`
};
var $9867160d996455a0$exports = {};
$9867160d996455a0$exports = {
  "close": `Aizvērt`,
  "notifications": `Paziņojumi`
};
var $196258ea25c96487$exports = {};
$196258ea25c96487$exports = {
  "close": `Lukk`,
  "notifications": `Varsler`
};
var $949061cb954e8000$exports = {};
$949061cb954e8000$exports = {
  "close": `Sluiten`,
  "notifications": `Meldingen`
};
var $8189bed27add1ad3$exports = {};
$8189bed27add1ad3$exports = {
  "close": `Zamknij`,
  "notifications": `Powiadomienia`
};
var $a361756a93b6e28c$exports = {};
$a361756a93b6e28c$exports = {
  "close": `Fechar`,
  "notifications": `Notificações`
};
var $034c7393857c8db0$exports = {};
$034c7393857c8db0$exports = {
  "close": `Fechar`,
  "notifications": `Notificações`
};
var $e33d3b3868478b04$exports = {};
$e33d3b3868478b04$exports = {
  "close": `Închideţi`,
  "notifications": `Notificări`
};
var $9a7dcb914b29cd9f$exports = {};
$9a7dcb914b29cd9f$exports = {
  "close": `Закрыть`,
  "notifications": `Уведомления`
};
var $e43d964a0c7f1266$exports = {};
$e43d964a0c7f1266$exports = {
  "close": `Zatvoriť`,
  "notifications": `Oznámenia`
};
var $0bc56cee3275bcaa$exports = {};
$0bc56cee3275bcaa$exports = {
  "close": `Zapri`,
  "notifications": `Obvestila`
};
var $7dbdd7289c10d2ba$exports = {};
$7dbdd7289c10d2ba$exports = {
  "close": `Zatvori`,
  "notifications": `Obaveštenja`
};
var $ccbe6066c10b1e53$exports = {};
$ccbe6066c10b1e53$exports = {
  "close": `Stäng`,
  "notifications": `Aviseringar`
};
var $9d503476b9d858b7$exports = {};
$9d503476b9d858b7$exports = {
  "close": `Kapat`,
  "notifications": `Bildirimler`
};
var $32ee419c7b9b7a83$exports = {};
$32ee419c7b9b7a83$exports = {
  "close": `Закрити`,
  "notifications": `Сповіщення`
};
var $122525af1cb737c7$exports = {};
$122525af1cb737c7$exports = {
  "close": `关闭`,
  "notifications": `通知`
};
var $52e8b1b00094e5a3$exports = {};
$52e8b1b00094e5a3$exports = {
  "close": `關閉`,
  "notifications": `通知`
};
$7853651519a70071$exports = {
  "ar-AE": $ff9177efc58547ad$exports,
  "bg-BG": $25eb7c0c0c45e544$exports,
  "cs-CZ": $28feffc3d61a8691$exports,
  "da-DK": $390d441203d25ff4$exports,
  "de-DE": $7063c2d0f14f979a$exports,
  "el-GR": $2dfc1dbb6590af88$exports,
  "en-US": $9a12ff1caae5a7a5$exports,
  "es-ES": $f4095fb5a72adbe6$exports,
  "et-EE": $75bc5191b9d7826a$exports,
  "fi-FI": $e4b9aef18b0db8dc$exports,
  "fr-FR": $888756784d832bd7$exports,
  "he-IL": $6835949b68a1fabf$exports,
  "hr-HR": $87ffcbc0b651e40b$exports,
  "hu-HU": $dc6e3b2813600d69$exports,
  "it-IT": $fe136bcbacfcfa14$exports,
  "ja-JP": $8fb53a929b46df83$exports,
  "ko-KR": $2c38dbfaf041a865$exports,
  "lt-LT": $48f3f33a29908d4c$exports,
  "lv-LV": $9867160d996455a0$exports,
  "nb-NO": $196258ea25c96487$exports,
  "nl-NL": $949061cb954e8000$exports,
  "pl-PL": $8189bed27add1ad3$exports,
  "pt-BR": $a361756a93b6e28c$exports,
  "pt-PT": $034c7393857c8db0$exports,
  "ro-RO": $e33d3b3868478b04$exports,
  "ru-RU": $9a7dcb914b29cd9f$exports,
  "sk-SK": $e43d964a0c7f1266$exports,
  "sl-SI": $0bc56cee3275bcaa$exports,
  "sr-SP": $7dbdd7289c10d2ba$exports,
  "sv-SE": $ccbe6066c10b1e53$exports,
  "tr-TR": $9d503476b9d858b7$exports,
  "uk-UA": $32ee419c7b9b7a83$exports,
  "zh-CN": $122525af1cb737c7$exports,
  "zh-TW": $52e8b1b00094e5a3$exports
};
function $d6542812f0669241$export$a407b657d3044108(props, state, ref) {
  let { key, timer, timeout, animation } = props.toast;
  (0, import_react77.useEffect)(() => {
    if (!timer)
      return;
    timer.reset(timeout);
    return () => {
      timer.pause();
    };
  }, [
    timer,
    timeout
  ]);
  let focusOnUnmount = (0, import_react77.useRef)(null);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    let container = ref.current.closest("[role=region]");
    return () => {
      if (container && container.contains(document.activeElement))
        focusOnUnmount.current = container;
    };
  }, [
    ref
  ]);
  (0, import_react77.useEffect)(() => {
    return () => {
      if (focusOnUnmount.current)
        focusOnUnmount.current.focus();
    };
  }, [
    ref
  ]);
  let titleId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  let descriptionId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)();
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault8($7853651519a70071$exports)));
  return {
    toastProps: {
      role: "alert",
      "aria-label": props["aria-label"],
      "aria-labelledby": props["aria-labelledby"] || titleId,
      "aria-describedby": props["aria-describedby"] || descriptionId,
      "aria-details": props["aria-details"],
      // Hide toasts that are animating out so VoiceOver doesn't announce them.
      "aria-hidden": animation === "exiting" ? "true" : void 0
    },
    titleProps: {
      id: titleId
    },
    descriptionProps: {
      id: descriptionId
    },
    closeButtonProps: {
      "aria-label": stringFormatter.format("close"),
      onPress: () => state.close(key)
    }
  };
}
function $6cc546b19ee7130a$export$b8cbbb20a51697de(props, state, ref) {
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault8($7853651519a70071$exports)));
  let { landmarkProps } = (0, $a86207c5d7f7e1fb$export$4cc632584fd87fae)({
    role: "region",
    "aria-label": props["aria-label"] || stringFormatter.format("notifications")
  }, ref);
  let { hoverProps } = (0, $6179b936705e76d3$export$ae780daf29e6d456)({
    onHoverStart: state.pauseAll,
    onHoverEnd: state.resumeAll
  });
  let lastFocused = (0, import_react77.useRef)(null);
  let { focusWithinProps } = (0, $9ab94262bd0047c7$export$420e68273165f4ec)({
    onFocusWithin: (e6) => {
      state.pauseAll();
      lastFocused.current = e6.relatedTarget;
    },
    onBlurWithin: () => {
      state.resumeAll();
      lastFocused.current = null;
    }
  });
  (0, import_react77.useEffect)(() => {
    return () => {
      if (lastFocused.current && document.body.contains(lastFocused.current)) {
        if ((0, $507fabe10e71c6fb$export$630ff653c5ada6a9)() === "pointer")
          (0, $7215afc6de606d6b$export$de79e2c695e052f3)(lastFocused.current);
        else
          lastFocused.current.focus();
      }
    };
  }, [
    ref
  ]);
  return {
    regionProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(landmarkProps, hoverProps, focusWithinProps, {
      tabIndex: -1,
      // Mark the toast region as a "top layer", so that it:
      //   - is not aria-hidden when opening an overlay
      //   - allows focus even outside a containing focus scope
      //   - doesn’t dismiss overlays when clicking on it, even though it is outside
      // @ts-ignore
      "data-react-aria-top-layer": true
    })
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-checkCircle2Icon.js
var import_jsx_runtime89 = __toESM(require_jsx_runtime());
var checkCircle2Icon = (0, import_jsx_runtime89.jsxs)(import_jsx_runtime89.Fragment, {
  children: [(0, import_jsx_runtime89.jsx)("circle", {
    cx: 12,
    cy: 12,
    r: 10
  }), (0, import_jsx_runtime89.jsx)("path", {
    d: "m9 12 2 2 4-4"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-infoIcon.js
var import_jsx_runtime90 = __toESM(require_jsx_runtime());
var infoIcon = (0, import_jsx_runtime90.jsxs)(import_jsx_runtime90.Fragment, {
  children: [(0, import_jsx_runtime90.jsx)("circle", {
    cx: 12,
    cy: 12,
    r: 10
  }), (0, import_jsx_runtime90.jsx)("path", {
    d: "M12 16v-4M12 8h.01"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-toast.js
var import_jsx_runtime91 = __toESM(require_jsx_runtime());
var import_react_dom6 = __toESM(require_react_dom());
var intlMessages = {
  "ar-AE": {
    info: "معلومات",
    critical: "خطأ",
    positive: "تم بنجاح"
  },
  "bg-BG": {
    info: "Инфо",
    critical: "Грешка",
    positive: "Успех"
  },
  "cs-CZ": {
    info: "Informace",
    critical: "Chyba",
    positive: "Úspěch"
  },
  "da-DK": {
    info: "Info",
    critical: "Fejl",
    positive: "Fuldført"
  },
  "de-DE": {
    info: "Informationen",
    critical: "Fehler",
    positive: "Erfolg"
  },
  "el-GR": {
    info: "Πληροφορίες",
    critical: "Σφάλμα",
    positive: "Επιτυχία"
  },
  "en-US": {
    info: "Info",
    critical: "Error",
    positive: "Success"
  },
  "es-ES": {
    info: "Información",
    critical: "Error",
    positive: "Éxito"
  },
  "et-EE": {
    info: "Teave",
    critical: "Viga",
    positive: "Valmis"
  },
  "fi-FI": {
    info: "Tiedot",
    critical: "Virhe",
    positive: "Onnistui"
  },
  "fr-FR": {
    info: "Infos",
    critical: "Erreur",
    positive: "Succès"
  },
  "he-IL": {
    info: "מידע",
    critical: "שגיאה",
    positive: "הצלחה"
  },
  "hr-HR": {
    info: "Informacije",
    critical: "Pogreška",
    positive: "Uspješno"
  },
  "hu-HU": {
    info: "Információ",
    critical: "Hiba",
    positive: "Siker"
  },
  "it-IT": {
    info: "Informazioni",
    critical: "Errore",
    positive: "Operazione riuscita"
  },
  "ja-JP": {
    info: "情報",
    critical: "エラー",
    positive: "成功"
  },
  "ko-KR": {
    info: "정보",
    critical: "오류",
    positive: "성공"
  },
  "lt-LT": {
    info: "Informacija",
    critical: "Klaida",
    positive: "Sėkmingai"
  },
  "lv-LV": {
    info: "Informācija",
    critical: "Kļūda",
    positive: "Izdevās"
  },
  "nb-NO": {
    info: "Info",
    critical: "Feil",
    positive: "Vellykket"
  },
  "nl-NL": {
    info: "Info",
    critical: "Fout",
    positive: "Geslaagd"
  },
  "pl-PL": {
    info: "Informacje",
    critical: "Błąd",
    positive: "Powodzenie"
  },
  "pt-BR": {
    info: "Informações",
    critical: "Erro",
    positive: "Sucesso"
  },
  "pt-PT": {
    info: "Informação",
    critical: "Erro",
    positive: "Sucesso"
  },
  "ro-RO": {
    info: "Informaţii",
    critical: "Eroare",
    positive: "Succes"
  },
  "ru-RU": {
    info: "Информация",
    critical: "Ошибка",
    positive: "Успешно"
  },
  "sk-SK": {
    info: "Informácie",
    critical: "Chyba",
    positive: "Úspech"
  },
  "sl-SI": {
    info: "Informacije",
    critical: "Napaka",
    positive: "Uspešno"
  },
  "sr-SP": {
    info: "Informacije",
    critical: "Greška",
    positive: "Uspešno"
  },
  "sv-SE": {
    info: "Info",
    critical: "Fel",
    positive: "Lyckades"
  },
  "tr-TR": {
    info: "Bilgiler",
    critical: "Hata",
    positive: "Başarılı"
  },
  "uk-UA": {
    info: "Інформація",
    critical: "Помилка",
    positive: "Успішно"
  },
  "zh-CN": {
    info: "信息",
    critical: "错误",
    positive: "成功"
  },
  "zh-TW": {
    info: "資訊",
    critical: "錯誤",
    positive: "成功"
  }
};
var ICONS = {
  info: infoIcon,
  critical: alertTriangleIcon,
  // neutral: infoIcon,
  positive: checkCircle2Icon
};
function Toast(props, ref) {
  let {
    toast: {
      key,
      animation,
      content: {
        children,
        tone,
        actionLabel,
        onAction,
        shouldCloseOnAction
      }
    },
    state,
    ...otherProps
  } = props;
  let domRef = $df56164dff5785e2$export$4338b53315abf666(ref);
  let {
    closeButtonProps,
    titleProps,
    toastProps
  } = $d6542812f0669241$export$a407b657d3044108(props, state, domRef);
  let styleProps = useStyleProps(otherProps);
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(intlMessages);
  let iconLabel = tone && tone !== "neutral" ? stringFormatter.format(tone) : null;
  let icon = tone && tone !== "neutral" ? ICONS[tone] : null;
  const handleAction = () => {
    if (onAction) {
      onAction();
    }
    if (shouldCloseOnAction) {
      state.close(key);
    }
  };
  let slots = (0, import_react78.useMemo)(() => ({
    text: {
      color: "inherit"
    }
  }), []);
  return (0, import_jsx_runtime91.jsx)("div", {
    ...styleProps,
    ...toastProps,
    ref: domRef,
    "data-tone": tone,
    className: classNames(css({
      borderRadius: tokenSchema.size.radius.regular,
      display: "flex",
      margin: tokenSchema.size.space.large,
      maxWidth: tokenSchema.size.container.xsmall,
      minHeight: tokenSchema.size.element.large,
      padding: tokenSchema.size.space.regular,
      paddingInlineStart: tokenSchema.size.space.large,
      pointerEvents: "auto",
      position: "absolute",
      // tones
      color: tokenSchema.color.foreground.onEmphasis,
      "&[data-tone=neutral]": {
        background: tokenSchema.color.scale["slate9"]
      },
      "&[data-tone=info]": {
        background: tokenSchema.color.background.accentEmphasis
      },
      "&[data-tone=positive]": {
        background: tokenSchema.color.background.positiveEmphasis
      },
      "&[data-tone=critical]": {
        background: tokenSchema.color.background.criticalEmphasis
      },
      // animations
      "&[data-animation=entering]": {
        animation: `${slideInAnim} 300ms`
      },
      "&[data-animation=exiting]": {
        animation: `${fadeOutAnim} 300ms forwards`
      }
    }), styleProps.className),
    style: {
      ...styleProps.style,
      zIndex: props.toast.priority
    },
    "data-animation": animation,
    onAnimationEnd: () => {
      if (animation === "exiting") {
        state.remove(key);
      }
    },
    children: (0, import_jsx_runtime91.jsxs)(SlotProvider, {
      slots,
      children: [icon && (0, import_jsx_runtime91.jsx)(Icon, {
        "aria-label": iconLabel,
        src: icon,
        size: "medium",
        marginTop: "small",
        marginEnd: "regular"
      }), (0, import_jsx_runtime91.jsxs)("div", {
        className: classNames(css({
          alignItems: "center",
          display: "flex",
          columnGap: tokenSchema.size.space.large,
          flex: 1,
          flexWrap: "wrap",
          justifyContent: "flex-end",
          paddingInlineEnd: tokenSchema.size.space.large
        })),
        children: [(0, import_jsx_runtime91.jsx)("div", {
          className: classNames(css({
            flexGrow: 1,
            paddingBlock: tokenSchema.size.space.regular
          })),
          ...titleProps,
          children: isReactText(children) ? (0, import_jsx_runtime91.jsx)(Text2, {
            children
          }) : children
        }), actionLabel && (0, import_jsx_runtime91.jsx)(Button, {
          onPress: handleAction,
          static: "light",
          children: actionLabel
        })]
      }), (0, import_jsx_runtime91.jsx)("div", {
        className: css({
          borderInlineStart: `${tokenSchema.size.border.regular} solid #fff3`,
          paddingInlineStart: tokenSchema.size.space.regular
        }),
        children: (0, import_jsx_runtime91.jsx)(ClearButton, {
          static: "light",
          ...closeButtonProps
        })
      })]
    })
  });
}
var slideInAnim = keyframes({
  from: {
    transform: `var(--slide-from)`
  },
  to: {
    transform: `var(--slide-to)`
  }
});
var fadeOutAnim = keyframes({
  from: {
    opacity: 1
  },
  to: {
    opacity: 0
  }
});
var _Toast = (0, import_react78.forwardRef)(Toast);
function ToastContainer(props) {
  let {
    children,
    state
  } = props;
  let {
    direction
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let isMobileDevice = useIsMobileDevice();
  let placement = isMobileDevice ? "center" : props.placement || "end";
  let position3 = isMobileDevice ? "bottom" : props.position || "bottom";
  let ref = (0, import_react78.useRef)(null);
  let {
    regionProps
  } = $6cc546b19ee7130a$export$b8cbbb20a51697de(props, state, ref);
  let contents = (0, import_jsx_runtime91.jsx)(KeystarProvider, {
    UNSAFE_style: {
      background: "transparent"
    },
    children: (0, import_jsx_runtime91.jsx)(FocusRing, {
      children: (0, import_jsx_runtime91.jsx)("div", {
        ...regionProps,
        ref,
        "data-direction": direction,
        "data-position": position3,
        "data-placement": placement,
        className: css({
          display: "flex",
          insetInline: 0,
          outline: "none",
          pointerEvents: "none",
          position: "fixed",
          zIndex: 100,
          "&[data-focus=visible] > :first-child:after": {
            borderRadius: `calc(${tokenSchema.size.radius.regular} + ${tokenSchema.size.alias.focusRingGap})`,
            boxShadow: `0 0 0 ${tokenSchema.size.alias.focusRing} ${tokenSchema.color.alias.focusRing}`,
            content: '""',
            inset: 0,
            margin: `calc(-1 * ${tokenSchema.size.alias.focusRingGap})`,
            pointerEvents: "none",
            position: "absolute"
          },
          "&[data-position=top]": {
            top: 0,
            flexDirection: "column",
            "--slide-from": "translateY(-100%)",
            "--slide-to": "translateY(0)"
          },
          "&[data-position=bottom]": {
            bottom: 0,
            flexDirection: "column-reverse",
            "--slide-from": "translateY(100%)",
            "--slide-to": "translateY(0)"
          },
          "&[data-placement=start]": {
            alignItems: "flex-start",
            "--slide-from": "translateX(-100%)",
            "--slide-to": "translateX(0)",
            "&[data-direction=rtl]": {
              "--slide-from": "translateX(100%)"
            }
          },
          "&[data-placement=center]": {
            alignItems: "center"
          },
          "&[data-placement=end]": {
            alignItems: "flex-end",
            "--slide-from": "translateX(100%)",
            "--slide-to": "translateX(0)",
            "&[data-direction=rtl]": {
              "--slide-from": "translateX(-100%)"
            }
          }
        }),
        children
      })
    })
  });
  return import_react_dom6.default.createPortal(contents, document.body);
}
var globalToastQueue = null;
function getGlobalToastQueue() {
  if (!globalToastQueue) {
    globalToastQueue = new $77b352cf12efcf73$export$f1f8569633bbbec4({
      maxVisibleToasts: 1,
      hasExitAnimation: true
    });
  }
  return globalToastQueue;
}
var toastProviders = /* @__PURE__ */ new Set();
var subscriptions = /* @__PURE__ */ new Set();
function subscribe4(fn2) {
  subscriptions.add(fn2);
  return () => subscriptions.delete(fn2);
}
function getActiveToaster() {
  return toastProviders.values().next().value;
}
function useActiveToaster() {
  return (0, import_react78.useSyncExternalStore)(subscribe4, getActiveToaster, getActiveToaster);
}
function Toaster(props) {
  let ref = (0, import_react78.useRef)();
  toastProviders.add(ref);
  (0, import_react78.useEffect)(() => {
    return () => {
      for (let toast of getGlobalToastQueue().visibleToasts) {
        toast.animation = void 0;
      }
      toastProviders.delete(ref);
      for (let fn2 of subscriptions) {
        fn2();
      }
    };
  }, []);
  let activeToaster = useActiveToaster();
  let state = $77b352cf12efcf73$export$84726ef35ca2129a(getGlobalToastQueue());
  if (ref === activeToaster && state.visibleToasts.length > 0) {
    return (0, import_jsx_runtime91.jsx)(ToastContainer, {
      state,
      ...props,
      children: state.visibleToasts.map((toast) => (0, import_jsx_runtime91.jsx)(_Toast, {
        toast,
        state
      }, toast.key))
    });
  }
  return null;
}
function addToast(children, tone, options = {}) {
  if (typeof CustomEvent !== "undefined" && typeof window !== "undefined") {
    let event = new CustomEvent("keystar-ui-toast", {
      cancelable: true,
      bubbles: true,
      detail: {
        children,
        tone,
        options
      }
    });
    let shouldContinue = window.dispatchEvent(event);
    if (!shouldContinue) {
      return () => {
      };
    }
  }
  let value2 = {
    children,
    tone,
    actionLabel: options.actionLabel,
    onAction: options.onAction,
    shouldCloseOnAction: options.shouldCloseOnAction
  };
  warning(!(options.timeout && options.onAction), "Timeouts are not supported on actionable toasts.");
  warning(!!(options.timeout && options.timeout >= 5e3), "Timeouts must be at least 5000ms, for accessibility.");
  let timeout = options.timeout && !options.onAction ? Math.max(options.timeout, 5e3) : void 0;
  let queue = getGlobalToastQueue();
  let key = queue.add(value2, {
    priority: getPriority(tone, options),
    timeout,
    onClose: options.onClose
  });
  return () => queue.close(key);
}
var toastQueue = {
  /** Queues a neutral toast. */
  neutral(children, options = {}) {
    return addToast(children, "neutral", options);
  },
  /** Queues a positive toast. */
  positive(children, options = {}) {
    return addToast(children, "positive", options);
  },
  /** Queues a critical toast. */
  critical(children, options = {}) {
    return addToast(children, "critical", options);
  },
  /** Queues an informational toast. */
  info(children, options = {}) {
    return addToast(children, "info", options);
  }
};
var PRIORITY = {
  // actionable toasts gain 4 priority points. make sure critical toasts are
  // always at the top.
  critical: 10,
  positive: 3,
  info: 2,
  neutral: 1
};
function getPriority(tone, options) {
  let priority = PRIORITY[tone] || 1;
  if (options.onAction) {
    priority += 4;
  }
  return priority;
}

// node_modules/@keystatic/core/dist/index-172a6993.js
var import_react79 = __toESM(require_react(), 1);
var import_jsx_runtime92 = __toESM(require_jsx_runtime(), 1);
var import_is_hotkey2 = __toESM(require_lib3(), 1);
var import_sanitize_url = __toESM(require_dist(), 1);
var import_cookie = __toESM(require_cookie(), 1);
var import_slugify = __toESM(require_slugify(), 1);
var l10nMessages = {
  "he-IL": {
    add: "לְהוֹסִיף",
    basedOn: "מבוסס על",
    branchName: "שם הסניף",
    branches: "ענפים",
    clear: "נקי",
    cancel: "לְבַטֵל",
    collections: "אוספים",
    collection: "אוסף",
    create: "לִיצוֹר",
    createPullRequest: "צור בקשת משיכה",
    currentBranch: "סניף נוכחי",
    dashboard: "לוּחַ מַחווָנִים",
    defaultBranch: "סניף ברירת מחדל",
    "delete": "לִמְחוֹק",
    deleteBranch: "מחק סניף",
    edit: "לַעֲרוֹך",
    loading: "טוען",
    newBranch: "סניף חדש",
    otherBranches: "סניפים אחרים",
    save: "להציל",
    pullRequests: "משוך בקשות",
    search: "חפש",
    singleton: "קְלָף בּוֹדֵד",
    singletons: "רווקים",
    theCurrentlyCheckedOutBranch: "הסניף שנקבע כעת. בחר באפשרות זו אם אתה צריך לבנות על עבודה קיימת מהסניף הנוכחי.",
    theDefaultBranchInYourRepository: "סניף ברירת המחדל במאגר שלך. בחר באפשרות זו כדי להתחיל משהו חדש שאינו תלוי בסניף הנוכחי שלך.",
    viewPullRequests: "הצג בקשות משיכה"
  },
  "hr-HR": {
    add: "Dodati",
    basedOn: "Na temelju",
    branchName: "Naziv podružnice",
    branches: "Podružnice",
    clear: "Izbriši",
    cancel: "Otkazati",
    collection: "Kolekcija",
    create: "Stvoriti",
    collections: "Zbirke",
    createPullRequest: "Kreirajte zahtjev za povlačenjem",
    dashboard: "Nadzorna ploča",
    currentBranch: "Trenutna grana",
    defaultBranch: "Zadana grana",
    deleteBranch: "Izbriši granu",
    "delete": "Izbrisati",
    edit: "Uredi",
    loading: "Učitavam",
    newBranch: "Nova grana",
    otherBranches: "Ostale grane",
    save: "Uštedjeti",
    pullRequests: "Zahtjevi za povlačenjem",
    search: "Traži",
    singleton: "samac",
    singletons: "Samci",
    theCurrentlyCheckedOutBranch: "Trenutno odjavljena poslovnica. Odaberite ovo ako trebate graditi na postojećem radu iz trenutne grane.",
    theDefaultBranchInYourRepository: "Zadana grana u vašem spremištu. Odaberite ovo da započnete nešto novo što ne ovisi o vašoj trenutnoj grani.",
    viewPullRequests: "Pregledajte zahtjeve za povlačenjem"
  },
  "hu-HU": {
    add: "Hozzáadás",
    basedOn: "Alapján",
    branches: "Ágak",
    branchName: "Fiók neve",
    clear: "Törlés",
    cancel: "Megszünteti",
    collection: "Gyűjtemény",
    collections: "Gyűjtemények",
    createPullRequest: "Lehívási kérelem létrehozása",
    create: "Teremt",
    dashboard: "Irányítópult",
    defaultBranch: "Alapértelmezett ág",
    currentBranch: "Jelenlegi ág",
    "delete": "Töröl",
    deleteBranch: "Elágazás törlése",
    edit: "Szerkesztés",
    loading: "Betöltés folyamatban",
    newBranch: "Új ág",
    otherBranches: "Egyéb ágak",
    pullRequests: "Lehívási kérések",
    save: "Megment",
    search: "Keresés",
    singleton: "szingli",
    singletons: "Singletons",
    theCurrentlyCheckedOutBranch: "A jelenleg kivett fiók. Válassza ezt, ha az aktuális ág meglévő munkájára kell építenie.",
    theDefaultBranchInYourRepository: "Az alapértelmezett ág az adattárban. Válassza ezt, ha valami újat szeretne indítani, amely nem függ az aktuális ágtól.",
    viewPullRequests: "Lehívási kérelmek megtekintése"
  },
  "it-IT": {
    add: "Aggiungere",
    basedOn: "Basato su",
    branchName: "Nome ramo",
    branches: "Rami",
    cancel: "Annulla",
    clear: "Cancella",
    collection: "Collezione",
    collections: "Collezioni",
    create: "Creare",
    createPullRequest: "Crea richiesta pull",
    currentBranch: "Ramo attuale",
    dashboard: "Pannello di controllo",
    "delete": "Eliminare",
    defaultBranch: "Ramo predefinito",
    deleteBranch: "Elimina ramo",
    edit: "Modificare",
    loading: "Caricamento in corso",
    newBranch: "Nuova filiale",
    pullRequests: "Richieste pull",
    otherBranches: "Altri rami",
    save: "Salva",
    search: "Cerca",
    singleton: "Singleton",
    singletons: "Singletons",
    theCurrentlyCheckedOutBranch: "La filiale attualmente verificata. Scegli questa opzione se devi basarti su un lavoro esistente dal ramo corrente.",
    theDefaultBranchInYourRepository: "Il ramo predefinito nel tuo repository. Scegli questa opzione per iniziare qualcosa di nuovo che non dipenda dal tuo ramo attuale.",
    viewPullRequests: "Visualizza le richieste pull"
  },
  "ja-JP": {
    basedOn: "に基づく",
    add: "追加",
    branchName: "支店名",
    cancel: "キャンセル",
    branches: "支店",
    clear: "クリア",
    collection: "コレクション",
    collections: "コレクション",
    create: "作成",
    createPullRequest: "プルリクエストを作成",
    currentBranch: "現在のブランチ",
    dashboard: "ダッシュボード",
    defaultBranch: "デフォルトのブランチ",
    "delete": "消去",
    deleteBranch: "ブランチを削除",
    edit: "編集",
    loading: "読み込み中",
    newBranch: "新しい支店",
    otherBranches: "その他の支店",
    pullRequests: "プルリクエスト",
    save: "保存",
    search: "検索",
    singleton: "シングルトン",
    singletons: "シングルトン",
    theCurrentlyCheckedOutBranch: "現在チェックアウトされているブランチ。 現在のブランチの既存の作業に基づいて構築する必要がある場合は、これを選択してください。",
    theDefaultBranchInYourRepository: "リポジトリのデフォルト ブランチ。 これを選択して、現在のブランチに依存しない新しい何かを開始します。",
    viewPullRequests: "プル リクエストを表示"
  },
  "ko-KR": {
    add: "추가하다",
    branches: "가지",
    branchName: "지점명",
    basedOn: "기반으로",
    cancel: "취소",
    clear: "지우기",
    collection: "수집",
    collections: "컬렉션",
    createPullRequest: "풀 요청 생성",
    create: "만들다",
    currentBranch: "현재 지점",
    dashboard: "계기반",
    defaultBranch: "기본 분기",
    "delete": "삭제",
    edit: "편집하다",
    deleteBranch: "분기 삭제",
    loading: "로드 중",
    newBranch: "새 지점",
    otherBranches: "기타 지점",
    pullRequests: "풀 리퀘스트",
    save: "구하다",
    search: "검색",
    singleton: "하나씩 일어나는 것",
    singletons: "싱글톤",
    theCurrentlyCheckedOutBranch: "현재 체크아웃된 브랜치. 현재 브랜치의 기존 작업을 기반으로 빌드해야 하는 경우 이 옵션을 선택하세요.",
    theDefaultBranchInYourRepository: "리포지토리의 기본 브랜치입니다. 현재 분기에 의존하지 않는 새로운 것을 시작하려면 이것을 선택하십시오.",
    viewPullRequests: "풀 요청 보기"
  },
  "lt-LT": {
    add: "Papildyti",
    basedOn: "Remiantis",
    branchName: "Filialo pavadinimas",
    branches: "Filialai",
    cancel: "Atšaukti",
    clear: "Skaidrus",
    collection: "Kolekcija",
    collections: "Kolekcijos",
    create: "Sukurti",
    createPullRequest: "Sukurti ištraukimo užklausą",
    currentBranch: "Dabartinis filialas",
    dashboard: "Prietaisų skydelis",
    defaultBranch: "Numatytoji šaka",
    "delete": "Ištrinti",
    edit: "Redaguoti",
    deleteBranch: "Ištrinti šaką",
    loading: "Įkeliama",
    newBranch: "Naujas filialas",
    otherBranches: "Kitos šakos",
    pullRequests: "Ištraukti užklausas",
    save: "Sutaupyti",
    search: "Ieškoti",
    singleton: "vienvietis",
    singletons: "Vienišiai",
    theCurrentlyCheckedOutBranch: "Šiuo metu išregistruotas filialas. Pasirinkite tai, jei reikia remtis esamu darbu iš dabartinės šakos.",
    theDefaultBranchInYourRepository: "Numatytoji šaka jūsų saugykloje. Pasirinkite tai, kad pradėtumėte ką nors naujo, nepriklausančio nuo dabartinės šakos.",
    viewPullRequests: "Peržiūrėkite ištraukimo užklausas"
  },
  "de-DE": {
    add: "Hinzufügen",
    basedOn: "Bezogen auf",
    branchName: "Zweigname",
    branches: "Geäst",
    cancel: "Stornieren",
    clear: "Löschen",
    collection: "Sammlung",
    collections: "Sammlungen",
    create: "Erstellen",
    createPullRequest: "Pull-Request erstellen",
    currentBranch: "Aktueller Zweig",
    dashboard: "Armaturenbrett",
    defaultBranch: "Standardzweig",
    "delete": "Löschen",
    deleteBranch: "Zweig löschen",
    edit: "Bearbeiten",
    loading: "Wird geladen",
    newBranch: "Neue Zweig",
    otherBranches: "Andere Filialen",
    pullRequests: "Pull-Requests",
    save: "Speichern",
    search: "Suchen",
    singleton: "Einzelling",
    singletons: "Singles",
    theCurrentlyCheckedOutBranch: "Der aktuell ausgecheckte Zweig. Wählen Sie diese Option, wenn Sie auf vorhandener Arbeit aus dem aktuellen Zweig aufbauen müssen.",
    theDefaultBranchInYourRepository: "Der Standard-Branch in Ihrem Repository. Wählen Sie dies, um etwas Neues zu starten, das nicht von Ihrem aktuellen Zweig abhängt.",
    viewPullRequests: "Pull-Requests anzeigen"
  },
  "bg-BG": {
    add: "Добавете",
    branchName: "Име на клон",
    basedOn: "Базиран на",
    cancel: "Отказ",
    clear: "Изчисти",
    collection: "колекция",
    collections: "Колекции",
    createPullRequest: "Създайте заявка за изтегляне",
    create: "Създавайте",
    branches: "Клонове",
    currentBranch: "Текущ клон",
    dashboard: "Табло",
    defaultBranch: "Клон по подразбиране",
    "delete": "Изтрий",
    deleteBranch: "Изтриване на клон",
    edit: "редактиране",
    loading: "Зареждане",
    newBranch: "Нов клон",
    otherBranches: "Други клонове",
    pullRequests: "Заявки за изтегляне",
    save: "Запазване",
    search: "Търсене",
    singleton: "Сингълтън",
    singletons: "Единични",
    theDefaultBranchInYourRepository: "Клонът по подразбиране във вашето хранилище. Изберете това, за да започнете с нещо ново, което не зависи от текущия ви клон.",
    theCurrentlyCheckedOutBranch: "Текущо провереният клон. Изберете това, ако трябва да надграждате върху съществуваща работа от текущия клон.",
    viewPullRequests: "Преглед на заявките за изтегляне"
  },
  "ar-AE": {
    add: "يضيف",
    basedOn: "مرتكز على",
    branchName: "اسم الفرع",
    branches: "الفروع",
    cancel: "يلغي",
    clear: "مسح",
    collection: "مجموعة",
    collections: "المجموعات",
    create: "يخلق",
    createPullRequest: "إنشاء طلب سحب",
    currentBranch: "الفرع الحالي",
    dashboard: "لوحة القيادة",
    defaultBranch: "الفرع الافتراضي",
    "delete": "يمسح",
    deleteBranch: "حذف الفرع",
    loading: "جارٍ التحميل",
    edit: "يحرر",
    newBranch: "فرع جديد",
    otherBranches: "الفروع الأخرى",
    pullRequests: "طلبات السحب",
    search: "بحث",
    singleton: "سينجلتون",
    save: "يحفظ",
    singletons: "الفردي",
    theCurrentlyCheckedOutBranch: "الفرع المعاد حاليا. اختر هذا إذا كنت بحاجة إلى البناء على العمل الحالي من الفرع الحالي.",
    theDefaultBranchInYourRepository: "الفرع الافتراضي في المستودع الخاص بك. اختر هذا لبدء شيء جديد لا يعتمد على فرعك الحالي.",
    viewPullRequests: "عرض طلبات السحب"
  },
  "cs-CZ": {
    add: "Přidat",
    basedOn: "Na základě",
    branchName: "Jméno pobočky",
    branches: "Větve",
    cancel: "zrušení",
    clear: "Vymazat",
    collection: "Sbírka",
    collections: "Sbírky",
    create: "Vytvořit",
    createPullRequest: "Vytvořit požadavek na stažení",
    currentBranch: "Současná pobočka",
    dashboard: "Přístrojová deska",
    defaultBranch: "Výchozí větev",
    "delete": "Vymazat",
    deleteBranch: "Smazat větev",
    edit: "Upravit",
    loading: "Načítání",
    newBranch: "Nová pobočka",
    pullRequests: "Vytáhněte požadavky",
    otherBranches: "Ostatní pobočky",
    save: "Uložit",
    search: "Hledat",
    singleton: "Jedináček",
    singletons: "Singletons",
    theCurrentlyCheckedOutBranch: "Aktuálně odhlášená pobočka. Tuto možnost vyberte, pokud potřebujete navázat na stávající práci z aktuální pobočky.",
    theDefaultBranchInYourRepository: "Výchozí větev ve vašem úložišti. Zvolte tuto možnost, chcete-li začít s něčím novým, co není závislé na vaší aktuální větvi.",
    viewPullRequests: "Zobrazit žádosti o stažení"
  },
  "da-DK": {
    defaultBranch: "Standard gren",
    "delete": "Slet",
    deleteBranch: "Slet filial",
    edit: "Redigere",
    loading: "Indlæser",
    newBranch: "Ny filial",
    otherBranches: "Andre grene",
    pullRequests: "Træk anmodninger",
    save: "Gemme",
    search: "Søg",
    singleton: "Singleton",
    singletons: "Singletoner",
    theCurrentlyCheckedOutBranch: "Den aktuelt tjekkede filial. Vælg dette, hvis du skal bygge videre på eksisterende arbejde fra den nuværende filial.",
    theDefaultBranchInYourRepository: "Standardgrenen i dit lager. Vælg dette for at starte på noget nyt, der ikke er afhængigt af din nuværende filial.",
    viewPullRequests: "Se pull-anmodninger",
    add: "Tilføje",
    basedOn: "Baseret på",
    branchName: "Afdelingsnavn",
    branches: "Grene",
    cancel: "Afbestille",
    clear: "Ryd",
    collection: "Kollektion",
    collections: "Samlinger",
    create: "skab",
    createPullRequest: "Opret pull-anmodning",
    currentBranch: "Nuværende filial",
    dashboard: "Dashboard"
  },
  "en-US": {
    add: "Add",
    basedOn: "Based on",
    branchName: "Branch name",
    branches: "Branches",
    cancel: "Cancel",
    clear: "Clear",
    collection: "Collection",
    collections: "Collections",
    create: "Create",
    createPullRequest: "Create pull request",
    currentBranch: "Current branch",
    dashboard: "Dashboard",
    "delete": "Delete",
    defaultBranch: "Default branch",
    edit: "Edit",
    deleteBranch: "Delete branch",
    loading: "Loading",
    newBranch: "New branch…",
    otherBranches: "Other branches",
    pullRequests: "Pull requests",
    save: "Save",
    search: "Search",
    singleton: "Singleton",
    singletons: "Singletons",
    theCurrentlyCheckedOutBranch: "The currently checked out branch. Choose this if you need to build on existing work from the current branch.",
    viewPullRequests: "View pull requests",
    theDefaultBranchInYourRepository: "The default branch in your repository. Choose this to start something new that's not dependent on your current branch."
  },
  "et-EE": {
    add: "Lisama",
    basedOn: "Põhineb",
    branchName: "Filiaali nimi",
    branches: "Filiaalid",
    cancel: "Tühista",
    collection: "Kollektsioon",
    clear: "Puhasta",
    collections: "Kollektsioonid",
    create: "Loo",
    createPullRequest: "Loo tõmbamistaotlus",
    defaultBranch: "Vaikeharu",
    currentBranch: "Praegune filiaal",
    dashboard: "Armatuurlaud",
    "delete": "Kustuta",
    deleteBranch: "Kustuta haru",
    loading: "Laadimine",
    edit: "Muuda",
    newBranch: "Uus filiaal",
    otherBranches: "Muud oksad",
    pullRequests: "Tõmbetaotlused",
    search: "Otsi",
    save: "Salvesta",
    singleton: "üksikud",
    singletons: "Üksikud",
    theCurrentlyCheckedOutBranch: "Praegu välja registreeritud filiaal. Valige see, kui peate kasutama praeguse haru olemasolevaid töid.",
    theDefaultBranchInYourRepository: "Vaikeharu teie hoidlas. Valige see, et alustada midagi uut, mis ei sõltu teie praegusest harust.",
    viewPullRequests: "Vaadake tõmbamistaotlusi"
  },
  "fi-FI": {
    add: "Lisätä",
    basedOn: "Perustuen",
    branchName: "Sivukonttorin nimi",
    branches: "Oksat",
    cancel: "Tühista",
    collection: "Kokoelma",
    clear: "Kirkas",
    collections: "Kokoelmat",
    create: "Luoda",
    createPullRequest: "Luo vetopyyntö",
    currentBranch: "Nykyinen haara",
    defaultBranch: "Oletushaara",
    "delete": "Poistaa",
    dashboard: "Kojelauta",
    deleteBranch: "Poista haara",
    loading: "Ladataan",
    edit: "Muokata",
    newBranch: "Uusi haara",
    pullRequests: "Vedä pyyntöjä",
    otherBranches: "Muut haarat",
    save: "Tallentaa",
    search: "Hae",
    singleton: "Singleton",
    singletons: "Singletons",
    theCurrentlyCheckedOutBranch: "Tällä hetkellä uloskirjautunut sivuliike. Valitse tämä, jos haluat rakentaa nykyisen haaran olemassa olevaan työhön.",
    theDefaultBranchInYourRepository: "Oletushaara arkistossasi. Valitse tämä aloittaaksesi jotain uutta, joka ei ole riippuvainen nykyisestä haarastasi.",
    viewPullRequests: "Näytä vetopyynnöt"
  },
  "el-GR": {
    add: "Προσθήκη",
    basedOn: "Βασισμένο στο",
    branchName: "Όνομα υποκαταστήματος",
    branches: "Κλαδια δεντρου",
    cancel: "Ματαίωση",
    clear: "Καθαρισμός",
    collection: "Συλλογή",
    collections: "Συλλογές",
    create: "Δημιουργώ",
    createPullRequest: "Δημιουργία αιτήματος έλξης",
    currentBranch: "Τρέχον υποκατάστημα",
    dashboard: "Ταμπλό",
    defaultBranch: "Προεπιλεγμένος κλάδος",
    "delete": "Διαγράφω",
    deleteBranch: "Διαγραφή υποκαταστήματος",
    edit: "Επεξεργασία",
    loading: "Φόρτωση",
    newBranch: "Νέο υποκατάστημα",
    otherBranches: "Άλλα υποκαταστήματα",
    pullRequests: "Τραβήξτε αιτήματα",
    save: "Αποθηκεύσετε",
    theCurrentlyCheckedOutBranch: "Το υποκατάστημα που ελέγχεται αυτήν τη στιγμή. Επιλέξτε αυτό εάν χρειάζεται να βασιστείτε σε υπάρχουσες εργασίες από τον τρέχοντα κλάδο.",
    search: "Αναζήτηση",
    theDefaultBranchInYourRepository: "Ο προεπιλεγμένος κλάδος στο αποθετήριο σας. Επιλέξτε αυτό για να ξεκινήσετε κάτι νέο που δεν εξαρτάται από το τρέχον υποκατάστημά σας.",
    viewPullRequests: "Προβολή αιτημάτων έλξης",
    singleton: "Μοναδικό χαρτί",
    singletons: "Singletons"
  },
  "fr-FR": {
    branchName: "Nom de la filiale",
    branches: "Branches",
    cancel: "Annuler",
    collection: "Collection",
    collections: "Collections",
    create: "Créer",
    createPullRequest: "Créer une demande d'extraction",
    currentBranch: "Succursale actuelle",
    dashboard: "Tableau de bord",
    "delete": "Supprimer",
    defaultBranch: "Branche par défaut",
    deleteBranch: "Supprimer la branche",
    loading: "Chargement en cours",
    edit: "Modifier",
    newBranch: "Nouvelle branche",
    pullRequests: "Demandes d'extraction",
    otherBranches: "Autres succursales",
    save: "Sauvegarder",
    search: "Rechercher",
    singleton: "Singleton",
    singletons: "Célibataires",
    theCurrentlyCheckedOutBranch: "La branche actuellement extraite. Choisissez cette option si vous devez vous appuyer sur le travail existant de la branche actuelle.",
    theDefaultBranchInYourRepository: "La branche par défaut de votre référentiel. Choisissez ceci pour commencer quelque chose de nouveau qui ne dépend pas de votre branche actuelle.",
    viewPullRequests: "Afficher les demandes d'extraction",
    clear: "Effacer",
    basedOn: "Basé sur",
    add: "Ajouter"
  },
  "lv-LV": {
    basedOn: "Balstoties uz",
    add: "Pievienot",
    branchName: "Filiāles nosaukums",
    branches: "Nozares",
    cancel: "Atcelt",
    clear: "Notīrīt",
    collection: "Kolekcija",
    collections: "Kolekcijas",
    create: "Izveidot",
    createPullRequest: "Izveidot izvilkšanas pieprasījumu",
    currentBranch: "Pašreizējā filiāle",
    dashboard: "Mērinstrumentu panelis",
    "delete": "Dzēst",
    defaultBranch: "Noklusējuma filiāle",
    deleteBranch: "Dzēst filiāli",
    edit: "Rediģēt",
    loading: "Notiek ielāde",
    newBranch: "Jauna filiāle",
    search: "Meklēt",
    pullRequests: "Izvilkšanas pieprasījumi",
    singleton: "Singleton",
    singletons: "Vientuļi",
    theCurrentlyCheckedOutBranch: "Pašlaik izrakstītā filiāle. Izvēlieties šo, ja vēlaties izmantot esošo darbu no pašreizējās filiāles.",
    otherBranches: "Citas filiāles",
    theDefaultBranchInYourRepository: "Noklusējuma filiāle jūsu repozitorijā. Izvēlieties šo, lai sāktu kaut ko jaunu, kas nav atkarīgs no jūsu pašreizējās filiāles.",
    viewPullRequests: "Skatīt izvilkšanas pieprasījumus",
    save: "Saglabāt"
  },
  "nb-NO": {
    add: "Legg til",
    basedOn: "Basert på",
    branchName: "Filialnavn",
    cancel: "Avbryt",
    branches: "Grener",
    clear: "Tøm",
    collections: "Samlinger",
    collection: "Samling",
    create: "Skape",
    createPullRequest: "Opprett pull-forespørsel",
    currentBranch: "Nåværende gren",
    dashboard: "Dashbord",
    defaultBranch: "Standard gren",
    "delete": "Slett",
    deleteBranch: "Slett filial",
    edit: "Redigere",
    loading: "Laster inn",
    newBranch: "Ny gren",
    otherBranches: "Andre grener",
    pullRequests: "Trekk forespørsler",
    save: "Lagre",
    search: "Søk",
    singleton: "Singleton",
    singletons: "Singletoner",
    theCurrentlyCheckedOutBranch: "Den utsjekkede grenen. Velg dette hvis du skal bygge på eksisterende arbeid fra gjeldende gren.",
    theDefaultBranchInYourRepository: "Standardgrenen i depotet ditt. Velg dette for å starte noe nytt som ikke er avhengig av din nåværende filial.",
    viewPullRequests: "Se pull-forespørsler"
  },
  "nl-NL": {
    add: "Toevoegen",
    basedOn: "Gebaseerd op",
    branchName: "Filiaal naam",
    branches: "Takken",
    cancel: "Annuleren",
    clear: "Helder",
    collections: "Collecties",
    collection: "Verzameling",
    create: "Creëren",
    createPullRequest: "Pull-aanvraag maken",
    currentBranch: "Huidige tak",
    dashboard: "Dashboard",
    defaultBranch: "Standaard filiaal",
    "delete": "Verwijderen",
    deleteBranch: "Filiaal verwijderen",
    edit: "Bewerking",
    loading: "Laden",
    newBranch: "Nieuwe tak",
    otherBranches: "Andere takken",
    pullRequests: "Trek verzoeken",
    save: "Redden",
    search: "Zoeken",
    singleton: "eenling",
    singletons: "Eenlingen",
    theDefaultBranchInYourRepository: "De standaard branch in uw repository. Kies dit om iets nieuws te starten dat niet afhankelijk is van uw huidige branche.",
    theCurrentlyCheckedOutBranch: "Het momenteel uitgecheckte filiaal. Kies dit als u moet voortbouwen op bestaand werk van de huidige branch.",
    viewPullRequests: "Bekijk pull-aanvragen"
  },
  "pl-PL": {
    add: "Dodać",
    branchName: "Nazwa filii",
    basedOn: "Oparte na",
    branches: "Gałęzie",
    cancel: "Anulować",
    clear: "Wyczyść",
    collection: "Kolekcja",
    collections: "Kolekcje",
    create: "Tworzyć",
    createPullRequest: "Utwórz żądanie ściągnięcia",
    currentBranch: "Obecny oddział",
    dashboard: "Panel",
    defaultBranch: "Oddział domyślny",
    "delete": "Usuwać",
    deleteBranch: "Usuń oddział",
    edit: "Edytować",
    loading: "Trwa ładowanie",
    newBranch: "Nowa gałąź",
    otherBranches: "Inne gałęzie",
    save: "Ratować",
    pullRequests: "Żądania ściągnięcia",
    search: "Szukaj",
    singleton: "singel",
    singletons: "Singletony",
    theDefaultBranchInYourRepository: "Domyślna gałąź w twoim repozytorium. Wybierz tę opcję, aby rozpocząć coś nowego, co nie jest zależne od bieżącej gałęzi.",
    theCurrentlyCheckedOutBranch: "Aktualnie wyewidencjonowana gałąź. Wybierz tę opcję, jeśli chcesz oprzeć się na istniejącej pracy z bieżącej gałęzi.",
    viewPullRequests: "Wyświetl żądania ściągnięcia"
  },
  "pt-BR": {
    add: "Adicionar",
    basedOn: "Baseado em",
    branchName: "Nome da filial",
    branches: "Galhos",
    clear: "Limpar",
    cancel: "Cancelar",
    collection: "Coleção",
    collections: "Coleções",
    create: "Criar",
    createPullRequest: "Criar solicitação pull",
    currentBranch: "filial atual",
    dashboard: "Painel",
    "delete": "Excluir",
    defaultBranch: "ramo padrão",
    deleteBranch: "Excluir ramificação",
    edit: "Editar",
    newBranch: "Nova filial",
    loading: "Carregando",
    otherBranches: "Outros ramos",
    pullRequests: "Requisições pull",
    save: "Guardar",
    singleton: "solteiro",
    search: "Pesquisar",
    singletons: "Solteiros",
    theDefaultBranchInYourRepository: "A ramificação padrão em seu repositório. Escolha isso para iniciar algo novo que não dependa de sua ramificação atual.",
    theCurrentlyCheckedOutBranch: "A ramificação atualmente com check-out. Escolha esta opção se precisar criar um trabalho existente na ramificação atual.",
    viewPullRequests: "Ver solicitações pull"
  },
  "pt-PT": {
    add: "Adicionar",
    basedOn: "Baseado em",
    branchName: "Nome da filial",
    branches: "Galhos",
    cancel: "Cancelar",
    clear: "Limpar",
    collection: "Coleção",
    collections: "Coleções",
    create: "Criar",
    currentBranch: "filial atual",
    createPullRequest: "Criar solicitação pull",
    dashboard: "Painel",
    defaultBranch: "ramo padrão",
    "delete": "Excluir",
    deleteBranch: "Excluir ramificação",
    edit: "Editar",
    loading: "A carregar",
    newBranch: "Nova filial",
    otherBranches: "Outros ramos",
    save: "Guardar",
    pullRequests: "Requisições pull",
    singleton: "solteiro",
    search: "Procurar",
    singletons: "Solteiros",
    theCurrentlyCheckedOutBranch: "A ramificação atualmente com check-out. Escolha esta opção se precisar criar um trabalho existente na ramificação atual.",
    theDefaultBranchInYourRepository: "A ramificação padrão em seu repositório. Escolha isso para iniciar algo novo que não dependa de sua ramificação atual.",
    viewPullRequests: "Ver solicitações pull"
  },
  "es-ES": {
    basedOn: "Residencia en",
    branchName: "Nombre de la sucursal",
    add: "Agregar",
    branches: "Sucursales",
    cancel: "Cancelar",
    collection: "Colección",
    collections: "Colecciones",
    clear: "Borrar",
    create: "Crear",
    createPullRequest: "Crear solicitud de extracción",
    currentBranch: "Rama actual",
    dashboard: "Panel",
    defaultBranch: "Rama predeterminada",
    "delete": "Borrar",
    deleteBranch: "Eliminar rama",
    edit: "Editar",
    loading: "Cargando",
    otherBranches: "Otras sucursales",
    newBranch: "Nueva sucursal",
    pullRequests: "Solicitudes de extracción",
    save: "Ahorrar",
    singleton: "Semifallo",
    search: "Buscar",
    singletons: "Solteros",
    theCurrentlyCheckedOutBranch: "La sucursal actualmente desprotegida. Elija esto si necesita desarrollar el trabajo existente de la rama actual.",
    viewPullRequests: "Ver solicitudes de extracción",
    theDefaultBranchInYourRepository: "La rama predeterminada en su repositorio. Elija esto para comenzar algo nuevo que no dependa de su sucursal actual."
  },
  "ro-RO": {
    add: "Adăuga",
    basedOn: "Bazat pe",
    branchName: "Numele sucursalei",
    branches: "Ramuri",
    cancel: "Anulare",
    clear: "Golire",
    collection: "Colectie",
    create: "Crea",
    collections: "Colecții",
    createPullRequest: "Creați cerere de tragere",
    currentBranch: "Filiala actuală",
    dashboard: "Bord",
    defaultBranch: "Ramura implicită",
    "delete": "Șterge",
    deleteBranch: "Ștergeți ramura",
    edit: "Editați",
    loading: "Se încarcă",
    newBranch: "Filiala noua",
    otherBranches: "Alte ramuri",
    pullRequests: "Solicitări de tragere",
    save: "Salvați",
    search: "Căutare",
    singleton: "Singleton",
    singletons: "Singletons",
    theCurrentlyCheckedOutBranch: "Sucursala verificată în prezent. Alegeți acest lucru dacă trebuie să vă bazați pe munca existentă din ramura curentă.",
    theDefaultBranchInYourRepository: "Ramura implicită din depozitul dvs. Alegeți acest lucru pentru a începe ceva nou, care nu depinde de ramura dvs. actuală.",
    viewPullRequests: "Vizualizați solicitările de extragere"
  },
  "ru-RU": {
    basedOn: "На основе",
    add: "Добавлять",
    branchName: "Название филиала",
    branches: "Ветви",
    clear: "Очистить",
    cancel: "Отмена",
    collection: "Коллекция",
    collections: "Коллекции",
    create: "Создавать",
    createPullRequest: "Создать запрос на включение",
    currentBranch: "Текущая ветвь",
    dashboard: "Панель приборов",
    "delete": "Удалить",
    defaultBranch: "Ветка по умолчанию",
    deleteBranch: "Удалить ветку",
    edit: "Редактировать",
    loading: "Загрузка",
    newBranch: "Новая ветка",
    pullRequests: "Пулл-реквесты",
    otherBranches: "Другие филиалы",
    search: "Поиск",
    save: "Сохранять",
    singletons: "Одиночки",
    singleton: "Синглтон",
    theCurrentlyCheckedOutBranch: "Текущая проверенная ветвь. Выберите это, если вам нужно опираться на существующую работу из текущей ветки.",
    theDefaultBranchInYourRepository: "Ветка по умолчанию в вашем репозитории. Выберите это, чтобы начать что-то новое, не зависящее от вашей текущей ветки.",
    viewPullRequests: "Посмотреть пул-реквесты"
  },
  "sl-SI": {
    add: "Dodaj",
    basedOn: "Temelji na",
    branchName: "Ime podružnice",
    branches: "Podružnice",
    cancel: "Prekliči",
    collection: "Zbirka",
    clear: "Jasen",
    collections: "Zbirke",
    create: "Ustvari",
    createPullRequest: "Ustvari zahtevo za vleko",
    currentBranch: "Trenutna veja",
    dashboard: "Nadzorna plošča",
    defaultBranch: "Privzeta veja",
    "delete": "Izbriši",
    deleteBranch: "Izbriši vejo",
    edit: "Uredi",
    loading: "Nalaganje",
    otherBranches: "Druge veje",
    save: "Shrani",
    pullRequests: "Zahteve za vlečenje",
    newBranch: "Nova podružnica",
    search: "Iskanje",
    singleton: "Singleton",
    singletons: "Samski",
    theCurrentlyCheckedOutBranch: "Trenutno odjavljena podružnica. To izberite, če morate graditi na obstoječem delu iz trenutne veje.",
    theDefaultBranchInYourRepository: "Privzeta veja v vašem skladišču. Izberite to, da začnete nekaj novega, kar ni odvisno od vaše trenutne veje.",
    viewPullRequests: "Oglejte si zahteve za vlečenje"
  },
  "sr-SP": {
    add: "Додати",
    basedOn: "На бази",
    branchName: "Назив огранка",
    cancel: "Поништити, отказати",
    branches: "Огранци",
    clear: "Izbriši",
    collection: "Цоллецтион",
    create: "Креирај",
    createPullRequest: "Креирајте захтев за повлачење",
    collections: "Збирке",
    currentBranch: "Тренутна грана",
    dashboard: "Командна табла",
    defaultBranch: "Подразумевана грана",
    "delete": "Избриши",
    deleteBranch: "Обриши грану",
    edit: "Уредити",
    newBranch: "Нова грана",
    loading: "Učitavam",
    otherBranches: "Остале гране",
    pullRequests: "Захтеви за повлачење",
    save: "сачувати",
    search: "Pretraga",
    singleton: "Синглетон",
    singletons: "Синглетонс",
    theCurrentlyCheckedOutBranch: "Тренутно одјављена филијала. Изаберите ово ако треба да надоградите постојећи рад из тренутне гране.",
    theDefaultBranchInYourRepository: "Подразумевана грана у вашем спремишту. Изаберите ово да започнете нешто ново што не зависи од ваше тренутне гране.",
    viewPullRequests: "Прегледајте захтеве за повлачењем"
  },
  "sv-SE": {
    add: "Lägg till",
    basedOn: "Baserat på",
    branchName: "Filialens namn",
    branches: "Grenar",
    cancel: "Поништити, отказати",
    collections: "Samlingar",
    clear: "Rensa",
    collection: "Samling",
    create: "Skapa",
    currentBranch: "Nuvarande gren",
    defaultBranch: "Standardgren",
    createPullRequest: "Skapa pull-förfrågan",
    dashboard: "instrumentbräda",
    "delete": "Radera",
    deleteBranch: "Ta bort gren",
    edit: "Redigera",
    newBranch: "Ny gren",
    loading: "Läser in",
    otherBranches: "Andra grenar",
    save: "Spara",
    search: "Sök",
    pullRequests: "Dra förfrågningar",
    singleton: "Singleton",
    singletons: "Singlar",
    theCurrentlyCheckedOutBranch: "Den utcheckade filialen. Välj detta om du behöver bygga på befintligt arbete från den aktuella grenen.",
    theDefaultBranchInYourRepository: "Standardgrenen i ditt arkiv. Välj detta för att starta något nytt som inte är beroende av din nuvarande filial.",
    viewPullRequests: "Visa pull-förfrågningar"
  },
  "tr-TR": {
    add: "Avbryt",
    basedOn: "Dayalı",
    branchName: "şube adı",
    cancel: "iptal etmek",
    clear: "Temizle",
    branches: "Şubeler",
    collection: "Toplamak",
    collections: "Koleksiyonlar",
    create: "Yaratmak",
    createPullRequest: "Çekme isteği oluştur",
    currentBranch: "Mevcut şube",
    dashboard: "Gösterge Paneli",
    "delete": "Silmek",
    defaultBranch: "varsayılan dal",
    deleteBranch: "Şubeyi sil",
    edit: "Düzenlemek",
    otherBranches: "Diğer şubeler",
    newBranch: "Yeni dal",
    loading: "Yükleniyor",
    pullRequests: "Çekme istekleri",
    save: "Kaydetmek",
    search: "Ara",
    singleton: "Tekil",
    singletons: "Singleton'lar",
    theCurrentlyCheckedOutBranch: "Şu anda kontrol edilen şube. Geçerli daldaki mevcut işi geliştirmeniz gerekiyorsa bunu seçin.",
    viewPullRequests: "Çekme isteklerini görüntüle",
    theDefaultBranchInYourRepository: "Deponuzdaki varsayılan şube. Mevcut şubenize bağlı olmayan yeni bir şey başlatmak için bunu seçin."
  },
  "uk-UA": {
    add: "додати",
    basedOn: "На основі",
    branchName: "Назва гілки",
    branches: "Відділення",
    cancel: "скасувати",
    clear: "Очистити",
    collections: "Колекції",
    collection: "Колекція",
    create: "Створити",
    createPullRequest: "Створити запит на отримання",
    dashboard: "Панель приладів",
    currentBranch: "Поточне відділення",
    defaultBranch: "Гілка за замовчуванням",
    "delete": "Видалити",
    deleteBranch: "Видалити гілку",
    edit: "Редагувати",
    loading: "Завантаження",
    newBranch: "Нова гілка",
    otherBranches: "Інші гілки",
    pullRequests: "Запити на витягування",
    save: "зберегти",
    search: "Пошук",
    singleton: "Синглтон",
    singletons: "Одиночки",
    theCurrentlyCheckedOutBranch: "Поточна перевірена гілка. Виберіть це, якщо вам потрібно створити на основі існуючої роботи з поточної гілки.",
    theDefaultBranchInYourRepository: "Стандартна гілка у вашому сховищі. Виберіть це, щоб почати щось нове, що не залежить від вашої поточної гілки.",
    viewPullRequests: "Перегляд запитів на отримання"
  },
  "zh-CN": {
    add: "添加",
    basedOn: "基于",
    branches: "分支机构",
    cancel: "取消",
    branchName: "分店名称",
    clear: "透明",
    collection: "收藏",
    collections: "收藏品",
    create: "创造",
    currentBranch: "当前分支",
    createPullRequest: "创建拉取请求",
    dashboard: "仪表板",
    defaultBranch: "默认分支",
    deleteBranch: "删除分支",
    edit: "编辑",
    loading: "正在加载",
    "delete": "删除",
    newBranch: "新分行",
    pullRequests: "拉取请求",
    otherBranches: "其他分行",
    save: "节省",
    singleton: "单例",
    singletons: "单例",
    search: "搜索",
    theCurrentlyCheckedOutBranch: "当前签出的分支。 如果您需要在当前分支的现有工作的基础上构建，请选择此项。",
    theDefaultBranchInYourRepository: "存储库中的默认分支。 选择此选项可开始一些不依赖于当前分支的新操作。",
    viewPullRequests: "查看拉取请求"
  },
  "zh-TW": {
    add: "添加",
    basedOn: "基於",
    branchName: "分店名稱",
    branches: "分支機構",
    clear: "清除",
    cancel: "取消",
    collection: "收藏",
    collections: "收藏品",
    create: "創造",
    createPullRequest: "創建拉取請求",
    currentBranch: "當前分支",
    dashboard: "儀表板",
    defaultBranch: "默認分支",
    "delete": "刪除",
    deleteBranch: "刪除分支",
    edit: "編輯",
    loading: "正在載入",
    newBranch: "新分行",
    otherBranches: "其他分行",
    pullRequests: "拉取請求",
    search: "搜尋",
    singleton: "單例",
    save: "節省",
    singletons: "單例",
    theCurrentlyCheckedOutBranch: "當前簽出的分支。 如果您需要在當前分支的現有工作的基礎上構建，請選擇此項。",
    theDefaultBranchInYourRepository: "存儲庫中的默認分支。 選擇此選項可開始一些不依賴於當前分支的新操作。",
    viewPullRequests: "查看拉取請求"
  },
  "sk-SK": {
    add: "Pridať",
    basedOn: "Založené na",
    branchName: "Meno pobočky",
    clear: "Vymazať",
    cancel: "Zrušiť",
    branches: "Pobočky",
    collection: "Zbierka",
    collections: "zbierky",
    create: "Vytvorte",
    createPullRequest: "Vytvorte požiadavku na stiahnutie",
    defaultBranch: "Predvolená vetva",
    "delete": "Odstrániť",
    dashboard: "Dashboard",
    currentBranch: "Aktuálna pobočka",
    edit: "Upraviť",
    deleteBranch: "Odstrániť vetvu",
    loading: "Načítava sa",
    newBranch: "Nová pobočka",
    pullRequests: "Vytiahnite žiadosti",
    otherBranches: "Ostatné pobočky",
    save: "Uložiť",
    search: "Vyhľadávať",
    singleton: "Singleton",
    theCurrentlyCheckedOutBranch: "Aktuálne odhlásená pobočka. Túto možnosť vyberte, ak potrebujete stavať na existujúcej práci z aktuálnej pobočky.",
    theDefaultBranchInYourRepository: "Predvolená vetva vo vašom úložisku. Zvoľte túto možnosť, ak chcete začať niečo nové, čo nezávisí od vašej aktuálnej pobočky.",
    singletons: "Singletons",
    viewPullRequests: "Zobraziť požiadavky na stiahnutie"
  }
};
var RouterContext = (0, import_react79.createContext)(null);
function RouterProvider(props) {
  const [url, setUrl] = (0, import_react79.useState)(() => window.location.href);
  const router = (0, import_react79.useMemo)(() => {
    function navigate(url2, replace2) {
      const newUrl = new URL(url2, window.location.href);
      if (newUrl.origin !== window.location.origin || !newUrl.pathname.startsWith("/keystatic")) {
        window.location.assign(newUrl);
        return;
      }
      window.history[replace2 ? "replaceState" : "pushState"](null, "", newUrl);
      (0, import_react79.startTransition)(() => {
        setUrl(newUrl.toString());
      });
    }
    const replaced = location.pathname.replace(/^\/keystatic\/?/, "");
    const params2 = replaced === "" ? [] : replaced.split("/").map(decodeURIComponent);
    const parsedUrl = new URL(url);
    return {
      href: parsedUrl.pathname + parsedUrl.search,
      replace(path3) {
        navigate(path3, true);
      },
      push(path3) {
        navigate(path3, false);
      },
      params: params2
    };
  }, [url]);
  (0, import_react79.useEffect)(() => {
    const handleNavigate = () => {
      (0, import_react79.startTransition)(() => {
        setUrl(window.location.href);
      });
    };
    window.addEventListener("popstate", handleNavigate);
    return () => {
      window.removeEventListener("popstate", handleNavigate);
    };
  }, []);
  return (0, import_jsx_runtime92.jsx)(RouterContext.Provider, {
    value: router,
    children: props.children
  });
}
function useRouter() {
  const router = (0, import_react79.useContext)(RouterContext);
  if (router == null) {
    throw new Error("useRouter must be used within a RouterProvider");
  }
  return router;
}
function fixPath(path3) {
  return path3.replace(/^\.?\/+/, "").replace(/\/*$/, "");
}
var collectionPath = /\/\*\*?(?:$|\/)/;
function getConfiguredCollectionPath(config3, collection2) {
  var _collectionConfig$pat;
  const collectionConfig = config3.collections[collection2];
  const path3 = (_collectionConfig$pat = collectionConfig.path) !== null && _collectionConfig$pat !== void 0 ? _collectionConfig$pat : `${collection2}/*/`;
  if (!collectionPath.test(path3)) {
    throw new Error(`Collection path must end with /* or /** or include /*/ or /**/ but ${collection2} has ${path3}`);
  }
  return path3;
}
function getCollectionPath(config3, collection2) {
  const configuredPath = getConfiguredCollectionPath(config3, collection2);
  const path3 = fixPath(configuredPath.replace(/\*\*?.*$/, ""));
  return path3;
}
function getCollectionFormat(config3, collection2) {
  var _collectionConfig$for;
  const collectionConfig = config3.collections[collection2];
  return getFormatInfo((_collectionConfig$for = collectionConfig.format) !== null && _collectionConfig$for !== void 0 ? _collectionConfig$for : "yaml", collectionConfig.schema, getConfiguredCollectionPath(config3, collection2));
}
function getSingletonFormat(config3, singleton2) {
  var _singletonConfig$form, _singletonConfig$path;
  const singletonConfig = config3.singletons[singleton2];
  return getFormatInfo((_singletonConfig$form = singletonConfig.format) !== null && _singletonConfig$form !== void 0 ? _singletonConfig$form : "yaml", singletonConfig.schema, (_singletonConfig$path = singletonConfig.path) !== null && _singletonConfig$path !== void 0 ? _singletonConfig$path : `${singleton2}/`);
}
function getCollectionItemPath(config3, collection2, slug) {
  const basePath = getCollectionPath(config3, collection2);
  const suffix = getCollectionItemSlugSuffix(config3, collection2);
  return `${basePath}/${slug}${suffix}`;
}
function getEntryDataFilepath(dir, formatInfo) {
  return `${dir}${formatInfo.dataLocation === "index" ? "/index" : ""}${getDataFileExtension(formatInfo)}`;
}
function getSlugGlobForCollection(config3, collection2) {
  const collectionPath2 = getConfiguredCollectionPath(config3, collection2);
  return collectionPath2.includes("**") ? "**" : "*";
}
function getCollectionItemSlugSuffix(config3, collection2) {
  const configuredPath = getConfiguredCollectionPath(config3, collection2);
  const path3 = fixPath(configuredPath.replace(/^[^*]+\*\*?/, ""));
  return path3 ? `/${path3}` : "";
}
function getSingletonPath(config3, singleton2) {
  var _singleton$path, _singleton$path2;
  if ((_singleton$path = config3.singletons[singleton2].path) !== null && _singleton$path !== void 0 && _singleton$path.includes("*")) {
    throw new Error(`Singleton paths cannot include * but ${singleton2} has ${config3.singletons[singleton2].path}`);
  }
  return fixPath((_singleton$path2 = config3.singletons[singleton2].path) !== null && _singleton$path2 !== void 0 ? _singleton$path2 : singleton2);
}
function getDataFileExtension(formatInfo) {
  return formatInfo.contentField ? formatInfo.contentField.config.contentExtension : "." + formatInfo.data;
}
function getFormatInfo(format2, schema, path3) {
  var _format$data;
  const dataLocation = path3.endsWith("/") ? "index" : "outer";
  if (typeof format2 === "string") {
    return {
      dataLocation,
      contentField: void 0,
      data: format2
    };
  }
  let contentField;
  if (format2.contentField) {
    const field2 = schema[format2.contentField];
    assert((field2 === null || field2 === void 0 ? void 0 : field2.kind) === "form", `${format2.contentField} is not a form field`);
    assert(field2.formKind === "content", `${format2.contentField} is not a content field`);
    contentField = {
      key: format2.contentField,
      config: field2
    };
  }
  return {
    data: (_format$data = format2.data) !== null && _format$data !== void 0 ? _format$data : "yaml",
    contentField,
    dataLocation
  };
}
function getPathPrefix(storage) {
  if (storage.kind === "local" || !storage.pathPrefix) {
    return void 0;
  }
  return fixPath(storage.pathPrefix) + "/";
}
async function sha1(content3) {
  const hashBuffer = await crypto.subtle.digest("SHA-1", content3);
  return bytesToHex(new Uint8Array(hashBuffer));
}
var textEncoder$2 = new TextEncoder();
function blobSha(contents) {
  const blobPrefix = textEncoder$2.encode("blob " + contents.length + "\0");
  const array = new Uint8Array(blobPrefix.byteLength + contents.byteLength);
  array.set(blobPrefix, 0);
  array.set(contents, blobPrefix.byteLength);
  return sha1(array);
}
function getTreeNodeAtPath(root, path3) {
  const parts = path3.split("/");
  let node4 = root.get(parts[0]);
  for (const part of parts.slice(1)) {
    if (!node4)
      return void 0;
    if (!node4.children)
      return void 0;
    node4 = node4.children.get(part);
  }
  return node4;
}
function getNodeAtPath(tree2, path3) {
  let node4 = tree2;
  for (const part of path3.split("/")) {
    if (!node4.has(part)) {
      node4.set(part, /* @__PURE__ */ new Map());
    }
    const innerNode = node4.get(part);
    assert(innerNode instanceof Map, "expected tree");
    node4 = innerNode;
  }
  return node4;
}
function getFilename(path3) {
  return path3.replace(/.*\//, "");
}
function getDirname(path3) {
  return path3.replace(/\/[^/]+$/, "");
}
function toTreeChanges(changes) {
  const changesRoot = /* @__PURE__ */ new Map();
  for (const deletion of changes.deletions) {
    const parentTree = getNodeAtPath(changesRoot, getDirname(deletion));
    parentTree.set(getFilename(deletion), "delete");
  }
  for (const addition of changes.additions) {
    const parentTree = getNodeAtPath(changesRoot, getDirname(addition.path));
    parentTree.set(getFilename(addition.path), addition.contents);
  }
  return changesRoot;
}
var SPACE_CHAR_CODE = 32;
var space2 = new Uint8Array([SPACE_CHAR_CODE]);
var nullchar = new Uint8Array([0]);
var tree = textEncoder$2.encode("tree ");
function treeSha(children) {
  const entries2 = [...children].map(([name2, node4]) => ({
    name: name2,
    sha: node4.entry.sha,
    mode: node4.entry.mode
  }));
  entries2.sort((a3, b2) => {
    const aName = a3.mode === "040000" ? a3.name + "/" : a3.name;
    const bName = b2.mode === "040000" ? b2.name + "/" : b2.name;
    return aName === bName ? 0 : aName < bName ? -1 : 1;
  });
  const treeObject = entries2.flatMap((entry) => {
    const mode = textEncoder$2.encode(entry.mode.replace(/^0/, ""));
    const name2 = textEncoder$2.encode(entry.name);
    const sha = hexToBytes(entry.sha);
    return [mode, space2, name2, nullchar, sha];
  });
  return sha1(concatBytes([tree, textEncoder$2.encode(treeObject.reduce((sum2, val) => sum2 + val.byteLength, 0).toString()), nullchar, ...treeObject]));
}
function concatBytes(byteArrays) {
  const totalLength = byteArrays.reduce((sum2, arr) => sum2 + arr.byteLength, 0);
  const result = new Uint8Array(totalLength);
  let offset = 0;
  for (const arr of byteArrays) {
    result.set(arr, offset);
    offset += arr.byteLength;
  }
  return result;
}
function hexToBytes(str) {
  const bytes = new Uint8Array(str.length / 2);
  for (var i6 = 0; i6 < bytes.byteLength; i6 += 1) {
    const start2 = i6 * 2;
    bytes[i6] = parseInt(str.slice(start2, start2 + 2), 16);
  }
  return bytes;
}
async function createTreeNodeEntry(path3, children) {
  const sha = await treeSha(children);
  return {
    path: path3,
    mode: "040000",
    type: "tree",
    sha
  };
}
async function createBlobNodeEntry(path3, contents) {
  const sha = "sha" in contents ? contents.sha : await blobSha(contents);
  return {
    path: path3,
    mode: "100644",
    type: "blob",
    sha
  };
}
async function updateTreeWithChanges(tree2, changes) {
  var _await$updateTree;
  const newTree = (_await$updateTree = await updateTree(tree2, toTreeChanges(changes), [])) !== null && _await$updateTree !== void 0 ? _await$updateTree : /* @__PURE__ */ new Map();
  return {
    entries: treeToEntries(newTree),
    sha: await treeSha(newTree !== null && newTree !== void 0 ? newTree : /* @__PURE__ */ new Map())
  };
}
function treeToEntries(tree2) {
  return [...tree2.values()].flatMap((x4) => x4.children ? [x4.entry, ...treeToEntries(x4.children)] : [x4.entry]);
}
async function updateTree(tree2, changedTree, path3) {
  const newTree = new Map(tree2);
  for (const [key, value2] of changedTree) {
    if (value2 === "delete") {
      newTree.delete(key);
    }
    if (value2 instanceof Map) {
      var _newTree$get$children, _newTree$get;
      const existingChildren = (_newTree$get$children = (_newTree$get = newTree.get(key)) === null || _newTree$get === void 0 ? void 0 : _newTree$get.children) !== null && _newTree$get$children !== void 0 ? _newTree$get$children : /* @__PURE__ */ new Map();
      const children = await updateTree(existingChildren, value2, path3.concat(key));
      if (children === void 0) {
        newTree.delete(key);
        continue;
      }
      const entry = await createTreeNodeEntry(path3.concat(key).join("/"), children);
      newTree.set(key, {
        entry,
        children
      });
    }
    if (value2 instanceof Uint8Array || typeof value2 === "object" && "sha" in value2) {
      const entry = await createBlobNodeEntry(path3.concat(key).join("/"), value2);
      newTree.set(key, {
        entry
      });
    }
  }
  if (newTree.size === 0) {
    return void 0;
  }
  return newTree;
}
function treeEntriesToTreeNodes(entries2) {
  const root = /* @__PURE__ */ new Map();
  const getChildrenAtPath = (parts) => {
    var _node;
    if (parts.length === 0) {
      return root;
    }
    let node4 = root.get(parts[0]);
    for (const part of parts.slice(1)) {
      if (!node4)
        return void 0;
      if (!node4.children)
        return void 0;
      node4 = node4.children.get(part);
    }
    return (_node = node4) === null || _node === void 0 ? void 0 : _node.children;
  };
  for (const entry of entries2) {
    const split2 = entry.path.split("/");
    const children = getChildrenAtPath(split2.slice(0, -1));
    if (children) {
      children.set(split2[split2.length - 1], {
        entry,
        children: entry.type === "tree" ? /* @__PURE__ */ new Map() : void 0
      });
    }
  }
  return root;
}
var LOADING = Symbol("loading");
function isThenable(value2) {
  return value2 && typeof value2.then === "function";
}
function useData(func) {
  const [state, setState] = (0, import_react79.useState)({
    kind: "loading"
  });
  let stateToReturn = state;
  const result = (0, import_react79.useMemo)(() => {
    try {
      const result2 = func();
      if (isThenable(result2)) {
        result2.then(() => {
        }, () => {
        });
      }
      return {
        kind: "result",
        result: result2
      };
    } catch (error3) {
      return {
        kind: "error",
        error: error3
      };
    }
  }, [func]);
  const resultState = (0, import_react79.useMemo)(() => {
    if (result.kind === "error" && (state.kind !== "error" || state.error !== result.error)) {
      return {
        kind: "error",
        error: result.error
      };
    }
    if (result.kind === "result" && !isThenable(result.result) && result.result !== LOADING && (state.kind !== "loaded" || state.data !== result.result)) {
      return {
        kind: "loaded",
        data: result.result
      };
    }
  }, [result, state]);
  if (resultState && resultState !== state) {
    stateToReturn = resultState;
    setState(resultState);
  }
  (0, import_react79.useEffect)(() => {
    if (result.kind === "result" && isThenable(result.result)) {
      setState({
        kind: "loading"
      });
      let isActive = true;
      result.result.then((result2) => {
        if (result2 === LOADING || !isActive)
          return;
        setState({
          kind: "loaded",
          data: result2
        });
      }, (error3) => {
        if (!isActive)
          return;
        setState({
          kind: "error",
          error: error3
        });
      });
      return () => {
        isActive = false;
      };
    }
  }, [result]);
  return stateToReturn;
}
function mapDataState(state, func) {
  if (state.kind === "error" || state.kind === "loading") {
    return state;
  }
  return {
    kind: "loaded",
    data: func(state.data)
  };
}
function mergeDataStates(input) {
  const entries2 = Object.entries(input);
  for (const [, value2] of entries2) {
    if (value2.kind === "error") {
      return {
        kind: "error",
        error: value2.error
      };
    }
  }
  for (const [, value2] of entries2) {
    if (value2.kind === "loading") {
      return {
        kind: "loading"
      };
    }
  }
  return {
    kind: "loaded",
    data: Object.fromEntries(entries2.map(([key, val]) => {
      return [key, val.data];
    }))
  };
}
function collectDirectoriesUsedInSchemaInner(schema, directories, seenSchemas) {
  if (seenSchemas.has(schema)) {
    return;
  }
  seenSchemas.add(schema);
  if (schema.kind === "array") {
    return collectDirectoriesUsedInSchemaInner(schema.element, directories, seenSchemas);
  }
  if (schema.kind === "child") {
    return;
  }
  if (schema.kind === "form") {
    if (schema.formKind === "asset" && schema.directory !== void 0) {
      directories.add(fixPath(schema.directory));
    }
    if (schema.formKind === "content" && schema.directories !== void 0) {
      for (const directory of schema.directories) {
        directories.add(fixPath(directory));
      }
    }
    return;
  }
  if (schema.kind === "object") {
    for (const field2 of Object.values(schema.fields)) {
      collectDirectoriesUsedInSchemaInner(field2, directories, seenSchemas);
    }
    return;
  }
  if (schema.kind === "conditional") {
    for (const innerSchema of Object.values(schema.values)) {
      collectDirectoriesUsedInSchemaInner(innerSchema, directories, seenSchemas);
    }
    return;
  }
  assertNever(schema);
}
function collectDirectoriesUsedInSchema(schema) {
  const directories = /* @__PURE__ */ new Set();
  collectDirectoriesUsedInSchemaInner(schema, directories, /* @__PURE__ */ new Set());
  return directories;
}
function getDirectoriesForTreeKey(schema, directory, slug, format2) {
  const directories = [fixPath(directory)];
  if (format2.dataLocation === "outer") {
    directories.push(fixPath(directory) + getDataFileExtension(format2));
  }
  const toAdd = slug === void 0 ? "" : `/${slug}`;
  for (const directory2 of collectDirectoriesUsedInSchema(schema)) {
    directories.push(directory2 + toAdd);
  }
  return directories;
}
function getTreeKey(directories, tree2) {
  return directories.map((d5) => {
    var _getTreeNodeAtPath;
    return (_getTreeNodeAtPath = getTreeNodeAtPath(tree2, d5)) === null || _getTreeNodeAtPath === void 0 ? void 0 : _getTreeNodeAtPath.entry.sha;
  }).join("-");
}
var pkgJson = {
  name: "@keystatic/core",
  version: "0.3.19",
  license: "MIT",
  repository: {
    type: "git",
    url: "https://github.com/Thinkmill/keystatic/",
    directory: "packages/keystatic"
  },
  type: "module",
  exports: {
    "./ui": {
      types: "./dist/keystatic-core-ui.js",
      node: {
        "react-server": "./dist/keystatic-core-ui.node.react-server.js",
        "default": "./dist/keystatic-core-ui.node.js"
      },
      "react-server": "./dist/keystatic-core-ui.react-server.js",
      "default": "./dist/keystatic-core-ui.js"
    },
    ".": {
      types: "./dist/keystatic-core.js",
      node: {
        "react-server": "./dist/keystatic-core.node.react-server.js",
        "default": "./dist/keystatic-core.node.js"
      },
      "react-server": "./dist/keystatic-core.react-server.js",
      "default": "./dist/keystatic-core.js"
    },
    "./api/utils": {
      types: "./dist/keystatic-core-api-utils.js",
      node: {
        "react-server": "./dist/keystatic-core-api-utils.node.react-server.js",
        "default": "./dist/keystatic-core-api-utils.node.js"
      },
      "react-server": "./dist/keystatic-core-api-utils.react-server.js",
      "default": "./dist/keystatic-core-api-utils.js"
    },
    "./renderer": {
      types: "./dist/keystatic-core-renderer.js",
      node: {
        "react-server": "./dist/keystatic-core-renderer.node.react-server.js",
        "default": "./dist/keystatic-core-renderer.node.js"
      },
      "react-server": "./dist/keystatic-core-renderer.react-server.js",
      "default": "./dist/keystatic-core-renderer.js"
    },
    "./api/generic": {
      types: "./dist/keystatic-core-api-generic.js",
      node: {
        "react-server": "./dist/keystatic-core-api-generic.node.react-server.js",
        "default": "./dist/keystatic-core-api-generic.node.js"
      },
      "react-server": "./dist/keystatic-core-api-generic.react-server.js",
      "default": "./dist/keystatic-core-api-generic.js"
    },
    "./reader": {
      types: "./dist/keystatic-core-reader.js",
      node: {
        "react-server": "./dist/keystatic-core-reader.node.react-server.js",
        "default": "./dist/keystatic-core-reader.node.js"
      },
      "react-server": "./dist/keystatic-core-reader.react-server.js",
      "default": "./dist/keystatic-core-reader.js"
    },
    "./reader/github": {
      types: "./dist/keystatic-core-reader-github.js",
      node: {
        "react-server": "./dist/keystatic-core-reader-github.node.react-server.js",
        "default": "./dist/keystatic-core-reader-github.node.js"
      },
      "react-server": "./dist/keystatic-core-reader-github.react-server.js",
      "default": "./dist/keystatic-core-reader-github.js"
    },
    "./content-components": {
      types: "./dist/keystatic-core-content-components.js",
      node: {
        "react-server": "./dist/keystatic-core-content-components.node.react-server.js",
        "default": "./dist/keystatic-core-content-components.node.js"
      },
      "react-server": "./dist/keystatic-core-content-components.react-server.js",
      "default": "./dist/keystatic-core-content-components.js"
    },
    "./component-blocks": {
      types: "./dist/keystatic-core-component-blocks.js",
      node: {
        "react-server": "./dist/keystatic-core-component-blocks.node.react-server.js",
        "default": "./dist/keystatic-core-component-blocks.node.js"
      },
      "react-server": "./dist/keystatic-core-component-blocks.react-server.js",
      "default": "./dist/keystatic-core-component-blocks.js"
    },
    "./form/fields/markdoc": {
      types: "./dist/keystatic-core-form-fields-markdoc.js",
      node: {
        "react-server": "./dist/keystatic-core-form-fields-markdoc.node.react-server.js",
        "default": "./dist/keystatic-core-form-fields-markdoc.node.js"
      },
      "react-server": "./dist/keystatic-core-form-fields-markdoc.react-server.js",
      "default": "./dist/keystatic-core-form-fields-markdoc.js"
    },
    "./package.json": "./package.json"
  },
  files: [
    "dist"
  ],
  scripts: {
    setup: "ts-gql build && tsx scripts/l10n.cts && tsx scripts/build-prism.cts",
    build: "pnpm run setup && next build",
    dev: "next dev",
    start: "next start"
  },
  dependencies: {
    "@babel/runtime": "^7.18.3",
    "@braintree/sanitize-url": "^6.0.2",
    "@emotion/css": "^11.9.0",
    "@emotion/weak-memoize": "^0.3.0",
    "@floating-ui/react": "^0.24.0",
    "@internationalized/string": "^3.1.1",
    "@keystar/ui": "^0.7.0",
    "@markdoc/markdoc": "^0.3.0",
    "@react-aria/focus": "^3.14.3",
    "@react-aria/i18n": "^3.8.0",
    "@react-aria/interactions": "^3.19.1",
    "@react-aria/overlays": "^3.18.1",
    "@react-aria/selection": "^3.17.1",
    "@react-aria/utils": "^3.21.1",
    "@react-aria/visually-hidden": "^3.8.6",
    "@react-stately/collections": "^3.10.2",
    "@react-stately/list": "^3.10.0",
    "@react-stately/overlays": "^3.6.3",
    "@react-stately/utils": "^3.8.0",
    "@react-types/shared": "^3.21.0",
    "@sindresorhus/slugify": "^1.1.2",
    "@toeverything/y-indexeddb": "^0.10.0-canary.9",
    "@ts-gql/tag": "^0.7.0",
    "@types/mdast": "^4.0.3",
    "@types/node": "16.11.13",
    "@types/react": "^18.2.8",
    "@types/react-dom": "^18.0.11",
    "@urql/core": "^4.1.3",
    "@urql/exchange-auth": "^2.1.6",
    "@urql/exchange-graphcache": "^6.3.3",
    "@urql/exchange-persisted": "^4.1.0",
    cookie: "^0.5.0",
    "decimal.js": "^10.4.3",
    emery: "^1.4.1",
    "escape-string-regexp": "^4.0.0",
    "fast-deep-equal": "^3.1.3",
    graphql: "^16.6.0",
    "idb-keyval": "^6.2.1",
    ignore: "^5.2.4",
    "iron-webcrypto": "^0.10.1",
    "is-hotkey": "^0.2.0",
    "js-base64": "^3.7.5",
    "js-yaml": "^4.1.0",
    lib0: "^0.2.88",
    "lru-cache": "^7.14.1",
    "match-sorter": "^6.3.1",
    "mdast-util-from-markdown": "^2.0.0",
    "mdast-util-gfm": "^3.0.0",
    "mdast-util-gfm-autolink-literal": "^2.0.0",
    "mdast-util-gfm-strikethrough": "^2.0.0",
    "mdast-util-mdx": "^3.0.0",
    "mdast-util-to-markdown": "^2.1.0",
    "micromark-extension-gfm": "^3.0.0",
    "micromark-extension-gfm-autolink-literal": "^2.0.0",
    "micromark-extension-gfm-strikethrough": "^2.0.0",
    "micromark-extension-mdxjs": "^3.0.0",
    minimatch: "^9.0.3",
    partysocket: "^0.0.22",
    "prosemirror-commands": "^1.5.1",
    "prosemirror-history": "^1.3.0",
    "prosemirror-keymap": "^1.2.1",
    "prosemirror-model": "^1.19.0",
    "prosemirror-state": "^1.4.2",
    "prosemirror-tables": "^1.3.4",
    "prosemirror-transform": "^1.7.1",
    "prosemirror-view": "^1.30.2",
    "scroll-into-view-if-needed": "^3.0.3",
    slate: "^0.91.4",
    "slate-history": "^0.86.0",
    "slate-react": "^0.91.9",
    "unist-util-visit": "^5.0.0",
    urql: "^4.0.0",
    "y-prosemirror": "^1.2.2",
    "y-protocols": "^1.0.6",
    yjs: "^13.6.11",
    zod: "^3.20.2"
  },
  devDependencies: {
    "@jest/expect": "^29.7.0",
    "@jest/globals": "^29.7.0",
    "@testing-library/user-event": "^14.4.3",
    "@ts-gql/compiler": "^0.16.1",
    "@ts-gql/eslint-plugin": "^0.8.5",
    "@ts-gql/next": "^17.0.0",
    "@types/cookie": "^0.5.1",
    "@types/is-hotkey": "^0.1.7",
    "@types/js-yaml": "^4.0.5",
    "@types/prismjs": "^1.26.0",
    "@types/signal-exit": "^3.0.1",
    eslint: "^8.18.0",
    "fast-glob": "^3.2.12",
    "jest-diff": "^29.0.1",
    outdent: "^0.8.0",
    "pretty-format": "^29.0.1",
    prismjs: "^1.29.0",
    react: "^18.2.0",
    "react-dom": "^18.2.0",
    "react-element-to-jsx-string": "^15.0.0",
    "resize-observer-polyfill": "^1.5.1",
    "signal-exit": "^3.0.7",
    "slate-hyperscript": "^0.77.0",
    tsx: "^3.8.0",
    typescript: "^5.2.2"
  },
  peerDependencies: {
    react: "^18.2.0",
    "react-dom": "^18.2.0"
  },
  preconstruct: {
    entrypoints: [
      "index.ts",
      "api/generic.ts",
      "api/utils.ts",
      "reader/index.ts",
      "reader/github.ts",
      "renderer.tsx",
      "ui.tsx",
      "form/fields/markdoc/index.tsx",
      "component-blocks/index.tsx",
      "content-components.ts"
    ]
  },
  "ts-gql": {
    schema: "./github.graphql",
    mode: "no-transform",
    addTypename: false,
    scalars: {
      GitObjectID: "string"
    }
  },
  imports: {
    "#react-cache-in-react-server": {
      "react-server": "./src/reader/react-server-cache.ts",
      "default": "./src/reader/noop-cache.ts"
    },
    "#sha1": {
      node: "./src/sha1/node.ts",
      "default": "./src/sha1/webcrypto.ts"
    },
    "#webcrypto": {
      node: "./src/api/webcrypto/node.ts",
      "default": "./src/api/webcrypto/default.ts"
    },
    "#api-handler": {
      node: "./src/api/api-node.ts",
      "default": "./src/api/api-noop.ts"
    },
    "#field-ui/*": {
      "react-server": "./src/form/fields/empty-field-ui.tsx",
      "default": "./src/form/fields/*/ui.tsx"
    },
    "#component-block-primitives": {
      "react-server": "./src/form/fields/document/DocumentEditor/primitives/blank-for-react-server.tsx",
      "default": "./src/form/fields/document/DocumentEditor/primitives/index.tsx"
    },
    "#cloud-image-preview": {
      "react-server": "./src/component-blocks/blank-for-react-server.tsx",
      "default": "./src/component-blocks/cloud-image-preview.tsx"
    }
  }
};
function object(fields, opts) {
  return {
    ...opts,
    kind: "object",
    fields
  };
}
function pluralize(count, options) {
  const {
    singular,
    plural = singular + "s",
    inclusive = true
  } = options;
  const variant = count === 1 ? singular : plural;
  return inclusive ? `${count} ${variant}` : variant;
}
function getBranchPrefix(config3) {
  return config3.storage.kind !== "local" ? config3.storage.branchPrefix : void 0;
}
function isGitHubConfig(config3) {
  return config3.storage.kind === "github";
}
function isLocalConfig(config3) {
  return config3.storage.kind === "local";
}
function isCloudConfig(config3) {
  var _config$cloud;
  if (config3.storage.kind !== "cloud")
    return false;
  if (!((_config$cloud = config3.cloud) !== null && _config$cloud !== void 0 && _config$cloud.project) || !config3.cloud.project.includes("/")) {
    throw new Error(`Keystatic is set to \`storage: { kind: 'cloud' }\` but \`cloud.project\` isn't set.
config({
  storage: { kind: 'cloud' },
  cloud: { project: 'team/project' },
})`);
  }
  return true;
}
function getSplitCloudProject(config3) {
  var _config$cloud2;
  if (!((_config$cloud2 = config3.cloud) !== null && _config$cloud2 !== void 0 && _config$cloud2.project))
    return void 0;
  const [team, project] = config3.cloud.project.split("/");
  return {
    team,
    project
  };
}
function getRepoPath(config3) {
  return `${config3.mainOwner}/${config3.mainRepo}`;
}
function getRepoUrl(config3) {
  return `https://github.com/${getRepoPath(config3)}`;
}
function getSlugFromState(collectionConfig, state) {
  const value2 = state[collectionConfig.slugField];
  const field2 = collectionConfig.schema[collectionConfig.slugField];
  if (field2.kind !== "form" || field2.formKind !== "slug") {
    throw new Error(`slugField is not a slug field`);
  }
  return field2.serializeWithSlug(value2).slug;
}
function getEntriesInCollectionWithTreeKey(config3, collection2, rootTree) {
  var _getTreeNodeAtPath$ch, _getTreeNodeAtPath;
  const collectionConfig = config3.collections[collection2];
  const schema = object(collectionConfig.schema);
  const formatInfo = getCollectionFormat(config3, collection2);
  const extension2 = getDataFileExtension(formatInfo);
  const glob = getSlugGlobForCollection(config3, collection2);
  const collectionPath2 = getCollectionPath(config3, collection2);
  const directory = (_getTreeNodeAtPath$ch = (_getTreeNodeAtPath = getTreeNodeAtPath(rootTree, collectionPath2)) === null || _getTreeNodeAtPath === void 0 ? void 0 : _getTreeNodeAtPath.children) !== null && _getTreeNodeAtPath$ch !== void 0 ? _getTreeNodeAtPath$ch : /* @__PURE__ */ new Map();
  const entries2 = [];
  const directoriesUsedInSchema = [...collectDirectoriesUsedInSchema(schema)];
  const suffix = getCollectionItemSlugSuffix(config3, collection2);
  const possibleEntries = new Map(directory);
  if (glob === "**") {
    const handleDirectory = (dir, prefix4) => {
      for (const [key, entry] of dir) {
        if (entry.children) {
          possibleEntries.set(`${prefix4}${key}`, entry);
          handleDirectory(entry.children, `${prefix4}${key}/`);
        } else {
          possibleEntries.set(`${prefix4}${key}`, entry);
        }
      }
    };
    handleDirectory(directory, "");
  }
  for (const [key, entry] of possibleEntries) {
    if (formatInfo.dataLocation === "index") {
      var _actualEntry$children;
      const actualEntry = getTreeNodeAtPath(rootTree, getCollectionItemPath(config3, collection2, key));
      if (!(actualEntry !== null && actualEntry !== void 0 && (_actualEntry$children = actualEntry.children) !== null && _actualEntry$children !== void 0 && _actualEntry$children.has("index" + extension2)))
        continue;
      entries2.push({
        key: getTreeKey([actualEntry.entry.path, ...directoriesUsedInSchema.map((x4) => `${x4}/${key}`)], rootTree),
        slug: key,
        sha: actualEntry.children.get("index" + extension2).entry.sha
      });
    } else {
      if (suffix) {
        const newEntry = getTreeNodeAtPath(rootTree, getCollectionItemPath(config3, collection2, key) + extension2);
        if (!newEntry || newEntry.children)
          continue;
        entries2.push({
          key: getTreeKey([entry.entry.path, getCollectionItemPath(config3, collection2, key), ...directoriesUsedInSchema.map((x4) => `${x4}/${key}`)], rootTree),
          slug: key,
          sha: newEntry.entry.sha
        });
      }
      if (entry.children || !key.endsWith(extension2))
        continue;
      const slug = key.slice(0, -extension2.length);
      entries2.push({
        key: getTreeKey([entry.entry.path, getCollectionItemPath(config3, collection2, slug), ...directoriesUsedInSchema.map((x4) => `${x4}/${slug}`)], rootTree),
        slug,
        sha: entry.entry.sha
      });
    }
  }
  return entries2;
}
var KEYSTATIC_CLOUD_API_URL = "https://api.keystatic.cloud";
var PKG_VERSION = pkgJson.version;
var KEYSTATIC_CLOUD_HEADERS = {
  "x-keystatic-version": PKG_VERSION
};
var textEncoder$1 = new TextEncoder();
async function redirectToCloudAuth(from4, config3) {
  var _config$cloud3;
  if (!((_config$cloud3 = config3.cloud) !== null && _config$cloud3 !== void 0 && _config$cloud3.project)) {
    throw new Error("Not a cloud config");
  }
  const code_verifier = fromUint8Array(crypto.getRandomValues(new Uint8Array(32)), true);
  const code_challenge = fromUint8Array(new Uint8Array(await crypto.subtle.digest("SHA-256", textEncoder$1.encode(code_verifier))), true);
  const state = fromUint8Array(crypto.getRandomValues(new Uint8Array(32)), true);
  localStorage.setItem("keystatic-cloud-state", JSON.stringify({
    state,
    from: from4,
    code_verifier
  }));
  const url = new URL(`${KEYSTATIC_CLOUD_API_URL}/oauth/authorize`);
  url.searchParams.set("state", state);
  url.searchParams.set("client_id", config3.cloud.project);
  url.searchParams.set("redirect_uri", `${window.location.origin}/keystatic/cloud/oauth/callback`);
  url.searchParams.set("response_type", "code");
  url.searchParams.set("code_challenge_method", "S256");
  url.searchParams.set("code_challenge", code_challenge);
  url.searchParams.set("keystatic_version", pkgJson.version);
  window.location.href = url.toString();
}
var storedTokenSchema = z.object({
  token: z.string(),
  project: z.string(),
  validUntil: z.number().transform((val) => new Date(val))
});
function getSyncAuth(config3) {
  if (typeof document === "undefined") {
    return null;
  }
  if (config3.storage.kind === "github") {
    const cookies = (0, import_cookie.parse)(document.cookie);
    const accessToken = cookies["keystatic-gh-access-token"];
    if (!accessToken) {
      return null;
    }
    return {
      accessToken
    };
  }
  if (config3.storage.kind === "cloud") {
    return getCloudAuth(config3);
  }
  return null;
}
function getCloudAuth(config3) {
  var _config$cloud;
  if (!((_config$cloud = config3.cloud) !== null && _config$cloud !== void 0 && _config$cloud.project))
    return null;
  const unparsedTokenData = localStorage.getItem("keystatic-cloud-access-token");
  let tokenData;
  try {
    tokenData = storedTokenSchema.parse(JSON.parse(unparsedTokenData));
  } catch (err) {
    return null;
  }
  if (!tokenData || tokenData.validUntil < /* @__PURE__ */ new Date() || tokenData.project !== config3.cloud.project) {
    return null;
  }
  return {
    accessToken: tokenData.token
  };
}
async function getAuth(config3) {
  const token2 = getSyncAuth(config3);
  if (config3.storage.kind === "github" && !token2) {
    try {
      const res = await fetch("/api/keystatic/github/refresh-token", {
        method: "POST"
      });
      if (res.status === 200) {
        const cookies = (0, import_cookie.parse)(document.cookie);
        const accessToken = cookies["keystatic-gh-access-token"];
        if (accessToken) {
          return {
            accessToken
          };
        }
      }
    } catch {
    }
    return null;
  }
  return token2;
}
var SidebarFooter_viewer = lib_default2`
  fragment SidebarFooter_viewer on User {
    id
    name
    login
    avatarUrl
    databaseId
  }
`;
var ViewerContext = (0, import_react79.createContext)(void 0);
function useViewer() {
  return (0, import_react79.useContext)(ViewerContext);
}
function parseRepoConfig(repo) {
  if (typeof repo === "string") {
    const [owner, name2] = repo.split("/");
    return {
      owner,
      name: name2
    };
  }
  return repo;
}
function serializeRepoConfig(repo) {
  if (typeof repo === "string") {
    return repo;
  }
  return `${repo.owner}/${repo.name}`;
}
function assertValidRepoConfig(repo) {
  if (typeof repo === "string") {
    if (!repo.includes("/")) {
      throw new Error(`Invalid repo config: ${repo}. It must be in the form owner/name`);
    }
  }
  if (typeof repo === "object") {
    if (!repo.owner && !repo.name) {
      throw new Error(`Invalid repo config: owner and name are missing`);
    }
    if (!repo.owner) {
      throw new Error(`Invalid repo config: owner is missing`);
    }
    if (!repo.name) {
      throw new Error(`Invalid repo config: name is missing`);
    }
  }
}
function scopeEntriesWithPathPrefix(tree2, config3) {
  const prefix4 = getPathPrefix(config3.storage);
  if (!prefix4)
    return tree2;
  const newEntries = [];
  for (const entry of tree2.entries.values()) {
    if (entry.path.startsWith(prefix4)) {
      newEntries.push({
        ...entry,
        path: entry.path.slice(prefix4.length)
      });
    }
  }
  return {
    entries: new Map(newEntries.map((entry) => [entry.path, entry])),
    tree: treeEntriesToTreeNodes(newEntries)
  };
}
var _treeStore;
function getTreeStore() {
  if (!_treeStore) {
    _treeStore = createStore("keystatic-trees", "trees");
  }
  return _treeStore;
}
var _blobStore;
function getBlobStore() {
  if (!_blobStore) {
    _blobStore = createStore("keystatic-blobs", "blobs");
  }
  return _blobStore;
}
function setBlobToPersistedCache(sha, val) {
  return set(sha, val, getBlobStore());
}
async function getBlobFromPersistedCache(sha) {
  const stored = await get2(sha, getBlobStore());
  if (stored instanceof Uint8Array) {
    return stored;
  }
}
var _storedTreeCache;
var treeSchema = z.array(z.object({
  path: z.string(),
  mode: z.string(),
  sha: z.string()
}));
function getStoredTrees() {
  if (_storedTreeCache) {
    return _storedTreeCache;
  }
  const cache3 = /* @__PURE__ */ new Map();
  return entries(getTreeStore()).then((entries2) => {
    for (const [sha, tree2] of entries2) {
      const parsed = treeSchema.safeParse(tree2);
      if (parsed.success && typeof sha === "string") {
        cache3.set(sha, parsed.data);
      }
    }
    _storedTreeCache = cache3;
    return cache3;
  });
}
function constructTreeFromStoredTrees(sha, trees, parentPath = "") {
  const tree2 = /* @__PURE__ */ new Map();
  const storedTree = trees.get(sha);
  if (!storedTree) {
    return;
  }
  for (const entry of storedTree) {
    const innerPath = (parentPath === "" ? "" : parentPath + "/") + entry.path;
    if (entry.mode === "040000") {
      const child = constructTreeFromStoredTrees(entry.sha, trees, innerPath);
      if (child) {
        tree2.set(entry.path, child);
        continue;
      }
      return;
    }
    tree2.set(entry.path, {
      entry: {
        mode: entry.mode,
        path: innerPath,
        sha: entry.sha,
        type: entry.mode === "120000" ? "symlink" : "blob"
      }
    });
  }
  return {
    entry: {
      mode: "040000",
      path: parentPath,
      sha,
      type: "tree"
    },
    children: tree2
  };
}
function getTreeFromPersistedCache(sha) {
  const stored = getStoredTrees();
  if (stored instanceof Map) {
    return constructTreeFromStoredTrees(sha, stored);
  }
  return stored.then((stored2) => constructTreeFromStoredTrees(sha, stored2));
}
async function garbageCollectGitObjects(roots) {
  const treesToDelete = /* @__PURE__ */ new Map();
  const invalidTrees = [];
  for (const [sha, tree2] of await getStoredTrees()) {
    const parsed = treeSchema.safeParse(tree2);
    if (parsed.success && typeof sha === "string") {
      treesToDelete.set(sha, parsed.data);
    } else {
      invalidTrees.push(sha);
    }
  }
  const allBlobs = await keys2(getBlobStore());
  const blobsToDelete = new Set(allBlobs);
  const queue = new Set(roots);
  for (const sha of queue) {
    if (blobsToDelete.has(sha)) {
      blobsToDelete.delete(sha);
      continue;
    }
    const tree2 = treesToDelete.get(sha);
    if (tree2) {
      for (const entry of tree2) {
        queue.add(entry.sha);
      }
      treesToDelete.delete(sha);
      continue;
    }
  }
  const treeKeysToDelete = [...treesToDelete.keys(), ...invalidTrees];
  await Promise.all([delMany([...blobsToDelete], getBlobStore()), delMany([...treesToDelete.keys(), ...invalidTrees], getTreeStore())]);
  for (const key of treeKeysToDelete) {
    var _storedTreeCache2;
    (_storedTreeCache2 = _storedTreeCache) === null || _storedTreeCache2 === void 0 || _storedTreeCache2.delete(key);
  }
}
function setTreeToPersistedCache(sha, children) {
  const allTrees = [];
  collectTrees(sha, children, allTrees);
  return setMany(allTrees, getTreeStore());
}
function collectTrees(sha, children, allTrees) {
  const entries2 = [];
  for (const [path3, entry] of children) {
    entries2.push({
      path: path3.replace(/.*\//, ""),
      mode: entry.entry.mode,
      sha: entry.entry.sha
    });
    if (entry.children) {
      collectTrees(entry.entry.sha, entry.children, allTrees);
    }
  }
  allTrees.push([sha, entries2]);
}
async function clearObjectCache() {
  await Promise.all([clear(getBlobStore()), clear(getTreeStore())]);
}
var messageSync$1 = 0;
var messageQueryAwareness = 3;
var messageAwareness$1 = 1;
var messageAuth$1 = 2;
var messageSubDocSync = 4;
var messageHandlers = [];
messageHandlers[messageSync$1] = (encoder, decoder, provider, emitSynced) => {
  writeVarUint(encoder, messageSync$1);
  const syncMessageType = readSyncMessage(decoder, encoder, provider.doc, provider);
  if (emitSynced && syncMessageType === messageYjsSyncStep2 && !provider.synced) {
    provider.synced = true;
  }
};
messageHandlers[messageQueryAwareness] = (encoder, decoder, provider) => {
  writeVarUint(encoder, messageAwareness$1);
  writeVarUint8Array(encoder, encodeAwarenessUpdate(provider.awareness, Array.from(provider.awareness.getStates().keys())));
};
messageHandlers[messageAwareness$1] = (encoder, decoder, provider) => {
  applyAwarenessUpdate(provider.awareness, readVarUint8Array(decoder), provider);
};
messageHandlers[messageAuth$1] = (encoder, decoder, provider) => {
  readAuthMessage(decoder, provider.doc, permissionDeniedHandler);
};
messageHandlers[messageSubDocSync] = (encoder, decoder, provider, emitSynced) => {
  const subDocID = readVarString(decoder);
  writeVarUint(encoder, messageSync$1);
  const subDoc = provider.getSubDoc(subDocID);
  if (subDoc) {
    const syncMessageType = readSyncMessage(decoder, encoder, subDoc, provider);
    if (emitSynced && syncMessageType === messageYjsSyncStep2) {
      subDoc.emit("sync", [true]);
    }
  }
};
var reconnectTimeoutBase = 1200;
var maxReconnectTimeout = 2500;
var messageReconnectTimeout = 3e4;
var permissionDeniedHandler = (provider, reason) => console.warn(`Permission denied to access ${provider.url}.
${reason}`);
var readMessage = (provider, buf, emitSynced) => {
  const decoder = createDecoder(buf);
  const encoder = createEncoder();
  const messageType = readVarUint(decoder);
  const messageHandler = messageHandlers[messageType];
  if (messageHandler) {
    messageHandler(encoder, decoder, provider, emitSynced, messageType);
  } else {
    console.error("Unable to compute message");
  }
  return encoder;
};
var setupWS = (provider, WS) => {
  if (provider.shouldConnect && provider.ws === null) {
    const websocket = new WS(provider.url);
    websocket.binaryType = "arraybuffer";
    provider.ws = websocket;
    provider.wsconnecting = true;
    provider.wsconnected = false;
    provider.synced = false;
    let authState = {
      kind: "authenticating",
      queue: []
    };
    websocket.onmessage = (event) => {
      provider.wsLastMessageReceived = getUnixTime();
      const bytes = new Uint8Array(event.data);
      if (authState.kind === "authenticating") {
        const decoder = createDecoder(bytes);
        const messageType = readVarInt(decoder);
        if (messageType === messageAuth$1) {
          const authMessageType = readVarInt(decoder);
          if (authMessageType === 2) {
            const queue = authState.queue;
            authState = {
              kind: "authed"
            };
            provider.onConnect(websocket);
            for (const queued of queue) {
              const encoder = readMessage(provider, queued, true);
              if (length(encoder) > 1) {
                websocket.send(toUint8Array(encoder));
              }
            }
            return;
          }
        }
        authState.queue.push(bytes);
      } else {
        const encoder = readMessage(provider, bytes, true);
        if (length(encoder) > 1) {
          websocket.send(toUint8Array(encoder));
        }
      }
    };
    websocket.onclose = () => {
      provider.ws = null;
      provider.wsconnecting = false;
      if (provider.wsconnected) {
        provider.wsconnected = false;
        provider.synced = false;
        removeAwarenessStates(provider.awareness, Array.from(provider.awareness.getStates().keys()).filter((client) => client !== provider.doc.clientID), provider);
        provider.onStatus({
          status: "disconnected"
        });
      } else {
        provider.wsUnsuccessfulReconnects++;
      }
      setTimeout(setupWS, min(log10(provider.wsUnsuccessfulReconnects + 1) * reconnectTimeoutBase, maxReconnectTimeout), provider);
    };
    websocket.onopen = async () => {
      provider.wsLastMessageReceived = getUnixTime();
      const encoder = createEncoder();
      writeVarUint(encoder, messageAuth$1);
      writeVarUint(encoder, 0);
      writeVarString(encoder, await provider.authToken());
      websocket.send(toUint8Array(encoder));
    };
    provider.onStatus({
      status: "connecting"
    });
  }
};
var broadcastMessage = (provider, buf) => {
  if (provider.ws && provider.wsconnected) {
    var _provider$ws;
    (_provider$ws = provider.ws) === null || _provider$ws === void 0 || _provider$ws.send(buf);
  }
  if (provider.bcconnected) {
    provider.mux(() => {
      publish2(provider.bcChannel, buf);
    });
  }
};
var _WS, _synced, _resyncInterval, _checkInterval, _bcSubscriber, _beforeUnloadHandler, _awarenessUpdateHandler, _getSubDocUpdateHandler, _updateHandler;
var WebsocketProvider = class {
  constructor(opts) {
    __privateAdd(this, _WS, void 0);
    __privateAdd(this, _synced, void 0);
    __privateAdd(this, _resyncInterval, void 0);
    __privateAdd(this, _checkInterval, void 0);
    __privateAdd(this, _bcSubscriber, (data) => {
      this.mux(() => {
        const encoder = readMessage(this, new Uint8Array(data), false);
        if (length(encoder) > 1) {
          publish2(this.bcChannel, toUint8Array(encoder));
        }
      });
    });
    __privateAdd(this, _beforeUnloadHandler, () => {
      removeAwarenessStates(this.awareness, [this.doc.clientID], "window unload");
    });
    __publicField(this, "waitForConnection", (callback, interval) => {
      const ws = this.ws;
      if ((ws === null || ws === void 0 ? void 0 : ws.readyState) === 1) {
        callback(ws);
      } else {
        setTimeout(() => {
          this.waitForConnection(callback, interval);
        }, interval);
      }
    });
    __privateAdd(this, _awarenessUpdateHandler, ({
      added,
      updated,
      removed
    }) => {
      const changedClients = added.concat(updated).concat(removed);
      const encoder = createEncoder();
      writeVarUint(encoder, messageAwareness$1);
      writeVarUint8Array(encoder, encodeAwarenessUpdate(this.awareness, changedClients));
      broadcastMessage(this, toUint8Array(encoder));
    });
    __publicField(this, "send", (message, callback) => {
      this.waitForConnection((ws) => {
        ws.send(message);
        if (typeof callback !== "undefined") {
          callback();
        }
      }, 1e3);
    });
    __privateAdd(this, _getSubDocUpdateHandler, weakMemoize((subDoc) => (update) => {
      const encoder = createEncoder();
      writeVarUint(encoder, messageSubDocSync);
      writeVarString(encoder, subDoc.guid);
      writeUpdate(encoder, update);
      broadcastMessage(this, toUint8Array(encoder));
    }));
    __privateAdd(this, _updateHandler, (update, origin) => {
      if (origin !== this) {
        const encoder = createEncoder();
        writeVarUint(encoder, messageSync$1);
        writeUpdate(encoder, update);
        broadcastMessage(this, toUint8Array(encoder));
      }
    });
    var _opts$WebSocketPolyfi, _opts$onStatus, _opts$onSynced;
    this.bcChannel = opts.url;
    this.url = opts.url;
    this.doc = opts.doc;
    __privateSet(this, _WS, (_opts$WebSocketPolyfi = opts.WebSocketPolyfill) !== null && _opts$WebSocketPolyfi !== void 0 ? _opts$WebSocketPolyfi : WebSocket);
    this.awareness = opts.awareness;
    this.wsconnected = false;
    this.wsconnecting = false;
    this.bcconnected = false;
    this.wsUnsuccessfulReconnects = 0;
    this.mux = createMutex();
    __privateSet(this, _synced, false);
    this.authToken = opts.authToken;
    this.ws = null;
    this.wsLastMessageReceived = 0;
    this.onStatus = (_opts$onStatus = opts.onStatus) !== null && _opts$onStatus !== void 0 ? _opts$onStatus : () => {
    };
    this.onSynced = (_opts$onSynced = opts.onSynced) !== null && _opts$onSynced !== void 0 ? _opts$onSynced : () => {
    };
    this.shouldConnect = false;
    this.subdocs = /* @__PURE__ */ new Map();
    __privateSet(this, _resyncInterval, null);
    if (opts.resyncInterval !== void 0 && opts.resyncInterval > 0) {
      __privateSet(this, _resyncInterval, setInterval(() => {
        if (this.ws) {
          const encoder = createEncoder();
          writeVarUint(encoder, messageSync$1);
          writeSyncStep1(encoder, opts.doc);
          this.ws.send(toUint8Array(encoder));
        }
      }, opts.resyncInterval));
    }
    this.doc.on("subdocs", ({
      added,
      removed,
      loaded
    }) => {
      added.forEach((subdoc) => {
        this.subdocs.set(subdoc.guid, subdoc);
      });
      removed.forEach((subdoc) => {
        subdoc.off("update", __privateGet(this, _getSubDocUpdateHandler).call(this, subdoc));
        this.subdocs.delete(subdoc.guid);
      });
      loaded.forEach((subdoc) => {
        this.waitForConnection(() => {
          const encoder = createEncoder();
          writeVarUint(encoder, messageSubDocSync);
          writeVarString(encoder, subdoc.guid);
          writeSyncStep1(encoder, subdoc);
          this.send(toUint8Array(encoder), () => {
            subdoc.on("update", __privateGet(this, _getSubDocUpdateHandler).call(this, subdoc));
          });
        }, 1e3);
      });
    });
    this.doc.on("update", __privateGet(this, _updateHandler));
    if (typeof window !== "undefined") {
      window.addEventListener("beforeunload", __privateGet(this, _beforeUnloadHandler));
    }
    opts.awareness.on("update", __privateGet(this, _awarenessUpdateHandler));
    __privateSet(this, _checkInterval, setInterval(() => {
      if (this.wsconnected && messageReconnectTimeout < getUnixTime() - this.wsLastMessageReceived) {
        var _this$ws;
        (_this$ws = this.ws) === null || _this$ws === void 0 || _this$ws.close();
      }
    }, messageReconnectTimeout / 10));
  }
  onConnect(ws) {
    this.wsconnecting = false;
    this.wsconnected = true;
    this.wsUnsuccessfulReconnects = 0;
    this.onStatus({
      status: "connected"
    });
    const encoder = createEncoder();
    writeVarUint(encoder, messageSync$1);
    writeSyncStep1(encoder, this.doc);
    ws.send(toUint8Array(encoder));
    if (this.awareness.getLocalState() !== null) {
      const encoderAwarenessState = createEncoder();
      writeVarUint(encoderAwarenessState, messageAwareness$1);
      writeVarUint8Array(encoderAwarenessState, encodeAwarenessUpdate(this.awareness, [this.doc.clientID]));
      ws.send(toUint8Array(encoderAwarenessState));
    }
  }
  get synced() {
    return __privateGet(this, _synced);
  }
  getSubDoc(id2) {
    return this.subdocs.get(id2);
  }
  set synced(state) {
    if (__privateGet(this, _synced) !== state) {
      __privateSet(this, _synced, state);
      this.onSynced(state);
      this.doc.emit("sync", [state]);
    }
  }
  destroy() {
    if (__privateGet(this, _resyncInterval) !== null) {
      clearInterval(__privateGet(this, _resyncInterval));
    }
    clearInterval(__privateGet(this, _checkInterval));
    this.disconnect();
    if (typeof window !== "undefined") {
      window.removeEventListener("beforeunload", __privateGet(this, _beforeUnloadHandler));
    }
    this.awareness.off("update", __privateGet(this, _awarenessUpdateHandler));
    this.doc.off("update", __privateGet(this, _updateHandler));
  }
  connectBc() {
    if (!this.bcconnected) {
      subscribe3(this.bcChannel, __privateGet(this, _bcSubscriber));
      this.bcconnected = true;
    }
    this.mux(() => {
      const encoderSync = createEncoder();
      writeVarUint(encoderSync, messageSync$1);
      writeSyncStep1(encoderSync, this.doc);
      publish2(this.bcChannel, toUint8Array(encoderSync));
      const encoderState = createEncoder();
      writeVarUint(encoderState, messageSync$1);
      writeSyncStep2(encoderState, this.doc);
      publish2(this.bcChannel, toUint8Array(encoderState));
      const encoderAwarenessQuery = createEncoder();
      writeVarUint(encoderAwarenessQuery, messageQueryAwareness);
      publish2(this.bcChannel, toUint8Array(encoderAwarenessQuery));
      const encoderAwarenessState = createEncoder();
      writeVarUint(encoderAwarenessState, messageAwareness$1);
      writeVarUint8Array(encoderAwarenessState, encodeAwarenessUpdate(this.awareness, [this.doc.clientID]));
      publish2(this.bcChannel, toUint8Array(encoderAwarenessState));
    });
  }
  disconnectBc() {
    const encoder = createEncoder();
    writeVarUint(encoder, messageAwareness$1);
    writeVarUint8Array(encoder, encodeAwarenessUpdate(this.awareness, [this.doc.clientID], /* @__PURE__ */ new Map()));
    broadcastMessage(this, toUint8Array(encoder));
    if (this.bcconnected) {
      unsubscribe(this.bcChannel, __privateGet(this, _bcSubscriber));
      this.bcconnected = false;
    }
  }
  disconnect() {
    this.shouldConnect = false;
    this.disconnectBc();
    if (this.ws !== null) {
      this.ws.close();
    }
  }
  connect() {
    this.shouldConnect = true;
    if (!this.wsconnected && this.ws === null) {
      setupWS(this, __privateGet(this, _WS));
      this.connectBc();
    }
  }
};
_WS = new WeakMap();
_synced = new WeakMap();
_resyncInterval = new WeakMap();
_checkInterval = new WeakMap();
_bcSubscriber = new WeakMap();
_beforeUnloadHandler = new WeakMap();
_awarenessUpdateHandler = new WeakMap();
_getSubDocUpdateHandler = new WeakMap();
_updateHandler = new WeakMap();
var YjsContext = (0, import_react79.createContext)(null);
var messageSync = 0;
var messageAwareness = 1;
var messageAuth = 2;
var messageSyncSubdoc = 4;
function decodeSentMessage(message) {
  const decoder = createDecoder(message);
  const messageType = readVarUint(decoder);
  switch (messageType) {
    case messageSync: {
      return {
        kind: "sync"
      };
    }
    case messageSyncSubdoc: {
      return {
        kind: "sync-subdoc"
      };
    }
    case messageAwareness: {
      const awarenessUpdate = readVarUint8Array(decoder);
      const states = [];
      {
        const decoder2 = createDecoder(awarenessUpdate);
        const len = readVarUint(decoder2);
        for (let i6 = 0; i6 < len; i6++) {
          const clientID = readVarUint(decoder2);
          let clock = readVarUint(decoder2);
          const state = JSON.parse(readVarString(decoder2));
          states.push({
            clientID,
            clock,
            state
          });
        }
      }
      return {
        kind: "awareness",
        states
      };
    }
    case messageAuth: {
      return {
        kind: "auth"
      };
    }
  }
}
function decodeMessage(message) {
  const decoder = createDecoder(message);
  const messageType = readVarUint(decoder);
  switch (messageType) {
    case messageSync: {
      return {
        kind: "sync"
      };
    }
    case messageSyncSubdoc: {
      return {
        kind: "sync-subdoc"
      };
    }
    case messageAwareness: {
      const awarenessUpdate = readVarUint8Array(decoder);
      const states = [];
      {
        const decoder2 = createDecoder(awarenessUpdate);
        const len = readVarUint(decoder2);
        for (let i6 = 0; i6 < len; i6++) {
          const clientID = readVarUint(decoder2);
          let clock = readVarUint(decoder2);
          const state = JSON.parse(readVarString(decoder2));
          states.push({
            clientID,
            clock,
            state
          });
        }
      }
      return {
        kind: "awareness",
        states
      };
    }
    case messageAuth: {
      return {
        kind: "auth"
      };
    }
  }
}
function useYjs() {
  const yjs = (0, import_react79.useContext)(YjsContext);
  if (!yjs) {
    throw new Error("CollabProvider not found");
  }
  if (yjs === "loading") {
    throw new Error("CollabProvider is loading");
  }
  return yjs;
}
function useYjsIfAvailable() {
  return (0, import_react79.useContext)(YjsContext);
}
var enableMessageLogging = false;
function CollabProvider(props) {
  var _props$config$cloud;
  const branchInfo = useBranchInfo();
  const router = useRouter();
  const cloudInfo = useCloudInfo();
  const project = (_props$config$cloud = props.config.cloud) === null || _props$config$cloud === void 0 ? void 0 : _props$config$cloud.project;
  const key = `ks-multiplayer-${project}`;
  const isMultiplayerEnabled = cloudInfo === null ? localStorage.getItem(key) === "true" : cloudInfo.team.multiplayer;
  const yJsInfo = (0, import_react79.useMemo)(() => {
    if (!isMultiplayerEnabled) {
      return;
    }
    const doc2 = new Doc();
    const data = doc2.getMap("data");
    const awareness = new Awareness(doc2);
    const idb = W2(doc2, `keystatic-2-${project}`);
    const provider = new WebsocketProvider({
      doc: doc2,
      url: `wss://live.keystatic.cloud/${project}?v=${PKG_VERSION}`,
      WebSocketPolyfill: class extends ReconnectingWebSocket {
        constructor(url) {
          super(url);
          this.addEventListener("message", (event) => {
            if (event.data instanceof ArrayBuffer && enableMessageLogging) {
              console.log("recv", decodeMessage(new Uint8Array(event.data)));
            }
          });
        }
        send(data2) {
          if (data2 instanceof Uint8Array && enableMessageLogging) {
            console.log("send", decodeSentMessage(data2));
          }
          super.send(data2);
        }
      },
      awareness,
      authToken: async () => getAuth(props.config).then((auth) => {
        var _auth$accessToken;
        return (_auth$accessToken = auth === null || auth === void 0 ? void 0 : auth.accessToken) !== null && _auth$accessToken !== void 0 ? _auth$accessToken : "";
      })
    });
    return {
      doc: doc2,
      awareness,
      provider,
      data,
      idb
    };
  }, [isMultiplayerEnabled, project, props.config]);
  (0, import_react79.useEffect)(() => {
    yJsInfo === null || yJsInfo === void 0 || yJsInfo.awareness.setLocalStateField("branch", branchInfo.currentBranch);
    yJsInfo === null || yJsInfo === void 0 || yJsInfo.awareness.setLocalStateField("location", router.params.slice(2).join("/"));
  }, [branchInfo.currentBranch, router.params, yJsInfo === null || yJsInfo === void 0 ? void 0 : yJsInfo.awareness]);
  const hasRepo = branchInfo.currentBranch;
  (0, import_react79.useEffect)(() => {
    if (hasRepo && yJsInfo) {
      yJsInfo.idb.connect();
      let didConnectToWS = false;
      const remove = yJsInfo.idb.subscribeStatusChange(() => {
        if (yJsInfo.idb.status.type === "synced" || yJsInfo.idb.status.type === "error") {
          remove();
          yJsInfo.provider.connect();
          didConnectToWS = true;
        }
      });
      return () => {
        yJsInfo.idb.disconnect();
        if (didConnectToWS) {
          yJsInfo.provider.disconnect();
        } else {
          remove();
        }
      };
    }
  }, [yJsInfo, hasRepo]);
  (0, import_react79.useEffect)(() => {
    if (cloudInfo === null)
      return;
    const key2 = `ks-multiplayer-${project}`;
    if (cloudInfo.team.multiplayer) {
      localStorage.setItem(key2, "true");
    } else {
      localStorage.removeItem(key2);
    }
  }, [cloudInfo, project]);
  return (0, import_jsx_runtime92.jsx)(YjsContext.Provider, {
    value: yJsInfo === void 0 ? cloudInfo === void 0 ? "loading" : null : yJsInfo,
    children: props.children
  });
}
function fetchLocalTree(sha) {
  if (treeCache.has(sha)) {
    return treeCache.get(sha);
  }
  const promise = fetch("/api/keystatic/tree", {
    headers: {
      "no-cors": "1"
    }
  }).then((x4) => x4.json()).then(async (entries2) => hydrateTreeCacheWithEntries(entries2));
  treeCache.set(sha, promise);
  return promise;
}
function useSetTreeSha() {
  return (0, import_react79.useContext)(SetTreeShaContext);
}
var SetTreeShaContext = (0, import_react79.createContext)(() => {
  throw new Error("SetTreeShaContext not set");
});
function LocalAppShellProvider(props) {
  const [currentTreeSha, setCurrentTreeSha] = (0, import_react79.useState)("initial");
  const tree2 = useData((0, import_react79.useCallback)(() => fetchLocalTree(currentTreeSha), [currentTreeSha]));
  const allTreeData = (0, import_react79.useMemo)(() => ({
    unscopedDefault: tree2,
    scoped: {
      default: tree2,
      current: tree2,
      merged: mergeDataStates({
        default: tree2,
        current: tree2
      })
    }
  }), [tree2]);
  const changedData = (0, import_react79.useMemo)(() => {
    if (allTreeData.scoped.merged.kind !== "loaded") {
      return {
        collections: /* @__PURE__ */ new Map(),
        singletons: /* @__PURE__ */ new Set()
      };
    }
    return getChangedData(props.config, allTreeData.scoped.merged.data);
  }, [allTreeData, props.config]);
  return (0, import_jsx_runtime92.jsx)(SetTreeShaContext.Provider, {
    value: setCurrentTreeSha,
    children: (0, import_jsx_runtime92.jsx)(ChangedContext.Provider, {
      value: changedData,
      children: (0, import_jsx_runtime92.jsx)(TreeContext.Provider, {
        value: allTreeData,
        children: props.children
      })
    })
  });
}
var cloudInfoSchema = z.object({
  user: z.object({
    name: z.string(),
    email: z.string(),
    avatarUrl: z.string().optional()
  }),
  project: z.object({
    name: z.string()
  }),
  team: z.object({
    name: z.string(),
    slug: z.string(),
    images: z.boolean(),
    multiplayer: z.boolean()
  })
});
var CloudInfo = (0, import_react79.createContext)(null);
function useCloudInfo() {
  const context = (0, import_react79.useContext)(CloudInfo);
  return context === "unauthorized" ? null : context;
}
function useRawCloudInfo() {
  return (0, import_react79.useContext)(CloudInfo);
}
function CloudInfoProvider(props) {
  const data = useData((0, import_react79.useCallback)(async () => {
    var _props$config$cloud, _getCloudAuth;
    if (!((_props$config$cloud = props.config.cloud) !== null && _props$config$cloud !== void 0 && _props$config$cloud.project))
      throw new Error("no cloud project set");
    const token2 = (_getCloudAuth = getCloudAuth(props.config)) === null || _getCloudAuth === void 0 ? void 0 : _getCloudAuth.accessToken;
    if (!token2) {
      return "unauthorized";
    }
    const res = await fetch(`${KEYSTATIC_CLOUD_API_URL}/v1/info`, {
      headers: {
        ...KEYSTATIC_CLOUD_HEADERS,
        Authorization: `Bearer ${token2}`
      }
    });
    if (res.status === 401)
      return "unauthorized";
    return cloudInfoSchema.parse(await res.json());
  }, [props.config]));
  return (0, import_jsx_runtime92.jsx)(CloudInfo.Provider, {
    value: data.kind === "loaded" ? data.data : null,
    children: props.children
  });
}
var GitHubAppShellDataContext = (0, import_react79.createContext)(null);
function GitHubAppShellDataProvider(props) {
  var _state$data, _state$data2, _moreRefsState$data;
  const repo = props.config.storage.kind === "github" ? parseRepoConfig(props.config.storage.repo) : {
    name: "repo-name",
    owner: "repo-owner"
  };
  const [state] = useQuery({
    query: props.config.storage.kind === "github" ? GitHubAppShellQuery : CloudAppShellQuery,
    variables: repo
  });
  const [cursorState, setCursorState] = (0, import_react79.useState)(null);
  const [moreRefsState] = useQuery({
    query: lib_default2`
      query FetchMoreRefs($owner: String!, $name: String!, $after: String) {
        repository(owner: $owner, name: $name) {
          __typename
          id
          refs(refPrefix: "refs/heads/", first: 100, after: $after) {
            __typename
            nodes {
              ...Ref_base
            }
            pageInfo {
              hasNextPage
              endCursor
            }
          }
        }
      }
      ${Ref_base}
    `,
    pause: !((_state$data = state.data) !== null && _state$data !== void 0 && (_state$data = _state$data.repository) !== null && _state$data !== void 0 && (_state$data = _state$data.refs) !== null && _state$data !== void 0 && _state$data.pageInfo.hasNextPage),
    variables: {
      ...repo,
      after: cursorState !== null && cursorState !== void 0 ? cursorState : (_state$data2 = state.data) === null || _state$data2 === void 0 || (_state$data2 = _state$data2.repository) === null || _state$data2 === void 0 || (_state$data2 = _state$data2.refs) === null || _state$data2 === void 0 ? void 0 : _state$data2.pageInfo.endCursor
    }
  });
  const pageInfo = (_moreRefsState$data = moreRefsState.data) === null || _moreRefsState$data === void 0 || (_moreRefsState$data = _moreRefsState$data.repository) === null || _moreRefsState$data === void 0 || (_moreRefsState$data = _moreRefsState$data.refs) === null || _moreRefsState$data === void 0 ? void 0 : _moreRefsState$data.pageInfo;
  if (pageInfo !== null && pageInfo !== void 0 && pageInfo.hasNextPage && pageInfo.endCursor !== cursorState && pageInfo.endCursor) {
    setCursorState(pageInfo.endCursor);
  }
  return (0, import_jsx_runtime92.jsx)(GitHubAppShellDataContext.Provider, {
    value: state,
    children: (0, import_jsx_runtime92.jsx)(ViewerContext.Provider, {
      value: state.data && "viewer" in state.data ? state.data.viewer : void 0,
      children: props.children
    })
  });
}
var writePermissions = /* @__PURE__ */ new Set(["WRITE", "ADMIN", "MAINTAIN"]);
function GitHubAppShellProvider(props) {
  var _repo, _repo3, _repo5, _defaultBranchRef$tar, _currentBranchRef$tar, _currentBranchRef$tar2, _currentBranchRef$tar3, _repo7, _repo10, _repo11, _currentBranchRef$ass, _repo17, _repo18, _repo19, _data$repository3, _data$repository4, _repo20;
  const router = useRouter();
  const {
    data,
    error: error3
  } = (0, import_react79.useContext)(GitHubAppShellDataContext);
  let repo = data === null || data === void 0 ? void 0 : data.repository;
  if (repo && "viewerPermission" in repo && repo.viewerPermission && !writePermissions.has(repo.viewerPermission) && "forks" in repo) {
    var _repo$forks$nodes$, _repo$forks;
    repo = (_repo$forks$nodes$ = (_repo$forks = repo.forks) === null || _repo$forks === void 0 || (_repo$forks = _repo$forks.nodes) === null || _repo$forks === void 0 ? void 0 : _repo$forks[0]) !== null && _repo$forks$nodes$ !== void 0 ? _repo$forks$nodes$ : repo;
  }
  const defaultBranchRef = (_repo = repo) === null || _repo === void 0 || (_repo = _repo.refs) === null || _repo === void 0 || (_repo = _repo.nodes) === null || _repo === void 0 ? void 0 : _repo.find((x4) => {
    var _repo2;
    return (x4 === null || x4 === void 0 ? void 0 : x4.name) === ((_repo2 = repo) === null || _repo2 === void 0 || (_repo2 = _repo2.defaultBranchRef) === null || _repo2 === void 0 ? void 0 : _repo2.name);
  });
  const currentBranchRef = (_repo3 = repo) === null || _repo3 === void 0 || (_repo3 = _repo3.refs) === null || _repo3 === void 0 || (_repo3 = _repo3.nodes) === null || _repo3 === void 0 ? void 0 : _repo3.find((x4) => (x4 === null || x4 === void 0 ? void 0 : x4.name) === props.currentBranch);
  (0, import_react79.useEffect)(() => {
    var _repo4;
    if ((_repo4 = repo) !== null && _repo4 !== void 0 && (_repo4 = _repo4.refs) !== null && _repo4 !== void 0 && _repo4.nodes) {
      garbageCollectGitObjects(repo.refs.nodes.map((x4) => {
        var _x$target;
        return (x4 === null || x4 === void 0 || (_x$target = x4.target) === null || _x$target === void 0 ? void 0 : _x$target.__typename) === "Commit" ? x4.target.tree.oid : void 0;
      }).filter(isDefined));
    }
  }, [(_repo5 = repo) === null || _repo5 === void 0 ? void 0 : _repo5.id]);
  const defaultBranchTreeSha = (_defaultBranchRef$tar = defaultBranchRef === null || defaultBranchRef === void 0 ? void 0 : defaultBranchRef.target.tree.oid) !== null && _defaultBranchRef$tar !== void 0 ? _defaultBranchRef$tar : null;
  const currentBranchTreeSha = (_currentBranchRef$tar = currentBranchRef === null || currentBranchRef === void 0 ? void 0 : currentBranchRef.target.tree.oid) !== null && _currentBranchRef$tar !== void 0 ? _currentBranchRef$tar : null;
  const baseCommit = (_currentBranchRef$tar2 = currentBranchRef === null || currentBranchRef === void 0 || (_currentBranchRef$tar3 = currentBranchRef.target) === null || _currentBranchRef$tar3 === void 0 ? void 0 : _currentBranchRef$tar3.oid) !== null && _currentBranchRef$tar2 !== void 0 ? _currentBranchRef$tar2 : null;
  const defaultBranchTree = useGitHubTreeData(defaultBranchTreeSha, props.config);
  const currentBranchTree = useGitHubTreeData(currentBranchTreeSha, props.config);
  const allTreeData = (0, import_react79.useMemo)(() => {
    const scopedDefault = mapDataState(defaultBranchTree, (tree2) => scopeEntriesWithPathPrefix(tree2, props.config));
    const scopedCurrent = mapDataState(currentBranchTree, (tree2) => scopeEntriesWithPathPrefix(tree2, props.config));
    return {
      unscopedDefault: currentBranchTree,
      scoped: {
        default: scopedDefault,
        current: scopedCurrent,
        merged: mergeDataStates({
          default: scopedDefault,
          current: scopedCurrent
        })
      }
    };
  }, [currentBranchTree, defaultBranchTree, props.config]);
  const changedData = (0, import_react79.useMemo)(() => {
    if (allTreeData.scoped.merged.kind !== "loaded") {
      return {
        collections: /* @__PURE__ */ new Map(),
        singletons: /* @__PURE__ */ new Set()
      };
    }
    return getChangedData(props.config, allTreeData.scoped.merged.data);
  }, [allTreeData, props.config]);
  (0, import_react79.useEffect)(() => {
    var _error$response, _repo6;
    if ((error3 === null || error3 === void 0 || (_error$response = error3.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401) {
      if (isGitHubConfig(props.config)) {
        window.location.href = `/api/keystatic/github/login?from=${router.params.map(encodeURIComponent).join("/")}`;
      } else {
        redirectToCloudAuth(router.params.map(encodeURIComponent).join("/"), props.config);
      }
    }
    if (!((_repo6 = repo) !== null && _repo6 !== void 0 && _repo6.id) && error3 !== null && error3 !== void 0 && error3.graphQLErrors.some((err) => {
      var _err$originalError, _err$originalError2;
      return (err === null || err === void 0 || (_err$originalError = err.originalError) === null || _err$originalError === void 0 ? void 0 : _err$originalError.type) === "NOT_FOUND" || (err === null || err === void 0 || (_err$originalError2 = err.originalError) === null || _err$originalError2 === void 0 ? void 0 : _err$originalError2.type) === "FORBIDDEN";
    })) {
      window.location.href = `/api/keystatic/github/repo-not-found?from=${router.params.map(encodeURIComponent).join("/")}`;
    }
  }, [error3, router, (_repo7 = repo) === null || _repo7 === void 0 ? void 0 : _repo7.id, props.config]);
  const baseInfo = (0, import_react79.useMemo)(() => {
    var _repo$id, _repo8, _repo$isPrivate, _repo9;
    return {
      baseCommit: baseCommit || "",
      repositoryId: (_repo$id = (_repo8 = repo) === null || _repo8 === void 0 ? void 0 : _repo8.id) !== null && _repo$id !== void 0 ? _repo$id : "",
      isPrivate: (_repo$isPrivate = (_repo9 = repo) === null || _repo9 === void 0 ? void 0 : _repo9.isPrivate) !== null && _repo$isPrivate !== void 0 ? _repo$isPrivate : true
    };
  }, [baseCommit, (_repo10 = repo) === null || _repo10 === void 0 ? void 0 : _repo10.id, (_repo11 = repo) === null || _repo11 === void 0 ? void 0 : _repo11.isPrivate]);
  const pullRequestNumber = currentBranchRef === null || currentBranchRef === void 0 || (_currentBranchRef$ass = currentBranchRef.associatedPullRequests.nodes) === null || _currentBranchRef$ass === void 0 || (_currentBranchRef$ass = _currentBranchRef$ass[0]) === null || _currentBranchRef$ass === void 0 ? void 0 : _currentBranchRef$ass.number;
  const branchInfo = (0, import_react79.useMemo)(() => {
    var _repo$defaultBranchRe, _repo12, _repo$id2, _repo13, _repo$refs$nodes$map$, _repo14, _repo15, _repo16, _data$repository$owne, _data$repository, _data$repository$name, _data$repository2;
    return {
      defaultBranch: (_repo$defaultBranchRe = (_repo12 = repo) === null || _repo12 === void 0 || (_repo12 = _repo12.defaultBranchRef) === null || _repo12 === void 0 ? void 0 : _repo12.name) !== null && _repo$defaultBranchRe !== void 0 ? _repo$defaultBranchRe : "",
      currentBranch: props.currentBranch,
      baseCommit: baseCommit || "",
      repositoryId: (_repo$id2 = (_repo13 = repo) === null || _repo13 === void 0 ? void 0 : _repo13.id) !== null && _repo$id2 !== void 0 ? _repo$id2 : "",
      allBranches: (_repo$refs$nodes$map$ = (_repo14 = repo) === null || _repo14 === void 0 || (_repo14 = _repo14.refs) === null || _repo14 === void 0 || (_repo14 = _repo14.nodes) === null || _repo14 === void 0 ? void 0 : _repo14.map((x4) => x4 === null || x4 === void 0 ? void 0 : x4.name).filter(isDefined)) !== null && _repo$refs$nodes$map$ !== void 0 ? _repo$refs$nodes$map$ : [],
      pullRequestNumber,
      branchNameToId: new Map((_repo15 = repo) === null || _repo15 === void 0 || (_repo15 = _repo15.refs) === null || _repo15 === void 0 || (_repo15 = _repo15.nodes) === null || _repo15 === void 0 ? void 0 : _repo15.filter(isDefined).map((x4) => [x4.name, x4.id])),
      branchNameToBaseCommit: new Map((_repo16 = repo) === null || _repo16 === void 0 || (_repo16 = _repo16.refs) === null || _repo16 === void 0 || (_repo16 = _repo16.nodes) === null || _repo16 === void 0 ? void 0 : _repo16.flatMap((x4) => x4 !== null && x4 !== void 0 && x4.target ? [[x4.name, x4.target.oid]] : [])),
      mainOwner: (_data$repository$owne = data === null || data === void 0 || (_data$repository = data.repository) === null || _data$repository === void 0 ? void 0 : _data$repository.owner.login) !== null && _data$repository$owne !== void 0 ? _data$repository$owne : "",
      mainRepo: (_data$repository$name = data === null || data === void 0 || (_data$repository2 = data.repository) === null || _data$repository2 === void 0 ? void 0 : _data$repository2.name) !== null && _data$repository$name !== void 0 ? _data$repository$name : ""
    };
  }, [(_repo17 = repo) === null || _repo17 === void 0 || (_repo17 = _repo17.defaultBranchRef) === null || _repo17 === void 0 ? void 0 : _repo17.name, (_repo18 = repo) === null || _repo18 === void 0 ? void 0 : _repo18.id, (_repo19 = repo) === null || _repo19 === void 0 || (_repo19 = _repo19.refs) === null || _repo19 === void 0 ? void 0 : _repo19.nodes, props.currentBranch, baseCommit, pullRequestNumber, data === null || data === void 0 || (_data$repository3 = data.repository) === null || _data$repository3 === void 0 ? void 0 : _data$repository3.owner.login, data === null || data === void 0 || (_data$repository4 = data.repository) === null || _data$repository4 === void 0 ? void 0 : _data$repository4.name]);
  return (0, import_jsx_runtime92.jsx)(RepoWithWriteAccessContext.Provider, {
    value: repo && (props.config.storage.kind === "cloud" || "viewerPermission" in repo && (_repo20 = repo) !== null && _repo20 !== void 0 && _repo20.viewerPermission && writePermissions.has(repo.viewerPermission)) ? {
      name: repo.name,
      owner: repo.owner.login
    } : null,
    children: (0, import_jsx_runtime92.jsx)(AppShellErrorContext.Provider, {
      value: error3,
      children: (0, import_jsx_runtime92.jsx)(BranchInfoContext.Provider, {
        value: branchInfo,
        children: (0, import_jsx_runtime92.jsx)(BaseInfoContext.Provider, {
          value: baseInfo,
          children: (0, import_jsx_runtime92.jsx)(ChangedContext.Provider, {
            value: changedData,
            children: (0, import_jsx_runtime92.jsx)(TreeContext.Provider, {
              value: allTreeData,
              children: props.config.storage.kind === "cloud" ? (0, import_jsx_runtime92.jsx)(CollabProvider, {
                config: props.config,
                children: props.children
              }) : props.children
            })
          })
        })
      })
    })
  });
}
var AppShellErrorContext = (0, import_react79.createContext)(void 0);
var BaseInfoContext = (0, import_react79.createContext)({
  baseCommit: "",
  repositoryId: "",
  isPrivate: true
});
var ChangedContext = (0, import_react79.createContext)({
  collections: /* @__PURE__ */ new Map(),
  singletons: /* @__PURE__ */ new Set()
});
var TreeContext = (0, import_react79.createContext)({
  unscopedDefault: {
    kind: "loading"
  },
  scoped: {
    current: {
      kind: "loading"
    },
    default: {
      kind: "loading"
    },
    merged: {
      kind: "loading"
    }
  }
});
function useTree() {
  return (0, import_react79.useContext)(TreeContext).scoped;
}
function useCurrentUnscopedTree() {
  return (0, import_react79.useContext)(TreeContext).unscopedDefault;
}
function useChanged() {
  return (0, import_react79.useContext)(ChangedContext);
}
function useBaseCommit() {
  return (0, import_react79.useContext)(BaseInfoContext).baseCommit;
}
function useIsRepoPrivate() {
  return (0, import_react79.useContext)(BaseInfoContext).isPrivate;
}
function useRepositoryId() {
  return (0, import_react79.useContext)(BaseInfoContext).repositoryId;
}
var Ref_base = lib_default2`
  fragment Ref_base on Ref {
    id
    name
    target {
      __typename
      id
      oid
      ... on Commit {
        tree {
          id
          oid
        }
      }
    }
    associatedPullRequests(states: [OPEN], first: 1) {
      nodes {
        id
        number
      }
    }
  }
`;
var BaseRepo = lib_default2`
  fragment Repo_base on Repository {
    id
    isPrivate
    owner {
      id
      login
    }
    name
    defaultBranchRef {
      id
      name
    }
    refs(refPrefix: "refs/heads/", first: 100) {
      nodes {
        ...Ref_base
      }
      pageInfo {
        hasNextPage
        endCursor
      }
    }
  }
  ${Ref_base}
`;
var CloudAppShellQuery = lib_default2`
  query CloudAppShell($name: String!, $owner: String!) {
    repository(owner: $owner, name: $name) {
      id
      ...Repo_base
    }
  }
  ${BaseRepo}
`;
var Repo_ghDirect = lib_default2`
  fragment Repo_ghDirect on Repository {
    id
    ...Repo_base
    viewerPermission
  }
  ${BaseRepo}
`;
var Repo_primary = lib_default2`
  fragment Repo_primary on Repository {
    id
    ...Repo_ghDirect
    forks(affiliations: [OWNER], first: 1) {
      nodes {
        ...Repo_ghDirect
      }
    }
  }
  ${Repo_ghDirect}
`;
var GitHubAppShellQuery = lib_default2`
  query GitHubAppShell($name: String!, $owner: String!) {
    repository(owner: $owner, name: $name) {
      id
      ...Repo_primary
    }
    viewer {
      ...SidebarFooter_viewer
    }
  }
  ${Repo_primary}
  ${SidebarFooter_viewer}
`;
var treeCache = new lru_cache_default({
  max: 40
});
async function hydrateTreeCacheWithEntries(entries2) {
  const data = {
    entries: new Map(entries2.map((entry) => [entry.path, entry])),
    tree: treeEntriesToTreeNodes(entries2)
  };
  const sha = await treeSha(data.tree);
  treeCache.set(sha, data);
  return data;
}
function fetchGitHubTreeData(sha, config3) {
  const cached = treeCache.get(sha);
  if (cached)
    return cached;
  const cachedFromPersisted = getTreeFromPersistedCache(sha);
  if (cachedFromPersisted && !(cachedFromPersisted instanceof Promise)) {
    const entries2 = treeToEntries(cachedFromPersisted.children);
    const result = {
      entries: new Map(entries2.map((entry) => [entry.path, entry])),
      tree: cachedFromPersisted.children
    };
    treeCache.set(sha, result);
    return result;
  }
  const promise = (async () => {
    const cached2 = await cachedFromPersisted;
    if (cached2) {
      const entries2 = treeToEntries(cached2.children);
      const result = {
        entries: new Map(entries2.map((entry) => [entry.path, entry])),
        tree: cached2.children
      };
      treeCache.set(sha, result);
      return result;
    }
    const auth = await getAuth(config3);
    if (!auth)
      throw new Error("Not authorized");
    const {
      tree: tree2
    } = await fetch(config3.storage.kind === "github" ? `https://api.github.com/repos/${serializeRepoConfig(config3.storage.repo)}/git/trees/${sha}?recursive=1` : `${KEYSTATIC_CLOUD_API_URL}/v1/github/trees/${sha}`, {
      headers: {
        Authorization: `Bearer ${auth.accessToken}`,
        ...config3.storage.kind === "cloud" ? KEYSTATIC_CLOUD_HEADERS : {}
      }
    }).then((x4) => x4.json());
    const treeEntries = tree2.map(({
      url,
      size: size3,
      ...rest
    }) => rest);
    await setTreeToPersistedCache(sha, treeEntriesToTreeNodes(treeEntries));
    return hydrateTreeCacheWithEntries(treeEntries);
  })();
  treeCache.set(sha, promise);
  return promise;
}
function useGitHubTreeData(sha, config3) {
  return useData((0, import_react79.useCallback)(() => sha ? fetchGitHubTreeData(sha, config3) : LOADING, [sha, config3]));
}
var RepoWithWriteAccessContext = (0, import_react79.createContext)(null);
var BranchInfoContext = (0, import_react79.createContext)({
  currentBranch: "",
  allBranches: [],
  defaultBranch: "",
  pullRequestNumber: void 0,
  branchNameToId: /* @__PURE__ */ new Map(),
  branchNameToBaseCommit: /* @__PURE__ */ new Map(),
  mainOwner: "",
  mainRepo: ""
});
function useBranchInfo() {
  return (0, import_react79.useContext)(BranchInfoContext);
}
function getChangedData(config3, trees) {
  var _config$collections, _config$singletons;
  return {
    collections: new Map(Object.keys((_config$collections = config3.collections) !== null && _config$collections !== void 0 ? _config$collections : {}).map((collection2) => {
      const currentBranch = new Map(getEntriesInCollectionWithTreeKey(config3, collection2, trees.current.tree).map((x4) => [x4.slug, x4.key]));
      const defaultBranch = new Map(getEntriesInCollectionWithTreeKey(config3, collection2, trees.default.tree).map((x4) => [x4.slug, x4.key]));
      const changed = /* @__PURE__ */ new Set();
      const added = /* @__PURE__ */ new Set();
      for (const [key, entry] of currentBranch) {
        const defaultBranchEntry = defaultBranch.get(key);
        if (defaultBranchEntry === void 0) {
          added.add(key);
          continue;
        }
        if (entry !== defaultBranchEntry) {
          changed.add(key);
        }
      }
      const removed = new Set([...defaultBranch.keys()].filter((key) => !currentBranch.has(key)));
      return [collection2, {
        removed,
        added,
        changed,
        totalCount: currentBranch.size
      }];
    })),
    singletons: new Set(Object.keys((_config$singletons = config3.singletons) !== null && _config$singletons !== void 0 ? _config$singletons : {}).filter((singleton2) => {
      var _getTreeNodeAtPath, _getTreeNodeAtPath2;
      const singletonPath = getSingletonPath(config3, singleton2);
      return ((_getTreeNodeAtPath = getTreeNodeAtPath(trees.current.tree, singletonPath)) === null || _getTreeNodeAtPath === void 0 ? void 0 : _getTreeNodeAtPath.entry.sha) !== ((_getTreeNodeAtPath2 = getTreeNodeAtPath(trees.default.tree, singletonPath)) === null || _getTreeNodeAtPath2 === void 0 ? void 0 : _getTreeNodeAtPath2.entry.sha);
    }))
  };
}
var SIDE_PANEL_ID = "keystatic-side-panel";
var MAIN_PANEL_ID = "keystatic-main-panel";
var View = (props) => {
  return (0, import_jsx_runtime92.jsx)(Box, {
    height: "100%",
    minHeight: 0,
    minWidth: 0,
    ...props
  });
};
var ScrollView3 = (props) => {
  let {
    isDisabled,
    ...otherProps
  } = props;
  return (0, import_jsx_runtime92.jsx)(View, {
    "data-scrollable": isDisabled ? void 0 : true,
    UNSAFE_className: css({
      "&[data-scrollable]": {
        overflowY: "auto",
        WebkitOverflowScrolling: "touch"
      }
    }),
    ...otherProps
  });
};
var NAVIGATION_DIVIDER_KEY = "---";
function config2(config3) {
  return config3;
}
function collection(collection2) {
  return collection2;
}
function singleton(collection2) {
  return collection2;
}
var ConfigContext = (0, import_react79.createContext)(null);
function useConfig() {
  const config3 = (0, import_react79.useContext)(ConfigContext);
  if (!config3) {
    throw new Error("ConfigContext.Provider not found");
  }
  return config3;
}
var AppStateContext = (0, import_react79.createContext)({
  basePath: "/keystatic"
});
function useAppState() {
  const appState = (0, import_react79.useContext)(AppStateContext);
  if (!appState) {
    throw new Error("AppStateContext.Provider not found");
  }
  return appState;
}
var ContentPanelContext = (0, import_react79.createContext)("mobile");
var ContentPanelProvider = ContentPanelContext.Provider;
function useContentPanelSize() {
  return (0, import_react79.useContext)(ContentPanelContext);
}
function useContentPanelQuery(options) {
  const sizes = ["mobile", "tablet", "desktop", "wide"];
  const size3 = useContentPanelSize();
  const startIndex = "above" in options ? sizes.indexOf(options.above) + 1 : 0;
  const endIndex = "below" in options ? sizes.indexOf(options.below) - 1 : sizes.length - 1;
  const range = sizes.slice(startIndex, endIndex + 1);
  return range.includes(size3);
}
function useContentPanelState(ref) {
  let [contentSize, setContentSize] = (0, import_react79.useState)("mobile");
  const onResize = () => {
    setContentSize((size3) => {
      let contentPane = ref.current;
      if (!contentPane) {
        return size3;
      }
      if (contentPane.offsetWidth >= breakpoints.wide) {
        return "wide";
      }
      if (contentPane.offsetWidth >= breakpoints.desktop) {
        return "desktop";
      }
      if (contentPane.offsetWidth >= breakpoints.tablet) {
        return "tablet";
      }
      return "mobile";
    });
  };
  $9daab02d461809db$export$683480f191c0e3ea({
    ref,
    onResize
  });
  return contentSize;
}
function useNavItems() {
  var _config$ui;
  let {
    basePath
  } = useAppState();
  let config3 = useConfig();
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  let changeMap = useChanged();
  const collectionKeys = Object.keys(config3.collections || {});
  const singletonKeys = Object.keys(config3.singletons || {});
  const items = ((_config$ui = config3.ui) === null || _config$ui === void 0 ? void 0 : _config$ui.navigation) || {
    ...!!collectionKeys.length && {
      [stringFormatter.format("collections")]: collectionKeys
    },
    ...!!singletonKeys.length && {
      [stringFormatter.format("singletons")]: singletonKeys
    }
  };
  const options = {
    basePath,
    changeMap,
    config: config3
  };
  if (Array.isArray(items)) {
    return items.map((key) => populateItemData(key, options));
  }
  return Object.entries(items).map(([section, keys3]) => ({
    title: section,
    children: keys3.map((key) => populateItemData(key, options))
  }));
}
function populateItemData(key, options) {
  let {
    basePath,
    changeMap,
    config: config3
  } = options;
  if (key === NAVIGATION_DIVIDER_KEY) {
    return {
      isDivider: true
    };
  }
  if (config3.collections && key in config3.collections) {
    const href = `${basePath}/collection/${encodeURIComponent(key)}`;
    const changes = changeMap.collections.get(key);
    const changed = changes ? changes.changed.size + changes.added.size + changes.removed.size : 0;
    const label = config3.collections[key].label;
    return {
      key,
      href,
      label,
      changed,
      entryCount: changes === null || changes === void 0 ? void 0 : changes.totalCount
    };
  }
  if (config3.singletons && key in config3.singletons) {
    const href = `${basePath}/singleton/${encodeURIComponent(key)}`;
    const changed = changeMap.singletons.has(key);
    const label = config3.singletons[key].label;
    return {
      key,
      href,
      label,
      changed
    };
  }
  throw new Error(`Unknown navigation key: "${key}".`);
}
function useBrand() {
  var _config$ui, _config$ui2;
  let {
    colorScheme
  } = useProvider();
  let config3 = useConfig();
  let prefersDark = useMediaQuery("(prefers-color-scheme: dark)");
  let brandMark = (0, import_jsx_runtime92.jsx)(ZapLogo, {});
  let brandName = "Keystatic";
  if ((_config$ui = config3.ui) !== null && _config$ui !== void 0 && (_config$ui = _config$ui.brand) !== null && _config$ui !== void 0 && _config$ui.mark) {
    let BrandMark = config3.ui.brand.mark;
    let resolvedColorScheme = colorScheme === "auto" ? prefersDark ? "dark" : "light" : colorScheme;
    brandMark = (0, import_jsx_runtime92.jsx)(BrandMark, {
      colorScheme: resolvedColorScheme
    });
  }
  if ("repo" in config3.storage) {
    brandName = serializeRepoConfig(config3.storage.repo);
  }
  if (config3.cloud) {
    brandName = config3.cloud.project;
  }
  if ((_config$ui2 = config3.ui) !== null && _config$ui2 !== void 0 && (_config$ui2 = _config$ui2.brand) !== null && _config$ui2 !== void 0 && _config$ui2.name) {
    brandName = config3.ui.brand.name;
  }
  return {
    brandMark,
    brandName
  };
}
function ZapLogo() {
  let id2 = "brand-mark-gradient";
  let size3 = 24;
  return (0, import_jsx_runtime92.jsxs)("svg", {
    width: size3,
    height: size3,
    viewBox: "0 0 32 32",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [(0, import_jsx_runtime92.jsx)("path", {
      d: "M18 8L14 24L12 32L30 14L18 8Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime92.jsx)("path", {
      d: "M2 18L20 0L18 8L2 18Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime92.jsx)("path", {
      d: "M18 8L2 18L14 24L18 8Z",
      fill: `url(#${id2})`
    }), (0, import_jsx_runtime92.jsx)("defs", {
      children: (0, import_jsx_runtime92.jsxs)("linearGradient", {
        id: id2,
        x1: "2",
        y1: "18",
        x2: "20",
        y2: "14",
        gradientUnits: "userSpaceOnUse",
        children: [(0, import_jsx_runtime92.jsx)("stop", {
          stopColor: "currentColor",
          stopOpacity: "0.2"
        }), (0, import_jsx_runtime92.jsx)("stop", {
          offset: "1",
          stopColor: "currentColor"
        })]
      })
    })]
  });
}
function BranchPicker() {
  const {
    allBranches,
    currentBranch,
    defaultBranch
  } = (0, import_react79.useContext)(BranchInfoContext);
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  const router = useRouter();
  const config3 = useConfig();
  const branchPrefix = getBranchPrefix(config3);
  const items = (0, import_react79.useMemo)(() => {
    let defaultItems = allBranches.map((name2) => ({
      id: name2,
      name: name2
    }));
    if (defaultBranch) {
      return [{
        id: defaultBranch,
        name: defaultBranch,
        description: stringFormatter.format("defaultBranch")
      }, ...defaultItems.filter((i6) => i6.name !== defaultBranch)];
    }
    return defaultItems;
  }, [allBranches, defaultBranch, stringFormatter]);
  const filteredBranches = (0, import_react79.useMemo)(() => items.filter((item2) => item2.name === defaultBranch || !branchPrefix || item2.name.startsWith(branchPrefix) || item2.name === currentBranch), [branchPrefix, currentBranch, defaultBranch, items]);
  return (0, import_jsx_runtime92.jsx)(_Combobox, {
    "aria-label": stringFormatter.format("currentBranch"),
    defaultItems: filteredBranches,
    loadingState: filteredBranches.length === 0 ? "loading" : void 0,
    selectedKey: currentBranch,
    onSelectionChange: (key) => {
      if (typeof key === "string") {
        router.push(router.href.replace(/\/branch\/[^/]+/, "/branch/" + encodeURIComponent(key)));
      }
    },
    menuTrigger: "focus",
    flex: true,
    children: (item2) => (0, import_jsx_runtime92.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
      textValue: item2.name,
      children: [(0, import_jsx_runtime92.jsx)(Icon, {
        src: gitBranchIcon
      }), (0, import_jsx_runtime92.jsx)(Text2, {
        truncate: true,
        children: item2.name
      }), "description" in item2 && (0, import_jsx_runtime92.jsx)(Text2, {
        slot: "description",
        children: item2.description
      })]
    }, item2.id)
  });
}
function CreateBranchDialog(props) {
  const config3 = useConfig();
  const branchInfo = (0, import_react79.useContext)(BranchInfoContext);
  const isDefaultBranch = branchInfo.defaultBranch === branchInfo.currentBranch;
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  const [{
    error: error3,
    fetching
  }, createBranch] = useCreateBranchMutation();
  const repositoryId = useRepositoryId();
  const createBranchSubmitButtonId = "create-branch-submit-button";
  const [branchName, setBranchName] = (0, import_react79.useState)("");
  const [baseBranch, setBaseBranch] = (0, import_react79.useState)(branchInfo.defaultBranch);
  const branchPrefix = getBranchPrefix(config3);
  const propsForBranchPrefix = branchPrefix ? {
    UNSAFE_className: css({
      "& input": {
        paddingInlineStart: tokenSchema.size.space.xsmall
      }
    }),
    startElement: (0, import_jsx_runtime92.jsx)(Flex, {
      alignItems: "center",
      paddingStart: "regular",
      justifyContent: "center",
      pointerEvents: "none",
      children: (0, import_jsx_runtime92.jsx)(Text2, {
        color: "neutralSecondary",
        children: branchPrefix
      })
    })
  } : {};
  return (0, import_jsx_runtime92.jsx)(Dialog, {
    size: "small",
    children: (0, import_jsx_runtime92.jsxs)("form", {
      style: {
        display: "contents"
      },
      onSubmit: async (event) => {
        var _result$data;
        if (event.target !== event.currentTarget)
          return;
        event.preventDefault();
        const fullBranchName = (branchPrefix !== null && branchPrefix !== void 0 ? branchPrefix : "") + branchName;
        const name2 = `refs/heads/${fullBranchName}`;
        const result = await createBranch({
          input: {
            name: name2,
            oid: branchInfo.branchNameToBaseCommit.get(baseBranch),
            repositoryId
          }
        });
        if ((_result$data = result.data) !== null && _result$data !== void 0 && (_result$data = _result$data.createRef) !== null && _result$data !== void 0 && _result$data.__typename) {
          props.onCreate(fullBranchName);
        }
      },
      children: [(0, import_jsx_runtime92.jsx)(Heading, {
        children: stringFormatter.format("newBranch")
      }), (0, import_jsx_runtime92.jsx)(Content, {
        children: isDefaultBranch ? (0, import_jsx_runtime92.jsx)(TextField, {
          value: branchName,
          onChange: setBranchName,
          label: stringFormatter.format("branchName"),
          autoFocus: true,
          errorMessage: prettyErrorForCreateBranchMutation(error3),
          ...propsForBranchPrefix
        }) : (0, import_jsx_runtime92.jsxs)(Grid, {
          gap: "xlarge",
          children: [(0, import_jsx_runtime92.jsx)(TextField, {
            label: stringFormatter.format("branchName"),
            value: branchName,
            onChange: setBranchName,
            autoFocus: true,
            errorMessage: prettyErrorForCreateBranchMutation(error3),
            ...propsForBranchPrefix
          }), (0, import_jsx_runtime92.jsxs)(RadioGroup, {
            label: stringFormatter.format("basedOn"),
            value: baseBranch,
            onChange: setBaseBranch,
            children: [(0, import_jsx_runtime92.jsxs)(Radio, {
              value: branchInfo.defaultBranch,
              children: [(0, import_jsx_runtime92.jsxs)(Text2, {
                children: [branchInfo.defaultBranch, (0, import_jsx_runtime92.jsx)(Text2, {
                  visuallyHidden: true,
                  children: "."
                })]
              }), (0, import_jsx_runtime92.jsx)(Text2, {
                slot: "description",
                children: stringFormatter.format("theDefaultBranchInYourRepository")
              })]
            }), (0, import_jsx_runtime92.jsxs)(Radio, {
              value: branchInfo.currentBranch,
              children: [(0, import_jsx_runtime92.jsxs)(Text2, {
                children: [branchInfo.currentBranch, (0, import_jsx_runtime92.jsx)(Text2, {
                  visuallyHidden: true,
                  children: "."
                })]
              }), (0, import_jsx_runtime92.jsx)(Text2, {
                slot: "description",
                children: stringFormatter.format("theCurrentlyCheckedOutBranch")
              })]
            })]
          })]
        })
      }), (0, import_jsx_runtime92.jsx)(Footer, {
        UNSAFE_style: {
          justifyContent: "flex-end"
        },
        children: fetching && (0, import_jsx_runtime92.jsx)(ProgressCircle, {
          "aria-labelledby": createBranchSubmitButtonId,
          isIndeterminate: true,
          size: "small"
        })
      }), (0, import_jsx_runtime92.jsxs)(ButtonGroup, {
        children: [(0, import_jsx_runtime92.jsx)(Button, {
          onPress: props.onDismiss,
          isDisabled: fetching,
          children: stringFormatter.format("cancel")
        }), (0, import_jsx_runtime92.jsx)(Button, {
          isDisabled: fetching,
          prominence: "high",
          type: "submit",
          id: createBranchSubmitButtonId,
          children: stringFormatter.format("create")
        })]
      })]
    })
  });
}
var invalidAnywhere = [" ", "~", "^", ":", "*", "?", "[", "..", "@{", "\\"];
var invalidStart = [".", "/"];
var invalidEnd = [".", "/", ".lock"];
function prettyErrorForCreateBranchMutation(error3) {
  if (!error3) {
    return void 0;
  }
  if (error3.message.includes("is not a valid ref name")) {
    let refnameMatch = error3.message.match(/"([^"]+)"/);
    let branchname = refnameMatch ? refnameMatch[1].replace("refs/heads/", "") : "";
    for (let char2 of invalidStart) {
      if (branchname.startsWith(char2)) {
        return `Cannot start with "${char2}"`;
      }
    }
    for (let char2 of invalidEnd) {
      if (branchname.endsWith(char2)) {
        return `Cannot end with "${char2}"`;
      }
    }
    let invalidMatches = invalidAnywhere.filter((c5) => branchname.includes(c5));
    if (invalidMatches.length > 0) {
      let options = {
        style: "long",
        type: "conjunction"
      };
      let formatter = new Intl.ListFormat("en-US", options);
      let list3 = invalidMatches.map((char2) => `"${char2}"`);
      return `Some characters are not allowed: ${formatter.format(list3)}`;
    }
    return "Invalid branch name";
  }
  return error3.message;
}
function useCreateBranchMutation() {
  return useMutation(lib_default2`
      mutation CreateBranch($input: CreateRefInput!) {
        createRef(input: $input) {
          __typename
          ref {
            ...Ref_base
          }
        }
      }
      ${Ref_base}
    `);
}
var ThemeContext = (0, import_react79.createContext)({
  theme: "auto",
  setTheme: () => {
    throw new Error("ThemeContext was not initialized.");
  }
});
var ThemeProvider = ThemeContext.Provider;
var STORAGE_KEY = "keystatic-color-scheme";
function useTheme() {
  let [theme, setThemeValue] = (0, import_react79.useState)(() => {
    let storedValue = localStorage.getItem(STORAGE_KEY);
    if (storedValue === "light" || storedValue === "dark") {
      return storedValue;
    }
    return "auto";
  });
  let setTheme = (theme2) => {
    localStorage.setItem(STORAGE_KEY, theme2);
    setThemeValue(theme2);
  };
  return {
    theme,
    setTheme
  };
}
function useThemeContext() {
  return (0, import_react79.useContext)(ThemeContext);
}
function focusWithPreviousSelection(editor) {
  const selection = window.getSelection();
  if (selection) {
    selection.removeAllRanges();
    selection.addRange(ReactEditor.toDOMRange(editor, editor.selection));
  }
  ReactEditor.focus(editor);
}
var blockElementSpacing = css({
  marginBlock: "0.75em",
  "&:first-child": {
    marginBlockStart: 0
  },
  "&:last-child": {
    marginBlockEnd: 0
  }
});
var ForceValidationContext = import_react79.default.createContext(false);
ForceValidationContext.Provider;
function useElementWithSetNodes(editor, element4) {
  const [state, setState] = (0, import_react79.useState)({
    element: element4,
    elementWithChanges: element4
  });
  if (state.element !== element4) {
    setState({
      element: element4,
      elementWithChanges: element4
    });
  }
  const elementRef = (0, import_react79.useRef)(element4);
  (0, import_react79.useEffect)(() => {
    elementRef.current = element4;
  });
  const setNodes = (0, import_react79.useCallback)((changesOrCallback) => {
    const currentElement = elementRef.current;
    const changes = typeof changesOrCallback === "function" ? changesOrCallback(currentElement) : changesOrCallback;
    Transforms.setNodes(editor, changes, {
      at: ReactEditor.findPath(editor, currentElement)
    });
    setState({
      element: currentElement,
      elementWithChanges: {
        ...currentElement,
        ...changes
      }
    });
  }, [editor]);
  return [state.elementWithChanges, setNodes];
}
function useEventCallback(callback) {
  const callbackRef = (0, import_react79.useRef)(callback);
  const cb = (0, import_react79.useCallback)((...args2) => {
    return callbackRef.current(...args2);
  }, []);
  (0, import_react79.useEffect)(() => {
    callbackRef.current = callback;
  });
  return cb;
}
function insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, nodes) {
  var _pathRefForEmptyNodeA;
  let pathRefForEmptyNodeAtCursor;
  const entry = Editor.above(editor, {
    match: (node4) => node4.type === "heading" || node4.type === "paragraph"
  });
  if (entry && Node3.string(entry[0]) === "") {
    pathRefForEmptyNodeAtCursor = Editor.pathRef(editor, entry[1]);
  }
  Transforms.insertNodes(editor, nodes);
  let path3 = (_pathRefForEmptyNodeA = pathRefForEmptyNodeAtCursor) === null || _pathRefForEmptyNodeA === void 0 ? void 0 : _pathRefForEmptyNodeA.unref();
  if (path3) {
    Transforms.removeNodes(editor, {
      at: path3
    });
    ReactEditor.focus(editor);
  }
}
var tableCellChildren = ["paragraph", "code", "heading", "ordered-list", "unordered-list", "divider", "image"];
var blockquoteChildren = [...tableCellChildren, "table"];
var paragraphLike = [...blockquoteChildren, "blockquote"];
var insideOfLayouts = [...paragraphLike, "component-block"];
function blockContainer(args2) {
  return {
    kind: "blocks",
    allowedChildren: new Set(args2.allowedChildren),
    blockToWrapInlinesIn: args2.allowedChildren[0],
    invalidPositionHandleMode: args2.invalidPositionHandleMode
  };
}
function inlineContainer(args2) {
  return {
    kind: "inlines",
    invalidPositionHandleMode: args2.invalidPositionHandleMode
  };
}
var editorSchema = {
  editor: blockContainer({
    allowedChildren: [...insideOfLayouts, "layout"],
    invalidPositionHandleMode: "move"
  }),
  layout: blockContainer({
    allowedChildren: ["layout-area"],
    invalidPositionHandleMode: "move"
  }),
  "layout-area": blockContainer({
    allowedChildren: insideOfLayouts,
    invalidPositionHandleMode: "unwrap"
  }),
  blockquote: blockContainer({
    allowedChildren: blockquoteChildren,
    invalidPositionHandleMode: "move"
  }),
  paragraph: inlineContainer({
    invalidPositionHandleMode: "unwrap"
  }),
  code: inlineContainer({
    invalidPositionHandleMode: "move"
  }),
  divider: inlineContainer({
    invalidPositionHandleMode: "move"
  }),
  heading: inlineContainer({
    invalidPositionHandleMode: "unwrap"
  }),
  "component-block": blockContainer({
    allowedChildren: ["component-block-prop", "component-inline-prop"],
    invalidPositionHandleMode: "move"
  }),
  "component-inline-prop": inlineContainer({
    invalidPositionHandleMode: "unwrap"
  }),
  "component-block-prop": blockContainer({
    allowedChildren: insideOfLayouts,
    invalidPositionHandleMode: "unwrap"
  }),
  "ordered-list": blockContainer({
    allowedChildren: ["list-item"],
    invalidPositionHandleMode: "move"
  }),
  "unordered-list": blockContainer({
    allowedChildren: ["list-item"],
    invalidPositionHandleMode: "move"
  }),
  "list-item": blockContainer({
    allowedChildren: ["list-item-content", "ordered-list", "unordered-list"],
    invalidPositionHandleMode: "unwrap"
  }),
  "list-item-content": inlineContainer({
    invalidPositionHandleMode: "unwrap"
  }),
  image: inlineContainer({
    invalidPositionHandleMode: "move"
  }),
  table: blockContainer({
    invalidPositionHandleMode: "move",
    allowedChildren: ["table-head", "table-body"]
  }),
  "table-body": blockContainer({
    invalidPositionHandleMode: "move",
    allowedChildren: ["table-row"]
  }),
  "table-row": blockContainer({
    invalidPositionHandleMode: "move",
    allowedChildren: ["table-cell"]
  }),
  "table-cell": blockContainer({
    invalidPositionHandleMode: "move",
    allowedChildren: tableCellChildren
  }),
  "table-head": blockContainer({
    invalidPositionHandleMode: "move",
    allowedChildren: ["table-row"]
  })
};
var inlineContainerTypes = new Set(Object.entries(editorSchema).filter(([, value2]) => value2.kind === "inlines").map(([type2]) => type2));
function isInlineContainer(node4) {
  return node4.type !== void 0 && inlineContainerTypes.has(node4.type);
}
var blockTypes = new Set(Object.keys(editorSchema).filter((x4) => x4 !== "editor"));
function isBlock(node4) {
  return blockTypes.has(node4.type);
}
function getWholeDocumentFeaturesForChildField(editorDocumentFeatures, options) {
  var _options$formatting, _options$formatting2, _options$formatting3, _options$formatting4, _options$formatting5, _options$formatting6, _options$formatting7;
  const inlineMarksFromOptions = (_options$formatting = options.formatting) === null || _options$formatting === void 0 ? void 0 : _options$formatting.inlineMarks;
  const inlineMarks2 = Object.fromEntries(Object.keys(editorDocumentFeatures.formatting.inlineMarks).map((_mark) => {
    const mark = _mark;
    return [mark, inlineMarksFromOptions === "inherit" || (inlineMarksFromOptions === null || inlineMarksFromOptions === void 0 ? void 0 : inlineMarksFromOptions[mark]) === "inherit" ? editorDocumentFeatures.formatting.inlineMarks[mark] : false];
  }));
  const headingLevels = (_options$formatting2 = options.formatting) === null || _options$formatting2 === void 0 ? void 0 : _options$formatting2.headingLevels;
  return {
    formatting: {
      inlineMarks: inlineMarks2,
      softBreaks: ((_options$formatting3 = options.formatting) === null || _options$formatting3 === void 0 ? void 0 : _options$formatting3.softBreaks) === "inherit" && editorDocumentFeatures.formatting.softBreaks,
      alignment: {
        center: editorDocumentFeatures.formatting.alignment.center && ((_options$formatting4 = options.formatting) === null || _options$formatting4 === void 0 ? void 0 : _options$formatting4.alignment) === "inherit",
        end: editorDocumentFeatures.formatting.alignment.end && ((_options$formatting5 = options.formatting) === null || _options$formatting5 === void 0 ? void 0 : _options$formatting5.alignment) === "inherit"
      },
      blockTypes: ((_options$formatting6 = options.formatting) === null || _options$formatting6 === void 0 ? void 0 : _options$formatting6.blockTypes) === "inherit" ? editorDocumentFeatures.formatting.blockTypes : {
        blockquote: false,
        code: false
      },
      headings: headingLevels === "inherit" ? editorDocumentFeatures.formatting.headings : {
        levels: headingLevels ? editorDocumentFeatures.formatting.headings.levels.filter((level) => headingLevels.includes(level)) : [],
        schema: editorDocumentFeatures.formatting.headings.schema
      },
      listTypes: ((_options$formatting7 = options.formatting) === null || _options$formatting7 === void 0 ? void 0 : _options$formatting7.listTypes) === "inherit" ? editorDocumentFeatures.formatting.listTypes : {
        ordered: false,
        unordered: false
      }
    },
    dividers: options.dividers === "inherit" ? editorDocumentFeatures.dividers : false,
    images: options.images === "inherit" && editorDocumentFeatures.images,
    layouts: [],
    links: options.links === "inherit" && editorDocumentFeatures.links,
    tables: options.tables === "inherit" && editorDocumentFeatures.tables
  };
}
function getDocumentFeaturesForChildField(editorDocumentFeatures, options) {
  var _options$formatting8, _options$formatting10, _options$formatting11, _options$formatting12, _options$formatting13, _options$formatting14;
  const inlineMarksFromOptions = (_options$formatting8 = options.formatting) === null || _options$formatting8 === void 0 ? void 0 : _options$formatting8.inlineMarks;
  const inlineMarks2 = inlineMarksFromOptions === "inherit" ? "inherit" : Object.fromEntries(Object.keys(editorDocumentFeatures.formatting.inlineMarks).map((mark) => {
    return [mark, !!(inlineMarksFromOptions || {})[mark]];
  }));
  if (options.kind === "inline") {
    var _options$formatting9;
    return {
      kind: "inline",
      inlineMarks: inlineMarks2,
      documentFeatures: {
        links: options.links === "inherit"
      },
      softBreaks: ((_options$formatting9 = options.formatting) === null || _options$formatting9 === void 0 ? void 0 : _options$formatting9.softBreaks) === "inherit"
    };
  }
  const headingLevels = (_options$formatting10 = options.formatting) === null || _options$formatting10 === void 0 ? void 0 : _options$formatting10.headingLevels;
  return {
    kind: "block",
    inlineMarks: inlineMarks2,
    softBreaks: ((_options$formatting11 = options.formatting) === null || _options$formatting11 === void 0 ? void 0 : _options$formatting11.softBreaks) === "inherit",
    documentFeatures: {
      layouts: [],
      dividers: options.dividers === "inherit" ? editorDocumentFeatures.dividers : false,
      formatting: {
        alignment: ((_options$formatting12 = options.formatting) === null || _options$formatting12 === void 0 ? void 0 : _options$formatting12.alignment) === "inherit" ? editorDocumentFeatures.formatting.alignment : {
          center: false,
          end: false
        },
        blockTypes: ((_options$formatting13 = options.formatting) === null || _options$formatting13 === void 0 ? void 0 : _options$formatting13.blockTypes) === "inherit" ? editorDocumentFeatures.formatting.blockTypes : {
          blockquote: false,
          code: false
        },
        headings: headingLevels === "inherit" ? editorDocumentFeatures.formatting.headings : {
          levels: headingLevels ? editorDocumentFeatures.formatting.headings.levels.filter((level) => headingLevels.includes(level)) : [],
          schema: editorDocumentFeatures.formatting.headings.schema
        },
        listTypes: ((_options$formatting14 = options.formatting) === null || _options$formatting14 === void 0 ? void 0 : _options$formatting14.listTypes) === "inherit" ? editorDocumentFeatures.formatting.listTypes : {
          ordered: false,
          unordered: false
        }
      },
      links: options.links === "inherit",
      images: options.images === "inherit" ? editorDocumentFeatures.images : false,
      tables: options.tables === "inherit"
    },
    componentBlocks: options.componentBlocks === "inherit"
  };
}
function getSchemaAtPropPathInner(path3, value2, schema) {
  if (path3.length === 0) {
    return schema;
  }
  if (schema.kind === "child" || schema.kind === "form") {
    return;
  }
  if (schema.kind === "conditional") {
    const key = path3.shift();
    if (key === "discriminant") {
      return getSchemaAtPropPathInner(path3, value2.discriminant, schema.discriminant);
    }
    if (key === "value") {
      const propVal = schema.values[value2.discriminant];
      return getSchemaAtPropPathInner(path3, value2.value, propVal);
    }
    return;
  }
  if (schema.kind === "object") {
    const key = path3.shift();
    return getSchemaAtPropPathInner(path3, value2[key], schema.fields[key]);
  }
  if (schema.kind === "array") {
    const index3 = path3.shift();
    return getSchemaAtPropPathInner(path3, value2[index3], schema.element);
  }
  assertNever(schema);
}
function getSchemaAtPropPath(path3, value2, props) {
  return getSchemaAtPropPathInner([...path3], value2, {
    kind: "object",
    fields: props
  });
}
function getAncestorSchemas(rootSchema, path3, value2) {
  const ancestors = [];
  const currentPath = [...path3];
  let currentProp = rootSchema;
  let currentValue = value2;
  while (currentPath.length) {
    ancestors.push(currentProp);
    const key = currentPath.shift();
    if (currentProp.kind === "array") {
      currentProp = currentProp.element;
      currentValue = currentValue[key];
    } else if (currentProp.kind === "conditional") {
      currentProp = currentProp.values[value2.discriminant];
      currentValue = currentValue.value;
    } else if (currentProp.kind === "object") {
      currentValue = currentValue[key];
      currentProp = currentProp.fields[key];
    } else if (currentProp.kind === "child" || currentProp.kind === "form") {
      throw new Error(`unexpected prop "${key}"`);
    } else {
      assertNever(currentProp);
    }
  }
  return ancestors;
}
function getPlaceholderTextForPropPath(propPath, fields, formProps) {
  const field2 = getSchemaAtPropPath(propPath, formProps, fields);
  if ((field2 === null || field2 === void 0 ? void 0 : field2.kind) === "child" && (field2.options.kind === "block" && field2.options.editIn !== "modal" || field2.options.kind === "inline")) {
    return field2.options.placeholder;
  }
  return "";
}
function cloneDescendent(node4) {
  if (Element2.isElement(node4)) {
    return {
      ...node4,
      children: node4.children.map(cloneDescendent)
    };
  }
  return {
    ...node4
  };
}
var allMarks = ["bold", "italic", "underline", "strikethrough", "code", "superscript", "subscript", "keyboard"];
var isElementActive = (editor, format2) => {
  const [match3] = Editor.nodes(editor, {
    match: (n6) => n6.type === format2
  });
  return !!match3;
};
function clearFormatting(editor) {
  Transforms.unwrapNodes(editor, {
    match: (node4) => node4.type === "heading" || node4.type === "blockquote" || node4.type === "code"
  });
  Transforms.unsetNodes(editor, allMarks, {
    match: Text.isText
  });
}
function moveChildren(editor, parent, to, shouldMoveNode = () => true) {
  const parentPath = Path.isPath(parent) ? parent : parent[1];
  const parentNode = Path.isPath(parent) ? Node3.get(editor, parentPath) : parent[0];
  if (!isBlock(parentNode))
    return;
  for (let i6 = parentNode.children.length - 1; i6 >= 0; i6--) {
    if (shouldMoveNode(parentNode.children[i6], i6)) {
      const childPath = [...parentPath, i6];
      Transforms.moveNodes(editor, {
        at: childPath,
        to
      });
    }
  }
}
function EditorAfterButIgnoringingPointsWithNoContent(editor, at, {
  distance = 1
} = {}) {
  const anchor = Editor.point(editor, at, {
    edge: "end"
  });
  const focus = Editor.end(editor, []);
  const range = {
    anchor,
    focus
  };
  let d5 = 0;
  let target;
  for (const p5 of Editor.positions(editor, {
    at: range
  })) {
    if (d5 > distance) {
      break;
    }
    const node4 = Node3.get(editor, p5.path);
    if (node4.text.length === p5.offset) {
      continue;
    }
    if (d5 !== 0) {
      target = p5;
    }
    d5++;
  }
  return target;
}
function nodeTypeMatcher(...args2) {
  if (args2.length === 1) {
    const type2 = args2[0];
    return (node4) => node4.type === type2;
  }
  const set2 = new Set(args2);
  return (node4) => typeof node4.type === "string" && set2.has(node4.type);
}
function getAncestorComponentChildFieldDocumentFeatures(editor, editorDocumentFeatures, componentBlocks) {
  const ancestorComponentProp = Editor.above(editor, {
    match: nodeTypeMatcher("component-block-prop", "component-inline-prop")
  });
  if (ancestorComponentProp) {
    const propPath = ancestorComponentProp[0].propPath;
    const ancestorComponent = Editor.parent(editor, ancestorComponentProp[1]);
    if (ancestorComponent[0].type === "component-block") {
      const component = ancestorComponent[0].component;
      const componentBlock = componentBlocks[component];
      if (componentBlock && propPath) {
        const childField = getSchemaAtPropPath(propPath, ancestorComponent[0].props, componentBlock.schema);
        if ((childField === null || childField === void 0 ? void 0 : childField.kind) === "child") {
          return getDocumentFeaturesForChildField(editorDocumentFeatures, childField.options);
        }
      }
    }
  }
}
var BlockPopoverContext = (0, import_react79.createContext)(null);
function useBlockPopoverContext() {
  const context = (0, import_react79.useContext)(BlockPopoverContext);
  if (!context) {
    throw new Error("useBlockPopoverContext must be used within a BlockPopoverTrigger");
  }
  return context;
}
var typeMatcher = nodeTypeMatcher("code", "component-block", "image", "layout", "link", "table", "heading");
var ActiveBlockPopoverContext = (0, import_react79.createContext)(void 0);
function useActiveBlockPopover() {
  return (0, import_react79.useContext)(ActiveBlockPopoverContext);
}
function ActiveBlockPopoverProvider(props) {
  const nodeWithPopover = Editor.above(props.editor, {
    match: typeMatcher
  });
  return (0, import_jsx_runtime92.jsx)(ActiveBlockPopoverContext.Provider, {
    value: nodeWithPopover === null || nodeWithPopover === void 0 ? void 0 : nodeWithPopover[0],
    children: props.children
  });
}
var BlockPopoverTrigger = ({
  children,
  element: element4
}) => {
  const [trigger2, popover] = children;
  const activePopoverElement = useActiveBlockPopover();
  const triggerRef = (0, import_react79.useRef)(null);
  const state = $fc909762b330b746$export$61c6a8c84e605fb6({
    isOpen: activePopoverElement === element4
  });
  const context = (0, import_react79.useMemo)(() => ({
    state,
    triggerRef
  }), [state, triggerRef]);
  return (0, import_jsx_runtime92.jsxs)(BlockPopoverContext.Provider, {
    value: context,
    children: [(0, import_react79.cloneElement)(trigger2, {
      ref: triggerRef
    }), popover]
  });
};
function BlockPopover(props) {
  const {
    state
  } = useBlockPopoverContext();
  let wrapperRef = (0, import_react79.useRef)(null);
  return (
    /* @ts-expect-error FIXME: resolve ref inconsistencies */
    (0, import_jsx_runtime92.jsx)(Overlay, {
      isOpen: state.isOpen,
      nodeRef: wrapperRef,
      children: (0, import_jsx_runtime92.jsx)(BlockPopoverWrapper, {
        wrapperRef,
        ...props
      })
    })
  );
}
var BlockPopoverWrapper = ({
  children,
  placement: preferredPlacement = "bottom"
}) => {
  let popoverRef = (0, import_react79.useRef)(null);
  let {
    state,
    triggerRef
  } = useBlockPopoverContext();
  let {
    placement,
    popoverProps
  } = useBlockPopover({
    isNonModal: true,
    isKeyboardDismissDisabled: false,
    placement: preferredPlacement,
    triggerRef,
    popoverRef
  }, state);
  return (0, import_jsx_runtime92.jsx)("div", {
    ref: popoverRef,
    ...popoverProps,
    "data-open": state.isOpen,
    "data-placement": placement,
    contentEditable: false,
    className: css({
      backgroundColor: tokenSchema.color.background.surface,
      // TODO: component token?
      borderRadius: tokenSchema.size.radius.medium,
      // TODO: component token?
      border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.emphasis}`,
      boxSizing: "content-box",
      // resolves measurement/scroll issues related to border
      // boxShadow: `0 0 0 ${tokenSchema.size.border.regular} ${tokenSchema.color.border.emphasis}`,
      minHeight: tokenSchema.size.element.regular,
      minWidth: tokenSchema.size.element.regular,
      opacity: 0,
      outline: 0,
      pointerEvents: "auto",
      position: "absolute",
      // use filter:drop-shadow instead of box-shadow so the arrow is included
      filter: `drop-shadow(0 1px 4px ${tokenSchema.color.shadow.regular})`,
      // filter bug in safari: https://stackoverflow.com/questions/56478925/safari-drop-shadow-filter-remains-visible-even-with-hidden-element
      willChange: "filter",
      userSelect: "none",
      // placement
      '&[data-placement="top"]': {
        marginBottom: tokenSchema.size.space.regular,
        transform: `translateY(${tokenSchema.size.space.regular})`
      },
      '&[data-placement="bottom"]': {
        marginTop: tokenSchema.size.space.regular,
        transform: `translateY(calc(${tokenSchema.size.space.regular} * -1))`
      },
      '&[data-open="true"]': {
        opacity: 1,
        transform: `translateX(0) translateY(0)`,
        // enter animation
        transition: transition(["opacity", "transform"], {
          easing: "easeOut"
        })
      }
    }),
    children: typeof children === "function" ? children(state.close) : children
  });
};
function useBlockPopover(props, state) {
  var _triggerRef$current2;
  let {
    triggerRef,
    popoverRef,
    isNonModal,
    isKeyboardDismissDisabled,
    ...otherProps
  } = props;
  let [isSticky, setSticky] = (0, import_react79.useState)(false);
  let {
    overlayProps,
    underlayProps
  } = $a11501f3d1d39e6c$export$ea8f71083e90600f({
    isOpen: state.isOpen,
    onClose: state.close,
    shouldCloseOnBlur: true,
    isDismissable: !isNonModal,
    isKeyboardDismissDisabled: false
  }, popoverRef);
  const containerPadding = 8;
  (0, import_react79.useEffect)(() => {
    if (state.isOpen) {
      const checkForStickiness = () => {
        var _popoverRef$current, _triggerRef$current;
        const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
        let popoverRect = (_popoverRef$current = popoverRef.current) === null || _popoverRef$current === void 0 ? void 0 : _popoverRef$current.getBoundingClientRect();
        let triggerRect = (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : _triggerRef$current.getBoundingClientRect();
        if (popoverRect && triggerRect) {
          setSticky(triggerRect.bottom + popoverRect.height + containerPadding * 2 > vh && triggerRect.top < vh);
        }
      };
      checkForStickiness();
      window.addEventListener("scroll", checkForStickiness);
      return () => {
        checkForStickiness();
        window.removeEventListener("scroll", checkForStickiness);
      };
    }
  }, [popoverRef, triggerRef, state.isOpen]);
  let {
    overlayProps: positionProps,
    arrowProps,
    placement,
    updatePosition
  } = $2a41e45df1593e64$export$d39e1813b3bdd0e1({
    ...otherProps,
    containerPadding,
    shouldFlip: false,
    targetRef: triggerRef,
    overlayRef: popoverRef,
    isOpen: state.isOpen,
    onClose: void 0
  });
  let previousBoundingRect = usePrevious2((_triggerRef$current2 = triggerRef.current) === null || _triggerRef$current2 === void 0 ? void 0 : _triggerRef$current2.getBoundingClientRect());
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    if (previousBoundingRect) {
      var _triggerRef$current3;
      const currentBoundingRect = (_triggerRef$current3 = triggerRef.current) === null || _triggerRef$current3 === void 0 ? void 0 : _triggerRef$current3.getBoundingClientRect();
      if (currentBoundingRect) {
        const hasChanged = previousBoundingRect.height !== currentBoundingRect.height || previousBoundingRect.width !== currentBoundingRect.width || previousBoundingRect.x !== currentBoundingRect.x || previousBoundingRect.y !== currentBoundingRect.y;
        if (hasChanged) {
          updatePosition();
        }
      }
    }
  }, [previousBoundingRect, triggerRef, updatePosition]);
  if (positionProps.style) {
    positionProps.style.zIndex = 1;
  }
  if (isSticky) {
    positionProps.style = {
      ...positionProps.style,
      // @ts-expect-error
      maxHeight: null,
      position: "fixed",
      // @ts-expect-error
      top: null,
      bottom: containerPadding
    };
  }
  return {
    arrowProps,
    placement,
    popoverProps: $3ef42575df84b30b$export$9d1611c77c2fe928(overlayProps, positionProps),
    underlayProps,
    updatePosition
  };
}
function usePrevious2(value2) {
  const ref = (0, import_react79.useRef)();
  (0, import_react79.useEffect)(() => {
    ref.current = value2;
  });
  return ref.current;
}
var BlockWrapper = (props) => {
  let {
    attributes,
    children,
    draggable = false
  } = props;
  return (0, import_jsx_runtime92.jsx)("div", {
    draggable,
    className: blockElementSpacing,
    ...attributes,
    children
  });
};
var NotEditable = (0, import_react79.forwardRef)(function NotEditable2({
  className,
  ...props
}, ref) {
  return (0, import_jsx_runtime92.jsx)("div", {
    ...props,
    ref,
    className: [css({
      userSelect: "none",
      whiteSpace: "initial"
    }), className].join(" "),
    contentEditable: false
  });
});
var ToolbarSeparator = () => {
  return (0, import_jsx_runtime92.jsx)(Divider, {
    orientation: "vertical",
    flexShrink: 0
  });
};
function parseImageData(data) {
  try {
    const parsed = JSON.parse(data);
    if (typeof parsed === "object" && parsed !== null && "src" in parsed && typeof parsed.src === "string") {
      return {
        src: parsed.src,
        alt: "alt" in parsed && typeof parsed.alt === "string" ? parsed.alt : "",
        height: "height" in parsed && typeof parsed.height === "number" && Number.isInteger(parsed.height) ? parsed.height : void 0,
        width: "width" in parsed && typeof parsed.width === "number" && Number.isInteger(parsed.width) ? parsed.width : void 0
      };
    }
  } catch (err) {
  }
  const pattern = /^\s*!\[(.*)\]\(([a-z0-9_\-/:.]+)\)\s*$/;
  const match3 = data.match(pattern);
  if (match3) {
    return {
      src: match3[2],
      alt: match3[1]
    };
  }
  return {
    src: data,
    alt: ""
  };
}
function useImageDimensions(src) {
  const [dimensions, setDimensions] = (0, import_react79.useState)({});
  (0, import_react79.useEffect)(() => {
    if (!src || !isValidURL$1(src)) {
      setDimensions({});
      return;
    }
    let shouldSet = true;
    loadImageDimensions(src).then((dimensions2) => {
      if (shouldSet)
        setDimensions(dimensions2);
    });
    return () => {
      shouldSet = false;
    };
  }, [src]);
  return dimensions;
}
function loadImageDimensions(url) {
  return new Promise((resolve3, reject) => {
    const img = new Image();
    img.onload = () => {
      resolve3({
        width: img.width,
        height: img.height
      });
    };
    img.onerror = () => {
      reject();
    };
    img.src = url;
  });
}
var imageDataSchema = z.object({
  src: z.string(),
  alt: z.string(),
  width: z.number(),
  height: z.number()
});
async function loadImageData(url, config3) {
  const auth = getCloudAuth(config3);
  if (auth) {
    const res = await fetch(`${KEYSTATIC_CLOUD_API_URL}/v1/image?${new URLSearchParams({
      url
    })}`, {
      headers: {
        Authorization: `Bearer ${auth.accessToken}`,
        ...KEYSTATIC_CLOUD_HEADERS
      }
    });
    if (res.ok) {
      const data = await res.json();
      const parsed = imageDataSchema.safeParse(data);
      if (parsed.success) {
        return parsed.data;
      }
    }
  }
  return loadImageDimensions(url).then((dimensions) => ({
    src: url,
    alt: "",
    ...dimensions
  }));
}
function ImageDimensionsInput(props) {
  const dimensions = useImageDimensions(props.src);
  const [constrainProportions, setConstrainProportions] = (0, import_react79.useState)(true);
  const revertLabel = `Revert to original (${dimensions.width} × ${dimensions.height})`;
  const dimensionsMatchOriginal = dimensions.width === props.image.width && dimensions.height === props.image.height;
  return (0, import_jsx_runtime92.jsxs)(HStack, {
    gap: "regular",
    alignItems: "end",
    children: [(0, import_jsx_runtime92.jsx)(NumberField, {
      label: "Width",
      width: "scale.1600",
      formatOptions: {
        maximumFractionDigits: 0
      },
      value: props.image.width,
      onChange: (width) => {
        if (constrainProportions) {
          props.onChange({
            width,
            height: Math.round(width / getAspectRatio(props.image))
          });
        } else {
          props.onChange({
            width
          });
        }
      }
    }), (0, import_jsx_runtime92.jsxs)(_TooltipTrigger, {
      children: [(0, import_jsx_runtime92.jsx)(ToggleButton, {
        isSelected: constrainProportions,
        "aria-label": "Constrain proportions",
        prominence: "low",
        onPress: () => {
          setConstrainProportions((state) => !state);
        },
        children: (0, import_jsx_runtime92.jsx)(Icon, {
          src: constrainProportions ? link2Icon : link2OffIcon
        })
      }), (0, import_jsx_runtime92.jsx)(Tooltip, {
        children: "Constrain proportions"
      })]
    }), (0, import_jsx_runtime92.jsx)(NumberField, {
      label: "Height",
      width: "scale.1600",
      formatOptions: {
        maximumFractionDigits: 0
      },
      value: props.image.height,
      onChange: (height) => {
        if (constrainProportions) {
          props.onChange({
            height,
            width: Math.round(height * getAspectRatio(props.image))
          });
        } else {
          props.onChange({
            height
          });
        }
      }
    }), (0, import_jsx_runtime92.jsxs)(_TooltipTrigger, {
      children: [(0, import_jsx_runtime92.jsx)(ActionButton, {
        "aria-label": revertLabel,
        isDisabled: dimensionsMatchOriginal || !dimensions.width || !dimensions.height,
        onPress: () => {
          props.onChange({
            height: dimensions.height,
            width: dimensions.width
          });
        },
        children: (0, import_jsx_runtime92.jsx)(Icon, {
          src: undo2Icon
        })
      }), (0, import_jsx_runtime92.jsx)(Tooltip, {
        maxWidth: "100%",
        children: revertLabel
      })]
    })]
  });
}
var emptyImageData = {
  src: "",
  alt: ""
};
function isValidURL$1(str) {
  try {
    new URL(str);
    return true;
  } catch {
    return false;
  }
}
function useImageLibraryURL() {
  const config3 = useConfig();
  const split2 = getSplitCloudProject(config3);
  if (!split2)
    return "https://keystatic.cloud/";
  return `https://keystatic.cloud/teams/${split2.team}/project/${split2.project}/images`;
}
function getAspectRatio(state) {
  if (!state.width || !state.height)
    return 1;
  return state.width / state.height;
}
var units = {
  seconds: 60,
  minutes: 60,
  hours: 24,
  days: 7,
  weeks: 4,
  months: 12,
  years: Infinity
};
function formatTimeAgo(targetDate, currentDate, formatter) {
  let duration = (targetDate.getTime() - currentDate.getTime()) / 1e3;
  for (const [name2, amount] of Object.entries(units)) {
    if (Math.abs(duration) < amount) {
      return formatter.format(Math.round(duration), name2);
    }
    duration /= amount;
  }
  return "unknown";
}
function RelativeTime(props) {
  const {
    locale
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  const [now] = (0, import_react79.useState)(() => /* @__PURE__ */ new Date());
  const formatted = (0, import_react79.useMemo)(() => {
    const formatter = new Intl.RelativeTimeFormat(locale);
    formatter.format(props.date.getTime() - now.getTime(), "second");
    return formatTimeAgo(props.date, now, formatter);
  }, [locale, now, props.date]);
  return (0, import_jsx_runtime92.jsx)("time", {
    dateTime: props.date.toISOString(),
    children: formatted
  });
}
function showDraftRestoredToast(savedAt, hasChangedSince) {
  toastQueue.info((0, import_jsx_runtime92.jsxs)(Text2, {
    children: ["Restored draft from ", (0, import_jsx_runtime92.jsx)(RelativeTime, {
      date: savedAt
    }), ".", " ", hasChangedSince && (0, import_jsx_runtime92.jsx)(Text2, {
      color: "accent",
      children: "Other changes have been made to this entry since the draft. You may want to discard the draft changes."
    })]
  }), {
    timeout: 8e3
  });
}
var store;
function getStore() {
  if (!store) {
    store = createStore("keystatic", "items");
  }
  return store;
}
function setDraft(key, val) {
  return set(key, val, getStore());
}
function delDraft(key) {
  return del(key, getStore());
}
function getDraft(key) {
  return get2(key, getStore());
}
async function clearDrafts() {
  await clear(getStore());
}
var THEME_MODE = {
  light: {
    icon: sunIcon,
    label: "Light"
  },
  dark: {
    icon: moonIcon,
    label: "Dark"
  },
  auto: {
    icon: monitorIcon,
    label: "System"
  }
};
var themeItems = Object.entries(THEME_MODE).map(([id2, {
  icon,
  label
}]) => ({
  id: id2,
  icon,
  label
}));
function ThemeMenu() {
  let {
    theme,
    setTheme
  } = useThemeContext();
  let matchesDark = useMediaQuery("(prefers-color-scheme: dark)");
  let icon = THEME_MODE[theme].icon;
  if (theme === "auto") {
    icon = matchesDark ? moonIcon : sunIcon;
  }
  return (0, import_jsx_runtime92.jsxs)(MenuTrigger, {
    align: "end",
    children: [(0, import_jsx_runtime92.jsx)(ActionButton, {
      "aria-label": "theme",
      prominence: "low",
      children: (0, import_jsx_runtime92.jsx)(Icon, {
        src: icon
      })
    }), (0, import_jsx_runtime92.jsx)(_Menu, {
      items: themeItems,
      onSelectionChange: ([key]) => setTheme(key),
      disallowEmptySelection: true,
      selectedKeys: [theme],
      selectionMode: "single",
      children: (item2) => (0, import_jsx_runtime92.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
        textValue: item2.label,
        children: [(0, import_jsx_runtime92.jsx)(Icon, {
          src: item2.icon
        }), (0, import_jsx_runtime92.jsx)(Text2, {
          children: item2.label
        })]
      })
    })]
  });
}
function UserActions() {
  let config3 = useConfig();
  let userData = useUserData();
  let router = useRouter();
  if (!userData) {
    return null;
  }
  if (userData === "unauthorized") {
    return (0, import_jsx_runtime92.jsx)(ActionButton, {
      onPress: () => {
        redirectToCloudAuth(router.params.map(encodeURIComponent).join("/"), config3);
      },
      flex: true,
      children: "Sign into Cloud"
    });
  }
  return (0, import_jsx_runtime92.jsx)(UserMenu, {
    ...userData
  });
}
function UserMenu(user) {
  let config3 = useConfig();
  const cloudInfo = useCloudInfo();
  const imageLibraryUrl = useImageLibraryURL();
  const menuItems = (0, import_react79.useMemo)(() => {
    var _config$cloud;
    let items = [{
      key: "logout",
      label: "Log out",
      icon: logOutIcon
    }];
    if ((_config$cloud = config3.cloud) !== null && _config$cloud !== void 0 && _config$cloud.project) {
      items.unshift({
        key: "manage",
        label: "Account",
        icon: userIcon,
        href: "https://keystatic.cloud/account",
        target: "_blank",
        rel: "noopener noreferrer"
      });
    }
    if (cloudInfo !== null && cloudInfo !== void 0 && cloudInfo.team.images) {
      items.unshift({
        key: "image-library",
        label: "Image library",
        icon: imageIcon,
        href: imageLibraryUrl,
        target: "_blank",
        rel: "noopener noreferrer"
      });
    }
    return items;
  }, [cloudInfo, config3, imageLibraryUrl]);
  if (!user) {
    return null;
  }
  return (0, import_jsx_runtime92.jsxs)(MenuTrigger, {
    children: [(0, import_jsx_runtime92.jsx)(UserDetailsButton, {
      ...user
    }), (0, import_jsx_runtime92.jsx)(import_jsx_runtime92.Fragment, {
      children: (0, import_jsx_runtime92.jsx)(_Menu, {
        items: menuItems,
        minWidth: "scale.2400",
        onAction: async (key) => {
          await Promise.all([clearObjectCache(), clearDrafts()]);
          switch (key) {
            case "logout":
              switch (config3.storage.kind) {
                case "github":
                  window.location.href = "/api/keystatic/github/logout";
                  break;
                case "cloud":
                case "local":
                  localStorage.removeItem("keystatic-cloud-access-token");
                  window.location.reload();
                  break;
              }
          }
        },
        children: (item2) => (0, import_jsx_runtime92.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
          textValue: item2.label,
          href: item2.href,
          rel: item2.rel,
          target: item2.target,
          children: [(0, import_jsx_runtime92.jsx)(Icon, {
            src: item2.icon
          }), (0, import_jsx_runtime92.jsx)(Text2, {
            children: item2.label
          })]
        }, item2.key)
      })
    })]
  });
}
var UserDetailsButton = (0, import_react79.forwardRef)(function UserDetailsButton2(props, ref) {
  let {
    avatarUrl,
    login,
    name: name2,
    ...otherProps
  } = props;
  return (0, import_jsx_runtime92.jsx)(ActionButton, {
    ...otherProps,
    ref,
    "aria-label": "User menu",
    prominence: "low",
    flexGrow: 1,
    UNSAFE_className: css({
      justifyContent: "start",
      textAlign: "start"
    }),
    children: (0, import_jsx_runtime92.jsxs)(Flex, {
      alignItems: "center",
      gap: "regular",
      children: [(0, import_jsx_runtime92.jsx)(Avatar, {
        src: avatarUrl,
        name: name2 !== null && name2 !== void 0 ? name2 : void 0,
        size: "small"
      }), (0, import_jsx_runtime92.jsx)(ClearSlots, {
        children: (0, import_jsx_runtime92.jsxs)(Flex, {
          direction: "column",
          gap: "small",
          children: [(0, import_jsx_runtime92.jsx)(Text2, {
            size: "small",
            weight: "semibold",
            color: "neutralEmphasis",
            children: name2
          }), name2 === login ? null : (0, import_jsx_runtime92.jsx)(Text2, {
            size: "small",
            color: "neutralTertiary",
            children: login
          })]
        })
      })]
    })
  });
});
function GitMenu() {
  var _appShellData$data, _appShellData$data$re;
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  const data = (0, import_react79.useContext)(BranchInfoContext);
  const [newBranchDialogVisible, toggleNewBranchDialog] = (0, import_react79.useReducer)((v6) => !v6, false);
  const [deleteBranchDialogVisible, toggleDeleteBranchDialog] = (0, import_react79.useReducer)((v6) => !v6, false);
  const [, deleteBranch] = useMutation(lib_default2`
      mutation DeleteBranch($refId: ID!) {
        deleteRef(input: { refId: $refId }) {
          __typename
        }
      }
    `);
  const repoURL = getRepoUrl(data);
  const appShellData = (0, import_react79.useContext)(GitHubAppShellDataContext);
  const fork = (appShellData === null || appShellData === void 0 || (_appShellData$data = appShellData.data) === null || _appShellData$data === void 0 ? void 0 : _appShellData$data.repository) && "forks" in appShellData.data.repository && ((_appShellData$data$re = appShellData.data.repository.forks.nodes) === null || _appShellData$data$re === void 0 ? void 0 : _appShellData$data$re[0]);
  const gitMenuItems = (0, import_react79.useMemo)(() => {
    let isDefaultBranch = data.currentBranch === data.defaultBranch;
    let items = [];
    let branchSection = [{
      key: "new-branch",
      icon: gitBranchPlusIcon,
      label: stringFormatter.format("newBranch")
    }];
    let prSection = [];
    let repoSection = [{
      key: "repo",
      icon: githubIcon,
      href: repoURL,
      target: "_blank",
      rel: "noopener noreferrer",
      label: "Github repo"
      // TODO: l10n
    }];
    if (!isDefaultBranch) {
      if (data.pullRequestNumber === void 0) {
        prSection.push({
          key: "create-pull-request",
          icon: gitPullRequestIcon,
          href: `${repoURL}/pull/new/${data.currentBranch}`,
          target: "_blank",
          rel: "noopener noreferrer",
          label: stringFormatter.format("createPullRequest")
        });
      } else {
        prSection.push({
          key: "view-pull-request",
          icon: gitPullRequestIcon,
          href: `${repoURL}/pull/${data.pullRequestNumber}`,
          target: "_blank",
          rel: "noopener noreferrer",
          label: `Pull Request #${data.pullRequestNumber}`
        });
      }
      if (data.pullRequestNumber === void 0) {
        branchSection.push({
          key: "delete-branch",
          icon: trash2Icon,
          label: stringFormatter.format("deleteBranch")
        });
      }
    }
    if (fork) {
      repoSection.push({
        key: "fork",
        icon: gitForkIcon,
        href: `https://github.com/${fork.owner.login}/${fork.name}`,
        target: "_blank",
        rel: "noopener noreferrer",
        label: "View fork"
        // TODO: l10n
      });
    }
    if (branchSection.length) {
      items.push({
        key: "branch-section",
        label: stringFormatter.format("branches"),
        children: branchSection
      });
    }
    if (prSection.length) {
      items.push({
        key: "pr-section",
        label: stringFormatter.format("pullRequests"),
        children: prSection
      });
    }
    if (repoSection.length) {
      items.push({
        key: "repo-section",
        label: "Repository",
        // TODO: l10n
        children: repoSection
      });
    }
    return items;
  }, [fork, data.currentBranch, data.defaultBranch, data.pullRequestNumber, repoURL, stringFormatter]);
  const router = useRouter();
  return (0, import_jsx_runtime92.jsxs)(import_jsx_runtime92.Fragment, {
    children: [(0, import_jsx_runtime92.jsx)(_ActionMenu, {
      "aria-label": "git actions",
      align: "end",
      items: gitMenuItems,
      onAction: (key) => {
        switch (key) {
          case "new-branch":
            toggleNewBranchDialog();
            break;
          case "delete-branch": {
            toggleDeleteBranchDialog();
            break;
          }
        }
      },
      children: (item2) => (0, import_jsx_runtime92.jsx)($9fc4852771d079eb$export$6e2c8f0811a474ce, {
        items: item2.children,
        "aria-label": item2.label,
        children: (item3) => (0, import_jsx_runtime92.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
          textValue: item3.label,
          href: item3.href,
          rel: item3.rel,
          target: item3.target,
          children: [(0, import_jsx_runtime92.jsx)(Icon, {
            src: item3.icon
          }), (0, import_jsx_runtime92.jsx)(Text2, {
            children: item3.label
          })]
        }, item3.key)
      }, item2.key)
    }), (0, import_jsx_runtime92.jsx)(DialogContainer, {
      onDismiss: toggleNewBranchDialog,
      children: newBranchDialogVisible && (0, import_jsx_runtime92.jsx)(CreateBranchDialog, {
        onDismiss: toggleNewBranchDialog,
        onCreate: (branchName) => {
          toggleNewBranchDialog();
          router.push(router.href.replace(/\/branch\/[^/]+/, "/branch/" + encodeURIComponent(branchName)));
        }
      })
    }), (0, import_jsx_runtime92.jsx)(DialogContainer, {
      onDismiss: toggleDeleteBranchDialog,
      children: deleteBranchDialogVisible && (0, import_jsx_runtime92.jsxs)(AlertDialog, {
        title: "Delete branch",
        tone: "critical",
        cancelLabel: "Cancel",
        primaryActionLabel: "Yes, delete",
        autoFocusButton: "cancel",
        onPrimaryAction: async () => {
          await deleteBranch({
            refId: data.branchNameToId.get(data.currentBranch)
          });
          router.push(router.href.replace(/\/branch\/[^/]+/, "/branch/" + encodeURIComponent(data.defaultBranch)));
        },
        children: ['Are you sure you want to delete the "', data.currentBranch, '" branch? This cannot be undone.']
      })
    })]
  });
}
function useUserData() {
  const config3 = useConfig();
  const user = useViewer();
  const rawCloudInfo = useRawCloudInfo();
  if (rawCloudInfo) {
    if (rawCloudInfo === "unauthorized") {
      return rawCloudInfo;
    }
    return {
      avatarUrl: rawCloudInfo.user.avatarUrl,
      login: rawCloudInfo.user.email,
      name: rawCloudInfo.user.name
    };
  }
  if (isGitHubConfig(config3) && user) {
    var _user$name;
    return {
      avatarUrl: user.avatarUrl,
      login: user.login,
      name: (_user$name = user.name) !== null && _user$name !== void 0 ? _user$name : user.login
    };
  }
  return void 0;
}
var SidebarContext = (0, import_react79.createContext)(null);
function useSidebar() {
  let context = (0, import_react79.useContext)(SidebarContext);
  if (!context) {
    throw new Error("useSidebar must be within a SidebarProvider");
  }
  return context;
}
var breakpointNames2 = typedKeys(breakpoints);
function SidebarProvider(props) {
  const matchedBreakpoints = useBreakpoint();
  const state = $fc909762b330b746$export$61c6a8c84e605fb6({
    defaultOpen: matchedBreakpoints.includes("desktop")
  });
  let breakpointIndex = breakpointNames2.indexOf(matchedBreakpoints[0]);
  let previousIndex = usePrevious(breakpointIndex) || 0;
  $4f58c5f72bcf79f7$export$496315a1608d9602(() => {
    let larger = previousIndex < breakpointIndex;
    if (larger && breakpointIndex >= 2) {
      state.open();
    } else if (breakpointIndex < 2) {
      state.close();
    }
  }, [matchedBreakpoints]);
  return (0, import_jsx_runtime92.jsx)(SidebarContext.Provider, {
    value: state,
    children: props.children
  });
}
function SidebarPanel() {
  return (0, import_jsx_runtime92.jsxs)(VStack, {
    backgroundColor: "surface",
    height: "100%",
    children: [(0, import_jsx_runtime92.jsx)(SidebarHeader, {}), (0, import_jsx_runtime92.jsx)(SidebarGitActions, {}), (0, import_jsx_runtime92.jsx)(SidebarNav, {}), (0, import_jsx_runtime92.jsx)(SidebarFooter, {})]
  });
}
function SidebarHeader() {
  let isLocalNoCloud = useIsLocalNoCloud();
  let {
    brandMark,
    brandName
  } = useBrand();
  return (0, import_jsx_runtime92.jsxs)(HStack, {
    alignItems: "center",
    gap: "regular",
    paddingY: "regular",
    paddingX: "medium",
    height: {
      mobile: "element.large",
      tablet: "element.xlarge"
    },
    children: [(0, import_jsx_runtime92.jsxs)(HStack, {
      flex: true,
      alignItems: "center",
      gap: "regular",
      UNSAFE_className: css({
        // let consumers use "currentColor" in SVG for their brand mark
        color: tokenSchema.color.foreground.neutralEmphasis,
        // ensure that the brand mark doesn't get squashed
        "& :first-child": {
          flexShrink: 0
        }
      }),
      children: [brandMark, (0, import_jsx_runtime92.jsx)(Text2, {
        color: "inherit",
        weight: "medium",
        truncate: true,
        children: brandName
      })]
    }), isLocalNoCloud && (0, import_jsx_runtime92.jsx)(ThemeMenu, {})]
  });
}
function SidebarFooter() {
  let isLocalNoCloud = useIsLocalNoCloud();
  if (isLocalNoCloud) {
    return null;
  }
  return (0, import_jsx_runtime92.jsxs)(HStack, {
    alignItems: "center",
    paddingY: "regular",
    paddingX: "medium",
    gap: "regular",
    children: [(0, import_jsx_runtime92.jsx)(UserActions, {}), (0, import_jsx_runtime92.jsx)(ThemeMenu, {})]
  });
}
function SidebarGitActions() {
  let config3 = useConfig();
  if (isLocalConfig(config3)) {
    return null;
  }
  return (0, import_jsx_runtime92.jsxs)(HStack, {
    gap: "regular",
    paddingY: "regular",
    paddingX: "medium",
    children: [(0, import_jsx_runtime92.jsx)(BranchPicker, {}), (0, import_jsx_runtime92.jsx)(GitMenu, {})]
  });
}
function SidebarDialog() {
  const state = useSidebar();
  const router = useRouter();
  $4f58c5f72bcf79f7$export$496315a1608d9602(() => {
    state.close();
  }, [router.href]);
  let dialogRef = (0, import_react79.useRef)(null);
  let {
    modalProps,
    underlayProps
  } = $8ac8429251c45e4b$export$dbc0f175b25fb0fb({
    isDismissable: true
  }, state, dialogRef);
  return (0, import_jsx_runtime92.jsxs)(import_jsx_runtime92.Fragment, {
    children: [(0, import_jsx_runtime92.jsx)(Blanket, {
      ...underlayProps,
      isOpen: state.isOpen,
      zIndex: 10
    }), (0, import_jsx_runtime92.jsxs)("div", {
      "data-visible": state.isOpen,
      id: SIDE_PANEL_ID,
      ref: dialogRef,
      ...modalProps,
      // styles
      className: css({
        backgroundColor: tokenSchema.color.background.surface,
        boxShadow: `${tokenSchema.size.shadow.large} ${tokenSchema.color.shadow.regular}`,
        display: "flex",
        flexDirection: "column",
        inset: 0,
        insetInlineEnd: "auto",
        // ensure that there's always enough of gutter for the user to press
        // and exit the sidebar
        maxWidth: `calc(100% - ${tokenSchema.size.element.medium})`,
        minWidth: tokenSchema.size.scale[3e3],
        outline: 0,
        pointerEvents: "none",
        position: "fixed",
        transform: "translateX(-100%)",
        visibility: "hidden",
        zIndex: 10,
        // exit animation
        transition: [transition("transform", {
          easing: "easeIn",
          duration: "short"
          // delay: 'short',
        }), transition("visibility", {
          delay: "regular",
          duration: 0,
          easing: "linear"
        })].join(", "),
        "&[data-visible=true]": {
          transform: "translateX(0)",
          // enter animation
          transition: transition("transform", {
            easing: "easeOut"
          }),
          pointerEvents: "auto",
          visibility: "visible"
        }
      }),
      children: [(0, import_jsx_runtime92.jsx)(SidebarHeader, {}), (0, import_jsx_runtime92.jsx)(SidebarGitActions, {}), (0, import_jsx_runtime92.jsx)(SidebarNav, {}), (0, import_jsx_runtime92.jsx)(SidebarFooter, {}), (0, import_jsx_runtime92.jsx)($86ea4cb521eb2e37$export$2317d149ed6f78c4, {
        onDismiss: state.close
      })]
    })]
  });
}
function SidebarNav() {
  const {
    basePath
  } = useAppState();
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  const navItems = useNavItems();
  const isCurrent = useIsCurrent();
  return (0, import_jsx_runtime92.jsx)(ScrollView, {
    flex: true,
    paddingY: "large",
    paddingEnd: "medium",
    children: (0, import_jsx_runtime92.jsxs)(NavList, {
      children: [(0, import_jsx_runtime92.jsx)(NavItem, {
        href: basePath,
        "aria-current": isCurrent(basePath, {
          exact: true
        }),
        children: stringFormatter.format("dashboard")
      }), navItems.map((item2) => renderItemOrGroup(item2, isCurrent))]
    })
  });
}
function useIsLocalNoCloud() {
  const config3 = useConfig();
  return isLocalConfig(config3) && !config3.cloud;
}
function useIsCurrent() {
  const router = useRouter();
  return (0, import_react79.useCallback)((href, {
    exact = false
  } = {}) => {
    if (exact) {
      return href === router.href ? "page" : void 0;
    }
    return href === router.href || router.href.startsWith(`${href}/`) ? "page" : void 0;
  }, [router.href]);
}
var dividerCount = 0;
function renderItemOrGroup(itemOrGroup, isCurrent) {
  if ("isDivider" in itemOrGroup) {
    return (0, import_jsx_runtime92.jsx)(Divider, {}, dividerCount++);
  }
  if ("children" in itemOrGroup) {
    return (0, import_jsx_runtime92.jsx)(NavGroup, {
      title: itemOrGroup.title,
      children: itemOrGroup.children.map((child) => renderItemOrGroup(child, isCurrent))
    }, itemOrGroup.title);
  }
  let changeElement = (() => {
    if (!itemOrGroup.changed) {
      return null;
    }
    return typeof itemOrGroup.changed === "number" ? (0, import_jsx_runtime92.jsxs)(Badge, {
      tone: "accent",
      marginStart: "auto",
      children: [(0, import_jsx_runtime92.jsx)(Text2, {
        children: itemOrGroup.changed
      }), (0, import_jsx_runtime92.jsx)(Text2, {
        visuallyHidden: true,
        children: pluralize(itemOrGroup.changed, {
          singular: "change",
          plural: "changes",
          inclusive: false
        })
      })]
    }) : (0, import_jsx_runtime92.jsx)(StatusLight, {
      tone: "accent",
      marginStart: "auto",
      "aria-label": "Changed",
      role: "status"
    });
  })();
  return (0, import_jsx_runtime92.jsxs)(NavItem, {
    href: itemOrGroup.href,
    "aria-current": isCurrent(itemOrGroup.href),
    children: [(0, import_jsx_runtime92.jsx)(Text2, {
      truncate: true,
      title: itemOrGroup.label,
      children: itemOrGroup.label
    }), changeElement]
  }, itemOrGroup.key);
}
var PageContext = (0, import_react79.createContext)({
  containerWidth: "medium"
});
var PageRoot = ({
  children,
  containerWidth = "medium"
}) => {
  return (0, import_jsx_runtime92.jsx)(PageContext.Provider, {
    value: {
      containerWidth
    },
    children: (0, import_jsx_runtime92.jsx)(Flex, {
      elementType: "main",
      direction: "column",
      id: MAIN_PANEL_ID,
      flex: true,
      height: "100%",
      minHeight: 0,
      minWidth: 0,
      children
    })
  });
};
var PageHeader = ({
  children
}) => {
  const sidebarState = useSidebar();
  const menuButtonRef = (0, import_react79.useRef)(null);
  const {
    direction
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let icon = sidebarState.isOpen ? panelLeftCloseIcon : panelLeftOpenIcon;
  if (direction === "rtl") {
    icon = sidebarState.isOpen ? panelRightCloseIcon : panelRightOpenIcon;
  }
  return (0, import_jsx_runtime92.jsx)(Box, {
    borderBottom: "muted",
    elementType: "header",
    height: {
      mobile: "element.large",
      tablet: "element.xlarge"
    },
    flexShrink: 0,
    children: (0, import_jsx_runtime92.jsx)(Box, {
      minHeight: 0,
      minWidth: 0,
      paddingX: {
        mobile: "medium",
        tablet: "xlarge",
        desktop: "xxlarge"
      },
      children: (0, import_jsx_runtime92.jsxs)(Flex, {
        alignItems: "center",
        gap: {
          mobile: "small",
          tablet: "regular"
        },
        height: {
          mobile: "element.large",
          tablet: "element.xlarge"
        },
        children: [(0, import_jsx_runtime92.jsx)(ActionButton, {
          prominence: "low",
          "aria-label": "Open app navigation",
          "aria-pressed": sidebarState.isOpen,
          isHidden: sidebarState.isOpen ? {
            above: "tablet"
          } : void 0,
          onPress: sidebarState.toggle,
          ref: menuButtonRef,
          UNSAFE_className: css({
            marginInlineStart: `calc(${tokenSchema.size.space.regular} * -1)`
          }),
          children: (0, import_jsx_runtime92.jsx)(Icon, {
            src: icon
          })
        }), children]
      })
    })
  });
};
var PageBody = ({
  children,
  isScrollable
}) => {
  return (0, import_jsx_runtime92.jsx)(ScrollView3, {
    isDisabled: !isScrollable,
    children: (0, import_jsx_runtime92.jsx)(
      PageContainer,
      {
        paddingY: "xxlarge",
        children
      }
    )
  });
};
var PageContainer = (props) => {
  const {
    containerWidth
  } = (0, import_react79.useContext)(PageContext);
  const maxWidth = containerWidth === "none" ? void 0 : `container.${containerWidth}`;
  return (0, import_jsx_runtime92.jsx)(Box, {
    minHeight: 0,
    minWidth: 0,
    maxWidth,
    paddingX: {
      mobile: "medium",
      tablet: "xlarge",
      desktop: "xxlarge"
    },
    ...props
  });
};
var FieldDataError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "FieldDataError";
  }
};
function assertRequired(value2, validation, label) {
  if (value2 === null && validation !== null && validation !== void 0 && validation.isRequired) {
    throw new FieldDataError(`${label} is required`);
  }
}
function basicFormFieldWithSimpleReaderParse(config3) {
  return {
    kind: "form",
    Input: config3.Input,
    defaultValue: config3.defaultValue,
    parse: config3.parse,
    serialize: config3.serialize,
    validate: config3.validate,
    reader: {
      parse(value2) {
        return config3.validate(config3.parse(value2));
      }
    },
    label: config3.label
  };
}
var arrayValuesToElementKeys = /* @__PURE__ */ new WeakMap();
var counter = 0;
function getKeysForArrayValue(value2) {
  if (!arrayValuesToElementKeys.has(value2)) {
    arrayValuesToElementKeys.set(value2, Array.from({
      length: value2.length
    }, getNewArrayElementKey));
  }
  return arrayValuesToElementKeys.get(value2);
}
function setKeysForArrayValue(value2, elementIds) {
  arrayValuesToElementKeys.set(value2, elementIds);
}
function getNewArrayElementKey() {
  return (counter++).toString();
}
var getInitialPropsValue = _getInitialPropsValue;
function _getInitialPropsValue(schema) {
  switch (schema.kind) {
    case "form":
      return schema.defaultValue();
    case "child":
      return schema.options.kind === "block" ? [{
        type: "paragraph",
        children: [{
          text: ""
        }]
      }] : null;
    case "conditional": {
      const defaultValue = schema.discriminant.defaultValue();
      return {
        discriminant: defaultValue,
        value: getInitialPropsValue(schema.values[defaultValue.toString()])
      };
    }
    case "object": {
      const obj = {};
      for (const key of Object.keys(schema.fields)) {
        obj[key] = getInitialPropsValue(schema.fields[key]);
      }
      return obj;
    }
    case "array": {
      return [];
    }
  }
  assertNever(schema);
}
function getInitialPropsValueFromInitializer(schema, initializer) {
  switch (schema.kind) {
    case "form":
      return initializer === void 0 ? schema.defaultValue() : initializer;
    case "child":
      return initializer !== null && initializer !== void 0 ? initializer : schema.options.kind === "block" ? [{
        type: "paragraph",
        children: [{
          text: ""
        }]
      }] : null;
    case "conditional": {
      const defaultValue = initializer === void 0 ? schema.discriminant.defaultValue() : initializer.discriminant;
      if (defaultValue === void 0) {
        debugger;
      }
      return {
        discriminant: defaultValue,
        value: getInitialPropsValueFromInitializer(schema.values[defaultValue.toString()], initializer === void 0 ? void 0 : initializer.value)
      };
    }
    case "object": {
      const obj = {};
      for (const key of Object.keys(schema.fields)) {
        obj[key] = getInitialPropsValueFromInitializer(schema.fields[key], initializer === void 0 ? void 0 : initializer[key]);
      }
      return obj;
    }
    case "array": {
      return (initializer !== null && initializer !== void 0 ? initializer : []).map((x4) => getInitialPropsValueFromInitializer(schema.element, x4.value));
    }
  }
  assertNever(schema);
}
function updateValue(schema, currentValue, updater) {
  if (updater === void 0)
    return currentValue;
  switch (schema.kind) {
    case "form":
      return updater;
    case "child":
      return updater;
    case "conditional": {
      return {
        discriminant: updater.discriminant,
        value: updater.discriminant === currentValue.discriminant ? updateValue(schema.values[updater.discriminant.toString()], currentValue.value, updater.value) : getInitialPropsValueFromInitializer(schema.values[updater.discriminant.toString()], updater.value)
      };
    }
    case "object": {
      const obj = {};
      for (const key of Object.keys(schema.fields)) {
        obj[key] = updateValue(schema.fields[key], currentValue[key], updater[key]);
      }
      return obj;
    }
    case "array": {
      const currentArrVal = currentValue;
      const newVal = updater;
      const uniqueKeys = /* @__PURE__ */ new Set();
      for (const x4 of newVal) {
        if (x4.key !== void 0) {
          if (uniqueKeys.has(x4.key)) {
            throw new Error("Array elements must have unique keys");
          }
          uniqueKeys.add(x4.key);
        }
      }
      const keys3 = newVal.map((x4) => {
        if (x4.key !== void 0)
          return x4.key;
        let elementKey = getNewArrayElementKey();
        while (uniqueKeys.has(elementKey)) {
          elementKey = getNewArrayElementKey();
        }
        uniqueKeys.add(elementKey);
        return elementKey;
      });
      const prevKeys = getKeysForArrayValue(currentArrVal);
      const prevValuesByKey = new Map(currentArrVal.map((value2, i6) => {
        return [prevKeys[i6], value2];
      }));
      const val = newVal.map((x4, i6) => {
        const id2 = keys3[i6];
        if (prevValuesByKey.has(id2)) {
          return updateValue(schema.element, prevValuesByKey.get(id2), x4.value);
        }
        return getInitialPropsValueFromInitializer(schema.element, x4.value);
      });
      setKeysForArrayValue(val, keys3);
      return val;
    }
  }
  assertNever(schema);
}
function getValueAtPropPath(value2, inputPath) {
  const path3 = [...inputPath];
  while (path3.length) {
    const key = path3.shift();
    value2 = value2[key];
  }
  return value2;
}
function traverseProps(schema, value2, visitor, path3 = []) {
  if (schema.kind === "form" || schema.kind === "child") {
    visitor(schema, value2, path3);
    return;
  }
  if (schema.kind === "object") {
    for (const [key, childProp] of Object.entries(schema.fields)) {
      traverseProps(childProp, value2[key], visitor, [...path3, key]);
    }
    visitor(schema, value2, path3);
    return;
  }
  if (schema.kind === "array") {
    for (const [idx, val] of value2.entries()) {
      traverseProps(schema.element, val, visitor, path3.concat(idx));
    }
    return visitor(schema, value2, path3);
  }
  if (schema.kind === "conditional") {
    const discriminant = value2.discriminant;
    visitor(schema, discriminant, path3.concat("discriminant"));
    traverseProps(schema.values[discriminant.toString()], value2.value, visitor, path3.concat("value"));
    visitor(schema, value2, path3);
    return;
  }
  assertNever(schema);
}
function transformProps(schema, value2, visitors, path3 = []) {
  if (schema.kind === "form" || schema.kind === "child") {
    if (visitors[schema.kind]) {
      return visitors[schema.kind](schema, value2, path3);
    }
    return value2;
  }
  if (schema.kind === "object") {
    const val = Object.fromEntries(Object.entries(schema.fields).map(([key, val2]) => {
      return [key, transformProps(val2, value2[key], visitors, [...path3, key])];
    }));
    if (visitors.object) {
      return visitors[schema.kind](schema, val, path3);
    }
    return val;
  }
  if (schema.kind === "array") {
    const val = value2.map((val2, idx) => transformProps(schema.element, val2, visitors, path3.concat(idx)));
    if (visitors.array) {
      return visitors[schema.kind](schema, val, path3);
    }
    return val;
  }
  if (schema.kind === "conditional") {
    const discriminant = transformProps(schema.discriminant, value2.discriminant, visitors, path3.concat("discriminant"));
    const conditionalVal = transformProps(schema.values[discriminant.toString()], value2.value, visitors, path3.concat("value"));
    const val = {
      discriminant,
      value: conditionalVal
    };
    if (visitors.conditional) {
      return visitors[schema.kind](schema, val, path3);
    }
    return val;
  }
  assertNever(schema);
}
function replaceValueAtPropPath(schema, value2, newValue, path3) {
  if (path3.length === 0) {
    return newValue;
  }
  const [key, ...newPath] = path3;
  if (schema.kind === "object") {
    return {
      ...value2,
      [key]: replaceValueAtPropPath(schema.fields[key], value2[key], newValue, newPath)
    };
  }
  if (schema.kind === "conditional") {
    const conditionalValue = value2;
    assert(key === "value");
    return {
      discriminant: conditionalValue.discriminant,
      value: replaceValueAtPropPath(schema.values[key], conditionalValue.value, newValue, newPath)
    };
  }
  if (schema.kind === "array") {
    const prevVal = value2;
    const newVal = [...prevVal];
    setKeysForArrayValue(newVal, getKeysForArrayValue(prevVal));
    newVal[key] = replaceValueAtPropPath(schema.element, newVal[key], newValue, newPath);
    return newVal;
  }
  assert(schema.kind !== "form" && schema.kind !== "child");
  assertNever(schema);
}
function getYjsValFromParsedValue(schema, value2) {
  if (schema.kind === "form") {
    if (schema.formKind === "content" && schema.collaboration) {
      return schema.collaboration.toYjs(value2);
    }
    return value2;
  }
  if (schema.kind === "child") {
    return null;
  }
  if (schema.kind === "object") {
    return new YMap(Object.entries(schema.fields).map(([key, val]) => [key, getYjsValFromParsedValue(val, value2[key])]));
  }
  if (schema.kind === "array") {
    const arr = new YArray();
    arr.push(value2.map((val) => getYjsValFromParsedValue(schema.element, val)));
    return arr;
  }
  if (schema.kind === "conditional") {
    const discriminant = value2.discriminant;
    return new YMap([["discriminant", discriminant], ["value", getYjsValFromParsedValue(schema.values[discriminant + ""], value2.value)]]);
  }
  assertNever(schema);
}
function yjsToVal(schema, awareness, yjsValue) {
  if (schema.kind === "form") {
    if (schema.formKind === "content" && schema.collaboration) {
      return schema.collaboration.fromYjs(yjsValue, awareness);
    }
    return yjsValue;
  }
  if (schema.kind === "child") {
    return null;
  }
  if (schema.kind === "object") {
    return Object.fromEntries(Object.entries(schema.fields).map(([key, val]) => [key, yjsToVal(val, awareness, yjsValue.get(key))]));
  }
  if (schema.kind === "array") {
    const yArr = yjsValue;
    if (!yArr) {
      debugger;
    }
    const val = yArr.map((val2) => yjsToVal(schema.element, awareness, val2));
    setKeysForArrayValue(val, getKeysForArrayValue(yArr));
    return val;
  }
  if (schema.kind === "conditional") {
    const yjsMap = yjsValue;
    return {
      discriminant: yjsToVal(schema.discriminant, awareness, yjsMap.get("discriminant")),
      value: yjsToVal(schema.values[yjsMap.get("discriminant") + ""], awareness, yjsMap.get("value"))
    };
  }
}
function parsedValToYjs(schema, value2) {
  if (schema.kind === "form" || schema.kind === "child") {
    return value2;
  }
  if (schema.kind === "object") {
    return new YMap(Object.entries(schema.fields).map(([key, val]) => [key, parsedValToYjs(val, value2[key])]));
  }
  if (schema.kind === "array") {
    const arr = new YArray();
    arr.push(value2.map((val) => parsedValToYjs(schema.element, val)));
    return arr;
  }
  if (schema.kind === "conditional") {
    const discriminant = value2.discriminant;
    return new YMap([["discriminant", discriminant], ["value", parsedValToYjs(schema.values[discriminant.toString()], value2.value)]]);
  }
}
var currentlyActiveMarks = /* @__PURE__ */ new Set();
var currentlyDisabledMarks = /* @__PURE__ */ new Set();
var currentLink = null;
function addMarkToChildren(mark, cb) {
  const wasPreviouslyActive = currentlyActiveMarks.has(mark);
  currentlyActiveMarks.add(mark);
  try {
    return cb();
  } finally {
    if (!wasPreviouslyActive) {
      currentlyActiveMarks.delete(mark);
    }
  }
}
function setLinkForChildren(href, cb) {
  if (currentLink !== null) {
    return cb();
  }
  currentLink = href;
  try {
    return cb();
  } finally {
    currentLink = null;
  }
}
function addMarksToChildren(marks, cb) {
  const marksToRemove = /* @__PURE__ */ new Set();
  for (const mark of marks) {
    if (!currentlyActiveMarks.has(mark)) {
      marksToRemove.add(mark);
    }
    currentlyActiveMarks.add(mark);
  }
  try {
    return cb();
  } finally {
    for (const mark of marksToRemove) {
      currentlyActiveMarks.delete(mark);
    }
  }
}
function forceDisableMarkForChildren(mark, cb) {
  const wasPreviouslyDisabled = currentlyDisabledMarks.has(mark);
  currentlyDisabledMarks.add(mark);
  try {
    return cb();
  } finally {
    if (!wasPreviouslyDisabled) {
      currentlyDisabledMarks.delete(mark);
    }
  }
}
function getInlineNodes(text7) {
  const node4 = {
    text: text7
  };
  for (const mark of currentlyActiveMarks) {
    if (!currentlyDisabledMarks.has(mark)) {
      node4[mark] = true;
    }
  }
  if (currentLink !== null) {
    return [{
      text: ""
    }, {
      type: "link",
      href: currentLink,
      children: [node4]
    }, {
      text: ""
    }];
  }
  return [node4];
}
var VariableChildFields = class extends Error {
  constructor() {
    super("There are a variable number of child fields");
  }
};
function findSingleChildField(schema) {
  try {
    const result = _findConstantChildFields(schema, [], /* @__PURE__ */ new Set());
    if (result.length === 1) {
      return result[0];
    }
    return;
  } catch (err) {
    if (err instanceof VariableChildFields) {
      return;
    }
    throw err;
  }
}
function _findConstantChildFields(schema, path3, seenSchemas) {
  if (seenSchemas.has(schema)) {
    return [];
  }
  seenSchemas.add(schema);
  switch (schema.kind) {
    case "form":
      return [];
    case "child":
      return [{
        relativePath: path3,
        options: schema.options,
        kind: "child"
      }];
    case "conditional": {
      if (couldContainChildField(schema)) {
        throw new VariableChildFields();
      }
      return [];
    }
    case "array": {
      if (schema.asChildTag) {
        const child = _findConstantChildFields(schema.element, [], seenSchemas);
        if (child.length > 1) {
          return [];
        }
        return [{
          kind: "array",
          asChildTag: schema.asChildTag,
          field: schema,
          relativePath: path3,
          child: child[0]
        }];
      }
      if (couldContainChildField(schema)) {
        throw new VariableChildFields();
      }
      return [];
    }
    case "object": {
      const paths = [];
      for (const [key, value2] of Object.entries(schema.fields)) {
        paths.push(..._findConstantChildFields(value2, path3.concat(key), seenSchemas));
      }
      return paths;
    }
  }
}
function couldContainChildField(schema, seen = /* @__PURE__ */ new Set()) {
  if (seen.has(schema)) {
    return false;
  }
  seen.add(schema);
  switch (schema.kind) {
    case "form":
      return false;
    case "child":
      return true;
    case "conditional":
      return Object.values(schema.values).some((value2) => couldContainChildField(value2, seen));
    case "object":
      return Object.keys(schema.fields).some((key) => couldContainChildField(schema.fields[key], seen));
    case "array":
      return couldContainChildField(schema.element, seen);
  }
}
function inlineNodeFromMarkdoc(node4) {
  if (node4.type === "inline") {
    return inlineChildrenFromMarkdoc(node4.children);
  }
  if (node4.type === "link") {
    return setLinkForChildren(node4.attributes.href, () => inlineChildrenFromMarkdoc(node4.children));
  }
  if (node4.type === "text") {
    return getInlineNodes(node4.attributes.content);
  }
  if (node4.type === "strong") {
    return addMarkToChildren("bold", () => inlineChildrenFromMarkdoc(node4.children));
  }
  if (node4.type === "code") {
    return addMarkToChildren("code", () => getInlineNodes(node4.attributes.content));
  }
  if (node4.type === "em") {
    return addMarkToChildren("italic", () => inlineChildrenFromMarkdoc(node4.children));
  }
  if (node4.type === "s") {
    return addMarkToChildren("strikethrough", () => inlineChildrenFromMarkdoc(node4.children));
  }
  if (node4.type === "tag") {
    if (node4.tag === "u") {
      return addMarkToChildren("underline", () => inlineChildrenFromMarkdoc(node4.children));
    }
    if (node4.tag === "kbd") {
      return addMarkToChildren("keyboard", () => inlineChildrenFromMarkdoc(node4.children));
    }
    if (node4.tag === "sub") {
      return addMarkToChildren("subscript", () => inlineChildrenFromMarkdoc(node4.children));
    }
    if (node4.tag === "sup") {
      return addMarkToChildren("superscript", () => inlineChildrenFromMarkdoc(node4.children));
    }
  }
  if (node4.type === "softbreak") {
    return getInlineNodes(" ");
  }
  if (node4.type === "hardbreak") {
    return getInlineNodes("\n");
  }
  if (node4.tag === "component-inline-prop" && Array.isArray(node4.attributes.propPath) && node4.attributes.propPath.every((x4) => typeof x4 === "string" || typeof x4 === "number")) {
    return {
      type: "component-inline-prop",
      children: inlineFromMarkdoc(node4.children),
      propPath: node4.attributes.propPath
    };
  }
  throw new Error(`Unknown inline node type: ${node4.type}`);
}
function inlineChildrenFromMarkdoc(nodes) {
  return nodes.flatMap(inlineNodeFromMarkdoc);
}
function inlineFromMarkdoc(nodes) {
  const transformedNodes = nodes.flatMap(inlineNodeFromMarkdoc);
  const nextNodes = [];
  let lastNode;
  for (const [idx, node4] of transformedNodes.entries()) {
    var _lastNode;
    if (node4.type === void 0 && node4.text === "" && ((_lastNode = lastNode) === null || _lastNode === void 0 ? void 0 : _lastNode.type) === void 0 && idx !== transformedNodes.length - 1) {
      continue;
    }
    nextNodes.push(node4);
    lastNode = node4;
  }
  if (!nextNodes.length) {
    nextNodes.push({
      text: ""
    });
  }
  return nextNodes;
}
function fromMarkdoc(node4, componentBlocks) {
  const nodes = node4.children.flatMap((x4) => fromMarkdocNode(x4, componentBlocks));
  if (nodes.length === 0) {
    return [{
      type: "paragraph",
      children: [{
        text: ""
      }]
    }];
  }
  if (nodes[nodes.length - 1].type !== "paragraph") {
    nodes.push({
      type: "paragraph",
      children: [{
        text: ""
      }]
    });
  }
  return nodes;
}
function fromMarkdocNode(node4, componentBlocks) {
  if (node4.type === "blockquote") {
    return {
      type: "blockquote",
      children: node4.children.flatMap((x4) => fromMarkdocNode(x4, componentBlocks))
    };
  }
  if (node4.type === "fence") {
    const {
      language,
      content: content3,
      ...rest
    } = node4.attributes;
    return {
      type: "code",
      children: [{
        text: content3.replace(/\n$/, "")
      }],
      ...typeof language === "string" ? {
        language
      } : {},
      ...rest
    };
  }
  if (node4.type === "heading") {
    return {
      ...node4.attributes,
      level: node4.attributes.level,
      type: "heading",
      children: inlineFromMarkdoc(node4.children)
    };
  }
  if (node4.type === "list") {
    return {
      type: node4.attributes.ordered ? "ordered-list" : "unordered-list",
      children: node4.children.flatMap((x4) => fromMarkdocNode(x4, componentBlocks))
    };
  }
  if (node4.type === "item") {
    var _node$children$;
    const children = [{
      type: "list-item-content",
      children: node4.children.length ? inlineFromMarkdoc([node4.children[0]]) : [{
        text: ""
      }]
    }];
    if (((_node$children$ = node4.children[1]) === null || _node$children$ === void 0 ? void 0 : _node$children$.type) === "list") {
      const list3 = node4.children[1];
      children.push({
        type: list3.attributes.ordered ? "ordered-list" : "unordered-list",
        children: list3.children.flatMap((x4) => fromMarkdocNode(x4, componentBlocks))
      });
    }
    return {
      type: "list-item",
      children
    };
  }
  if (node4.type === "paragraph") {
    if (node4.children.length === 1 && node4.children[0].type === "inline" && node4.children[0].children.length === 1 && node4.children[0].children[0].type === "image") {
      var _image$attributes$tit;
      const image2 = node4.children[0].children[0];
      return {
        type: "image",
        src: decodeURI(image2.attributes.src),
        alt: image2.attributes.alt,
        title: (_image$attributes$tit = image2.attributes.title) !== null && _image$attributes$tit !== void 0 ? _image$attributes$tit : "",
        children: [{
          text: ""
        }]
      };
    }
    const children = inlineFromMarkdoc(node4.children);
    if (children.length === 1 && children[0].type === "component-inline-prop") {
      return children[0];
    }
    return {
      type: "paragraph",
      children,
      textAlign: node4.attributes.textAlign
    };
  }
  if (node4.type === "hr") {
    return {
      type: "divider",
      children: [{
        text: ""
      }]
    };
  }
  if (node4.type === "table") {
    return {
      type: "table",
      children: node4.children.flatMap((x4) => fromMarkdocNode(x4, componentBlocks))
    };
  }
  if (node4.type === "tbody") {
    return {
      type: "table-body",
      children: node4.children.flatMap((x4) => fromMarkdocNode(x4, componentBlocks))
    };
  }
  if (node4.type === "thead") {
    if (!node4.children.length)
      return [];
    return {
      type: "table-head",
      children: node4.children.flatMap((x4) => fromMarkdocNode(x4, componentBlocks))
    };
  }
  if (node4.type === "tr") {
    return {
      type: "table-row",
      children: node4.children.flatMap((x4) => fromMarkdocNode(x4, componentBlocks))
    };
  }
  if (node4.type === "td") {
    return {
      type: "table-cell",
      children: node4.children.flatMap((x4) => fromMarkdocNode(x4, componentBlocks))
    };
  }
  if (node4.type === "th") {
    return {
      type: "table-cell",
      header: true,
      children: node4.children.flatMap((x4) => fromMarkdocNode(x4, componentBlocks))
    };
  }
  if (node4.type === "tag") {
    if (node4.tag === "table") {
      return fromMarkdocNode(node4.children[0], componentBlocks);
    }
    if (node4.tag === "layout") {
      return {
        type: "layout",
        layout: node4.attributes.layout,
        children: node4.children.flatMap((x4) => fromMarkdocNode(x4, componentBlocks))
      };
    }
    if (node4.tag === "layout-area") {
      return {
        type: "layout-area",
        children: node4.children.flatMap((x4) => fromMarkdocNode(x4, componentBlocks))
      };
    }
    if (node4.tag === "component-block") {
      return {
        type: "component-block",
        component: node4.attributes.component,
        props: node4.attributes.props,
        children: node4.children.length === 0 ? [{
          type: "component-inline-prop",
          children: [{
            text: ""
          }]
        }] : node4.children.flatMap((x4) => fromMarkdocNode(x4, componentBlocks))
      };
    }
    if (node4.tag === "component-block-prop" && Array.isArray(node4.attributes.propPath) && node4.attributes.propPath.every((x4) => typeof x4 === "string" || typeof x4 === "number")) {
      return {
        type: "component-block-prop",
        children: node4.children.flatMap((x4) => fromMarkdocNode(x4, componentBlocks)),
        propPath: node4.attributes.propPath
      };
    }
    if (node4.tag) {
      const componentBlock = componentBlocks[node4.tag];
      if (componentBlock) {
        const singleChildField = findSingleChildField({
          kind: "object",
          fields: componentBlock.schema
        });
        if (singleChildField) {
          const newAttributes = JSON.parse(JSON.stringify(node4.attributes));
          const children = [];
          toChildrenAndProps$1(node4.children, children, newAttributes, singleChildField, [], componentBlocks);
          return {
            type: "component-block",
            component: node4.tag,
            props: newAttributes,
            children
          };
        }
        return {
          type: "component-block",
          component: node4.tag,
          props: node4.attributes,
          children: node4.children.length === 0 ? [{
            type: "component-inline-prop",
            children: [{
              text: ""
            }]
          }] : node4.children.flatMap((x4) => fromMarkdocNode(x4, componentBlocks))
        };
      }
    }
    throw new Error(`Unknown tag: ${node4.tag}`);
  }
  return inlineNodeFromMarkdoc(node4);
}
function toChildrenAndProps$1(fromMarkdoc2, resultingChildren, value2, singleChildField, parentPropPath, componentBlocks) {
  if (singleChildField.kind === "child") {
    const children = fromMarkdoc2.flatMap((x4) => fromMarkdocNode(x4, componentBlocks));
    resultingChildren.push({
      type: `component-${singleChildField.options.kind}-prop`,
      propPath: [...parentPropPath, ...singleChildField.relativePath],
      children
    });
  }
  if (singleChildField.kind === "array") {
    const arr = [];
    for (let [idx, child] of fromMarkdoc2.entries()) {
      if (child.type === "paragraph") {
        child = child.children[0].children[0];
      }
      if (child.type !== "tag") {
        throw new Error(`expected tag ${singleChildField.asChildTag}, found type: ${child.type}`);
      }
      if (child.tag !== singleChildField.asChildTag) {
        throw new Error(`expected tag ${singleChildField.asChildTag}, found tag: ${child.tag}`);
      }
      const attributes = JSON.parse(JSON.stringify(child.attributes));
      if (singleChildField.child) {
        toChildrenAndProps$1(child.children, resultingChildren, attributes, singleChildField.child, [...parentPropPath, ...singleChildField.relativePath, idx], componentBlocks);
      }
      arr.push(attributes);
    }
    const key = singleChildField.relativePath[singleChildField.relativePath.length - 1];
    const parent = getValueAtPropPath(value2, singleChildField.relativePath.slice(0, -1));
    parent[key] = arr;
  }
}
function areArraysEqual(a3, b2) {
  return a3.length === b2.length && a3.every((x4, i6) => x4 === b2[i6]);
}
function normalizeTextBasedOnInlineMarksAndSoftBreaks([node4, path3], editor, inlineMarks2, softBreaks) {
  const marksToRemove = Object.keys(node4).filter((x4) => x4 !== "text" && x4 !== "insertMenu" && inlineMarks2[x4] !== true);
  if (marksToRemove.length) {
    Transforms.unsetNodes(editor, marksToRemove, {
      at: path3
    });
    return true;
  }
  if (!softBreaks) {
    const hasSoftBreaks = node4.text.includes("\n");
    if (hasSoftBreaks) {
      const [parentNode] = Editor.parent(editor, path3);
      if (parentNode.type !== "code") {
        for (const position3 of Editor.positions(editor, {
          at: path3
        })) {
          const character2 = Node3.get(editor, position3.path).text[position3.offset];
          if (character2 === "\n") {
            Transforms.delete(editor, {
              at: position3
            });
            return true;
          }
        }
      }
    }
  }
  return false;
}
function normalizeInlineBasedOnLinks([node4, path3], editor, links) {
  if (node4.type === "link" && !links) {
    Transforms.insertText(editor, ` (${node4.href})`, {
      at: Editor.end(editor, path3)
    });
    Transforms.unwrapNodes(editor, {
      at: path3
    });
    return true;
  }
  return false;
}
function normalizeElementBasedOnDocumentFeatures([node4, path3], editor, {
  formatting,
  dividers,
  layouts,
  links,
  images,
  tables
}) {
  if (node4.type === "heading" && (!formatting.headings.levels.length || !formatting.headings.levels.includes(node4.level)) || node4.type === "ordered-list" && !formatting.listTypes.ordered || node4.type === "unordered-list" && !formatting.listTypes.unordered || node4.type === "code" && !formatting.blockTypes.code || node4.type === "blockquote" && !formatting.blockTypes.blockquote || node4.type === "image" && !images || node4.type === "table" && !tables || node4.type === "layout" && (layouts.length === 0 || !layouts.some((layout) => areArraysEqual(layout, node4.layout)))) {
    Transforms.unwrapNodes(editor, {
      at: path3
    });
    return true;
  }
  if ((node4.type === "paragraph" || node4.type === "heading") && (!formatting.alignment.center && node4.textAlign === "center" || !formatting.alignment.end && node4.textAlign === "end" || "textAlign" in node4 && node4.textAlign !== "center" && node4.textAlign !== "end")) {
    Transforms.unsetNodes(editor, "textAlign", {
      at: path3
    });
    return true;
  }
  if (node4.type === "divider" && !dividers) {
    Transforms.removeNodes(editor, {
      at: path3
    });
    return true;
  }
  return normalizeInlineBasedOnLinks([node4, path3], editor, links);
}
function withDocumentFeaturesNormalization(documentFeatures, editor) {
  const {
    normalizeNode
  } = editor;
  editor.normalizeNode = ([node4, path3]) => {
    if (Text.isText(node4)) {
      normalizeTextBasedOnInlineMarksAndSoftBreaks([node4, path3], editor, documentFeatures.formatting.inlineMarks, documentFeatures.formatting.softBreaks);
    } else if (Element2.isElement(node4)) {
      normalizeElementBasedOnDocumentFeatures([node4, path3], editor, documentFeatures);
    }
    normalizeNode([node4, path3]);
  };
  return editor;
}
function getSrcPrefix(publicPath, slug) {
  return typeof publicPath === "string" ? `${publicPath.replace(/\/*$/, "")}/${slug === void 0 ? "" : slug + "/"}` : "";
}
function deserializeFiles(nodes, componentBlocks, files, otherFiles, mode, documentFeatures, slug) {
  return nodes.map((node4) => {
    if (node4.type === "component-block") {
      const componentBlock = componentBlocks[node4.component];
      if (!componentBlock)
        return node4;
      const schema = object(componentBlock.schema);
      return {
        ...node4,
        props: deserializeProps(schema, node4.props, files, otherFiles, mode, slug)
      };
    }
    if (node4.type === "image" && typeof node4.src === "string" && mode === "edit") {
      var _ref;
      const prefix4 = getSrcPrefixForImageBlock(documentFeatures, slug);
      const filename = node4.src.slice(prefix4.length);
      const content3 = (_ref = typeof documentFeatures.images === "object" && typeof documentFeatures.images.directory === "string" ? otherFiles.get(fixPath(documentFeatures.images.directory)) : files) === null || _ref === void 0 ? void 0 : _ref.get(filename);
      if (!content3) {
        return {
          type: "paragraph",
          children: [{
            text: `Missing image ${filename}`
          }]
        };
      }
      return {
        type: "image",
        src: {
          filename,
          content: content3
        },
        alt: node4.alt,
        title: node4.title,
        children: [{
          text: ""
        }]
      };
    }
    if (typeof node4.type === "string") {
      const children = deserializeFiles(node4.children, componentBlocks, files, otherFiles, mode, documentFeatures, slug);
      return {
        ...node4,
        children
      };
    }
    return node4;
  });
}
function deserializeProps(schema, value2, files, otherFiles, mode, slug) {
  return transformProps(schema, value2, {
    form: (schema2, value3) => {
      if (schema2.formKind === "asset") {
        var _otherFiles$get;
        if (mode === "read") {
          return schema2.reader.parse(value3);
        }
        const filename = schema2.filename(value3, {
          slug,
          suggestedFilenamePrefix: void 0
        });
        return schema2.parse(value3, {
          asset: filename ? schema2.directory ? (_otherFiles$get = otherFiles.get(schema2.directory)) === null || _otherFiles$get === void 0 ? void 0 : _otherFiles$get.get(filename) : files.get(filename) : void 0,
          slug
        });
      }
      if (schema2.formKind === "content") {
        throw new Error("Not implemented");
      }
      if (mode === "read") {
        return schema2.reader.parse(value3);
      }
      return schema2.parse(value3, void 0);
    }
  });
}
function getSrcPrefixForImageBlock(documentFeatures, slug) {
  return getSrcPrefix(typeof documentFeatures.images === "object" ? documentFeatures.images.publicPath : void 0, slug);
}
function serializeProps(rootValue, rootSchema, slugField, slug, shouldSuggestFilenamePrefix) {
  const extraFiles = [];
  return {
    value: transformProps(rootSchema, rootValue, {
      form(schema, value2, propPath) {
        if (propPath.length === 1 && slugField === propPath[0]) {
          if (schema.formKind !== "slug") {
            throw new Error("slugField is a not a slug field");
          }
          return schema.serializeWithSlug(value2).value;
        }
        if (schema.formKind === "asset") {
          const {
            asset,
            value: forYaml
          } = schema.serialize(value2, {
            suggestedFilenamePrefix: shouldSuggestFilenamePrefix ? getPropPathPortion(propPath, rootSchema, rootValue) : void 0,
            slug
          });
          if (asset) {
            extraFiles.push({
              path: asset.filename,
              contents: asset.content,
              parent: schema.directory
            });
          }
          return forYaml;
        }
        if (schema.formKind === "content") {
          const {
            other,
            external: external2,
            content: content3,
            value: forYaml
          } = schema.serialize(value2, {
            slug
          });
          if (content3) {
            extraFiles.push({
              path: getPropPathPortion(propPath, rootSchema, rootValue) + schema.contentExtension,
              contents: content3,
              parent: void 0
            });
          }
          for (const [key, contents] of other) {
            extraFiles.push({
              path: getPropPathPortion(propPath, rootSchema, rootValue) + "/" + key,
              contents,
              parent: void 0
            });
          }
          const allowedDirectories = new Set(schema.directories);
          for (const [directory, contents] of external2) {
            if (!allowedDirectories.has(directory)) {
              throw new Error(`Invalid directory ${directory} in content field serialization`);
            }
            for (const [filename, fileContents] of contents) {
              extraFiles.push({
                path: filename,
                contents: fileContents,
                parent: directory
              });
            }
          }
          return forYaml;
        }
        return schema.serialize(value2).value;
      },
      object(_schema, value2) {
        return Object.fromEntries(Object.entries(value2).filter(([_2, val]) => val !== void 0));
      },
      array(_schema, value2) {
        return value2.map((val) => val === void 0 ? null : val);
      },
      child() {
        return void 0;
      }
    }),
    extraFiles
  };
}
function getPropPathPortion(path3, schema, value2) {
  const end = [];
  for (const portion of path3) {
    if (schema.kind === "array") {
      value2 = value2[portion];
      if (schema.slugField && schema.element.kind === "object") {
        const slug = getSlugFromState({
          schema: schema.element.fields,
          slugField: schema.slugField
        }, value2);
        end.push(slug);
      } else {
        end.push(portion);
      }
      schema = schema.element;
      continue;
    }
    end.push(portion);
    if (schema.kind === "object") {
      value2 = value2[portion];
      schema = schema.fields[portion];
      continue;
    }
    if (schema.kind === "conditional") {
      if (portion === "discriminant") {
        schema = schema.discriminant;
      } else if (portion === "value") {
        schema = schema.values[value2.discriminant];
      }
      value2 = value2[portion];
      continue;
    }
    throw new Error(`unexpected ${schema.kind}`);
  }
  return end.join("/");
}
var {
  Ast
} = Markdoc;
function toInline(nodes) {
  return new Ast.Node("inline", {}, nodes.flatMap(toMarkdocInline));
}
var markToMarkdoc = {
  bold: {
    type: "strong"
  },
  code: {
    type: "code"
  },
  italic: {
    type: "em"
  },
  underline: {
    type: "tag",
    tag: "u"
  },
  keyboard: {
    type: "tag",
    tag: "kbd"
  },
  strikethrough: {
    type: "s"
  },
  subscript: {
    type: "tag",
    tag: "sub"
  },
  superscript: {
    type: "tag",
    tag: "sup"
  }
};
function toMarkdocInline(node4) {
  var _exec, _exec2;
  if (node4.type === "link") {
    return new Ast.Node("link", {
      href: node4.href
    }, node4.children.flatMap(toMarkdocInline));
  }
  if (node4.type !== void 0) {
    throw new Error(`unexpected inline node type: ${node4.type}`);
  }
  const marks = Object.keys(node4).filter((mark) => mark !== "text" && mark !== "code").sort();
  const splitByNewLines = node4.text.split(/\n/);
  if (splitByNewLines.length > 1) {
    return splitByNewLines.flatMap((x4, i6) => {
      if (i6 === 0) {
        return toMarkdocInline({
          ...node4,
          text: x4
        });
      }
      const inner = toMarkdocInline({
        ...node4,
        text: x4
      });
      return [new Ast.Node("hardbreak"), ...Array.isArray(inner) ? inner : [inner]];
    });
  }
  const leadingWhitespace2 = (_exec = /^\s+/.exec(node4.text)) === null || _exec === void 0 ? void 0 : _exec[0];
  const trailingWhitespace = (_exec2 = /\s+$/.exec(node4.text)) === null || _exec2 === void 0 ? void 0 : _exec2[0];
  let children = node4.code ? [new Ast.Node("code", {
    content: node4.text.trim()
  }, [])] : [new Ast.Node("text", {
    content: node4.text.trim()
  })];
  for (const mark of marks) {
    const config3 = markToMarkdoc[mark];
    if (config3) {
      children = [new Ast.Node(config3.type, {}, children, config3.tag)];
    }
  }
  if (/^\s+$/.test(node4.text)) {
    children.unshift(new Ast.Node("text", {
      content: leadingWhitespace2
    }, []));
  } else {
    if (leadingWhitespace2 !== null && leadingWhitespace2 !== void 0 && leadingWhitespace2.length) {
      children.unshift(new Ast.Node("text", {
        content: leadingWhitespace2
      }, []));
    }
    if (trailingWhitespace !== null && trailingWhitespace !== void 0 && trailingWhitespace.length) {
      children.push(new Ast.Node("text", {
        content: trailingWhitespace
      }, []));
    }
  }
  return children;
}
function toMarkdocDocument(nodes, _config) {
  const extraFiles = [];
  const config3 = {
    ..._config,
    extraFiles
  };
  const node4 = new Ast.Node("document", {}, nodes.flatMap((x4) => toMarkdoc(x4, config3)));
  return {
    node: node4,
    extraFiles
  };
}
function toChildrenAndProps(childrenAsMarkdoc, resultingChildren, value2, singleChildField) {
  if (singleChildField.kind === "child") {
    const child = childrenAsMarkdoc.find((x4) => areArraysEqual(x4.propPath, singleChildField.relativePath));
    if (child) {
      resultingChildren.push(...child.children);
    }
    return;
  }
  if (singleChildField.kind === "array") {
    const key = singleChildField.relativePath[singleChildField.relativePath.length - 1];
    const parent = getValueAtPropPath(value2, singleChildField.relativePath.slice(0, -1));
    const valueAtPropPath = parent[key];
    delete parent[key];
    const childNodes = /* @__PURE__ */ new Map();
    for (const child of childrenAsMarkdoc) {
      const innerPropPath = child.propPath.slice(singleChildField.relativePath.length + 1);
      const num = child.propPath[singleChildField.relativePath.length];
      if (childNodes.get(num) === void 0) {
        childNodes.set(num, []);
      }
      childNodes.get(num).push({
        children: child.children,
        propPath: innerPropPath
      });
    }
    resultingChildren.push(...valueAtPropPath.map((x4, i6) => {
      var _childNodes$get;
      const newChildrenAsMarkdoc = (_childNodes$get = childNodes.get(i6)) !== null && _childNodes$get !== void 0 ? _childNodes$get : [];
      const children = [];
      toChildrenAndProps(newChildrenAsMarkdoc, children, x4, singleChildField.child);
      return new Ast.Node("tag", x4, children, singleChildField.asChildTag);
    }));
  }
}
function toMarkdoc(node4, config3) {
  if (node4.type === "paragraph") {
    const markdocNode = new Ast.Node("paragraph", node4.textAlign ? {
      textAlign: node4.textAlign
    } : {}, [toInline(node4.children)]);
    if (node4.textAlign) {
      markdocNode.annotations.push({
        name: "textAlign",
        value: node4.textAlign,
        type: "attribute"
      });
    }
    return markdocNode;
  }
  if (node4.type === "image") {
    config3.extraFiles.push({
      contents: node4.src.content,
      path: node4.src.filename,
      parent: typeof config3.documentFeatures.images === "object" && typeof config3.documentFeatures.images.directory === "string" ? fixPath(config3.documentFeatures.images.directory) : void 0
    });
    return new Ast.Node("paragraph", {}, [new Ast.Node("inline", {}, [new Ast.Node("image", {
      src: encodeURI(`${getSrcPrefixForImageBlock(config3.documentFeatures, config3.slug)}${node4.src.filename}`),
      alt: node4.alt,
      title: node4.title
    })])]);
  }
  if (node4.type === "code") {
    const extraAttributes = {};
    const {
      children,
      language,
      type: type2,
      ...rest
    } = node4;
    const schema = typeof config3.documentFeatures.formatting.blockTypes.code === "object" ? config3.documentFeatures.formatting.blockTypes.code.schema : void 0;
    if (schema && Object.keys(schema.fields).length > 0) {
      const serialized = serializeProps(getInitialPropsValueFromInitializer(schema, rest), schema, void 0, config3.slug, false);
      Object.assign(extraAttributes, serialized.value);
      config3.extraFiles.push(...serialized.extraFiles);
    }
    let content3 = children[0].text + "\n";
    const markdocNode = new Ast.Node("fence", {
      content: content3,
      language,
      ...extraAttributes
    }, [new Ast.Node("text", {
      content: content3
    })]);
    for (const [key, value2] of Object.entries(extraAttributes)) {
      markdocNode.annotations.push({
        name: key,
        value: value2,
        type: "attribute"
      });
    }
    return markdocNode;
  }
  const _toMarkdoc = (node5) => toMarkdoc(node5, config3);
  if (node4.type === "blockquote") {
    return new Ast.Node("blockquote", {}, node4.children.map(_toMarkdoc));
  }
  if (node4.type === "divider") {
    return new Ast.Node("hr");
  }
  if (node4.type === "table") {
    const head = node4.children.find((x4) => x4.type === "table-head");
    return new Ast.Node("tag", {}, [new Ast.Node("table", {}, [new Ast.Node("thead", {}, head ? head.children.map(_toMarkdoc) : []), _toMarkdoc(node4.children.find((x4) => x4.type === "table-body"))])], "table");
  }
  if (node4.type === "table-body") {
    return new Ast.Node("tbody", {}, node4.children.map(_toMarkdoc));
  }
  if (node4.type === "table-row") {
    return new Ast.Node("tr", {}, node4.children.map(_toMarkdoc));
  }
  if (node4.type === "table-cell") {
    return new Ast.Node(node4.header ? "th" : "td", {}, node4.children.map(_toMarkdoc));
  }
  if (node4.type === "heading") {
    const extraAttributes = {};
    if (node4.textAlign) {
      extraAttributes.textAlign = node4.textAlign;
    }
    const {
      children,
      level,
      textAlign,
      type: type2,
      ...rest
    } = node4;
    const schema = config3.documentFeatures.formatting.headings.schema;
    if (Object.keys(schema.fields).length > 0) {
      Object.assign(extraAttributes, serializeProps(getInitialPropsValueFromInitializer(schema, rest), schema, void 0, config3.slug, false).value);
    }
    const markdocNode = new Ast.Node("heading", {
      level: node4.level,
      ...extraAttributes
    }, [toInline(node4.children)]);
    for (const [key, value2] of Object.entries(extraAttributes)) {
      markdocNode.annotations.push({
        name: key,
        value: value2,
        type: "attribute"
      });
    }
    return markdocNode;
  }
  if (node4.type === "ordered-list") {
    return new Ast.Node("list", {
      ordered: true
    }, node4.children.map(_toMarkdoc));
  }
  if (node4.type === "unordered-list") {
    return new Ast.Node("list", {
      ordered: false
    }, node4.children.map(_toMarkdoc));
  }
  if (node4.type === "layout") {
    return new Ast.Node("tag", {
      layout: node4.layout
    }, node4.children.map(_toMarkdoc), "layout");
  }
  if (node4.type === "layout-area") {
    return new Ast.Node("tag", {}, node4.children.flatMap(_toMarkdoc), "layout-area");
  }
  if (node4.type === "component-block") {
    const isVoid = node4.children.length === 1 && node4.children[0].type === "component-inline-prop" && node4.children[0].propPath === void 0;
    const componentBlock = config3.componentBlocks[node4.component];
    const childrenAsMarkdoc = [];
    for (const child of node4.children) {
      if ((child.type === "component-block-prop" || child.type === "component-inline-prop") && child.propPath !== void 0) {
        childrenAsMarkdoc.push({
          type: child.type,
          propPath: child.propPath,
          children: child.type === "component-block-prop" ? child.children.flatMap(_toMarkdoc) : [toInline(child.children)]
        });
      }
    }
    let attributes = node4.props;
    if (componentBlock) {
      const serialized = serializeProps(node4.props, {
        kind: "object",
        fields: componentBlock.schema
      }, void 0, config3.slug, false);
      attributes = serialized.value;
      config3.extraFiles.push(...serialized.extraFiles);
      const singleChildField = findSingleChildField({
        kind: "object",
        fields: componentBlock.schema
      });
      if (singleChildField) {
        const children2 = [];
        toChildrenAndProps(childrenAsMarkdoc, children2, attributes, singleChildField);
        return new Ast.Node("tag", attributes, children2, node4.component);
      }
    }
    const children = isVoid ? [] : childrenAsMarkdoc.map((x4) => new Ast.Node("tag", {
      propPath: x4.propPath
    }, x4.children, x4.type));
    return new Ast.Node("tag", attributes, children, node4.component);
  }
  if (node4.type === "component-block-prop" || node4.type === "component-inline-prop") {
    return new Ast.Node("tag", {
      propPath: node4.propPath
    }, node4.type === "component-inline-prop" ? [toInline(node4.children)] : node4.children.flatMap(_toMarkdoc), node4.type);
  }
  if (node4.type === "list-item") {
    const listItemContent = node4.children[0];
    if (listItemContent.type !== "list-item-content") {
      throw new Error("list item content must contain a list-item-content");
    }
    const inline4 = toInline(listItemContent.children);
    const children = [inline4];
    const nestedList = node4.children[1];
    if (nestedList) {
      children.push(toMarkdoc(nestedList, config3));
    }
    return new Ast.Node("item", {}, children);
  }
  if (node4.type === "list-item-content") {
    throw new Error("list-item-content in unexpected position");
  }
  debugger;
  throw new Error(`unexpected node type: ${node4.type}`);
}
function validateText(val, min3, max4, fieldLabel, slugInfo) {
  if (val.length < min3) {
    if (min3 === 1) {
      return `${fieldLabel} must not be empty`;
    } else {
      return `${fieldLabel} must be at least ${min3} characters long`;
    }
  }
  if (val.length > max4) {
    return `${fieldLabel} must be no longer than ${max4} characters`;
  }
  if (slugInfo) {
    if (val === "") {
      return `${fieldLabel} must not be empty`;
    }
    if (val === "..") {
      return `${fieldLabel} must not be ..`;
    }
    if (val === ".") {
      return `${fieldLabel} must not be .`;
    }
    if (slugInfo.glob === "**") {
      const split2 = val.split("/");
      if (split2.some((s4) => s4 === "..")) {
        return `${fieldLabel} must not contain ..`;
      }
      if (split2.some((s4) => s4 === ".")) {
        return `${fieldLabel} must not be .`;
      }
    }
    if ((slugInfo.glob === "*" ? /[\\/]/ : /[\\]/).test(val)) {
      return `${fieldLabel} must not contain slashes`;
    }
    if (/^\s|\s$/.test(val)) {
      return `${fieldLabel} must not start or end with spaces`;
    }
    if (slugInfo.slugs.has(val)) {
      return `${fieldLabel} must be unique`;
    }
  }
}
function AddToPathProvider(props) {
  const path3 = (0, import_react79.useContext)(PathContext);
  return (0, import_jsx_runtime92.jsx)(PathContext.Provider, {
    value: (0, import_react79.useMemo)(() => path3.concat(props.part), [path3, props.part]),
    children: props.children
  });
}
var SlugFieldContext = (0, import_react79.createContext)(void 0);
var SlugFieldProvider = SlugFieldContext.Provider;
var PathContext = (0, import_react79.createContext)([]);
var PathContextProvider = PathContext.Provider;
function TextFieldInput(props) {
  const TextFieldComponent = props.multiline ? TextArea : TextField;
  const [blurred, setBlurred] = (0, import_react79.useState)(false);
  const slugContext = (0, import_react79.useContext)(SlugFieldContext);
  const path3 = (0, import_react79.useContext)(PathContext);
  return (0, import_jsx_runtime92.jsx)(TextFieldComponent, {
    label: props.label,
    description: props.description,
    autoFocus: props.autoFocus,
    value: props.value,
    onChange: props.onChange,
    onBlur: () => setBlurred(true),
    isRequired: props.min > 0,
    errorMessage: props.forceValidation || blurred ? validateText(props.value, props.min, props.max, props.label, path3.length === 1 && (slugContext === null || slugContext === void 0 ? void 0 : slugContext.field) === path3[0] ? slugContext : void 0) : void 0
  });
}
function parseAsNormalField(value2) {
  if (value2 === void 0) {
    return "";
  }
  if (typeof value2 !== "string") {
    throw new FieldDataError("Must be a string");
  }
  return value2;
}
var emptySet = /* @__PURE__ */ new Set();
function text6({
  label,
  defaultValue = "",
  validation: {
    length: {
      max: max4 = Infinity,
      min: min3 = 0
    } = {}
  } = {},
  description,
  multiline = false
}) {
  function validate3(value2, slugField) {
    const message = validateText(value2, min3, max4, label, slugField);
    if (message !== void 0) {
      throw new FieldDataError(message);
    }
    return value2;
  }
  return {
    kind: "form",
    formKind: "slug",
    label,
    Input(props) {
      return (0, import_jsx_runtime92.jsx)(TextFieldInput, {
        label,
        description,
        min: min3,
        max: max4,
        multiline,
        ...props
      });
    },
    defaultValue() {
      return typeof defaultValue === "string" ? defaultValue : defaultValue();
    },
    parse(value2, args2) {
      if ((args2 === null || args2 === void 0 ? void 0 : args2.slug) !== void 0) {
        return args2.slug;
      }
      return parseAsNormalField(value2);
    },
    serialize(value2) {
      return {
        value: value2 === "" ? void 0 : value2
      };
    },
    serializeWithSlug(value2) {
      return {
        slug: value2,
        value: void 0
      };
    },
    reader: {
      parse(value2) {
        const parsed = parseAsNormalField(value2);
        return validate3(parsed, void 0);
      },
      parseWithSlug(_value, args2) {
        validate3(parseAsNormalField(args2.slug), {
          glob: args2.glob,
          slugs: emptySet
        });
        return null;
      }
    },
    validate(value2, args2) {
      return validate3(value2, args2 === null || args2 === void 0 ? void 0 : args2.slugField);
    }
  };
}
var FIELD_GRID_COLUMNS = 12;
var FieldContext = (0, import_react79.createContext)({
  span: FIELD_GRID_COLUMNS
});
var useFieldContext = () => (0, import_react79.useContext)(FieldContext);
var FieldContextProvider = FieldContext.Provider;
function ObjectFieldInput({
  schema,
  autoFocus,
  fields,
  forceValidation
}) {
  validateLayout(schema);
  const firstFocusable = autoFocus ? findFocusableObjectFieldKey(schema) : void 0;
  const inner = (0, import_jsx_runtime92.jsx)(Grid, {
    columns: `repeat(${FIELD_GRID_COLUMNS}, minmax(auto, 1fr))`,
    columnGap: "medium",
    rowGap: "xlarge",
    children: Object.entries(fields).map(([key, propVal], index3) => {
      var _schema$layout$index, _schema$layout;
      let span = (_schema$layout$index = (_schema$layout = schema.layout) === null || _schema$layout === void 0 ? void 0 : _schema$layout[index3]) !== null && _schema$layout$index !== void 0 ? _schema$layout$index : FIELD_GRID_COLUMNS;
      return (0, import_jsx_runtime92.jsx)(FieldContextProvider, {
        value: {
          span
        },
        children: (0, import_jsx_runtime92.jsx)("div", {
          className: css({
            gridColumn: `span ${span}`,
            [containerQueries.below.tablet]: {
              gridColumn: `span ${FIELD_GRID_COLUMNS}`
            }
          }),
          children: (0, import_jsx_runtime92.jsx)(AddToPathProvider, {
            part: key,
            children: (0, import_jsx_runtime92.jsx)(InnerFormValueContentFromPreviewProps, {
              forceValidation,
              autoFocus: key === firstFocusable,
              marginBottom: "xlarge",
              ...propVal
            })
          })
        })
      }, key);
    })
  });
  const id2 = (0, import_react79.useId)();
  if (!schema.label) {
    return inner;
  }
  const labelId = `${id2}-label`;
  const descriptionId = `${id2}-description`;
  return (0, import_jsx_runtime92.jsxs)(Grid, {
    role: "group",
    gap: "medium",
    marginY: "xlarge",
    "aria-labelledby": labelId,
    "aria-describedby": schema.description ? descriptionId : void 0,
    children: [(0, import_jsx_runtime92.jsx)(Text2, {
      color: "neutralEmphasis",
      size: "medium",
      weight: "semibold",
      id: labelId,
      children: schema.label
    }), !!schema.description && (0, import_jsx_runtime92.jsx)(Text2, {
      id: descriptionId,
      size: "regular",
      color: "neutralSecondary",
      children: schema.description
    }), (0, import_jsx_runtime92.jsx)("div", {}), inner]
  });
}
function validateLayout(schema) {
  if (!schema.layout) {
    return;
  }
  assert(schema.layout.length === Object.keys(schema.fields).length, 'A column "span" is required for every field in the layout');
  assert(schema.layout.every((span) => span > 0), "The layout must not contain empty columns");
  assert(schema.layout.every((span) => span <= 12), "Fields may not span more than 12 columns");
  assert(schema.layout.reduce((acc, cur) => acc + cur, 0) % 12 === 0, "The layout must span exactly 12 columns");
}
function findFocusableObjectFieldKey(schema) {
  for (const [key, innerProp] of Object.entries(schema.fields)) {
    const childFocusable = canFieldBeFocused(innerProp);
    if (childFocusable) {
      return key;
    }
  }
  return void 0;
}
function canFieldBeFocused(schema) {
  if (schema.kind === "array" || schema.kind === "conditional" || schema.kind === "form") {
    return true;
  }
  if (schema.kind === "child") {
    return false;
  }
  if (schema.kind === "object") {
    for (const innerProp of Object.values(schema.fields)) {
      if (canFieldBeFocused(innerProp)) {
        return true;
      }
    }
    return false;
  }
  assertNever(schema);
}
function ConditionalFieldInput({
  schema,
  autoFocus,
  discriminant,
  onChange: onChange2,
  value: value2,
  forceValidation
}) {
  const schemaDiscriminant = schema.discriminant;
  return (0, import_jsx_runtime92.jsxs)(Flex, {
    gap: "xlarge",
    direction: "column",
    children: [(0, import_react79.useMemo)(() => (0, import_jsx_runtime92.jsx)(AddToPathProvider, {
      part: "discriminant",
      children: (0, import_jsx_runtime92.jsx)(schemaDiscriminant.Input, {
        autoFocus: !!autoFocus,
        value: discriminant,
        onChange: onChange2,
        forceValidation
      })
    }), [autoFocus, schemaDiscriminant, discriminant, onChange2, forceValidation]), (0, import_jsx_runtime92.jsx)(AddToPathProvider, {
      part: "value",
      children: (0, import_jsx_runtime92.jsx)(InnerFormValueContentFromPreviewProps, {
        forceValidation,
        ...value2
      })
    })]
  });
}
function castToMemoizedInfoForSchema(val) {
  return val;
}
function getOrInsert(map4, key, val) {
  if (!map4.has(key)) {
    map4.set(key, val(key));
  }
  return map4.get(key);
}
var childFieldData = /* @__PURE__ */ new WeakMap();
function storeChildFieldData(value2) {
  let key = {};
  childFieldData.set(key, value2);
  return key;
}
function getChildFieldData(props) {
  const val = childFieldData.get(props._);
  if (!val) {
    throw new Error("expected child field data to exist");
  }
  return val;
}
function createGetPreviewProps(rootSchema, rootOnChange, getChildFieldElement) {
  const memoizedInfoForSchema = castToMemoizedInfoForSchema({
    form(schema, onChange2) {
      return (newVal) => onChange2(() => newVal);
    },
    array(schema, onChange2) {
      return {
        rawOnChange: onChange2,
        inner: /* @__PURE__ */ new Map(),
        onChange(updater) {
          onChange2((value2) => updateValue(schema, value2, updater));
        }
      };
    },
    child(schema, onChange2) {
      return (newVal) => onChange2(() => newVal);
    },
    conditional(schema, onChange2) {
      return {
        onChange: (discriminant, value2) => onChange2((val) => updateValue(schema, val, {
          discriminant,
          value: value2
        })),
        onChangeForValue: (cb) => onChange2((val) => ({
          discriminant: val.discriminant,
          value: cb(val.value)
        }))
      };
    },
    object(schema, onChange2) {
      return {
        onChange: (updater) => {
          onChange2((value2) => updateValue(schema, value2, updater));
        },
        innerOnChanges: Object.fromEntries(Object.keys(schema.fields).map((key) => {
          return [key, (newVal) => {
            onChange2((val) => ({
              ...val,
              [key]: newVal(val[key])
            }));
          }];
        }))
      };
    }
  });
  const previewPropsFactories = {
    form(schema, value2, onChange2) {
      return {
        value: value2,
        onChange: onChange2,
        schema
      };
    },
    child(schema, value2, onChange2, path3) {
      return {
        element: getChildFieldElement(path3),
        schema,
        _: storeChildFieldData({
          value: value2,
          onChange: onChange2
        })
      };
    },
    object(schema, value2, memoized, path3, getInnerProp) {
      const fields = {};
      for (const key of Object.keys(schema.fields)) {
        fields[key] = getInnerProp(schema.fields[key], value2[key], memoized.innerOnChanges[key], key);
      }
      const previewProps = {
        fields,
        onChange: memoized.onChange,
        schema
      };
      return previewProps;
    },
    array(schema, value2, memoized, path3, getInnerProp) {
      const arrayValue = value2;
      const keys3 = getKeysForArrayValue(arrayValue);
      const unusedKeys = new Set(getKeysForArrayValue(value2));
      const props = {
        elements: arrayValue.map((val, i6) => {
          const key = keys3[i6];
          unusedKeys.delete(key);
          const element4 = getOrInsert(memoized.inner, key, () => {
            const onChange2 = (val2) => {
              memoized.rawOnChange((prev2) => {
                const keys4 = getKeysForArrayValue(prev2);
                const index3 = keys4.indexOf(key);
                const newValue = [...prev2];
                newValue[index3] = val2(newValue[index3]);
                setKeysForArrayValue(newValue, keys4);
                return newValue;
              });
            };
            const element5 = getInnerProp(schema.element, val, onChange2, key);
            return {
              element: element5,
              elementWithKey: {
                ...element5,
                key
              },
              onChange: onChange2
            };
          });
          const currentInnerProp = getInnerProp(schema.element, val, element4.onChange, key);
          if (element4.element !== currentInnerProp) {
            element4.element = currentInnerProp;
            element4.elementWithKey = {
              ...currentInnerProp,
              key
            };
          }
          return element4.elementWithKey;
        }),
        schema,
        onChange: memoized.onChange
      };
      for (const key of unusedKeys) {
        memoized.inner.delete(key);
      }
      return props;
    },
    conditional(schema, value2, memoized, path3, getInnerProp) {
      const props = {
        discriminant: value2.discriminant,
        onChange: memoized.onChange,
        value: getInnerProp(schema.values[value2.discriminant.toString()], value2.value, memoized.onChangeForValue, "value"),
        schema
      };
      return props;
    }
  };
  function getPreviewPropsForProp(schema, value2, memoedThing, path3, getInnerProp) {
    return previewPropsFactories[schema.kind](schema, value2, memoedThing, path3, getInnerProp);
  }
  function getInitialMemoState(schema, value2, onChange2, path3) {
    const innerState = /* @__PURE__ */ new Map();
    const memoizedInfo = memoizedInfoForSchema[schema.kind](schema, onChange2);
    const state = {
      value: value2,
      inner: innerState,
      props: getPreviewPropsForProp(schema, value2, memoizedInfo, path3, (schema2, value3, onChange3, key) => {
        const state2 = getInitialMemoState(schema2, value3, onChange3, path3.concat(key));
        innerState.set(key, state2);
        return state2.props;
      }),
      schema,
      cached: memoizedInfo
    };
    return state;
  }
  function getUpToDateProps(schema, value2, onChange2, memoState2, path3) {
    if (memoState2.schema !== schema) {
      Object.assign(memoState2, getInitialMemoState(schema, value2, onChange2, path3));
      return memoState2.props;
    }
    if (memoState2.value === value2) {
      return memoState2.props;
    }
    memoState2.value = value2;
    const unusedKeys = new Set(memoState2.inner.keys());
    memoState2.props = getPreviewPropsForProp(schema, value2, memoState2.cached, path3, (schema2, value3, onChange3, innerMemoStateKey) => {
      unusedKeys.delete(innerMemoStateKey);
      if (!memoState2.inner.has(innerMemoStateKey)) {
        const innerState = getInitialMemoState(schema2, value3, onChange3, path3.concat(innerMemoStateKey));
        memoState2.inner.set(innerMemoStateKey, innerState);
        return innerState.props;
      }
      return getUpToDateProps(schema2, value3, onChange3, memoState2.inner.get(innerMemoStateKey), path3.concat(innerMemoStateKey));
    });
    for (const key of unusedKeys) {
      memoState2.inner.delete(key);
    }
    return memoState2.props;
  }
  let memoState;
  return (value2) => {
    if (memoState === void 0) {
      memoState = getInitialMemoState(rootSchema, value2, rootOnChange, []);
      return memoState.props;
    }
    return getUpToDateProps(rootSchema, value2, rootOnChange, memoState, []);
  };
}
var previewPropsToValueConverter = {
  child(props) {
    const childFieldData2 = getChildFieldData(props);
    return childFieldData2.value;
  },
  form(props) {
    return props.value;
  },
  array(props) {
    const values3 = props.elements.map((x4) => previewPropsToValue(x4));
    setKeysForArrayValue(values3, props.elements.map((x4) => x4.key));
    return values3;
  },
  conditional(props) {
    return {
      discriminant: props.discriminant,
      value: previewPropsToValue(props.value)
    };
  },
  object(props) {
    return Object.fromEntries(Object.entries(props.fields).map(([key, val]) => [key, previewPropsToValue(val)]));
  }
};
function previewPropsToValue(props) {
  return previewPropsToValueConverter[props.schema.kind](props);
}
var valueToUpdaters = {
  child(value2) {
    return value2 !== null && value2 !== void 0 ? value2 : void 0;
  },
  form(value2) {
    return value2;
  },
  array(value2, schema) {
    const keys3 = getKeysForArrayValue(value2);
    return value2.map((x4, i6) => ({
      key: keys3[i6],
      value: valueToUpdater(x4, schema.element)
    }));
  },
  conditional(value2, schema) {
    return {
      discriminant: value2.discriminant,
      value: valueToUpdater(value2.value, schema.values[value2.discriminant.toString()])
    };
  },
  object(value2, schema) {
    return Object.fromEntries(Object.entries(schema.fields).map(([key, schema2]) => [key, valueToUpdater(value2[key], schema2)]));
  }
};
function valueToUpdater(value2, schema) {
  return valueToUpdaters[schema.kind](value2, schema);
}
function setValueToPreviewProps(value2, props) {
  if (isKind(props, "child")) {
    const {
      onChange: onChange2
    } = getChildFieldData(props);
    onChange2(value2);
    return;
  }
  if (isKind(props, "form") || isKind(props, "object") || isKind(props, "array")) {
    props.onChange(valueToUpdater(value2, props.schema));
    return;
  }
  if (isKind(props, "conditional")) {
    const updater = valueToUpdater(value2, props.schema);
    props.onChange(updater.discriminant, updater.value);
    return;
  }
  assertNever(props);
}
function isKind(props, kind) {
  return props.schema.kind === kind;
}
function validateArrayLength(schema, val, path3) {
  var _schema$validation, _schema$validation2;
  if (((_schema$validation = schema.validation) === null || _schema$validation === void 0 || (_schema$validation = _schema$validation.length) === null || _schema$validation === void 0 ? void 0 : _schema$validation.min) !== void 0 && val.length < schema.validation.length.min) {
    return new PropValidationError(new FieldDataError(`Must have at least ${schema.validation.length.min} element${schema.validation.length.min === 1 ? "" : "s"}`), path3, schema);
  }
  if (((_schema$validation2 = schema.validation) === null || _schema$validation2 === void 0 || (_schema$validation2 = _schema$validation2.length) === null || _schema$validation2 === void 0 ? void 0 : _schema$validation2.max) !== void 0 && val.length > schema.validation.length.max) {
    return new PropValidationError(new FieldDataError(`Must have at most ${schema.validation.length.max} element${schema.validation.length.max === 1 ? "" : "s"}}`), path3, schema);
  }
}
var PropValidationError = class extends Error {
  constructor(cause, path3, schema) {
    super(`field error at ${path3.join(".")}`, {
      cause
    });
    this.path = path3;
    this.schema = schema;
    this.cause = cause;
  }
};
function toFormFieldStoredValue(val) {
  if (val === null) {
    return void 0;
  }
  return val;
}
var isArray2 = Array.isArray;
function parseProps(schema, _value, path3, pathWithArrayFieldSlugs, parseFormField, validateArrayFieldLength) {
  let value2 = toFormFieldStoredValue(_value);
  if (schema.kind === "form") {
    try {
      return parseFormField(schema, value2, path3, pathWithArrayFieldSlugs);
    } catch (err) {
      throw new PropValidationError(err, path3, schema);
    }
  }
  if (schema.kind === "child") {
    return null;
  }
  if (schema.kind === "conditional") {
    if (value2 === void 0) {
      return getInitialPropsValue(schema);
    }
    try {
      if (typeof value2 !== "object" || value2 === null || isArray2(value2)) {
        throw new FieldDataError("Must be an object");
      }
      for (const key of Object.keys(value2)) {
        if (key !== "discriminant" && key !== "value") {
          throw new FieldDataError(`Must only contain keys "discriminant" and "value", not "${key}"`);
        }
      }
    } catch (err) {
      throw new PropValidationError(err, path3, schema);
    }
    const parsedDiscriminant = parseProps(schema.discriminant, value2.discriminant, path3.concat("discriminant"), pathWithArrayFieldSlugs.concat("discriminant"), parseFormField, validateArrayFieldLength);
    return {
      discriminant: parsedDiscriminant,
      value: parseProps(schema.values[parsedDiscriminant], value2.value, path3.concat("value"), pathWithArrayFieldSlugs.concat("value"), parseFormField, validateArrayFieldLength)
    };
  }
  if (schema.kind === "object") {
    if (value2 === void 0) {
      value2 = {};
    }
    try {
      if (typeof value2 !== "object" || value2 === null || isArray2(value2)) {
        throw new FieldDataError("Must be an object");
      }
      const allowedKeysSet = new Set(Object.keys(schema.fields));
      for (const key of Object.keys(value2)) {
        if (!allowedKeysSet.has(key)) {
          throw new FieldDataError(`Key on object value "${key}" is not allowed`);
        }
      }
    } catch (err) {
      throw new PropValidationError(err, path3, schema);
    }
    const val = {};
    const errors = [];
    for (const key of Object.keys(schema.fields)) {
      let individualVal = value2[key];
      try {
        const propVal = parseProps(schema.fields[key], individualVal, path3.concat(key), pathWithArrayFieldSlugs.concat(key), parseFormField, validateArrayFieldLength);
        val[key] = propVal;
      } catch (err) {
        errors.push(err);
      }
    }
    if (errors.length) {
      throw new AggregateError(errors);
    }
    return val;
  }
  if (schema.kind === "array") {
    if (value2 === void 0) {
      return [];
    }
    try {
      if (!isArray2(value2)) {
        throw new FieldDataError("Must be an array");
      }
    } catch (err) {
      throw new PropValidationError(err, path3, schema);
    }
    const errors = [];
    try {
      if (validateArrayFieldLength) {
        const error3 = validateArrayLength(schema, value2, path3);
        if (error3 !== void 0) {
          errors.push(error3);
        }
      }
      return value2.map((innerVal, i6) => {
        try {
          let slug = i6.toString();
          if (schema.slugField && typeof innerVal === "object" && innerVal !== null && !isArray2(innerVal)) {
            if (schema.element.kind !== "object") {
              throw new Error("slugField on array fields requires the an object field element");
            }
            const slugField = schema.element.fields[schema.slugField];
            if (!slugField) {
              throw new Error(`slugField "${schema.slugField}" does not exist on object field`);
            }
            if (slugField.kind !== "form") {
              throw new Error(`slugField "${schema.slugField}" is not a form field`);
            }
            if (slugField.formKind !== "slug") {
              throw new Error(`slugField "${schema.slugField}" is not a slug field`);
            }
            let parsedSlugFieldValue;
            try {
              parsedSlugFieldValue = slugField.parse(toFormFieldStoredValue(innerVal[schema.slugField]), void 0);
            } catch (err) {
              throw new AggregateError([err]);
            }
            slug = slugField.serializeWithSlug(parsedSlugFieldValue).slug;
          }
          return parseProps(schema.element, innerVal, path3.concat(i6), pathWithArrayFieldSlugs.concat(slug), parseFormField, validateArrayFieldLength);
        } catch (err) {
          errors.push(err);
        }
      });
    } finally {
      if (errors.length) {
        throw new AggregateError(errors);
      }
    }
  }
  assertNever(schema);
}
function flattenErrors(error3) {
  if (error3 instanceof AggregateError) {
    return error3.errors.flatMap(flattenErrors);
  }
  return [error3];
}
function formatFormDataError(error3) {
  const flatErrors = flattenErrors(error3);
  return flatErrors.map((error4) => {
    if (error4 instanceof PropValidationError) {
      const path3 = error4.path.join(".");
      return `${path3}: ${error4.cause instanceof FieldDataError ? error4.cause.message : `Unexpected error: ${error4.cause}`}`;
    }
    return `Unexpected error: ${error4}`;
  }).join("\n");
}
function toFormattedFormDataError(error3) {
  const formatted = formatFormDataError(error3);
  return new Error(`Field validation failed:
` + formatted);
}
function clientSideValidateProp(schema, value2, slugField) {
  try {
    validateValueWithSchema(schema, value2, slugField);
    return true;
  } catch (error3) {
    console.warn(toFormattedFormDataError(error3));
    return false;
  }
}
function validateValueWithSchema(schema, value2, slugField, path3 = []) {
  switch (schema.kind) {
    case "child": {
      return;
    }
    case "form": {
      try {
        if (slugField && path3[path3.length - 1] === (slugField === null || slugField === void 0 ? void 0 : slugField.field)) {
          schema.validate(value2, {
            slugField: {
              slugs: slugField.slugs,
              glob: slugField.glob
            }
          });
          return;
        }
        schema.validate(value2, void 0);
      } catch (err) {
        throw new PropValidationError(err, path3, schema);
      }
      return;
    }
    case "conditional": {
      schema.discriminant.validate(value2.discriminant);
      validateValueWithSchema(schema.values[value2.discriminant], value2.value, void 0, path3.concat("value"));
      return;
    }
    case "object": {
      const errors = [];
      for (const [key, childProp] of Object.entries(schema.fields)) {
        try {
          validateValueWithSchema(childProp, value2[key], key === (slugField === null || slugField === void 0 ? void 0 : slugField.field) ? slugField : void 0, path3.concat(key));
        } catch (err) {
          errors.push(err);
        }
      }
      if (errors.length > 0) {
        throw new AggregateError(errors);
      }
      return;
    }
    case "array": {
      let slugInfo;
      if (schema.slugField !== void 0 && schema.element.kind === "object") {
        const innerSchema = schema.element.fields;
        const {
          slugField: slugField2
        } = schema;
        slugInfo = {
          slugField: slugField2,
          slugs: value2.map((val2) => getSlugFromState({
            schema: innerSchema,
            slugField: slugField2
          }, val2))
        };
      }
      const errors = [];
      const val = value2;
      const error3 = validateArrayLength(schema, value2, path3);
      if (error3 !== void 0) {
        errors.push(error3);
      }
      for (const [idx, innerVal] of val.entries()) {
        try {
          validateValueWithSchema(schema.element, innerVal, slugInfo === void 0 ? void 0 : {
            field: slugInfo.slugField,
            slugs: new Set(slugInfo.slugs.filter((_2, i6) => idx !== i6)),
            glob: "*"
          }, path3.concat(idx));
        } catch (err) {
          errors.push(err);
        }
      }
      if (errors.length > 0) {
        throw new AggregateError(errors);
      }
      return;
    }
  }
}
function ArrayFieldInput(props) {
  const labelId = (0, import_react79.useId)();
  const descriptionId = (0, import_react79.useId)();
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  const [modalState, setModalState] = (0, import_react79.useState)({
    state: "closed"
  });
  const formId = (0, import_react79.useId)();
  return (0, import_jsx_runtime92.jsxs)(Flex, {
    elementType: "section",
    gap: "medium",
    role: "group",
    "aria-labelledby": labelId,
    "aria-describedby": props.schema.description ? descriptionId : void 0,
    direction: "column",
    children: [(0, import_jsx_runtime92.jsx)(FieldLabel, {
      elementType: "h3",
      id: labelId,
      children: props.schema.label
    }), props.schema.description && (0, import_jsx_runtime92.jsx)(Text2, {
      id: descriptionId,
      size: "small",
      color: "neutralSecondary",
      children: props.schema.description
    }), (0, import_jsx_runtime92.jsx)(ActionButton, {
      autoFocus: props.autoFocus,
      onPress: () => {
        setModalState({
          state: "new"
        });
      },
      alignSelf: "start",
      children: stringFormatter.format("add")
    }), (0, import_jsx_runtime92.jsx)(ArrayFieldListView, {
      ...props,
      labelId,
      onOpenItem: (idx) => {
        setModalState({
          state: "edit",
          index: idx
        });
      }
    }), (0, import_jsx_runtime92.jsx)(ArrayFieldValidationMessages, {
      ...props
    }), (0, import_jsx_runtime92.jsx)(DialogContainer, {
      onDismiss: () => {
        setModalState({
          state: "closed"
        });
      },
      children: (() => {
        if (props.schema.element.kind === "child")
          return;
        if (modalState.state === "new") {
          return (0, import_jsx_runtime92.jsx)(ArrayFieldAddItemModalContent, {
            formId,
            onClose: () => {
              setModalState({
                state: "closed"
              });
            },
            previewProps: props
          });
        }
        if (modalState.state !== "edit")
          return;
        return (0, import_jsx_runtime92.jsxs)(Dialog, {
          children: [(0, import_jsx_runtime92.jsx)(Heading, {
            children: "Edit item"
          }), (0, import_jsx_runtime92.jsx)(ArrayEditItemModalContent, {
            formId,
            modalStateIndex: modalState.index,
            onClose: () => {
              setModalState({
                state: "closed"
              });
            },
            previewProps: props
          }), (0, import_jsx_runtime92.jsx)(ButtonGroup, {
            children: (0, import_jsx_runtime92.jsx)(Button, {
              form: formId,
              prominence: "high",
              type: "submit",
              children: "Done"
            })
          })]
        });
      })()
    })]
  });
}
function ArrayFieldAddItemModalContent(props) {
  const [forceValidation, setForceValidation] = (0, import_react79.useState)(false);
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  const slugInfo = (0, import_react79.useMemo)(() => {
    if (props.previewProps.schema.slugField === void 0 || props.previewProps.schema.element.kind !== "object") {
      return;
    }
    const val = previewPropsToValue(props.previewProps);
    const schema = props.previewProps.schema.element.fields;
    const slugField = props.previewProps.schema.slugField;
    const slugs = new Set(val.map((x4) => getSlugFromState({
      schema,
      slugField
    }, x4)));
    return {
      slugs,
      field: slugField,
      glob: "*"
    };
  }, [props.previewProps]);
  const [value2, setValue] = (0, import_react79.useState)(() => getInitialPropsValue(props.previewProps.schema.element));
  const previewProps = (0, import_react79.useMemo)(() => createGetPreviewProps(props.previewProps.schema.element, setValue, () => void 0), [props.previewProps.schema.element, setValue])(value2);
  return (0, import_jsx_runtime92.jsxs)(Dialog, {
    children: [(0, import_jsx_runtime92.jsx)(Heading, {
      children: "Add item"
    }), (0, import_jsx_runtime92.jsx)(Content, {
      children: (0, import_jsx_runtime92.jsx)(Flex, {
        id: props.formId,
        elementType: "form",
        onSubmit: (event) => {
          if (event.target !== event.currentTarget)
            return;
          event.preventDefault();
          if (!clientSideValidateProp(props.previewProps.schema.element, value2, void 0)) {
            setForceValidation(true);
            return;
          }
          props.previewProps.onChange([...props.previewProps.elements.map((x4) => ({
            key: x4.key
          })), {
            key: void 0,
            value: valueToUpdater(value2, props.previewProps.schema.element)
          }]);
          props.onClose();
        },
        direction: "column",
        gap: "xxlarge",
        children: (0, import_jsx_runtime92.jsx)(FormValueContentFromPreviewProps, {
          slugField: slugInfo,
          autoFocus: true,
          ...previewProps,
          forceValidation
        })
      })
    }), (0, import_jsx_runtime92.jsxs)(ButtonGroup, {
      children: [(0, import_jsx_runtime92.jsx)(Button, {
        onPress: () => {
          props.onClose();
        },
        children: stringFormatter.format("cancel")
      }), (0, import_jsx_runtime92.jsx)(Button, {
        form: props.formId,
        prominence: "high",
        type: "submit",
        children: stringFormatter.format("add")
      })]
    })]
  });
}
function ArrayEditItemModalContent(props) {
  const slugInfo = (0, import_react79.useMemo)(() => {
    if (props.previewProps.schema.slugField === void 0 || props.previewProps.schema.element.kind !== "object") {
      return;
    }
    const val = previewPropsToValue(props.previewProps);
    const schema = props.previewProps.schema.element.fields;
    const slugField = props.previewProps.schema.slugField;
    const slugs = new Set(val.filter((x4, i6) => i6 !== props.modalStateIndex).map((x4) => getSlugFromState({
      schema,
      slugField
    }, x4)));
    return {
      slugs,
      field: slugField,
      glob: "*"
    };
  }, [props.previewProps, props.modalStateIndex]);
  return (0, import_jsx_runtime92.jsx)(Content, {
    children: (0, import_jsx_runtime92.jsx)(Flex, {
      id: props.formId,
      elementType: "form",
      onSubmit: (event) => {
        if (event.target !== event.currentTarget)
          return;
        event.preventDefault();
        props.onClose();
      },
      direction: "column",
      gap: "xxlarge",
      children: (0, import_jsx_runtime92.jsx)(FormValueContentFromPreviewProps, {
        slugField: slugInfo,
        autoFocus: true,
        ...props.previewProps.elements[props.modalStateIndex]
      })
    })
  });
}
function ArrayFieldValidationMessages(props) {
  var _props$schema$validat, _props$schema$validat2;
  return (0, import_jsx_runtime92.jsx)(import_jsx_runtime92.Fragment, {
    children: props.forceValidation && (((_props$schema$validat = props.schema.validation) === null || _props$schema$validat === void 0 || (_props$schema$validat = _props$schema$validat.length) === null || _props$schema$validat === void 0 ? void 0 : _props$schema$validat.min) !== void 0 && props.elements.length < props.schema.validation.length.min ? (0, import_jsx_runtime92.jsxs)(FieldMessage, {
      children: ["Must have at least ", props.schema.validation.length.min, " item", props.schema.validation.length.min === 1 ? "" : "s"]
    }) : ((_props$schema$validat2 = props.schema.validation) === null || _props$schema$validat2 === void 0 || (_props$schema$validat2 = _props$schema$validat2.length) === null || _props$schema$validat2 === void 0 ? void 0 : _props$schema$validat2.max) !== void 0 && props.elements.length > props.schema.validation.length.max ? (0, import_jsx_runtime92.jsxs)(FieldMessage, {
      children: ["Must have at most ", props.schema.validation.length.max, " item", props.schema.validation.length.max === 1 ? "" : "s"]
    }) : void 0)
  });
}
function ArrayFieldListView(props) {
  let onMove = (keys3, target) => {
    const targetIndex = props.elements.findIndex((x4) => x4.key === target.key);
    if (targetIndex === -1)
      return;
    const allKeys = props.elements.map((x4) => ({
      key: x4.key
    }));
    const indexToMoveTo = target.dropPosition === "before" ? targetIndex : targetIndex + 1;
    const indices = keys3.map((key) => allKeys.findIndex((x4) => x4.key === key));
    props.onChange(move(allKeys, indices, indexToMoveTo));
  };
  const dragType = (0, import_react79.useMemo)(() => Math.random().toString(36), []);
  let {
    dragAndDropHooks
  } = useDragAndDrop({
    getItems(keys3) {
      return [...keys3].map((key) => {
        key = JSON.stringify(key);
        return {
          [dragType]: key,
          "text/plain": key
        };
      });
    },
    getAllowedDropOperations() {
      return ["move", "cancel"];
    },
    async onDrop(e6) {
      if (e6.target.type !== "root" && e6.target.dropPosition !== "on") {
        let keys3 = [];
        for (let item2 of e6.items) {
          if (item2.kind === "text") {
            let key;
            if (item2.types.has(dragType)) {
              key = JSON.parse(await item2.getText(dragType));
              keys3.push(key);
            } else if (item2.types.has("text/plain")) {
              key = await item2.getText("text/plain");
              keys3 = key.split("\n").map((val) => val.replaceAll('"', ""));
            }
          }
        }
        onMove(keys3, e6.target);
      }
    },
    getDropOperation(target) {
      if (target.type === "root" || target.dropPosition === "on") {
        return "cancel";
      }
      return "move";
    }
  });
  const onRemoveKey = useEventCallback((key) => {
    props.onChange(props.elements.map((x4) => ({
      key: x4.key
    })).filter((val) => val.key !== key));
  });
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  return (0, import_jsx_runtime92.jsx)(_ListView, {
    "aria-labelledby": props.labelId,
    items: props.elements,
    dragAndDropHooks,
    height: props.elements.length ? void 0 : "scale.2000",
    renderEmptyState: () => (0, import_jsx_runtime92.jsxs)(Flex, {
      direction: "column",
      gap: "large",
      alignItems: "center",
      justifyContent: "center",
      height: "100%",
      padding: "regular",
      children: [(0, import_jsx_runtime92.jsx)(Text2, {
        elementType: "h3",
        align: "center",
        color: "neutralSecondary",
        size: "large",
        weight: "medium",
        children: "Empty list"
      }), (0, import_jsx_runtime92.jsx)(Text2, {
        align: "center",
        color: "neutralTertiary",
        children: "Add the first item to see it here."
      })]
    }),
    onAction: (key) => {
      const idx = props.elements.findIndex((x4) => x4.key === key);
      if (idx === -1)
        return;
      props.onOpenItem(idx);
    },
    children: (item2) => {
      var _props$schema$itemLab, _props$schema;
      const label = ((_props$schema$itemLab = (_props$schema = props.schema).itemLabel) === null || _props$schema$itemLab === void 0 ? void 0 : _props$schema$itemLab.call(_props$schema, item2)) || `Item ${props.elements.indexOf(item2) + 1}`;
      return (0, import_jsx_runtime92.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
        textValue: label,
        children: [(0, import_jsx_runtime92.jsx)(Text2, {
          children: label
        }), (0, import_jsx_runtime92.jsxs)(_TooltipTrigger, {
          placement: "start",
          children: [(0, import_jsx_runtime92.jsx)(ActionButton, {
            onPress: () => {
              onRemoveKey(item2.key);
            },
            children: (0, import_jsx_runtime92.jsx)(Icon, {
              src: trash2Icon
            })
          }), (0, import_jsx_runtime92.jsx)(Tooltip, {
            tone: "critical",
            children: stringFormatter.format("delete")
          })]
        })]
      }, item2.key);
    }
  });
}
function move(items, indices, toIndex) {
  toIndex -= indices.filter((index3) => index3 < toIndex).length;
  let moves = indices.map((from4) => ({
    from: from4,
    to: toIndex++
  }));
  for (let i6 = 0; i6 < moves.length; i6++) {
    let a3 = moves[i6].from;
    for (let j4 = i6; j4 < moves.length; j4++) {
      let b2 = moves[j4].from;
      if (b2 > a3) {
        moves[j4].from--;
      }
    }
  }
  for (let i6 = 0; i6 < moves.length; i6++) {
    let a3 = moves[i6];
    for (let j4 = moves.length - 1; j4 > i6; j4--) {
      let b2 = moves[j4];
      if (b2.from < a3.to) {
        a3.to++;
      } else {
        b2.from++;
      }
    }
  }
  let copy3 = items.slice();
  for (let move2 of moves) {
    let [item2] = copy3.splice(move2.from, 1);
    copy3.splice(move2.to, 0, item2);
  }
  return copy3;
}
var isListType2 = (type2) => type2 === "ordered-list" || type2 === "unordered-list";
var isListNode = (node4) => isListType2(node4.type);
function getAncestorList(editor) {
  if (editor.selection) {
    const listItem = Editor.above(editor, {
      match: nodeTypeMatcher("list-item")
    });
    const list3 = Editor.above(editor, {
      match: isListNode
    });
    if (listItem && list3) {
      return {
        isInside: true,
        listItem,
        list: list3
      };
    }
  }
  return {
    isInside: false
  };
}
function withList(editor) {
  const {
    insertBreak,
    normalizeNode,
    deleteBackward
  } = editor;
  editor.deleteBackward = (unit) => {
    if (editor.selection) {
      const ancestorList = getAncestorList(editor);
      if (ancestorList.isInside && Range.isCollapsed(editor.selection) && Editor.isStart(editor, editor.selection.anchor, ancestorList.list[1])) {
        Transforms.unwrapNodes(editor, {
          match: isListNode,
          split: true
        });
        return;
      }
    }
    deleteBackward(unit);
  };
  editor.insertBreak = () => {
    const [listItem] = Editor.nodes(editor, {
      match: (node4) => node4.type === "list-item",
      mode: "lowest"
    });
    if (listItem && Node3.string(listItem[0]) === "") {
      Transforms.unwrapNodes(editor, {
        match: isListNode,
        split: true
      });
      return;
    }
    insertBreak();
  };
  editor.normalizeNode = (entry) => {
    const [node4, path3] = entry;
    if (Element2.isElement(node4) || Editor.isEditor(node4)) {
      const isElementBeingNormalizedAList = isListNode(node4);
      for (const [childNode, childPath] of Node3.children(editor, path3)) {
        const index3 = childPath[childPath.length - 1];
        if (isListNode(childNode)) {
          var _node$children;
          if (((_node$children = node4.children[childPath[childPath.length - 1] + 1]) === null || _node$children === void 0 ? void 0 : _node$children.type) === childNode.type) {
            const siblingNodePath = Path.next(childPath);
            moveChildren(editor, siblingNodePath, [...childPath, childNode.children.length]);
            Transforms.removeNodes(editor, {
              at: siblingNodePath
            });
            return;
          }
          if (isElementBeingNormalizedAList) {
            const previousChild = node4.children[index3 - 1];
            if (Element2.isElement(previousChild)) {
              Transforms.moveNodes(editor, {
                at: childPath,
                to: [...Path.previous(childPath), previousChild.children.length - 1]
              });
            } else {
              Transforms.unwrapNodes(editor, {
                at: childPath
              });
            }
            return;
          }
        }
        if (node4.type === "list-item" && childNode.type !== "list-item-content" && index3 === 0 && isBlock(childNode)) {
          if (path3[path3.length - 1] !== 0) {
            const previousChild = Node3.get(editor, Path.previous(path3));
            if (Element2.isElement(previousChild)) {
              Transforms.moveNodes(editor, {
                at: path3,
                to: [...Path.previous(path3), previousChild.children.length]
              });
              return;
            }
          }
          Transforms.unwrapNodes(editor, {
            at: childPath
          });
          return;
        }
        if (node4.type === "list-item" && childNode.type === "list-item-content" && index3 !== 0) {
          Transforms.splitNodes(editor, {
            at: childPath
          });
          return;
        }
      }
    }
    normalizeNode(entry);
  };
  return editor;
}
var ToolbarStateContext = import_react79.default.createContext(null);
function useToolbarState() {
  const toolbarState = (0, import_react79.useContext)(ToolbarStateContext);
  if (!toolbarState) {
    throw new Error("ToolbarStateProvider must be used to use useToolbarState");
  }
  return toolbarState;
}
var createToolbarState = (editor, componentBlocks, editorDocumentFeatures) => {
  const locationDocumentFeatures = getAncestorComponentChildFieldDocumentFeatures(editor, editorDocumentFeatures, componentBlocks) || {
    kind: "block",
    inlineMarks: "inherit",
    documentFeatures: {
      dividers: true,
      formatting: {
        alignment: {
          center: true,
          end: true
        },
        blockTypes: {
          blockquote: true,
          code: editorDocumentFeatures.formatting.blockTypes.code
        },
        headings: editorDocumentFeatures.formatting.headings,
        listTypes: {
          ordered: true,
          unordered: true
        }
      },
      layouts: editorDocumentFeatures.layouts,
      links: true,
      images: editorDocumentFeatures.images,
      tables: true
    },
    softBreaks: true,
    componentBlocks: true
  };
  let [maybeCodeBlockEntry] = Editor.nodes(editor, {
    match: (node4) => node4.type !== "code" && isBlock(node4)
  });
  const editorMarks = Editor.marks(editor) || {};
  const marks = Object.fromEntries(allMarks.map((mark) => [mark, {
    isDisabled: locationDocumentFeatures.inlineMarks !== "inherit" && !locationDocumentFeatures.inlineMarks[mark] || !maybeCodeBlockEntry,
    isSelected: !!editorMarks[mark]
  }]));
  if (editor.selection && Range.isExpanded(editor.selection)) {
    for (const node4 of Editor.nodes(editor, {
      match: Text.isText
    })) {
      for (const key of Object.keys(node4[0])) {
        if (key === "insertMenu" || key === "text") {
          continue;
        }
        if (key in marks) {
          marks[key].isSelected = true;
        }
      }
    }
  }
  let [headingEntry] = Editor.nodes(editor, {
    match: nodeTypeMatcher("heading")
  });
  let [listEntry] = Editor.nodes(editor, {
    match: isListNode
  });
  let [alignableEntry] = Editor.nodes(editor, {
    match: nodeTypeMatcher("paragraph", "heading")
  });
  const listTypeAbove = getListTypeAbove(editor);
  return {
    marks,
    textStyles: {
      selected: headingEntry ? headingEntry[0].level : "normal",
      allowedHeadingLevels: locationDocumentFeatures.kind === "block" && !listEntry ? locationDocumentFeatures.documentFeatures.formatting.headings.levels : []
    },
    code: {
      isSelected: isElementActive(editor, "code"),
      isDisabled: !(locationDocumentFeatures.kind === "block" && locationDocumentFeatures.documentFeatures.formatting.blockTypes.code)
    },
    lists: {
      ordered: {
        isSelected: isElementActive(editor, "ordered-list") && (listTypeAbove === "none" || listTypeAbove === "ordered-list"),
        isDisabled: !(locationDocumentFeatures.kind === "block" && locationDocumentFeatures.documentFeatures.formatting.listTypes.ordered && !headingEntry)
      },
      unordered: {
        isSelected: isElementActive(editor, "unordered-list") && (listTypeAbove === "none" || listTypeAbove === "unordered-list"),
        isDisabled: !(locationDocumentFeatures.kind === "block" && locationDocumentFeatures.documentFeatures.formatting.listTypes.unordered && !headingEntry)
      }
    },
    alignment: {
      isDisabled: !alignableEntry && !(locationDocumentFeatures.kind === "block" && locationDocumentFeatures.documentFeatures.formatting.alignment),
      selected: (alignableEntry === null || alignableEntry === void 0 ? void 0 : alignableEntry[0].textAlign) || "start"
    },
    blockquote: {
      isDisabled: !(locationDocumentFeatures.kind === "block" && locationDocumentFeatures.documentFeatures.formatting.blockTypes.blockquote),
      isSelected: isElementActive(editor, "blockquote")
    },
    layouts: {
      isSelected: isElementActive(editor, "layout")
    },
    links: {
      isDisabled: !editor.selection || Range.isCollapsed(editor.selection) || !locationDocumentFeatures.documentFeatures.links,
      isSelected: isElementActive(editor, "link")
    },
    editor,
    dividers: {
      isDisabled: locationDocumentFeatures.kind === "inline" || !locationDocumentFeatures.documentFeatures.dividers
    },
    clearFormatting: {
      isDisabled: !(Object.values(marks).some((x4) => x4.isSelected) || !!hasBlockThatClearsOnClearFormatting(editor))
    },
    editorDocumentFeatures
  };
};
function hasBlockThatClearsOnClearFormatting(editor) {
  const [node4] = Editor.nodes(editor, {
    match: (node5) => node5.type === "heading" || node5.type === "code" || node5.type === "blockquote"
  });
  return !!node4;
}
function getListTypeAbove(editor) {
  const listAbove = Editor.above(editor, {
    match: isListNode
  });
  if (!listAbove) {
    return "none";
  }
  return listAbove[0].type;
}
var DocumentEditorConfigContext = (0, import_react79.createContext)(null);
function useDocumentEditorConfig() {
  const context = (0, import_react79.useContext)(DocumentEditorConfigContext);
  if (!context) {
    throw new Error("useDocumentEditorConfig must be used within a DocumentEditorConfigContext.Provider");
  }
  return context;
}
var ToolbarStateProvider = ({
  children,
  componentBlocks,
  editorDocumentFeatures
}) => {
  const editor = useSlate();
  return (0, import_jsx_runtime92.jsx)(DocumentEditorConfigContext.Provider, {
    value: (0, import_react79.useMemo)(() => ({
      componentBlocks,
      documentFeatures: editorDocumentFeatures
    }), [componentBlocks, editorDocumentFeatures]),
    children: (0, import_jsx_runtime92.jsx)(ToolbarStateContext.Provider, {
      value: createToolbarState(editor, componentBlocks, editorDocumentFeatures),
      children
    })
  });
};
globalThis.Prism = {
  manual: true
};
var _self = globalThis;
var Prism = function(_self2) {
  var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
  var uniqueId = 0;
  var plainTextGrammar = {};
  var _2 = {
    /**
     * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
     * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
     * additional languages or plugins yourself.
     *
     * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
     *
     * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
     * empty Prism object into the global scope before loading the Prism script like this:
     *
     * ```js
     * window.Prism = window.Prism || {};
     * Prism.manual = true;
     * // add a new <script> to load Prism's script
     * ```
     *
     * @default false
     * @type {boolean}
     * @memberof Prism
     * @public
     */
    manual: _self2.Prism && _self2.Prism.manual,
    /**
     * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
     * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
     * own worker, you don't want it to do this.
     *
     * By setting this value to `true`, Prism will not add its own listeners to the worker.
     *
     * You obviously have to change this value before Prism executes. To do this, you can add an
     * empty Prism object into the global scope before loading the Prism script like this:
     *
     * ```js
     * window.Prism = window.Prism || {};
     * Prism.disableWorkerMessageHandler = true;
     * // Load Prism's script
     * ```
     *
     * @default false
     * @type {boolean}
     * @memberof Prism
     * @public
     */
    disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
    /**
     * A namespace for utility methods.
     *
     * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
     * change or disappear at any time.
     *
     * @namespace
     * @memberof Prism
     */
    util: {
      encode: function encode3(tokens) {
        if (tokens instanceof Token2) {
          return new Token2(tokens.type, encode3(tokens.content), tokens.alias);
        } else if (Array.isArray(tokens)) {
          return tokens.map(encode3);
        } else {
          return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
        }
      },
      /**
       * Returns the name of the type of the given value.
       *
       * @param {any} o
       * @returns {string}
       * @example
       * type(null)      === 'Null'
       * type(undefined) === 'Undefined'
       * type(123)       === 'Number'
       * type('foo')     === 'String'
       * type(true)      === 'Boolean'
       * type([1, 2])    === 'Array'
       * type({})        === 'Object'
       * type(String)    === 'Function'
       * type(/abc+/)    === 'RegExp'
       */
      type: function(o5) {
        return Object.prototype.toString.call(o5).slice(8, -1);
      },
      /**
       * Returns a unique number for the given object. Later calls will still return the same number.
       *
       * @param {Object} obj
       * @returns {number}
       */
      objId: function(obj) {
        if (!obj["__id"]) {
          Object.defineProperty(obj, "__id", {
            value: ++uniqueId
          });
        }
        return obj["__id"];
      },
      /**
       * Creates a deep clone of the given object.
       *
       * The main intended use of this function is to clone language definitions.
       *
       * @param {T} o
       * @param {Record<number, any>} [visited]
       * @returns {T}
       * @template T
       */
      clone: function deepClone(o5, visited) {
        visited = visited || {};
        var clone2;
        var id2;
        switch (_2.util.type(o5)) {
          case "Object":
            id2 = _2.util.objId(o5);
            if (visited[id2]) {
              return visited[id2];
            }
            clone2 = /** @type {Record<string, any>} */
            {};
            visited[id2] = clone2;
            for (var key in o5) {
              if (o5.hasOwnProperty(key)) {
                clone2[key] = deepClone(o5[key], visited);
              }
            }
            return (
              /** @type {any} */
              clone2
            );
          case "Array":
            id2 = _2.util.objId(o5);
            if (visited[id2]) {
              return visited[id2];
            }
            clone2 = [];
            visited[id2] = clone2;
            /** @type {Array} */
            /** @type {any} */
            o5.forEach(function(v6, i6) {
              clone2[i6] = deepClone(v6, visited);
            });
            return (
              /** @type {any} */
              clone2
            );
          default:
            return o5;
        }
      },
      /**
       * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
       *
       * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
       *
       * @param {Element} element
       * @returns {string}
       */
      getLanguage: function(element4) {
        while (element4) {
          var m3 = lang.exec(element4.className);
          if (m3) {
            return m3[1].toLowerCase();
          }
          element4 = element4.parentElement;
        }
        return "none";
      },
      /**
       * Sets the Prism `language-xxxx` class of the given element.
       *
       * @param {Element} element
       * @param {string} language
       * @returns {void}
       */
      setLanguage: function(element4, language) {
        element4.className = element4.className.replace(RegExp(lang, "gi"), "");
        element4.classList.add("language-" + language);
      },
      /**
       * Returns the script element that is currently executing.
       *
       * This does __not__ work for line script element.
       *
       * @returns {HTMLScriptElement | null}
       */
      currentScript: function() {
        if (typeof document === "undefined") {
          return null;
        }
        if ("currentScript" in document && 1 < 2) {
          return (
            /** @type {any} */
            document.currentScript
          );
        }
        try {
          throw new Error();
        } catch (err) {
          var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
          if (src) {
            var scripts = document.getElementsByTagName("script");
            for (var i6 in scripts) {
              if (scripts[i6].src == src) {
                return scripts[i6];
              }
            }
          }
          return null;
        }
      },
      /**
       * Returns whether a given class is active for `element`.
       *
       * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
       * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
       * given class is just the given class with a `no-` prefix.
       *
       * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
       * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
       * ancestors have the given class or the negated version of it, then the default activation will be returned.
       *
       * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
       * version of it, the class is considered active.
       *
       * @param {Element} element
       * @param {string} className
       * @param {boolean} [defaultActivation=false]
       * @returns {boolean}
       */
      isActive: function(element4, className, defaultActivation) {
        var no = "no-" + className;
        while (element4) {
          var classList = element4.classList;
          if (classList.contains(className)) {
            return true;
          }
          if (classList.contains(no)) {
            return false;
          }
          element4 = element4.parentElement;
        }
        return !!defaultActivation;
      }
    },
    /**
     * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
     *
     * @namespace
     * @memberof Prism
     * @public
     */
    languages: {
      /**
       * The grammar for plain, unformatted text.
       */
      plain: plainTextGrammar,
      plaintext: plainTextGrammar,
      text: plainTextGrammar,
      txt: plainTextGrammar,
      /**
       * Creates a deep copy of the language with the given id and appends the given tokens.
       *
       * If a token in `redef` also appears in the copied language, then the existing token in the copied language
       * will be overwritten at its original position.
       *
       * ## Best practices
       *
       * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
       * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
       * understand the language definition because, normally, the order of tokens matters in Prism grammars.
       *
       * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
       * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
       *
       * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
       * @param {Grammar} redef The new tokens to append.
       * @returns {Grammar} The new language created.
       * @public
       * @example
       * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
       *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
       *     // at its original position
       *     'comment': { ... },
       *     // CSS doesn't have a 'color' token, so this token will be appended
       *     'color': /\b(?:red|green|blue)\b/
       * });
       */
      extend: function(id2, redef) {
        var lang2 = _2.util.clone(_2.languages[id2]);
        for (var key in redef) {
          lang2[key] = redef[key];
        }
        return lang2;
      },
      /**
       * Inserts tokens _before_ another token in a language definition or any other grammar.
       *
       * ## Usage
       *
       * This helper method makes it easy to modify existing languages. For example, the CSS language definition
       * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
       * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
       * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
       * this:
       *
       * ```js
       * Prism.languages.markup.style = {
       *     // token
       * };
       * ```
       *
       * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
       * before existing tokens. For the CSS example above, you would use it like this:
       *
       * ```js
       * Prism.languages.insertBefore('markup', 'cdata', {
       *     'style': {
       *         // token
       *     }
       * });
       * ```
       *
       * ## Special cases
       *
       * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
       * will be ignored.
       *
       * This behavior can be used to insert tokens after `before`:
       *
       * ```js
       * Prism.languages.insertBefore('markup', 'comment', {
       *     'comment': Prism.languages.markup.comment,
       *     // tokens after 'comment'
       * });
       * ```
       *
       * ## Limitations
       *
       * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
       * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
       * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
       * deleting properties which is necessary to insert at arbitrary positions.
       *
       * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
       * Instead, it will create a new object and replace all references to the target object with the new one. This
       * can be done without temporarily deleting properties, so the iteration order is well-defined.
       *
       * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
       * you hold the target object in a variable, then the value of the variable will not change.
       *
       * ```js
       * var oldMarkup = Prism.languages.markup;
       * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
       *
       * assert(oldMarkup !== Prism.languages.markup);
       * assert(newMarkup === Prism.languages.markup);
       * ```
       *
       * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
       * object to be modified.
       * @param {string} before The key to insert before.
       * @param {Grammar} insert An object containing the key-value pairs to be inserted.
       * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
       * object to be modified.
       *
       * Defaults to `Prism.languages`.
       * @returns {Grammar} The new grammar object.
       * @public
       */
      insertBefore: function(inside, before, insert, root) {
        root = root || /** @type {any} */
        _2.languages;
        var grammar = root[inside];
        var ret = {};
        for (var token2 in grammar) {
          if (grammar.hasOwnProperty(token2)) {
            if (token2 == before) {
              for (var newToken in insert) {
                if (insert.hasOwnProperty(newToken)) {
                  ret[newToken] = insert[newToken];
                }
              }
            }
            if (!insert.hasOwnProperty(token2)) {
              ret[token2] = grammar[token2];
            }
          }
        }
        var old = root[inside];
        root[inside] = ret;
        _2.languages.DFS(_2.languages, function(key, value2) {
          if (value2 === old && key != inside) {
            this[key] = ret;
          }
        });
        return ret;
      },
      // Traverse a language definition with Depth First Search
      DFS: function DFS(o5, callback, type2, visited) {
        visited = visited || {};
        var objId = _2.util.objId;
        for (var i6 in o5) {
          if (o5.hasOwnProperty(i6)) {
            callback.call(o5, i6, o5[i6], type2 || i6);
            var property = o5[i6];
            var propertyType = _2.util.type(property);
            if (propertyType === "Object" && !visited[objId(property)]) {
              visited[objId(property)] = true;
              DFS(property, callback, null, visited);
            } else if (propertyType === "Array" && !visited[objId(property)]) {
              visited[objId(property)] = true;
              DFS(property, callback, i6, visited);
            }
          }
        }
      }
    },
    plugins: {},
    /**
     * This is the most high-level function in Prism’s API.
     * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
     * each one of them.
     *
     * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
     *
     * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
     * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
     * @memberof Prism
     * @public
     */
    highlightAll: function(async, callback) {
      _2.highlightAllUnder(document, async, callback);
    },
    /**
     * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
     * {@link Prism.highlightElement} on each one of them.
     *
     * The following hooks will be run:
     * 1. `before-highlightall`
     * 2. `before-all-elements-highlight`
     * 3. All hooks of {@link Prism.highlightElement} for each element.
     *
     * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
     * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
     * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
     * @memberof Prism
     * @public
     */
    highlightAllUnder: function(container, async, callback) {
      var env = {
        callback,
        container,
        selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
      };
      _2.hooks.run("before-highlightall", env);
      env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
      _2.hooks.run("before-all-elements-highlight", env);
      for (var i6 = 0, element4; element4 = env.elements[i6++]; ) {
        _2.highlightElement(element4, async === true, env.callback);
      }
    },
    /**
     * Highlights the code inside a single element.
     *
     * The following hooks will be run:
     * 1. `before-sanity-check`
     * 2. `before-highlight`
     * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
     * 4. `before-insert`
     * 5. `after-highlight`
     * 6. `complete`
     *
     * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
     * the element's language.
     *
     * @param {Element} element The element containing the code.
     * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
     * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
     * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
     * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
     *
     * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
     * asynchronous highlighting to work. You can build your own bundle on the
     * [Download page](https://prismjs.com/download.html).
     * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
     * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
     * @memberof Prism
     * @public
     */
    highlightElement: function(element4, async, callback) {
      var language = _2.util.getLanguage(element4);
      var grammar = _2.languages[language];
      _2.util.setLanguage(element4, language);
      var parent = element4.parentElement;
      if (parent && parent.nodeName.toLowerCase() === "pre") {
        _2.util.setLanguage(parent, language);
      }
      var code3 = element4.textContent;
      var env = {
        element: element4,
        language,
        grammar,
        code: code3
      };
      function insertHighlightedCode(highlightedCode) {
        env.highlightedCode = highlightedCode;
        _2.hooks.run("before-insert", env);
        env.element.innerHTML = env.highlightedCode;
        _2.hooks.run("after-highlight", env);
        _2.hooks.run("complete", env);
        callback && callback.call(env.element);
      }
      _2.hooks.run("before-sanity-check", env);
      parent = env.element.parentElement;
      if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
        parent.setAttribute("tabindex", "0");
      }
      if (!env.code) {
        _2.hooks.run("complete", env);
        callback && callback.call(env.element);
        return;
      }
      _2.hooks.run("before-highlight", env);
      if (!env.grammar) {
        insertHighlightedCode(_2.util.encode(env.code));
        return;
      }
      if (async && _self2.Worker) {
        var worker = new Worker(_2.filename);
        worker.onmessage = function(evt) {
          insertHighlightedCode(evt.data);
        };
        worker.postMessage(JSON.stringify({
          language: env.language,
          code: env.code,
          immediateClose: true
        }));
      } else {
        insertHighlightedCode(_2.highlight(env.code, env.grammar, env.language));
      }
    },
    /**
     * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
     * and the language definitions to use, and returns a string with the HTML produced.
     *
     * The following hooks will be run:
     * 1. `before-tokenize`
     * 2. `after-tokenize`
     * 3. `wrap`: On each {@link Token}.
     *
     * @param {string} text A string with the code to be highlighted.
     * @param {Grammar} grammar An object containing the tokens to use.
     *
     * Usually a language definition like `Prism.languages.markup`.
     * @param {string} language The name of the language definition passed to `grammar`.
     * @returns {string} The highlighted HTML.
     * @memberof Prism
     * @public
     * @example
     * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
     */
    highlight: function(text7, grammar, language) {
      var env = {
        code: text7,
        grammar,
        language
      };
      _2.hooks.run("before-tokenize", env);
      if (!env.grammar) {
        throw new Error('The language "' + env.language + '" has no grammar.');
      }
      env.tokens = _2.tokenize(env.code, env.grammar);
      _2.hooks.run("after-tokenize", env);
      return Token2.stringify(_2.util.encode(env.tokens), env.language);
    },
    /**
     * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
     * and the language definitions to use, and returns an array with the tokenized code.
     *
     * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
     *
     * This method could be useful in other contexts as well, as a very crude parser.
     *
     * @param {string} text A string with the code to be highlighted.
     * @param {Grammar} grammar An object containing the tokens to use.
     *
     * Usually a language definition like `Prism.languages.markup`.
     * @returns {TokenStream} An array of strings and tokens, a token stream.
     * @memberof Prism
     * @public
     * @example
     * let code = `var foo = 0;`;
     * let tokens = Prism.tokenize(code, Prism.languages.javascript);
     * tokens.forEach(token => {
     *     if (token instanceof Prism.Token && token.type === 'number') {
     *         console.log(`Found numeric literal: ${token.content}`);
     *     }
     * });
     */
    tokenize: function(text7, grammar) {
      var rest = grammar.rest;
      if (rest) {
        for (var token2 in rest) {
          grammar[token2] = rest[token2];
        }
        delete grammar.rest;
      }
      var tokenList = new LinkedList();
      addAfter(tokenList, tokenList.head, text7);
      matchGrammar(text7, tokenList, grammar, tokenList.head, 0);
      return toArray(tokenList);
    },
    /**
     * @namespace
     * @memberof Prism
     * @public
     */
    hooks: {
      all: {},
      /**
       * Adds the given callback to the list of callbacks for the given hook.
       *
       * The callback will be invoked when the hook it is registered for is run.
       * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
       *
       * One callback function can be registered to multiple hooks and the same hook multiple times.
       *
       * @param {string} name The name of the hook.
       * @param {HookCallback} callback The callback function which is given environment variables.
       * @public
       */
      add: function(name2, callback) {
        var hooks = _2.hooks.all;
        hooks[name2] = hooks[name2] || [];
        hooks[name2].push(callback);
      },
      /**
       * Runs a hook invoking all registered callbacks with the given environment variables.
       *
       * Callbacks will be invoked synchronously and in the order in which they were registered.
       *
       * @param {string} name The name of the hook.
       * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
       * @public
       */
      run: function(name2, env) {
        var callbacks2 = _2.hooks.all[name2];
        if (!callbacks2 || !callbacks2.length) {
          return;
        }
        for (var i6 = 0, callback; callback = callbacks2[i6++]; ) {
          callback(env);
        }
      }
    },
    Token: Token2
  };
  _self2.Prism = _2;
  function Token2(type2, content3, alias, matchedStr) {
    this.type = type2;
    this.content = content3;
    this.alias = alias;
    this.length = (matchedStr || "").length | 0;
  }
  Token2.stringify = function stringify4(o5, language) {
    if (typeof o5 == "string") {
      return o5;
    }
    if (Array.isArray(o5)) {
      var s4 = "";
      o5.forEach(function(e6) {
        s4 += stringify4(e6, language);
      });
      return s4;
    }
    var env = {
      type: o5.type,
      content: stringify4(o5.content, language),
      tag: "span",
      classes: ["token", o5.type],
      attributes: {},
      language
    };
    var aliases = o5.alias;
    if (aliases) {
      if (Array.isArray(aliases)) {
        Array.prototype.push.apply(env.classes, aliases);
      } else {
        env.classes.push(aliases);
      }
    }
    _2.hooks.run("wrap", env);
    var attributes = "";
    for (var name2 in env.attributes) {
      attributes += " " + name2 + '="' + (env.attributes[name2] || "").replace(/"/g, "&quot;") + '"';
    }
    return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
  };
  function matchPattern(pattern, pos, text7, lookbehind) {
    pattern.lastIndex = pos;
    var match3 = pattern.exec(text7);
    if (match3 && lookbehind && match3[1]) {
      var lookbehindLength = match3[1].length;
      match3.index += lookbehindLength;
      match3[0] = match3[0].slice(lookbehindLength);
    }
    return match3;
  }
  function matchGrammar(text7, tokenList, grammar, startNode, startPos, rematch) {
    for (var token2 in grammar) {
      if (!grammar.hasOwnProperty(token2) || !grammar[token2]) {
        continue;
      }
      var patterns = grammar[token2];
      patterns = Array.isArray(patterns) ? patterns : [patterns];
      for (var j4 = 0; j4 < patterns.length; ++j4) {
        if (rematch && rematch.cause == token2 + "," + j4) {
          return;
        }
        var patternObj = patterns[j4];
        var inside = patternObj.inside;
        var lookbehind = !!patternObj.lookbehind;
        var greedy = !!patternObj.greedy;
        var alias = patternObj.alias;
        if (greedy && !patternObj.pattern.global) {
          var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
          patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
        }
        var pattern = patternObj.pattern || patternObj;
        for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
          if (rematch && pos >= rematch.reach) {
            break;
          }
          var str = currentNode.value;
          if (tokenList.length > text7.length) {
            return;
          }
          if (str instanceof Token2) {
            continue;
          }
          var removeCount = 1;
          var match3;
          if (greedy) {
            match3 = matchPattern(pattern, pos, text7, lookbehind);
            if (!match3 || match3.index >= text7.length) {
              break;
            }
            var from4 = match3.index;
            var to = match3.index + match3[0].length;
            var p5 = pos;
            p5 += currentNode.value.length;
            while (from4 >= p5) {
              currentNode = currentNode.next;
              p5 += currentNode.value.length;
            }
            p5 -= currentNode.value.length;
            pos = p5;
            if (currentNode.value instanceof Token2) {
              continue;
            }
            for (var k2 = currentNode; k2 !== tokenList.tail && (p5 < to || typeof k2.value === "string"); k2 = k2.next) {
              removeCount++;
              p5 += k2.value.length;
            }
            removeCount--;
            str = text7.slice(pos, p5);
            match3.index -= pos;
          } else {
            match3 = matchPattern(pattern, 0, str, lookbehind);
            if (!match3) {
              continue;
            }
          }
          var from4 = match3.index;
          var matchStr = match3[0];
          var before = str.slice(0, from4);
          var after = str.slice(from4 + matchStr.length);
          var reach = pos + str.length;
          if (rematch && reach > rematch.reach) {
            rematch.reach = reach;
          }
          var removeFrom = currentNode.prev;
          if (before) {
            removeFrom = addAfter(tokenList, removeFrom, before);
            pos += before.length;
          }
          removeRange(tokenList, removeFrom, removeCount);
          var wrapped = new Token2(token2, inside ? _2.tokenize(matchStr, inside) : matchStr, alias, matchStr);
          currentNode = addAfter(tokenList, removeFrom, wrapped);
          if (after) {
            addAfter(tokenList, currentNode, after);
          }
          if (removeCount > 1) {
            var nestedRematch = {
              cause: token2 + "," + j4,
              reach
            };
            matchGrammar(text7, tokenList, grammar, currentNode.prev, pos, nestedRematch);
            if (rematch && nestedRematch.reach > rematch.reach) {
              rematch.reach = nestedRematch.reach;
            }
          }
        }
      }
    }
  }
  function LinkedList() {
    var head = {
      value: null,
      prev: null,
      next: null
    };
    var tail = {
      value: null,
      prev: head,
      next: null
    };
    head.next = tail;
    this.head = head;
    this.tail = tail;
    this.length = 0;
  }
  function addAfter(list3, node4, value2) {
    var next2 = node4.next;
    var newNode = {
      value: value2,
      prev: node4,
      next: next2
    };
    node4.next = newNode;
    next2.prev = newNode;
    list3.length++;
    return newNode;
  }
  function removeRange(list3, node4, count) {
    var next2 = node4.next;
    for (var i6 = 0; i6 < count && next2 !== list3.tail; i6++) {
      next2 = next2.next;
    }
    node4.next = next2;
    next2.prev = node4;
    list3.length -= i6;
  }
  function toArray(list3) {
    var array = [];
    var node4 = list3.head.next;
    while (node4 !== list3.tail) {
      array.push(node4.value);
      node4 = node4.next;
    }
    return array;
  }
  if (!_self2.document) {
    if (!_self2.addEventListener) {
      return _2;
    }
    if (!_2.disableWorkerMessageHandler) {
      _self2.addEventListener("message", function(evt) {
        var message = JSON.parse(evt.data);
        var lang2 = message.language;
        var code3 = message.code;
        var immediateClose = message.immediateClose;
        _self2.postMessage(_2.highlight(code3, _2.languages[lang2], lang2));
        if (immediateClose) {
          _self2.close();
        }
      }, false);
    }
    return _2;
  }
  var script = _2.util.currentScript();
  if (script) {
    _2.filename = script.src;
    if (script.hasAttribute("data-manual")) {
      _2.manual = true;
    }
  }
  function highlightAutomaticallyCallback() {
    if (!_2.manual) {
      _2.highlightAll();
    }
  }
  if (!_2.manual) {
    var readyState = document.readyState;
    if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
      document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
    } else {
      if (window.requestAnimationFrame) {
        window.requestAnimationFrame(highlightAutomaticallyCallback);
      } else {
        window.setTimeout(highlightAutomaticallyCallback, 16);
      }
    }
  }
  return _2;
}(_self);
Prism.languages.markup = {
  "comment": {
    pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
    greedy: true
  },
  "prolog": {
    pattern: /<\?[\s\S]+?\?>/,
    greedy: true
  },
  "doctype": {
    // https://www.w3.org/TR/xml/#NT-doctypedecl
    pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
    greedy: true,
    inside: {
      "internal-subset": {
        pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
        lookbehind: true,
        greedy: true,
        inside: null
        // see below
      },
      "string": {
        pattern: /"[^"]*"|'[^']*'/,
        greedy: true
      },
      "punctuation": /^<!|>$|[[\]]/,
      "doctype-tag": /^DOCTYPE/i,
      "name": /[^\s<>'"]+/
    }
  },
  "cdata": {
    pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
    greedy: true
  },
  "tag": {
    pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
    greedy: true,
    inside: {
      "tag": {
        pattern: /^<\/?[^\s>\/]+/,
        inside: {
          "punctuation": /^<\/?/,
          "namespace": /^[^\s>\/:]+:/
        }
      },
      "special-attr": [],
      "attr-value": {
        pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
        inside: {
          "punctuation": [{
            pattern: /^=/,
            alias: "attr-equals"
          }, {
            pattern: /^(\s*)["']|["']$/,
            lookbehind: true
          }]
        }
      },
      "punctuation": /\/?>/,
      "attr-name": {
        pattern: /[^\s>\/]+/,
        inside: {
          "namespace": /^[^\s>\/:]+:/
        }
      }
    }
  },
  "entity": [{
    pattern: /&[\da-z]{1,8};/i,
    alias: "named-entity"
  }, /&#x?[\da-f]{1,8};/i]
};
Prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism.languages.markup["entity"];
Prism.languages.markup["doctype"].inside["internal-subset"].inside = Prism.languages.markup;
Prism.hooks.add("wrap", function(env) {
  if (env.type === "entity") {
    env.attributes["title"] = env.content.replace(/&amp;/, "&");
  }
});
Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
  /**
   * Adds an inlined language to markup.
   *
   * An example of an inlined language is CSS with `<style>` tags.
   *
   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addInlined('style', 'css');
   */
  value: function addInlined(tagName3, lang) {
    var includedCdataInside = {};
    includedCdataInside["language-" + lang] = {
      pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
      lookbehind: true,
      inside: Prism.languages[lang]
    };
    includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
    var inside = {
      "included-cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        inside: includedCdataInside
      }
    };
    inside["language-" + lang] = {
      pattern: /[\s\S]+/,
      inside: Prism.languages[lang]
    };
    var def = {};
    def[tagName3] = {
      pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
        return tagName3;
      }), "i"),
      lookbehind: true,
      greedy: true,
      inside
    };
    Prism.languages.insertBefore("markup", "cdata", def);
  }
});
Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
  /**
   * Adds an pattern to highlight languages embedded in HTML attributes.
   *
   * An example of an inlined language is CSS with `style` attributes.
   *
   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addAttribute('style', 'css');
   */
  value: function(attrName, lang) {
    Prism.languages.markup.tag.inside["special-attr"].push({
      pattern: RegExp(/(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
      lookbehind: true,
      inside: {
        "attr-name": /^[^\s=]+/,
        "attr-value": {
          pattern: /=[\s\S]+/,
          inside: {
            "value": {
              pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
              lookbehind: true,
              alias: [lang, "language-" + lang],
              inside: Prism.languages[lang]
            },
            "punctuation": [{
              pattern: /^=/,
              alias: "attr-equals"
            }, /"|'/]
          }
        }
      }
    });
  }
});
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;
Prism.languages.xml = Prism.languages.extend("markup", {});
Prism.languages.ssml = Prism.languages.xml;
Prism.languages.atom = Prism.languages.xml;
Prism.languages.rss = Prism.languages.xml;
(function(Prism2) {
  var string3 = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
  Prism2.languages.css = {
    "comment": /\/\*[\s\S]*?\*\//,
    "atrule": {
      pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string3.source + ")*?" + /(?:;|(?=\s*\{))/.source),
      inside: {
        "rule": /^@[\w-]+/,
        "selector-function-argument": {
          pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
          lookbehind: true,
          alias: "selector"
        },
        "keyword": {
          pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
          lookbehind: true
        }
        // See rest below
      }
    },
    "url": {
      // https://drafts.csswg.org/css-values-3/#urls
      pattern: RegExp("\\burl\\((?:" + string3.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
      greedy: true,
      inside: {
        "function": /^url/i,
        "punctuation": /^\(|\)$/,
        "string": {
          pattern: RegExp("^" + string3.source + "$"),
          alias: "url"
        }
      }
    },
    "selector": {
      pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string3.source + ")*(?=\\s*\\{)"),
      lookbehind: true
    },
    "string": {
      pattern: string3,
      greedy: true
    },
    "property": {
      pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
      lookbehind: true
    },
    "important": /!important\b/i,
    "function": {
      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
      lookbehind: true
    },
    "punctuation": /[(){};:,]/
  };
  Prism2.languages.css["atrule"].inside.rest = Prism2.languages.css;
  var markup = Prism2.languages.markup;
  if (markup) {
    markup.tag.addInlined("style", "css");
    markup.tag.addAttribute("style", "css");
  }
})(Prism);
Prism.languages.clike = {
  "comment": [{
    pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
    lookbehind: true,
    greedy: true
  }, {
    pattern: /(^|[^\\:])\/\/.*/,
    lookbehind: true,
    greedy: true
  }],
  "string": {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  "class-name": {
    pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
    lookbehind: true,
    inside: {
      "punctuation": /[.\\]/
    }
  },
  "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
  "boolean": /\b(?:false|true)\b/,
  "function": /\b\w+(?=\()/,
  "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
  "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
  "punctuation": /[{}[\];(),.:]/
};
Prism.languages.javascript = Prism.languages.extend("clike", {
  "class-name": [Prism.languages.clike["class-name"], {
    pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
    lookbehind: true
  }],
  "keyword": [{
    pattern: /((?:^|\})\s*)catch\b/,
    lookbehind: true
  }, {
    pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
    lookbehind: true
  }],
  // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
  "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
  "number": {
    pattern: RegExp(/(^|[^\w$])/.source + "(?:" + // constant
    (/NaN|Infinity/.source + "|" + // binary integer
    /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
    /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
    /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
    /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
    /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source),
    lookbehind: true
  },
  "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});
Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
Prism.languages.insertBefore("javascript", "keyword", {
  "regex": {
    pattern: RegExp(
      // lookbehind
      // eslint-disable-next-line regexp/no-dupe-characters-character-class
      /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
      // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
      // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
      // with the only syntax, so we have to define 2 different regex patterns.
      /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
      /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
      /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
    ),
    lookbehind: true,
    greedy: true,
    inside: {
      "regex-source": {
        pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
        lookbehind: true,
        alias: "language-regex",
        inside: Prism.languages.regex
      },
      "regex-delimiter": /^\/|\/$/,
      "regex-flags": /^[a-z]+$/
    }
  },
  // This must be declared before keyword because we use "function" inside the look-forward
  "function-variable": {
    pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
    alias: "function"
  },
  "parameter": [{
    pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
    lookbehind: true,
    inside: Prism.languages.javascript
  }, {
    pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
    lookbehind: true,
    inside: Prism.languages.javascript
  }, {
    pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
    lookbehind: true,
    inside: Prism.languages.javascript
  }, {
    pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
    lookbehind: true,
    inside: Prism.languages.javascript
  }],
  "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});
Prism.languages.insertBefore("javascript", "string", {
  "hashbang": {
    pattern: /^#!.*/,
    greedy: true,
    alias: "comment"
  },
  "template-string": {
    pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
    greedy: true,
    inside: {
      "template-punctuation": {
        pattern: /^`|`$/,
        alias: "string"
      },
      "interpolation": {
        pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
        lookbehind: true,
        inside: {
          "interpolation-punctuation": {
            pattern: /^\$\{|\}$/,
            alias: "punctuation"
          },
          rest: Prism.languages.javascript
        }
      },
      "string": /[\s\S]+/
    }
  },
  "string-property": {
    pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
    lookbehind: true,
    greedy: true,
    alias: "property"
  }
});
Prism.languages.insertBefore("javascript", "operator", {
  "literal-property": {
    pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
    lookbehind: true,
    alias: "property"
  }
});
if (Prism.languages.markup) {
  Prism.languages.markup.tag.addInlined("script", "javascript");
  Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript");
}
Prism.languages.js = Prism.languages.javascript;
(function() {
  if (typeof Prism === "undefined" || typeof document === "undefined") {
    return;
  }
  if (!Element.prototype.matches) {
    Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
  }
  var LOADING_MESSAGE = "Loading…";
  var FAILURE_MESSAGE = function(status, message) {
    return "✖ Error " + status + " while fetching file: " + message;
  };
  var FAILURE_EMPTY_MESSAGE = "✖ Error: File does not exist or is empty";
  var EXTENSIONS = {
    "js": "javascript",
    "py": "python",
    "rb": "ruby",
    "ps1": "powershell",
    "psm1": "powershell",
    "sh": "bash",
    "bat": "batch",
    "h": "c",
    "tex": "latex"
  };
  var STATUS_ATTR = "data-src-status";
  var STATUS_LOADING = "loading";
  var STATUS_LOADED = "loaded";
  var STATUS_FAILED = "failed";
  var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
  function loadFile(src, success, error3) {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", src, true);
    xhr.onreadystatechange = function() {
      if (xhr.readyState == 4) {
        if (xhr.status < 400 && xhr.responseText) {
          success(xhr.responseText);
        } else {
          if (xhr.status >= 400) {
            error3(FAILURE_MESSAGE(xhr.status, xhr.statusText));
          } else {
            error3(FAILURE_EMPTY_MESSAGE);
          }
        }
      }
    };
    xhr.send(null);
  }
  function parseRange(range) {
    var m3 = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || "");
    if (m3) {
      var start2 = Number(m3[1]);
      var comma = m3[2];
      var end = m3[3];
      if (!comma) {
        return [start2, start2];
      }
      if (!end) {
        return [start2, void 0];
      }
      return [start2, Number(end)];
    }
    return void 0;
  }
  Prism.hooks.add("before-highlightall", function(env) {
    env.selector += ", " + SELECTOR;
  });
  Prism.hooks.add("before-sanity-check", function(env) {
    var pre = (
      /** @type {HTMLPreElement} */
      env.element
    );
    if (pre.matches(SELECTOR)) {
      env.code = "";
      pre.setAttribute(STATUS_ATTR, STATUS_LOADING);
      var code3 = pre.appendChild(document.createElement("CODE"));
      code3.textContent = LOADING_MESSAGE;
      var src = pre.getAttribute("data-src");
      var language = env.language;
      if (language === "none") {
        var extension2 = (/\.(\w+)$/.exec(src) || [, "none"])[1];
        language = EXTENSIONS[extension2] || extension2;
      }
      Prism.util.setLanguage(code3, language);
      Prism.util.setLanguage(pre, language);
      var autoloader = Prism.plugins.autoloader;
      if (autoloader) {
        autoloader.loadLanguages(language);
      }
      loadFile(src, function(text7) {
        pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
        var range = parseRange(pre.getAttribute("data-range"));
        if (range) {
          var lines = text7.split(/\r\n?|\n/g);
          var start2 = range[0];
          var end = range[1] == null ? lines.length : range[1];
          if (start2 < 0) {
            start2 += lines.length;
          }
          start2 = Math.max(0, Math.min(start2 - 1, lines.length));
          if (end < 0) {
            end += lines.length;
          }
          end = Math.max(0, Math.min(end, lines.length));
          text7 = lines.slice(start2, end).join("\n");
          if (!pre.hasAttribute("data-start")) {
            pre.setAttribute("data-start", String(start2 + 1));
          }
        }
        code3.textContent = text7;
        Prism.highlightElement(code3);
      }, function(error3) {
        pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
        code3.textContent = error3;
      });
    }
  });
  Prism.plugins.fileHighlight = {
    /**
     * Executes the File Highlight plugin for all matching `pre` elements under the given container.
     *
     * Note: Elements which are already loaded or currently loading will not be touched by this method.
     *
     * @param {ParentNode} [container=document]
     */
    highlight: function highlight(container) {
      var elements = (container || document).querySelectorAll(SELECTOR);
      for (var i6 = 0, element4; element4 = elements[i6++]; ) {
        Prism.highlightElement(element4);
      }
    }
  };
  var logged = false;
  Prism.fileHighlight = function() {
    if (!logged) {
      console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
      logged = true;
    }
    Prism.plugins.fileHighlight.highlight.apply(this, arguments);
  };
})();
Prism.languages.clike = {
  "comment": [{
    pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
    lookbehind: true,
    greedy: true
  }, {
    pattern: /(^|[^\\:])\/\/.*/,
    lookbehind: true,
    greedy: true
  }],
  "string": {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  "class-name": {
    pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
    lookbehind: true,
    inside: {
      "punctuation": /[.\\]/
    }
  },
  "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
  "boolean": /\b(?:false|true)\b/,
  "function": /\b\w+(?=\()/,
  "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
  "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
  "punctuation": /[{}[\];(),.:]/
};
Prism.languages.c = Prism.languages.extend("clike", {
  "comment": {
    pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: true
  },
  "string": {
    // https://en.cppreference.com/w/c/language/string_literal
    pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    greedy: true
  },
  "class-name": {
    pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
    lookbehind: true
  },
  "keyword": /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
  "function": /\b[a-z_]\w*(?=\s*\()/i,
  "number": /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
  "operator": />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
});
Prism.languages.insertBefore("c", "string", {
  "char": {
    // https://en.cppreference.com/w/c/language/character_constant
    pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
    greedy: true
  }
});
Prism.languages.insertBefore("c", "string", {
  "macro": {
    // allow for multiline macro definitions
    // spaces after the # character compile fine with gcc
    pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
    lookbehind: true,
    greedy: true,
    alias: "property",
    inside: {
      "string": [{
        // highlight the path of the include statement as a string
        pattern: /^(#\s*include\s*)<[^>]+>/,
        lookbehind: true
      }, Prism.languages.c["string"]],
      "char": Prism.languages.c["char"],
      "comment": Prism.languages.c["comment"],
      "macro-name": [{
        pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
        lookbehind: true
      }, {
        pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
        lookbehind: true,
        alias: "function"
      }],
      // highlight macro directives as keywords
      "directive": {
        pattern: /^(#\s*)[a-z]+/,
        lookbehind: true,
        alias: "keyword"
      },
      "directive-hash": /^#/,
      "punctuation": /##|\\(?=[\r\n])/,
      "expression": {
        pattern: /\S[\s\S]*/,
        inside: Prism.languages.c
      }
    }
  }
});
Prism.languages.insertBefore("c", "function", {
  // highlight predefined macros as constants
  "constant": /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
});
delete Prism.languages.c["boolean"];
(function(Prism2) {
  var keyword = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
  var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
    return keyword.source;
  });
  Prism2.languages.cpp = Prism2.languages.extend("c", {
    "class-name": [
      {
        pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
          return keyword.source;
        })),
        lookbehind: true
      },
      // This is intended to capture the class name of method implementations like:
      //   void foo::bar() const {}
      // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
      // it starts with an uppercase letter. This approximation should give decent results.
      /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
      // This will capture the class name before destructors like:
      //   Foo::~Foo() {}
      /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
      // This also intends to capture the class name of method implementations but here the class has template
      // parameters, so it can't be a namespace (until C++ adds generic namespaces).
      /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
    ],
    "keyword": keyword,
    "number": {
      pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
      greedy: true
    },
    "operator": />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
    "boolean": /\b(?:false|true)\b/
  });
  Prism2.languages.insertBefore("cpp", "string", {
    "module": {
      // https://en.cppreference.com/w/cpp/language/modules
      pattern: RegExp(/(\b(?:import|module)\s+)/.source + "(?:" + // header-name
      /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
      /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
        return modName;
      }) + ")"),
      lookbehind: true,
      greedy: true,
      inside: {
        "string": /^[<"][\s\S]+/,
        "operator": /:/,
        "punctuation": /\./
      }
    },
    "raw-string": {
      pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
      alias: "string",
      greedy: true
    }
  });
  Prism2.languages.insertBefore("cpp", "keyword", {
    "generic-function": {
      pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
      inside: {
        "function": /^\w+/,
        "generic": {
          pattern: /<[\s\S]+/,
          alias: "class-name",
          inside: Prism2.languages.cpp
        }
      }
    }
  });
  Prism2.languages.insertBefore("cpp", "operator", {
    "double-colon": {
      pattern: /::/,
      alias: "punctuation"
    }
  });
  Prism2.languages.insertBefore("cpp", "class-name", {
    // the base clause is an optional list of parent classes
    // https://en.cppreference.com/w/cpp/language/class
    "base-clause": {
      pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
      lookbehind: true,
      greedy: true,
      inside: Prism2.languages.extend("cpp", {})
    }
  });
  Prism2.languages.insertBefore("inside", "double-colon", {
    // All untokenized words that are not namespaces should be class names
    "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
  }, Prism2.languages.cpp["base-clause"]);
})(Prism);
Prism.languages.arduino = Prism.languages.extend("cpp", {
  "keyword": /\b(?:String|array|bool|boolean|break|byte|case|catch|continue|default|do|double|else|finally|for|function|goto|if|in|instanceof|int|integer|long|loop|new|null|return|setup|string|switch|throw|try|void|while|word)\b/,
  "constant": /\b(?:ANALOG_MESSAGE|DEFAULT|DIGITAL_MESSAGE|EXTERNAL|FIRMATA_STRING|HIGH|INPUT|INPUT_PULLUP|INTERNAL|INTERNAL1V1|INTERNAL2V56|LED_BUILTIN|LOW|OUTPUT|REPORT_ANALOG|REPORT_DIGITAL|SET_PIN_MODE|SYSEX_START|SYSTEM_RESET)\b/,
  "builtin": /\b(?:Audio|BSSID|Bridge|Client|Console|EEPROM|Esplora|EsploraTFT|Ethernet|EthernetClient|EthernetServer|EthernetUDP|File|FileIO|FileSystem|Firmata|GPRS|GSM|GSMBand|GSMClient|GSMModem|GSMPIN|GSMScanner|GSMServer|GSMVoiceCall|GSM_SMS|HttpClient|IPAddress|IRread|Keyboard|KeyboardController|LiquidCrystal|LiquidCrystal_I2C|Mailbox|Mouse|MouseController|PImage|Process|RSSI|RobotControl|RobotMotor|SD|SPI|SSID|Scheduler|Serial|Server|Servo|SoftwareSerial|Stepper|Stream|TFT|Task|USBHost|WiFi|WiFiClient|WiFiServer|WiFiUDP|Wire|YunClient|YunServer|abs|addParameter|analogRead|analogReadResolution|analogReference|analogWrite|analogWriteResolution|answerCall|attach|attachGPRS|attachInterrupt|attached|autoscroll|available|background|beep|begin|beginPacket|beginSD|beginSMS|beginSpeaker|beginTFT|beginTransmission|beginWrite|bit|bitClear|bitRead|bitSet|bitWrite|blink|blinkVersion|buffer|changePIN|checkPIN|checkPUK|checkReg|circle|cityNameRead|cityNameWrite|clear|clearScreen|click|close|compassRead|config|connect|connected|constrain|cos|countryNameRead|countryNameWrite|createChar|cursor|debugPrint|delay|delayMicroseconds|detach|detachInterrupt|digitalRead|digitalWrite|disconnect|display|displayLogos|drawBMP|drawCompass|encryptionType|end|endPacket|endSMS|endTransmission|endWrite|exists|exitValue|fill|find|findUntil|flush|gatewayIP|get|getAsynchronously|getBand|getButton|getCurrentCarrier|getIMEI|getKey|getModifiers|getOemKey|getPINUsed|getResult|getSignalStrength|getSocket|getVoiceCallStatus|getXChange|getYChange|hangCall|height|highByte|home|image|interrupts|isActionDone|isDirectory|isListening|isPIN|isPressed|isValid|keyPressed|keyReleased|keyboardRead|knobRead|leftToRight|line|lineFollowConfig|listen|listenOnLocalhost|loadImage|localIP|lowByte|macAddress|maintain|map|max|messageAvailable|micros|millis|min|mkdir|motorsStop|motorsWrite|mouseDragged|mouseMoved|mousePressed|mouseReleased|move|noAutoscroll|noBlink|noBuffer|noCursor|noDisplay|noFill|noInterrupts|noListenOnLocalhost|noStroke|noTone|onReceive|onRequest|open|openNextFile|overflow|parseCommand|parseFloat|parseInt|parsePacket|pauseMode|peek|pinMode|playFile|playMelody|point|pointTo|position|pow|prepare|press|print|printFirmwareVersion|printVersion|println|process|processInput|pulseIn|put|random|randomSeed|read|readAccelerometer|readBlue|readButton|readBytes|readBytesUntil|readGreen|readJoystickButton|readJoystickSwitch|readJoystickX|readJoystickY|readLightSensor|readMessage|readMicrophone|readNetworks|readRed|readSlider|readString|readStringUntil|readTemperature|ready|rect|release|releaseAll|remoteIP|remoteNumber|remotePort|remove|requestFrom|retrieveCallingNumber|rewindDirectory|rightToLeft|rmdir|robotNameRead|robotNameWrite|run|runAsynchronously|runShellCommand|runShellCommandAsynchronously|running|scanNetworks|scrollDisplayLeft|scrollDisplayRight|seek|sendAnalog|sendDigitalPortPair|sendDigitalPorts|sendString|sendSysex|serialEvent|setBand|setBitOrder|setClockDivider|setCursor|setDNS|setDataMode|setFirmwareVersion|setMode|setPINUsed|setSpeed|setTextSize|setTimeout|shiftIn|shiftOut|shutdown|sin|size|sqrt|startLoop|step|stop|stroke|subnetMask|switchPIN|tan|tempoWrite|text|tone|transfer|tuneWrite|turn|updateIR|userNameRead|userNameWrite|voiceCall|waitContinue|width|write|writeBlue|writeGreen|writeJSON|writeMessage|writeMicroseconds|writeRGB|writeRed|yield)\b/
});
Prism.languages.ino = Prism.languages.arduino;
(function(Prism2) {
  var envVars = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b";
  var commandAfterHeredoc = {
    pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
    lookbehind: true,
    alias: "punctuation",
    // this looks reasonably well in all themes
    inside: null
    // see below
  };
  var insideString = {
    "bash": commandAfterHeredoc,
    "environment": {
      pattern: RegExp("\\$" + envVars),
      alias: "constant"
    },
    "variable": [
      // [0]: Arithmetic Environment
      {
        pattern: /\$?\(\([\s\S]+?\)\)/,
        greedy: true,
        inside: {
          // If there is a $ sign at the beginning highlight $(( and )) as variable
          "variable": [{
            pattern: /(^\$\(\([\s\S]+)\)\)/,
            lookbehind: true
          }, /^\$\(\(/],
          "number": /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
          // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
          "operator": /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
          // If there is no $ sign at the beginning highlight (( and )) as punctuation
          "punctuation": /\(\(?|\)\)?|,|;/
        }
      },
      // [1]: Command Substitution
      {
        pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
        greedy: true,
        inside: {
          "variable": /^\$\(|^`|\)$|`$/
        }
      },
      // [2]: Brace expansion
      {
        pattern: /\$\{[^}]+\}/,
        greedy: true,
        inside: {
          "operator": /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
          "punctuation": /[\[\]]/,
          "environment": {
            pattern: RegExp("(\\{)" + envVars),
            lookbehind: true,
            alias: "constant"
          }
        }
      },
      /\$(?:\w+|[#?*!@$])/
    ],
    // Escape sequences from echo and printf's manuals, and escaped quotes.
    "entity": /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
  };
  Prism2.languages.bash = {
    "shebang": {
      pattern: /^#!\s*\/.*/,
      alias: "important"
    },
    "comment": {
      pattern: /(^|[^"{\\$])#.*/,
      lookbehind: true
    },
    "function-name": [
      // a) function foo {
      // b) foo() {
      // c) function foo() {
      // but not “foo {”
      {
        // a) and c)
        pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
        lookbehind: true,
        alias: "function"
      },
      {
        // b)
        pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
        alias: "function"
      }
    ],
    // Highlight variable names as variables in for and select beginnings.
    "for-or-select": {
      pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
      alias: "variable",
      lookbehind: true
    },
    // Highlight variable names as variables in the left-hand part
    // of assignments (“=” and “+=”).
    "assign-left": {
      pattern: /(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,
      inside: {
        "environment": {
          pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + envVars),
          lookbehind: true,
          alias: "constant"
        }
      },
      alias: "variable",
      lookbehind: true
    },
    // Highlight parameter names as variables
    "parameter": {
      pattern: /(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?=[=\s]|$)/,
      alias: "variable",
      lookbehind: true
    },
    "string": [
      // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
      {
        pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
        lookbehind: true,
        greedy: true,
        inside: insideString
      },
      // Here-document with quotes around the tag
      // → No expansion (so no “inside”).
      {
        pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
        lookbehind: true,
        greedy: true,
        inside: {
          "bash": commandAfterHeredoc
        }
      },
      // “Normal” string
      {
        // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
        pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
        lookbehind: true,
        greedy: true,
        inside: insideString
      },
      {
        // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
        pattern: /(^|[^$\\])'[^']*'/,
        lookbehind: true,
        greedy: true
      },
      {
        // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
        pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
        greedy: true,
        inside: {
          "entity": insideString.entity
        }
      }
    ],
    "environment": {
      pattern: RegExp("\\$?" + envVars),
      alias: "constant"
    },
    "variable": insideString.variable,
    "function": {
      pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    "keyword": {
      pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
    "builtin": {
      pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
      lookbehind: true,
      // Alias added to make those easier to distinguish from strings.
      alias: "class-name"
    },
    "boolean": {
      pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    "file-descriptor": {
      pattern: /\B&\d\b/,
      alias: "important"
    },
    "operator": {
      // Lots of redirections here, but not just that.
      pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
      inside: {
        "file-descriptor": {
          pattern: /^\d/,
          alias: "important"
        }
      }
    },
    "punctuation": /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
    "number": {
      pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
      lookbehind: true
    }
  };
  commandAfterHeredoc.inside = Prism2.languages.bash;
  var toBeCopied = ["comment", "function-name", "for-or-select", "assign-left", "parameter", "string", "environment", "function", "keyword", "builtin", "boolean", "file-descriptor", "operator", "punctuation", "number"];
  var inside = insideString.variable[1].inside;
  for (var i6 = 0; i6 < toBeCopied.length; i6++) {
    inside[toBeCopied[i6]] = Prism2.languages.bash[toBeCopied[i6]];
  }
  Prism2.languages.sh = Prism2.languages.bash;
  Prism2.languages.shell = Prism2.languages.bash;
})(Prism);
(function(Prism2) {
  function replace2(pattern, replacements) {
    return pattern.replace(/<<(\d+)>>/g, function(m3, index3) {
      return "(?:" + replacements[+index3] + ")";
    });
  }
  function re(pattern, replacements, flags) {
    return RegExp(replace2(pattern, replacements), flags || "");
  }
  function nested(pattern, depthLog2) {
    for (var i6 = 0; i6 < depthLog2; i6++) {
      pattern = pattern.replace(/<<self>>/g, function() {
        return "(?:" + pattern + ")";
      });
    }
    return pattern.replace(/<<self>>/g, "[^\\s\\S]");
  }
  var keywordKinds = {
    // keywords which represent a return or variable type
    type: "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void",
    // keywords which are used to declare a type
    typeDeclaration: "class enum interface record struct",
    // contextual keywords
    // ("var" and "dynamic" are missing because they are used like types)
    contextual: "add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)",
    // all other keywords
    other: "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield"
  };
  function keywordsToPattern(words) {
    return "\\b(?:" + words.trim().replace(/ /g, "|") + ")\\b";
  }
  var typeDeclarationKeywords = keywordsToPattern(keywordKinds.typeDeclaration);
  var keywords = RegExp(keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other));
  var nonTypeKeywords = keywordsToPattern(keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other);
  var nonContextualKeywords = keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.other);
  var generic = nested(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2);
  var nestedRound = nested(/\((?:[^()]|<<self>>)*\)/.source, 2);
  var name2 = /@?\b[A-Za-z_]\w*\b/.source;
  var genericName = replace2(/<<0>>(?:\s*<<1>>)?/.source, [name2, generic]);
  var identifier2 = replace2(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [nonTypeKeywords, genericName]);
  var array = /\[\s*(?:,\s*)*\]/.source;
  var typeExpressionWithoutTuple = replace2(/<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source, [identifier2, array]);
  var tupleElement = replace2(/[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [generic, nestedRound, array]);
  var tuple = replace2(/\(<<0>>+(?:,<<0>>+)+\)/.source, [tupleElement]);
  var typeExpression = replace2(/(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source, [tuple, identifier2, array]);
  var typeInside = {
    "keyword": keywords,
    "punctuation": /[<>()?,.:[\]]/
  };
  var character2 = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source;
  var regularString = /"(?:\\.|[^\\"\r\n])*"/.source;
  var verbatimString = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
  Prism2.languages.csharp = Prism2.languages.extend("clike", {
    "string": [{
      pattern: re(/(^|[^$\\])<<0>>/.source, [verbatimString]),
      lookbehind: true,
      greedy: true
    }, {
      pattern: re(/(^|[^@$\\])<<0>>/.source, [regularString]),
      lookbehind: true,
      greedy: true
    }],
    "class-name": [{
      // Using static
      // using static System.Math;
      pattern: re(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [identifier2]),
      lookbehind: true,
      inside: typeInside
    }, {
      // Using alias (type)
      // using Project = PC.MyCompany.Project;
      pattern: re(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [name2, typeExpression]),
      lookbehind: true,
      inside: typeInside
    }, {
      // Using alias (alias)
      // using Project = PC.MyCompany.Project;
      pattern: re(/(\busing\s+)<<0>>(?=\s*=)/.source, [name2]),
      lookbehind: true
    }, {
      // Type declarations
      // class Foo<A, B>
      // interface Foo<out A, B>
      pattern: re(/(\b<<0>>\s+)<<1>>/.source, [typeDeclarationKeywords, genericName]),
      lookbehind: true,
      inside: typeInside
    }, {
      // Single catch exception declaration
      // catch(Foo)
      // (things like catch(Foo e) is covered by variable declaration)
      pattern: re(/(\bcatch\s*\(\s*)<<0>>/.source, [identifier2]),
      lookbehind: true,
      inside: typeInside
    }, {
      // Name of the type parameter of generic constraints
      // where Foo : class
      pattern: re(/(\bwhere\s+)<<0>>/.source, [name2]),
      lookbehind: true
    }, {
      // Casts and checks via as and is.
      // as Foo<A>, is Bar<B>
      // (things like if(a is Foo b) is covered by variable declaration)
      pattern: re(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [typeExpressionWithoutTuple]),
      lookbehind: true,
      inside: typeInside
    }, {
      // Variable, field and parameter declaration
      // (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)
      pattern: re(/\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source, [typeExpression, nonContextualKeywords, name2]),
      inside: typeInside
    }],
    "keyword": keywords,
    // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals
    "number": /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
    "operator": />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
    "punctuation": /\?\.?|::|[{}[\];(),.:]/
  });
  Prism2.languages.insertBefore("csharp", "number", {
    "range": {
      pattern: /\.\./,
      alias: "operator"
    }
  });
  Prism2.languages.insertBefore("csharp", "punctuation", {
    "named-parameter": {
      pattern: re(/([(,]\s*)<<0>>(?=\s*:)/.source, [name2]),
      lookbehind: true,
      alias: "punctuation"
    }
  });
  Prism2.languages.insertBefore("csharp", "class-name", {
    "namespace": {
      // namespace Foo.Bar {}
      // using Foo.Bar;
      pattern: re(/(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source, [name2]),
      lookbehind: true,
      inside: {
        "punctuation": /\./
      }
    },
    "type-expression": {
      // default(Foo), typeof(Foo<Bar>), sizeof(int)
      pattern: re(/(\b(?:default|sizeof|typeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source, [nestedRound]),
      lookbehind: true,
      alias: "class-name",
      inside: typeInside
    },
    "return-type": {
      // Foo<Bar> ForBar(); Foo IFoo.Bar() => 0
      // int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];
      // int Foo => 0; int Foo { get; set } = 0;
      pattern: re(/<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source, [typeExpression, identifier2]),
      inside: typeInside,
      alias: "class-name"
    },
    "constructor-invocation": {
      // new List<Foo<Bar[]>> { }
      pattern: re(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [typeExpression]),
      lookbehind: true,
      inside: typeInside,
      alias: "class-name"
    },
    /*'explicit-implementation': {
    	// int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();
    	pattern: replace(/\b<<0>>(?=\.<<1>>)/, className, methodOrPropertyDeclaration),
    	inside: classNameInside,
    	alias: 'class-name'
    },*/
    "generic-method": {
      // foo<Bar>()
      pattern: re(/<<0>>\s*<<1>>(?=\s*\()/.source, [name2, generic]),
      inside: {
        "function": re(/^<<0>>/.source, [name2]),
        "generic": {
          pattern: RegExp(generic),
          alias: "class-name",
          inside: typeInside
        }
      }
    },
    "type-list": {
      // The list of types inherited or of generic constraints
      // class Foo<F> : Bar, IList<FooBar>
      // where F : Bar, IList<int>
      pattern: re(/\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/.source, [typeDeclarationKeywords, genericName, name2, typeExpression, keywords.source, nestedRound, /\bnew\s*\(\s*\)/.source]),
      lookbehind: true,
      inside: {
        "record-arguments": {
          pattern: re(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [genericName, nestedRound]),
          lookbehind: true,
          greedy: true,
          inside: Prism2.languages.csharp
        },
        "keyword": keywords,
        "class-name": {
          pattern: RegExp(typeExpression),
          greedy: true,
          inside: typeInside
        },
        "punctuation": /[,()]/
      }
    },
    "preprocessor": {
      pattern: /(^[\t ]*)#.*/m,
      lookbehind: true,
      alias: "property",
      inside: {
        // highlight preprocessor directives as keywords
        "directive": {
          pattern: /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
          lookbehind: true,
          alias: "keyword"
        }
      }
    }
  });
  var regularStringOrCharacter = regularString + "|" + character2;
  var regularStringCharacterOrComment = replace2(/\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source, [regularStringOrCharacter]);
  var roundExpression = nested(replace2(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [regularStringCharacterOrComment]), 2);
  var attrTarget = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source;
  var attr = replace2(/<<0>>(?:\s*\(<<1>>*\))?/.source, [identifier2, roundExpression]);
  Prism2.languages.insertBefore("csharp", "class-name", {
    "attribute": {
      // Attributes
      // [Foo], [Foo(1), Bar(2, Prop = "foo")], [return: Foo(1), Bar(2)], [assembly: Foo(Bar)]
      pattern: re(/((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source, [attrTarget, attr]),
      lookbehind: true,
      greedy: true,
      inside: {
        "target": {
          pattern: re(/^<<0>>(?=\s*:)/.source, [attrTarget]),
          alias: "keyword"
        },
        "attribute-arguments": {
          pattern: re(/\(<<0>>*\)/.source, [roundExpression]),
          inside: Prism2.languages.csharp
        },
        "class-name": {
          pattern: RegExp(identifier2),
          inside: {
            "punctuation": /\./
          }
        },
        "punctuation": /[:,]/
      }
    }
  });
  var formatString = /:[^}\r\n]+/.source;
  var mInterpolationRound = nested(replace2(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [regularStringCharacterOrComment]), 2);
  var mInterpolation = replace2(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [mInterpolationRound, formatString]);
  var sInterpolationRound = nested(replace2(/[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source, [regularStringOrCharacter]), 2);
  var sInterpolation = replace2(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [sInterpolationRound, formatString]);
  function createInterpolationInside(interpolation, interpolationRound) {
    return {
      "interpolation": {
        pattern: re(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [interpolation]),
        lookbehind: true,
        inside: {
          "format-string": {
            pattern: re(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [interpolationRound, formatString]),
            lookbehind: true,
            inside: {
              "punctuation": /^:/
            }
          },
          "punctuation": /^\{|\}$/,
          "expression": {
            pattern: /[\s\S]+/,
            alias: "language-csharp",
            inside: Prism2.languages.csharp
          }
        }
      },
      "string": /[\s\S]+/
    };
  }
  Prism2.languages.insertBefore("csharp", "string", {
    "interpolation-string": [{
      pattern: re(/(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source, [mInterpolation]),
      lookbehind: true,
      greedy: true,
      inside: createInterpolationInside(mInterpolation, mInterpolationRound)
    }, {
      pattern: re(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [sInterpolation]),
      lookbehind: true,
      greedy: true,
      inside: createInterpolationInside(sInterpolation, sInterpolationRound)
    }],
    "char": {
      pattern: RegExp(character2),
      greedy: true
    }
  });
  Prism2.languages.dotnet = Prism2.languages.cs = Prism2.languages.csharp;
})(Prism);
Prism.languages.markup = {
  "comment": {
    pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
    greedy: true
  },
  "prolog": {
    pattern: /<\?[\s\S]+?\?>/,
    greedy: true
  },
  "doctype": {
    // https://www.w3.org/TR/xml/#NT-doctypedecl
    pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
    greedy: true,
    inside: {
      "internal-subset": {
        pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
        lookbehind: true,
        greedy: true,
        inside: null
        // see below
      },
      "string": {
        pattern: /"[^"]*"|'[^']*'/,
        greedy: true
      },
      "punctuation": /^<!|>$|[[\]]/,
      "doctype-tag": /^DOCTYPE/i,
      "name": /[^\s<>'"]+/
    }
  },
  "cdata": {
    pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
    greedy: true
  },
  "tag": {
    pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
    greedy: true,
    inside: {
      "tag": {
        pattern: /^<\/?[^\s>\/]+/,
        inside: {
          "punctuation": /^<\/?/,
          "namespace": /^[^\s>\/:]+:/
        }
      },
      "special-attr": [],
      "attr-value": {
        pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
        inside: {
          "punctuation": [{
            pattern: /^=/,
            alias: "attr-equals"
          }, {
            pattern: /^(\s*)["']|["']$/,
            lookbehind: true
          }]
        }
      },
      "punctuation": /\/?>/,
      "attr-name": {
        pattern: /[^\s>\/]+/,
        inside: {
          "namespace": /^[^\s>\/:]+:/
        }
      }
    }
  },
  "entity": [{
    pattern: /&[\da-z]{1,8};/i,
    alias: "named-entity"
  }, /&#x?[\da-f]{1,8};/i]
};
Prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism.languages.markup["entity"];
Prism.languages.markup["doctype"].inside["internal-subset"].inside = Prism.languages.markup;
Prism.hooks.add("wrap", function(env) {
  if (env.type === "entity") {
    env.attributes["title"] = env.content.replace(/&amp;/, "&");
  }
});
Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
  /**
   * Adds an inlined language to markup.
   *
   * An example of an inlined language is CSS with `<style>` tags.
   *
   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addInlined('style', 'css');
   */
  value: function addInlined2(tagName3, lang) {
    var includedCdataInside = {};
    includedCdataInside["language-" + lang] = {
      pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
      lookbehind: true,
      inside: Prism.languages[lang]
    };
    includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
    var inside = {
      "included-cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        inside: includedCdataInside
      }
    };
    inside["language-" + lang] = {
      pattern: /[\s\S]+/,
      inside: Prism.languages[lang]
    };
    var def = {};
    def[tagName3] = {
      pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
        return tagName3;
      }), "i"),
      lookbehind: true,
      greedy: true,
      inside
    };
    Prism.languages.insertBefore("markup", "cdata", def);
  }
});
Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
  /**
   * Adds an pattern to highlight languages embedded in HTML attributes.
   *
   * An example of an inlined language is CSS with `style` attributes.
   *
   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addAttribute('style', 'css');
   */
  value: function(attrName, lang) {
    Prism.languages.markup.tag.inside["special-attr"].push({
      pattern: RegExp(/(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
      lookbehind: true,
      inside: {
        "attr-name": /^[^\s=]+/,
        "attr-value": {
          pattern: /=[\s\S]+/,
          inside: {
            "value": {
              pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
              lookbehind: true,
              alias: [lang, "language-" + lang],
              inside: Prism.languages[lang]
            },
            "punctuation": [{
              pattern: /^=/,
              alias: "attr-equals"
            }, /"|'/]
          }
        }
      }
    });
  }
});
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;
Prism.languages.xml = Prism.languages.extend("markup", {});
Prism.languages.ssml = Prism.languages.xml;
Prism.languages.atom = Prism.languages.xml;
Prism.languages.rss = Prism.languages.xml;
(function(Prism2) {
  var string3 = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
  Prism2.languages.css = {
    "comment": /\/\*[\s\S]*?\*\//,
    "atrule": {
      pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string3.source + ")*?" + /(?:;|(?=\s*\{))/.source),
      inside: {
        "rule": /^@[\w-]+/,
        "selector-function-argument": {
          pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
          lookbehind: true,
          alias: "selector"
        },
        "keyword": {
          pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
          lookbehind: true
        }
        // See rest below
      }
    },
    "url": {
      // https://drafts.csswg.org/css-values-3/#urls
      pattern: RegExp("\\burl\\((?:" + string3.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
      greedy: true,
      inside: {
        "function": /^url/i,
        "punctuation": /^\(|\)$/,
        "string": {
          pattern: RegExp("^" + string3.source + "$"),
          alias: "url"
        }
      }
    },
    "selector": {
      pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string3.source + ")*(?=\\s*\\{)"),
      lookbehind: true
    },
    "string": {
      pattern: string3,
      greedy: true
    },
    "property": {
      pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
      lookbehind: true
    },
    "important": /!important\b/i,
    "function": {
      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
      lookbehind: true
    },
    "punctuation": /[(){};:,]/
  };
  Prism2.languages.css["atrule"].inside.rest = Prism2.languages.css;
  var markup = Prism2.languages.markup;
  if (markup) {
    markup.tag.addInlined("style", "css");
    markup.tag.addAttribute("style", "css");
  }
})(Prism);
(function(Prism2) {
  Prism2.languages.diff = {
    "coord": [
      // Match all kinds of coord lines (prefixed by "+++", "---" or "***").
      /^(?:\*{3}|-{3}|\+{3}).*$/m,
      // Match "@@ ... @@" coord lines in unified diff.
      /^@@.*@@$/m,
      // Match coord lines in normal diff (starts with a number).
      /^\d.*$/m
    ]
    // deleted, inserted, unchanged, diff
  };
  var PREFIXES = {
    "deleted-sign": "-",
    "deleted-arrow": "<",
    "inserted-sign": "+",
    "inserted-arrow": ">",
    "unchanged": " ",
    "diff": "!"
  };
  Object.keys(PREFIXES).forEach(function(name2) {
    var prefix4 = PREFIXES[name2];
    var alias = [];
    if (!/^\w+$/.test(name2)) {
      alias.push(/\w+/.exec(name2)[0]);
    }
    if (name2 === "diff") {
      alias.push("bold");
    }
    Prism2.languages.diff[name2] = {
      pattern: RegExp("^(?:[" + prefix4 + "].*(?:\r\n?|\n|(?![\\s\\S])))+", "m"),
      alias,
      inside: {
        "line": {
          pattern: /(.)(?=[\s\S]).*(?:\r\n?|\n)?/,
          lookbehind: true
        },
        "prefix": {
          pattern: /[\s\S]/,
          alias: /\w+/.exec(name2)[0]
        }
      }
    };
  });
  Object.defineProperty(Prism2.languages.diff, "PREFIXES", {
    value: PREFIXES
  });
})(Prism);
Prism.languages.go = Prism.languages.extend("clike", {
  "string": {
    pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
    lookbehind: true,
    greedy: true
  },
  "keyword": /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
  "boolean": /\b(?:_|false|iota|nil|true)\b/,
  "number": [
    // binary and octal integers
    /\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
    // hexadecimal integers and floats
    /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
    // decimal integers and floats
    /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
  ],
  "operator": /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
  "builtin": /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
});
Prism.languages.insertBefore("go", "string", {
  "char": {
    pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
    greedy: true
  }
});
delete Prism.languages.go["class-name"];
Prism.languages.ini = {
  /**
   * The component mimics the behavior of the Win32 API parser.
   *
   * @see {@link https://github.com/PrismJS/prism/issues/2775#issuecomment-787477723}
   */
  "comment": {
    pattern: /(^[ \f\t\v]*)[#;][^\n\r]*/m,
    lookbehind: true
  },
  "section": {
    pattern: /(^[ \f\t\v]*)\[[^\n\r\]]*\]?/m,
    lookbehind: true,
    inside: {
      "section-name": {
        pattern: /(^\[[ \f\t\v]*)[^ \f\t\v\]]+(?:[ \f\t\v]+[^ \f\t\v\]]+)*/,
        lookbehind: true,
        alias: "selector"
      },
      "punctuation": /\[|\]/
    }
  },
  "key": {
    pattern: /(^[ \f\t\v]*)[^ \f\n\r\t\v=]+(?:[ \f\t\v]+[^ \f\n\r\t\v=]+)*(?=[ \f\t\v]*=)/m,
    lookbehind: true,
    alias: "attr-name"
  },
  "value": {
    pattern: /(=[ \f\t\v]*)[^ \f\n\r\t\v]+(?:[ \f\t\v]+[^ \f\n\r\t\v]+)*/,
    lookbehind: true,
    alias: "attr-value",
    inside: {
      "inner-value": {
        pattern: /^("|').+(?=\1$)/,
        lookbehind: true
      }
    }
  },
  "punctuation": /=/
};
(function(Prism2) {
  var keywords = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/;
  var classNamePrefix2 = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;
  var className = {
    pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix2 + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
    lookbehind: true,
    inside: {
      "namespace": {
        pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
        inside: {
          "punctuation": /\./
        }
      },
      "punctuation": /\./
    }
  };
  Prism2.languages.java = Prism2.languages.extend("clike", {
    "string": {
      pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
      lookbehind: true,
      greedy: true
    },
    "class-name": [className, {
      // variables, parameters, and constructor references
      // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
      pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix2 + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
      lookbehind: true,
      inside: className.inside
    }, {
      // class names based on keyword
      // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
      pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + classNamePrefix2 + /[A-Z]\w*\b/.source),
      lookbehind: true,
      inside: className.inside
    }],
    "keyword": keywords,
    "function": [Prism2.languages.clike.function, {
      pattern: /(::\s*)[a-z_]\w*/,
      lookbehind: true
    }],
    "number": /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
    "operator": {
      pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
      lookbehind: true
    },
    "constant": /\b[A-Z][A-Z_\d]+\b/
  });
  Prism2.languages.insertBefore("java", "string", {
    "triple-quoted-string": {
      // http://openjdk.java.net/jeps/355#Description
      pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
      greedy: true,
      alias: "string"
    },
    "char": {
      pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
      greedy: true
    }
  });
  Prism2.languages.insertBefore("java", "class-name", {
    "annotation": {
      pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
      lookbehind: true,
      alias: "punctuation"
    },
    "generics": {
      pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
      inside: {
        "class-name": className,
        "keyword": keywords,
        "punctuation": /[<>(),.:]/,
        "operator": /[?&|]/
      }
    },
    "import": [{
      pattern: RegExp(/(\bimport\s+)/.source + classNamePrefix2 + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
      lookbehind: true,
      inside: {
        "namespace": className.inside.namespace,
        "punctuation": /\./,
        "operator": /\*/,
        "class-name": /\w+/
      }
    }, {
      pattern: RegExp(/(\bimport\s+static\s+)/.source + classNamePrefix2 + /(?:\w+|\*)(?=\s*;)/.source),
      lookbehind: true,
      alias: "static",
      inside: {
        "namespace": className.inside.namespace,
        "static": /\b\w+$/,
        "punctuation": /\./,
        "operator": /\*/,
        "class-name": /\w+/
      }
    }],
    "namespace": {
      pattern: RegExp(/(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
        return keywords.source;
      })),
      lookbehind: true,
      inside: {
        "punctuation": /\./
      }
    }
  });
})(Prism);
(function(Prism2) {
  var specialEscape = {
    pattern: /\\[\\(){}[\]^$+*?|.]/,
    alias: "escape"
  };
  var escape3 = /\\(?:x[\da-fA-F]{2}|u[\da-fA-F]{4}|u\{[\da-fA-F]+\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/;
  var charSet = {
    pattern: /\.|\\[wsd]|\\p\{[^{}]+\}/i,
    alias: "class-name"
  };
  var charSetWithoutDot = {
    pattern: /\\[wsd]|\\p\{[^{}]+\}/i,
    alias: "class-name"
  };
  var rangeChar = "(?:[^\\\\-]|" + escape3.source + ")";
  var range = RegExp(rangeChar + "-" + rangeChar);
  var groupName = {
    pattern: /(<|')[^<>']+(?=[>']$)/,
    lookbehind: true,
    alias: "variable"
  };
  Prism2.languages.regex = {
    "char-class": {
      pattern: /((?:^|[^\\])(?:\\\\)*)\[(?:[^\\\]]|\\[\s\S])*\]/,
      lookbehind: true,
      inside: {
        "char-class-negation": {
          pattern: /(^\[)\^/,
          lookbehind: true,
          alias: "operator"
        },
        "char-class-punctuation": {
          pattern: /^\[|\]$/,
          alias: "punctuation"
        },
        "range": {
          pattern: range,
          inside: {
            "escape": escape3,
            "range-punctuation": {
              pattern: /-/,
              alias: "operator"
            }
          }
        },
        "special-escape": specialEscape,
        "char-set": charSetWithoutDot,
        "escape": escape3
      }
    },
    "special-escape": specialEscape,
    "char-set": charSet,
    "backreference": [{
      // a backreference which is not an octal escape
      pattern: /\\(?![123][0-7]{2})[1-9]/,
      alias: "keyword"
    }, {
      pattern: /\\k<[^<>']+>/,
      alias: "keyword",
      inside: {
        "group-name": groupName
      }
    }],
    "anchor": {
      pattern: /[$^]|\\[ABbGZz]/,
      alias: "function"
    },
    "escape": escape3,
    "group": [{
      // https://docs.oracle.com/javase/10/docs/api/java/util/regex/Pattern.html
      // https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference?view=netframework-4.7.2#grouping-constructs
      // (), (?<name>), (?'name'), (?>), (?:), (?=), (?!), (?<=), (?<!), (?is-m), (?i-m:)
      pattern: /\((?:\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/,
      alias: "punctuation",
      inside: {
        "group-name": groupName
      }
    }, {
      pattern: /\)/,
      alias: "punctuation"
    }],
    "quantifier": {
      pattern: /(?:[+*?]|\{\d+(?:,\d*)?\})[?+]?/,
      alias: "number"
    },
    "alternation": {
      pattern: /\|/,
      alias: "keyword"
    }
  };
})(Prism);
Prism.languages.javascript = Prism.languages.extend("clike", {
  "class-name": [Prism.languages.clike["class-name"], {
    pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
    lookbehind: true
  }],
  "keyword": [{
    pattern: /((?:^|\})\s*)catch\b/,
    lookbehind: true
  }, {
    pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
    lookbehind: true
  }],
  // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
  "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
  "number": {
    pattern: RegExp(/(^|[^\w$])/.source + "(?:" + // constant
    (/NaN|Infinity/.source + "|" + // binary integer
    /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
    /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
    /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
    /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
    /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source),
    lookbehind: true
  },
  "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});
Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
Prism.languages.insertBefore("javascript", "keyword", {
  "regex": {
    pattern: RegExp(
      // lookbehind
      // eslint-disable-next-line regexp/no-dupe-characters-character-class
      /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
      // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
      // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
      // with the only syntax, so we have to define 2 different regex patterns.
      /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
      /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
      /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
    ),
    lookbehind: true,
    greedy: true,
    inside: {
      "regex-source": {
        pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
        lookbehind: true,
        alias: "language-regex",
        inside: Prism.languages.regex
      },
      "regex-delimiter": /^\/|\/$/,
      "regex-flags": /^[a-z]+$/
    }
  },
  // This must be declared before keyword because we use "function" inside the look-forward
  "function-variable": {
    pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
    alias: "function"
  },
  "parameter": [{
    pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
    lookbehind: true,
    inside: Prism.languages.javascript
  }, {
    pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
    lookbehind: true,
    inside: Prism.languages.javascript
  }, {
    pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
    lookbehind: true,
    inside: Prism.languages.javascript
  }, {
    pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
    lookbehind: true,
    inside: Prism.languages.javascript
  }],
  "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});
Prism.languages.insertBefore("javascript", "string", {
  "hashbang": {
    pattern: /^#!.*/,
    greedy: true,
    alias: "comment"
  },
  "template-string": {
    pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
    greedy: true,
    inside: {
      "template-punctuation": {
        pattern: /^`|`$/,
        alias: "string"
      },
      "interpolation": {
        pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
        lookbehind: true,
        inside: {
          "interpolation-punctuation": {
            pattern: /^\$\{|\}$/,
            alias: "punctuation"
          },
          rest: Prism.languages.javascript
        }
      },
      "string": /[\s\S]+/
    }
  },
  "string-property": {
    pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
    lookbehind: true,
    greedy: true,
    alias: "property"
  }
});
Prism.languages.insertBefore("javascript", "operator", {
  "literal-property": {
    pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
    lookbehind: true,
    alias: "property"
  }
});
if (Prism.languages.markup) {
  Prism.languages.markup.tag.addInlined("script", "javascript");
  Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript");
}
Prism.languages.js = Prism.languages.javascript;
(function(Prism2) {
  var javascript = Prism2.util.clone(Prism2.languages.javascript);
  var space3 = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source;
  var braces = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source;
  var spread = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
  function re(source, flags) {
    source = source.replace(/<S>/g, function() {
      return space3;
    }).replace(/<BRACES>/g, function() {
      return braces;
    }).replace(/<SPREAD>/g, function() {
      return spread;
    });
    return RegExp(source, flags);
  }
  spread = re(spread).source;
  Prism2.languages.jsx = Prism2.languages.extend("markup", javascript);
  Prism2.languages.jsx.tag.pattern = re(/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source);
  Prism2.languages.jsx.tag.inside["tag"].pattern = /^<\/?[^\s>\/]*/;
  Prism2.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/;
  Prism2.languages.jsx.tag.inside["tag"].inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/;
  Prism2.languages.jsx.tag.inside["comment"] = javascript["comment"];
  Prism2.languages.insertBefore("inside", "attr-name", {
    "spread": {
      pattern: re(/<SPREAD>/.source),
      inside: Prism2.languages.jsx
    }
  }, Prism2.languages.jsx.tag);
  Prism2.languages.insertBefore("inside", "special-attr", {
    "script": {
      // Allow for two levels of nesting
      pattern: re(/=<BRACES>/.source),
      alias: "language-javascript",
      inside: {
        "script-punctuation": {
          pattern: /^=(?=\{)/,
          alias: "punctuation"
        },
        rest: Prism2.languages.jsx
      }
    }
  }, Prism2.languages.jsx.tag);
  var stringifyToken = function(token2) {
    if (!token2) {
      return "";
    }
    if (typeof token2 === "string") {
      return token2;
    }
    if (typeof token2.content === "string") {
      return token2.content;
    }
    return token2.content.map(stringifyToken).join("");
  };
  var walkTokens = function(tokens) {
    var openedTags = [];
    for (var i6 = 0; i6 < tokens.length; i6++) {
      var token2 = tokens[i6];
      var notTagNorBrace = false;
      if (typeof token2 !== "string") {
        if (token2.type === "tag" && token2.content[0] && token2.content[0].type === "tag") {
          if (token2.content[0].content[0].content === "</") {
            if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token2.content[0].content[1])) {
              openedTags.pop();
            }
          } else {
            if (token2.content[token2.content.length - 1].content === "/>")
              ;
            else {
              openedTags.push({
                tagName: stringifyToken(token2.content[0].content[1]),
                openedBraces: 0
              });
            }
          }
        } else if (openedTags.length > 0 && token2.type === "punctuation" && token2.content === "{") {
          openedTags[openedTags.length - 1].openedBraces++;
        } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token2.type === "punctuation" && token2.content === "}") {
          openedTags[openedTags.length - 1].openedBraces--;
        } else {
          notTagNorBrace = true;
        }
      }
      if (notTagNorBrace || typeof token2 === "string") {
        if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {
          var plainText = stringifyToken(token2);
          if (i6 < tokens.length - 1 && (typeof tokens[i6 + 1] === "string" || tokens[i6 + 1].type === "plain-text")) {
            plainText += stringifyToken(tokens[i6 + 1]);
            tokens.splice(i6 + 1, 1);
          }
          if (i6 > 0 && (typeof tokens[i6 - 1] === "string" || tokens[i6 - 1].type === "plain-text")) {
            plainText = stringifyToken(tokens[i6 - 1]) + plainText;
            tokens.splice(i6 - 1, 1);
            i6--;
          }
          tokens[i6] = new Prism2.Token("plain-text", plainText, null, plainText);
        }
      }
      if (token2.content && typeof token2.content !== "string") {
        walkTokens(token2.content);
      }
    }
  };
  Prism2.hooks.add("after-tokenize", function(env) {
    if (env.language !== "jsx" && env.language !== "tsx") {
      return;
    }
    walkTokens(env.tokens);
  });
})(Prism);
Prism.languages.json = {
  "property": {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
    lookbehind: true,
    greedy: true
  },
  "string": {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
    lookbehind: true,
    greedy: true
  },
  "comment": {
    pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: true
  },
  "number": /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
  "punctuation": /[{}[\],]/,
  "operator": /:/,
  "boolean": /\b(?:false|true)\b/,
  "null": {
    pattern: /\bnull\b/,
    alias: "keyword"
  }
};
Prism.languages.webmanifest = Prism.languages.json;
(function(Prism2) {
  Prism2.languages.kotlin = Prism2.languages.extend("clike", {
    "keyword": {
      // The lookbehind prevents wrong highlighting of e.g. kotlin.properties.get
      pattern: /(^|[^.])\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\b/,
      lookbehind: true
    },
    "function": [{
      pattern: /(?:`[^\r\n`]+`|\b\w+)(?=\s*\()/,
      greedy: true
    }, {
      pattern: /(\.)(?:`[^\r\n`]+`|\w+)(?=\s*\{)/,
      lookbehind: true,
      greedy: true
    }],
    "number": /\b(?:0[xX][\da-fA-F]+(?:_[\da-fA-F]+)*|0[bB][01]+(?:_[01]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?[fFL]?)\b/,
    "operator": /\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\/*%<>]=?|[?:]:?|\.\.|&&|\|\||\b(?:and|inv|or|shl|shr|ushr|xor)\b/
  });
  delete Prism2.languages.kotlin["class-name"];
  var interpolationInside = {
    "interpolation-punctuation": {
      pattern: /^\$\{?|\}$/,
      alias: "punctuation"
    },
    "expression": {
      pattern: /[\s\S]+/,
      inside: Prism2.languages.kotlin
    }
  };
  Prism2.languages.insertBefore("kotlin", "string", {
    // https://kotlinlang.org/spec/expressions.html#string-interpolation-expressions
    "string-literal": [{
      pattern: /"""(?:[^$]|\$(?:(?!\{)|\{[^{}]*\}))*?"""/,
      alias: "multiline",
      inside: {
        "interpolation": {
          pattern: /\$(?:[a-z_]\w*|\{[^{}]*\})/i,
          inside: interpolationInside
        },
        "string": /[\s\S]+/
      }
    }, {
      pattern: /"(?:[^"\\\r\n$]|\\.|\$(?:(?!\{)|\{[^{}]*\}))*"/,
      alias: "singleline",
      inside: {
        "interpolation": {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:[a-z_]\w*|\{[^{}]*\})/i,
          lookbehind: true,
          inside: interpolationInside
        },
        "string": /[\s\S]+/
      }
    }],
    "char": {
      // https://kotlinlang.org/spec/expressions.html#character-literals
      pattern: /'(?:[^'\\\r\n]|\\(?:.|u[a-fA-F0-9]{0,4}))'/,
      greedy: true
    }
  });
  delete Prism2.languages.kotlin["string"];
  Prism2.languages.insertBefore("kotlin", "keyword", {
    "annotation": {
      pattern: /\B@(?:\w+:)?(?:[A-Z]\w*|\[[^\]]+\])/,
      alias: "builtin"
    }
  });
  Prism2.languages.insertBefore("kotlin", "function", {
    "label": {
      pattern: /\b\w+@|@\w+\b/,
      alias: "symbol"
    }
  });
  Prism2.languages.kt = Prism2.languages.kotlin;
  Prism2.languages.kts = Prism2.languages.kotlin;
})(Prism);
Prism.languages.less = Prism.languages.extend("css", {
  "comment": [/\/\*[\s\S]*?\*\//, {
    pattern: /(^|[^\\])\/\/.*/,
    lookbehind: true
  }],
  "atrule": {
    pattern: /@[\w-](?:\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};\s]|\s+(?!\s))*?(?=\s*\{)/,
    inside: {
      "punctuation": /[:()]/
    }
  },
  // selectors and mixins are considered the same
  "selector": {
    pattern: /(?:@\{[\w-]+\}|[^{};\s@])(?:@\{[\w-]+\}|\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};@\s]|\s+(?!\s))*?(?=\s*\{)/,
    inside: {
      // mixin parameters
      "variable": /@+[\w-]+/
    }
  },
  "property": /(?:@\{[\w-]+\}|[\w-])+(?:\+_?)?(?=\s*:)/,
  "operator": /[+\-*\/]/
});
Prism.languages.insertBefore("less", "property", {
  "variable": [
    // Variable declaration (the colon must be consumed!)
    {
      pattern: /@[\w-]+\s*:/,
      inside: {
        "punctuation": /:/
      }
    },
    // Variable usage
    /@@?[\w-]+/
  ],
  "mixin-usage": {
    pattern: /([{;]\s*)[.#](?!\d)[\w-].*?(?=[(;])/,
    lookbehind: true,
    alias: "function"
  }
});
Prism.languages.lua = {
  "comment": /^#!.+|--(?:\[(=*)\[[\s\S]*?\]\1\]|.*)/m,
  // \z may be used to skip the following space
  "string": {
    pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\z(?:\r\n|\s)|\\(?:\r\n|[^z]))*\1|\[(=*)\[[\s\S]*?\]\2\]/,
    greedy: true
  },
  "number": /\b0x[a-f\d]+(?:\.[a-f\d]*)?(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|(?:\.\d*)?(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,
  "keyword": /\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,
  "function": /(?!\d)\w+(?=\s*(?:[({]))/,
  "operator": [/[-+*%^&|#]|\/\/?|<[<=]?|>[>=]?|[=~]=?/, {
    // Match ".." but don't break "..."
    pattern: /(^|[^.])\.\.(?!\.)/,
    lookbehind: true
  }],
  "punctuation": /[\[\](){},;]|\.+|:+/
};
Prism.languages.makefile = {
  "comment": {
    pattern: /(^|[^\\])#(?:\\(?:\r\n|[\s\S])|[^\\\r\n])*/,
    lookbehind: true
  },
  "string": {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  "builtin-target": {
    pattern: /\.[A-Z][^:#=\s]+(?=\s*:(?!=))/,
    alias: "builtin"
  },
  "target": {
    pattern: /^(?:[^:=\s]|[ \t]+(?![\s:]))+(?=\s*:(?!=))/m,
    alias: "symbol",
    inside: {
      "variable": /\$+(?:(?!\$)[^(){}:#=\s]+|(?=[({]))/
    }
  },
  "variable": /\$+(?:(?!\$)[^(){}:#=\s]+|\([@*%<^+?][DF]\)|(?=[({]))/,
  // Directives
  "keyword": /-include\b|\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\b/,
  "function": {
    pattern: /(\()(?:abspath|addsuffix|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:list|s)?)(?=[ \t])/,
    lookbehind: true
  },
  "operator": /(?:::|[?:+!])?=|[|@]/,
  "punctuation": /[:;(){}]/
};
(function(Prism2) {
  var anchorOrAlias = /[*&][^\s[\]{},]+/;
  var tag2 = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/;
  var properties = "(?:" + tag2.source + "(?:[ 	]+" + anchorOrAlias.source + ")?|" + anchorOrAlias.source + "(?:[ 	]+" + tag2.source + ")?)";
  var plainKey = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
    return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
  });
  var string3 = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
  function createValuePattern(value2, flags) {
    flags = (flags || "").replace(/m/g, "") + "m";
    var pattern = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
      return properties;
    }).replace(/<<value>>/g, function() {
      return value2;
    });
    return RegExp(pattern, flags);
  }
  Prism2.languages.yaml = {
    "scalar": {
      pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
        return properties;
      })),
      lookbehind: true,
      alias: "string"
    },
    "comment": /#.*/,
    "key": {
      pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
        return properties;
      }).replace(/<<key>>/g, function() {
        return "(?:" + plainKey + "|" + string3 + ")";
      })),
      lookbehind: true,
      greedy: true,
      alias: "atrule"
    },
    "directive": {
      pattern: /(^[ \t]*)%.+/m,
      lookbehind: true,
      alias: "important"
    },
    "datetime": {
      pattern: createValuePattern(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source),
      lookbehind: true,
      alias: "number"
    },
    "boolean": {
      pattern: createValuePattern(/false|true/.source, "i"),
      lookbehind: true,
      alias: "important"
    },
    "null": {
      pattern: createValuePattern(/null|~/.source, "i"),
      lookbehind: true,
      alias: "important"
    },
    "string": {
      pattern: createValuePattern(string3),
      lookbehind: true,
      greedy: true
    },
    "number": {
      pattern: createValuePattern(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"),
      lookbehind: true
    },
    "tag": tag2,
    "important": anchorOrAlias,
    "punctuation": /---|[:[\]{}\-,|>?]|\.\.\./
  };
  Prism2.languages.yml = Prism2.languages.yaml;
})(Prism);
(function(Prism2) {
  var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
  function createInline(pattern) {
    pattern = pattern.replace(/<inner>/g, function() {
      return inner;
    });
    return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + pattern + ")");
  }
  var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
  var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
    return tableCell;
  });
  var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
  Prism2.languages.markdown = Prism2.languages.extend("markup", {});
  Prism2.languages.insertBefore("markdown", "prolog", {
    "front-matter-block": {
      pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
      lookbehind: true,
      greedy: true,
      inside: {
        "punctuation": /^---|---$/,
        "front-matter": {
          pattern: /\S+(?:\s+\S+)*/,
          alias: ["yaml", "language-yaml"],
          inside: Prism2.languages.yaml
        }
      }
    },
    "blockquote": {
      // > ...
      pattern: /^>(?:[\t ]*>)*/m,
      alias: "punctuation"
    },
    "table": {
      pattern: RegExp("^" + tableRow + tableLine + "(?:" + tableRow + ")*", "m"),
      inside: {
        "table-data-rows": {
          pattern: RegExp("^(" + tableRow + tableLine + ")(?:" + tableRow + ")*$"),
          lookbehind: true,
          inside: {
            "table-data": {
              pattern: RegExp(tableCell),
              inside: Prism2.languages.markdown
            },
            "punctuation": /\|/
          }
        },
        "table-line": {
          pattern: RegExp("^(" + tableRow + ")" + tableLine + "$"),
          lookbehind: true,
          inside: {
            "punctuation": /\||:?-{3,}:?/
          }
        },
        "table-header-row": {
          pattern: RegExp("^" + tableRow + "$"),
          inside: {
            "table-header": {
              pattern: RegExp(tableCell),
              alias: "important",
              inside: Prism2.languages.markdown
            },
            "punctuation": /\|/
          }
        }
      }
    },
    "code": [{
      // Prefixed by 4 spaces or 1 tab and preceded by an empty line
      pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
      lookbehind: true,
      alias: "keyword"
    }, {
      // ```optional language
      // code block
      // ```
      pattern: /^```[\s\S]*?^```$/m,
      greedy: true,
      inside: {
        "code-block": {
          pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
          lookbehind: true
        },
        "code-language": {
          pattern: /^(```).+/,
          lookbehind: true
        },
        "punctuation": /```/
      }
    }],
    "title": [{
      // title 1
      // =======
      // title 2
      // -------
      pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
      alias: "important",
      inside: {
        punctuation: /==+$|--+$/
      }
    }, {
      // # title 1
      // ###### title 6
      pattern: /(^\s*)#.+/m,
      lookbehind: true,
      alias: "important",
      inside: {
        punctuation: /^#+|#+$/
      }
    }],
    "hr": {
      // ***
      // ---
      // * * *
      // -----------
      pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
      lookbehind: true,
      alias: "punctuation"
    },
    "list": {
      // * item
      // + item
      // - item
      // 1. item
      pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
      lookbehind: true,
      alias: "punctuation"
    },
    "url-reference": {
      // [id]: http://example.com "Optional title"
      // [id]: http://example.com 'Optional title'
      // [id]: http://example.com (Optional title)
      // [id]: <http://example.com> "Optional title"
      pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
      inside: {
        "variable": {
          pattern: /^(!?\[)[^\]]+/,
          lookbehind: true
        },
        "string": /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
        "punctuation": /^[\[\]!:]|[<>]/
      },
      alias: "url"
    },
    "bold": {
      // **strong**
      // __strong__
      // allow one nested instance of italic text using the same delimiter
      pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^..)[\s\S]+(?=..$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /\*\*|__/
      }
    },
    "italic": {
      // *em*
      // _em_
      // allow one nested instance of bold text using the same delimiter
      pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^.)[\s\S]+(?=.$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /[*_]/
      }
    },
    "strike": {
      // ~~strike through~~
      // ~strike~
      // eslint-disable-next-line regexp/strict
      pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^~~?)[\s\S]+(?=\1$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /~~?/
      }
    },
    "code-snippet": {
      // `code`
      // ``code``
      pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
      lookbehind: true,
      greedy: true,
      alias: ["code", "keyword"]
    },
    "url": {
      // [example](http://example.com "Optional title")
      // [example][id]
      // [example] [id]
      pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "operator": /^!/,
        "content": {
          pattern: /(^\[)[^\]]+(?=\])/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "variable": {
          pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
          lookbehind: true
        },
        "url": {
          pattern: /(^\]\()[^\s)]+/,
          lookbehind: true
        },
        "string": {
          pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
          lookbehind: true
        }
      }
    }
  });
  ["url", "bold", "italic", "strike"].forEach(function(token2) {
    ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(inside) {
      if (token2 !== inside) {
        Prism2.languages.markdown[token2].inside.content.inside[inside] = Prism2.languages.markdown[inside];
      }
    });
  });
  Prism2.hooks.add("after-tokenize", function(env) {
    if (env.language !== "markdown" && env.language !== "md") {
      return;
    }
    function walkTokens(tokens) {
      if (!tokens || typeof tokens === "string") {
        return;
      }
      for (var i6 = 0, l7 = tokens.length; i6 < l7; i6++) {
        var token2 = tokens[i6];
        if (token2.type !== "code") {
          walkTokens(token2.content);
          continue;
        }
        var codeLang = token2.content[1];
        var codeBlock = token2.content[3];
        if (codeLang && codeBlock && codeLang.type === "code-language" && codeBlock.type === "code-block" && typeof codeLang.content === "string") {
          var lang = codeLang.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
          lang = (/[a-z][\w-]*/i.exec(lang) || [""])[0].toLowerCase();
          var alias = "language-" + lang;
          if (!codeBlock.alias) {
            codeBlock.alias = [alias];
          } else if (typeof codeBlock.alias === "string") {
            codeBlock.alias = [codeBlock.alias, alias];
          } else {
            codeBlock.alias.push(alias);
          }
        }
      }
    }
    walkTokens(env.tokens);
  });
  Prism2.hooks.add("wrap", function(env) {
    if (env.type !== "code-block") {
      return;
    }
    var codeLang = "";
    for (var i6 = 0, l7 = env.classes.length; i6 < l7; i6++) {
      var cls = env.classes[i6];
      var match3 = /language-(.+)/.exec(cls);
      if (match3) {
        codeLang = match3[1];
        break;
      }
    }
    var grammar = Prism2.languages[codeLang];
    if (!grammar) {
      if (codeLang && codeLang !== "none" && Prism2.plugins.autoloader) {
        var id2 = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(Math.random() * 1e16);
        env.attributes["id"] = id2;
        Prism2.plugins.autoloader.loadLanguages(codeLang, function() {
          var ele = document.getElementById(id2);
          if (ele) {
            ele.innerHTML = Prism2.highlight(ele.textContent, Prism2.languages[codeLang], codeLang);
          }
        });
      }
    } else {
      env.content = Prism2.highlight(textContent(env.content), grammar, codeLang);
    }
  });
  var tagPattern = RegExp(Prism2.languages.markup.tag.pattern.source, "gi");
  var KNOWN_ENTITY_NAMES = {
    "amp": "&",
    "lt": "<",
    "gt": ">",
    "quot": '"'
  };
  var fromCodePoint4 = String.fromCodePoint || String.fromCharCode;
  function textContent(html) {
    var text7 = html.replace(tagPattern, "");
    text7 = text7.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(m3, code3) {
      code3 = code3.toLowerCase();
      if (code3[0] === "#") {
        var value2;
        if (code3[1] === "x") {
          value2 = parseInt(code3.slice(2), 16);
        } else {
          value2 = Number(code3.slice(1));
        }
        return fromCodePoint4(value2);
      } else {
        var known = KNOWN_ENTITY_NAMES[code3];
        if (known) {
          return known;
        }
        return m3;
      }
    });
    return text7;
  }
  Prism2.languages.md = Prism2.languages.markdown;
})(Prism);
Prism.languages.objectivec = Prism.languages.extend("c", {
  "string": {
    pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    greedy: true
  },
  "keyword": /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
  "operator": /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
});
delete Prism.languages.objectivec["class-name"];
Prism.languages.objc = Prism.languages.objectivec;
(function(Prism2) {
  var brackets = /(?:\((?:[^()\\]|\\[\s\S])*\)|\{(?:[^{}\\]|\\[\s\S])*\}|\[(?:[^[\]\\]|\\[\s\S])*\]|<(?:[^<>\\]|\\[\s\S])*>)/.source;
  Prism2.languages.perl = {
    "comment": [{
      // POD
      pattern: /(^\s*)=\w[\s\S]*?=cut.*/m,
      lookbehind: true,
      greedy: true
    }, {
      pattern: /(^|[^\\$])#.*/,
      lookbehind: true,
      greedy: true
    }],
    // TODO Could be nice to handle Heredoc too.
    "string": [
      {
        pattern: RegExp(/\b(?:q|qq|qw|qx)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
          // q/.../
          /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
          // q a...a
          // eslint-disable-next-line regexp/strict
          /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
          // q(...)
          // q{...}
          // q[...]
          // q<...>
          brackets
        ].join("|") + ")"),
        greedy: true
      },
      // "...", `...`
      {
        pattern: /("|`)(?:(?!\1)[^\\]|\\[\s\S])*\1/,
        greedy: true
      },
      // '...'
      // FIXME Multi-line single-quoted strings are not supported as they would break variables containing '
      {
        pattern: /'(?:[^'\\\r\n]|\\.)*'/,
        greedy: true
      }
    ],
    "regex": [
      {
        pattern: RegExp(/\b(?:m|qr)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
          // m/.../
          /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
          // m a...a
          // eslint-disable-next-line regexp/strict
          /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
          // m(...)
          // m{...}
          // m[...]
          // m<...>
          brackets
        ].join("|") + ")" + /[msixpodualngc]*/.source),
        greedy: true
      },
      // The lookbehinds prevent -s from breaking
      {
        pattern: RegExp(/(^|[^-])\b(?:s|tr|y)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
          // s/.../.../
          // eslint-disable-next-line regexp/strict
          /([^a-zA-Z0-9\s{(\[<])(?:(?!\2)[^\\]|\\[\s\S])*\2(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
          // s a...a...a
          // eslint-disable-next-line regexp/strict
          /([a-zA-Z0-9])(?:(?!\3)[^\\]|\\[\s\S])*\3(?:(?!\3)[^\\]|\\[\s\S])*\3/.source,
          // s(...)(...)
          // s{...}{...}
          // s[...][...]
          // s<...><...>
          // s(...)[...]
          brackets + /\s*/.source + brackets
        ].join("|") + ")" + /[msixpodualngcer]*/.source),
        lookbehind: true,
        greedy: true
      },
      // /.../
      // The look-ahead tries to prevent two divisions on
      // the same line from being highlighted as regex.
      // This does not support multi-line regex.
      {
        pattern: /\/(?:[^\/\\\r\n]|\\.)*\/[msixpodualngc]*(?=\s*(?:$|[\r\n,.;})&|\-+*~<>!?^]|(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|x|xor)\b))/,
        greedy: true
      }
    ],
    // FIXME Not sure about the handling of ::, ', and #
    "variable": [
      // ${^POSTMATCH}
      /[&*$@%]\{\^[A-Z]+\}/,
      // $^V
      /[&*$@%]\^[A-Z_]/,
      // ${...}
      /[&*$@%]#?(?=\{)/,
      // $foo
      /[&*$@%]#?(?:(?:::)*'?(?!\d)[\w$]+(?![\w$]))+(?:::)*/,
      // $1
      /[&*$@%]\d+/,
      // $_, @_, %!
      // The negative lookahead prevents from breaking the %= operator
      /(?!%=)[$@%][!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~]/
    ],
    "filehandle": {
      // <>, <FOO>, _
      pattern: /<(?![<=])\S*?>|\b_\b/,
      alias: "symbol"
    },
    "v-string": {
      // v1.2, 1.2.3
      pattern: /v\d+(?:\.\d+)*|\d+(?:\.\d+){2,}/,
      alias: "string"
    },
    "function": {
      pattern: /(\bsub[ \t]+)\w+/,
      lookbehind: true
    },
    "keyword": /\b(?:any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while)\b/,
    "number": /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)\b/,
    "operator": /-[rwxoRWXOezsfdlpSbctugkTBMAC]\b|\+[+=]?|-[-=>]?|\*\*?=?|\/\/?=?|=[=~>]?|~[~=]?|\|\|?=?|&&?=?|<(?:=>?|<=?)?|>>?=?|![~=]?|[%^]=?|\.(?:=|\.\.?)?|[\\?]|\bx(?:=|\b)|\b(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|xor)\b/,
    "punctuation": /[{}[\];(),:]/
  };
})(Prism);
(function(Prism2) {
  function getPlaceholder(language, index3) {
    return "___" + language.toUpperCase() + index3 + "___";
  }
  Object.defineProperties(Prism2.languages["markup-templating"] = {}, {
    buildPlaceholders: {
      /**
       * Tokenize all inline templating expressions matching `placeholderPattern`.
       *
       * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns
       * `true` will be replaced.
       *
       * @param {object} env The environment of the `before-tokenize` hook.
       * @param {string} language The language id.
       * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.
       * @param {(match: string) => boolean} [replaceFilter]
       */
      value: function(env, language, placeholderPattern, replaceFilter) {
        if (env.language !== language) {
          return;
        }
        var tokenStack = env.tokenStack = [];
        env.code = env.code.replace(placeholderPattern, function(match3) {
          if (typeof replaceFilter === "function" && !replaceFilter(match3)) {
            return match3;
          }
          var i6 = tokenStack.length;
          var placeholder;
          while (env.code.indexOf(placeholder = getPlaceholder(language, i6)) !== -1) {
            ++i6;
          }
          tokenStack[i6] = match3;
          return placeholder;
        });
        env.grammar = Prism2.languages.markup;
      }
    },
    tokenizePlaceholders: {
      /**
       * Replace placeholders with proper tokens after tokenizing.
       *
       * @param {object} env The environment of the `after-tokenize` hook.
       * @param {string} language The language id.
       */
      value: function(env, language) {
        if (env.language !== language || !env.tokenStack) {
          return;
        }
        env.grammar = Prism2.languages[language];
        var j4 = 0;
        var keys3 = Object.keys(env.tokenStack);
        function walkTokens(tokens) {
          for (var i6 = 0; i6 < tokens.length; i6++) {
            if (j4 >= keys3.length) {
              break;
            }
            var token2 = tokens[i6];
            if (typeof token2 === "string" || token2.content && typeof token2.content === "string") {
              var k2 = keys3[j4];
              var t5 = env.tokenStack[k2];
              var s4 = typeof token2 === "string" ? token2 : token2.content;
              var placeholder = getPlaceholder(language, k2);
              var index3 = s4.indexOf(placeholder);
              if (index3 > -1) {
                ++j4;
                var before = s4.substring(0, index3);
                var middle = new Prism2.Token(language, Prism2.tokenize(t5, env.grammar), "language-" + language, t5);
                var after = s4.substring(index3 + placeholder.length);
                var replacement = [];
                if (before) {
                  replacement.push.apply(replacement, walkTokens([before]));
                }
                replacement.push(middle);
                if (after) {
                  replacement.push.apply(replacement, walkTokens([after]));
                }
                if (typeof token2 === "string") {
                  tokens.splice.apply(tokens, [i6, 1].concat(replacement));
                } else {
                  token2.content = replacement;
                }
              }
            } else if (token2.content) {
              walkTokens(token2.content);
            }
          }
          return tokens;
        }
        walkTokens(env.tokens);
      }
    }
  });
})(Prism);
(function(Prism2) {
  var comment3 = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/;
  var constant = [{
    pattern: /\b(?:false|true)\b/i,
    alias: "boolean"
  }, {
    pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i,
    greedy: true,
    lookbehind: true
  }, {
    pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i,
    greedy: true,
    lookbehind: true
  }, /\b(?:null)\b/i, /\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/];
  var number = /\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i;
  var operator = /<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/;
  var punctuation = /[{}\[\](),:;]/;
  Prism2.languages.php = {
    "delimiter": {
      pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i,
      alias: "important"
    },
    "comment": comment3,
    "variable": /\$+(?:\w+\b|(?=\{))/,
    "package": {
      pattern: /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
      lookbehind: true,
      inside: {
        "punctuation": /\\/
      }
    },
    "class-name-definition": {
      pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i,
      lookbehind: true,
      alias: "class-name"
    },
    "function-definition": {
      pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i,
      lookbehind: true,
      alias: "function"
    },
    "keyword": [
      {
        pattern: /(\(\s*)\b(?:array|bool|boolean|float|int|integer|object|string)\b(?=\s*\))/i,
        alias: "type-casting",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /([(,?]\s*)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string)\b(?=\s*\$)/i,
        alias: "type-hint",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /(\)\s*:\s*(?:\?\s*)?)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|never|object|self|static|string|void)\b/i,
        alias: "return-type",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /\b(?:array(?!\s*\()|bool|float|int|iterable|mixed|object|string|void)\b/i,
        alias: "type-declaration",
        greedy: true
      },
      {
        pattern: /(\|\s*)(?:false|null)\b|\b(?:false|null)(?=\s*\|)/i,
        alias: "type-declaration",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /\b(?:parent|self|static)(?=\s*::)/i,
        alias: "static-context",
        greedy: true
      },
      {
        // yield from
        pattern: /(\byield\s+)from\b/i,
        lookbehind: true
      },
      // `class` is always a keyword unlike other keywords
      /\bclass\b/i,
      {
        // https://www.php.net/manual/en/reserved.keywords.php
        //
        // keywords cannot be preceded by "->"
        // the complex lookbehind means `(?<!(?:->|::)\s*)`
        pattern: /((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|never|new|or|parent|print|private|protected|public|readonly|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\b/i,
        lookbehind: true
      }
    ],
    "argument-name": {
      pattern: /([(,]\s*)\b[a-z_]\w*(?=\s*:(?!:))/i,
      lookbehind: true
    },
    "class-name": [{
      pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i,
      greedy: true,
      lookbehind: true
    }, {
      pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i,
      greedy: true,
      lookbehind: true
    }, {
      pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i,
      greedy: true
    }, {
      pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i,
      alias: "class-name-fully-qualified",
      greedy: true,
      lookbehind: true,
      inside: {
        "punctuation": /\\/
      }
    }, {
      pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i,
      alias: "class-name-fully-qualified",
      greedy: true,
      inside: {
        "punctuation": /\\/
      }
    }, {
      pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
      alias: "class-name-fully-qualified",
      greedy: true,
      lookbehind: true,
      inside: {
        "punctuation": /\\/
      }
    }, {
      pattern: /\b[a-z_]\w*(?=\s*\$)/i,
      alias: "type-declaration",
      greedy: true
    }, {
      pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
      alias: ["class-name-fully-qualified", "type-declaration"],
      greedy: true,
      inside: {
        "punctuation": /\\/
      }
    }, {
      pattern: /\b[a-z_]\w*(?=\s*::)/i,
      alias: "static-context",
      greedy: true
    }, {
      pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i,
      alias: ["class-name-fully-qualified", "static-context"],
      greedy: true,
      inside: {
        "punctuation": /\\/
      }
    }, {
      pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i,
      alias: "type-hint",
      greedy: true,
      lookbehind: true
    }, {
      pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
      alias: ["class-name-fully-qualified", "type-hint"],
      greedy: true,
      lookbehind: true,
      inside: {
        "punctuation": /\\/
      }
    }, {
      pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i,
      alias: "return-type",
      greedy: true,
      lookbehind: true
    }, {
      pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
      alias: ["class-name-fully-qualified", "return-type"],
      greedy: true,
      lookbehind: true,
      inside: {
        "punctuation": /\\/
      }
    }],
    "constant": constant,
    "function": {
      pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i,
      lookbehind: true,
      inside: {
        "punctuation": /\\/
      }
    },
    "property": {
      pattern: /(->\s*)\w+/,
      lookbehind: true
    },
    "number": number,
    "operator": operator,
    "punctuation": punctuation
  };
  var string_interpolation = {
    pattern: /\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/,
    lookbehind: true,
    inside: Prism2.languages.php
  };
  var string3 = [{
    pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
    alias: "nowdoc-string",
    greedy: true,
    inside: {
      "delimiter": {
        pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
        alias: "symbol",
        inside: {
          "punctuation": /^<<<'?|[';]$/
        }
      }
    }
  }, {
    pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
    alias: "heredoc-string",
    greedy: true,
    inside: {
      "delimiter": {
        pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
        alias: "symbol",
        inside: {
          "punctuation": /^<<<"?|[";]$/
        }
      },
      "interpolation": string_interpolation
    }
  }, {
    pattern: /`(?:\\[\s\S]|[^\\`])*`/,
    alias: "backtick-quoted-string",
    greedy: true
  }, {
    pattern: /'(?:\\[\s\S]|[^\\'])*'/,
    alias: "single-quoted-string",
    greedy: true
  }, {
    pattern: /"(?:\\[\s\S]|[^\\"])*"/,
    alias: "double-quoted-string",
    greedy: true,
    inside: {
      "interpolation": string_interpolation
    }
  }];
  Prism2.languages.insertBefore("php", "variable", {
    "string": string3,
    "attribute": {
      pattern: /#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,
      greedy: true,
      inside: {
        "attribute-content": {
          pattern: /^(#\[)[\s\S]+(?=\]$)/,
          lookbehind: true,
          // inside can appear subset of php
          inside: {
            "comment": comment3,
            "string": string3,
            "attribute-class-name": [{
              pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i,
              alias: "class-name",
              greedy: true,
              lookbehind: true
            }, {
              pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i,
              alias: ["class-name", "class-name-fully-qualified"],
              greedy: true,
              lookbehind: true,
              inside: {
                "punctuation": /\\/
              }
            }],
            "constant": constant,
            "number": number,
            "operator": operator,
            "punctuation": punctuation
          }
        },
        "delimiter": {
          pattern: /^#\[|\]$/,
          alias: "punctuation"
        }
      }
    }
  });
  Prism2.hooks.add("before-tokenize", function(env) {
    if (!/<\?/.test(env.code)) {
      return;
    }
    var phpPattern = /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/g;
    Prism2.languages["markup-templating"].buildPlaceholders(env, "php", phpPattern);
  });
  Prism2.hooks.add("after-tokenize", function(env) {
    Prism2.languages["markup-templating"].tokenizePlaceholders(env, "php");
  });
})(Prism);
Prism.languages.python = {
  "comment": {
    pattern: /(^|[^\\])#.*/,
    lookbehind: true,
    greedy: true
  },
  "string-interpolation": {
    pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
    greedy: true,
    inside: {
      "interpolation": {
        // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
        pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
        lookbehind: true,
        inside: {
          "format-spec": {
            pattern: /(:)[^:(){}]+(?=\}$)/,
            lookbehind: true
          },
          "conversion-option": {
            pattern: /![sra](?=[:}]$)/,
            alias: "punctuation"
          },
          rest: null
        }
      },
      "string": /[\s\S]+/
    }
  },
  "triple-quoted-string": {
    pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
    greedy: true,
    alias: "string"
  },
  "string": {
    pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
    greedy: true
  },
  "function": {
    pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
    lookbehind: true
  },
  "class-name": {
    pattern: /(\bclass\s+)\w+/i,
    lookbehind: true
  },
  "decorator": {
    pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
    lookbehind: true,
    alias: ["annotation", "punctuation"],
    inside: {
      "punctuation": /\./
    }
  },
  "keyword": /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
  "builtin": /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
  "boolean": /\b(?:False|None|True)\b/,
  "number": /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
  "operator": /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
  "punctuation": /[{}[\];(),.:]/
};
Prism.languages.python["string-interpolation"].inside["interpolation"].inside.rest = Prism.languages.python;
Prism.languages.py = Prism.languages.python;
Prism.languages.r = {
  "comment": /#.*/,
  "string": {
    pattern: /(['"])(?:\\.|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  "percent-operator": {
    // Includes user-defined operators
    // and %%, %*%, %/%, %in%, %o%, %x%
    pattern: /%[^%\s]*%/,
    alias: "operator"
  },
  "boolean": /\b(?:FALSE|TRUE)\b/,
  "ellipsis": /\.\.(?:\.|\d+)/,
  "number": [/\b(?:Inf|NaN)\b/, /(?:\b0x[\dA-Fa-f]+(?:\.\d*)?|\b\d+(?:\.\d*)?|\B\.\d+)(?:[EePp][+-]?\d+)?[iL]?/],
  "keyword": /\b(?:NA|NA_character_|NA_complex_|NA_integer_|NA_real_|NULL|break|else|for|function|if|in|next|repeat|while)\b/,
  "operator": /->?>?|<(?:=|<?-)?|[>=!]=?|::?|&&?|\|\|?|[+*\/^$@~]/,
  "punctuation": /[(){}\[\],;]/
};
(function(Prism2) {
  Prism2.languages.ruby = Prism2.languages.extend("clike", {
    "comment": {
      pattern: /#.*|^=begin\s[\s\S]*?^=end/m,
      greedy: true
    },
    "class-name": {
      pattern: /(\b(?:class|module)\s+|\bcatch\s+\()[\w.\\]+|\b[A-Z_]\w*(?=\s*\.\s*new\b)/,
      lookbehind: true,
      inside: {
        "punctuation": /[.\\]/
      }
    },
    "keyword": /\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/,
    "operator": /\.{2,3}|&\.|===|<?=>|[!=]?~|(?:&&|\|\||<<|>>|\*\*|[+\-*/%<>!^&|=])=?|[?:]/,
    "punctuation": /[(){}[\].,;]/
  });
  Prism2.languages.insertBefore("ruby", "operator", {
    "double-colon": {
      pattern: /::/,
      alias: "punctuation"
    }
  });
  var interpolation = {
    pattern: /((?:^|[^\\])(?:\\{2})*)#\{(?:[^{}]|\{[^{}]*\})*\}/,
    lookbehind: true,
    inside: {
      "content": {
        pattern: /^(#\{)[\s\S]+(?=\}$)/,
        lookbehind: true,
        inside: Prism2.languages.ruby
      },
      "delimiter": {
        pattern: /^#\{|\}$/,
        alias: "punctuation"
      }
    }
  };
  delete Prism2.languages.ruby.function;
  var percentExpression = "(?:" + [/([^a-zA-Z0-9\s{(\[<=])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source, /\((?:[^()\\]|\\[\s\S]|\((?:[^()\\]|\\[\s\S])*\))*\)/.source, /\{(?:[^{}\\]|\\[\s\S]|\{(?:[^{}\\]|\\[\s\S])*\})*\}/.source, /\[(?:[^\[\]\\]|\\[\s\S]|\[(?:[^\[\]\\]|\\[\s\S])*\])*\]/.source, /<(?:[^<>\\]|\\[\s\S]|<(?:[^<>\\]|\\[\s\S])*>)*>/.source].join("|") + ")";
  var symbolName = /(?:"(?:\\.|[^"\\\r\n])*"|(?:\b[a-zA-Z_]\w*|[^\s\0-\x7F]+)[?!]?|\$.)/.source;
  Prism2.languages.insertBefore("ruby", "keyword", {
    "regex-literal": [{
      pattern: RegExp(/%r/.source + percentExpression + /[egimnosux]{0,6}/.source),
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "regex": /[\s\S]+/
      }
    }, {
      pattern: /(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,
      lookbehind: true,
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "regex": /[\s\S]+/
      }
    }],
    "variable": /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
    "symbol": [{
      pattern: RegExp(/(^|[^:]):/.source + symbolName),
      lookbehind: true,
      greedy: true
    }, {
      pattern: RegExp(/([\r\n{(,][ \t]*)/.source + symbolName + /(?=:(?!:))/.source),
      lookbehind: true,
      greedy: true
    }],
    "method-definition": {
      pattern: /(\bdef\s+)\w+(?:\s*\.\s*\w+)?/,
      lookbehind: true,
      inside: {
        "function": /\b\w+$/,
        "keyword": /^self\b/,
        "class-name": /^\w+/,
        "punctuation": /\./
      }
    }
  });
  Prism2.languages.insertBefore("ruby", "string", {
    "string-literal": [{
      pattern: RegExp(/%[qQiIwWs]?/.source + percentExpression),
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "string": /[\s\S]+/
      }
    }, {
      pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "string": /[\s\S]+/
      }
    }, {
      pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
      alias: "heredoc-string",
      greedy: true,
      inside: {
        "delimiter": {
          pattern: /^<<[-~]?[a-z_]\w*|\b[a-z_]\w*$/i,
          inside: {
            "symbol": /\b\w+/,
            "punctuation": /^<<[-~]?/
          }
        },
        "interpolation": interpolation,
        "string": /[\s\S]+/
      }
    }, {
      pattern: /<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
      alias: "heredoc-string",
      greedy: true,
      inside: {
        "delimiter": {
          pattern: /^<<[-~]?'[a-z_]\w*'|\b[a-z_]\w*$/i,
          inside: {
            "symbol": /\b\w+/,
            "punctuation": /^<<[-~]?'|'$/
          }
        },
        "string": /[\s\S]+/
      }
    }],
    "command-literal": [{
      pattern: RegExp(/%x/.source + percentExpression),
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "command": {
          pattern: /[\s\S]+/,
          alias: "string"
        }
      }
    }, {
      pattern: /`(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|[^\\`#\r\n])*`/,
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "command": {
          pattern: /[\s\S]+/,
          alias: "string"
        }
      }
    }]
  });
  delete Prism2.languages.ruby.string;
  Prism2.languages.insertBefore("ruby", "number", {
    "builtin": /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\b/,
    "constant": /\b[A-Z][A-Z0-9_]*(?:[?!]|\b)/
  });
  Prism2.languages.rb = Prism2.languages.ruby;
})(Prism);
(function(Prism2) {
  var multilineComment = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source;
  for (var i6 = 0; i6 < 2; i6++) {
    multilineComment = multilineComment.replace(/<self>/g, function() {
      return multilineComment;
    });
  }
  multilineComment = multilineComment.replace(/<self>/g, function() {
    return /[^\s\S]/.source;
  });
  Prism2.languages.rust = {
    "comment": [{
      pattern: RegExp(/(^|[^\\])/.source + multilineComment),
      lookbehind: true,
      greedy: true
    }, {
      pattern: /(^|[^\\:])\/\/.*/,
      lookbehind: true,
      greedy: true
    }],
    "string": {
      pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
      greedy: true
    },
    "char": {
      pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
      greedy: true
    },
    "attribute": {
      pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
      greedy: true,
      alias: "attr-name",
      inside: {
        "string": null
        // see below
      }
    },
    // Closure params should not be confused with bitwise OR |
    "closure-params": {
      pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
      lookbehind: true,
      greedy: true,
      inside: {
        "closure-punctuation": {
          pattern: /^\||\|$/,
          alias: "punctuation"
        },
        rest: null
        // see below
      }
    },
    "lifetime-annotation": {
      pattern: /'\w+/,
      alias: "symbol"
    },
    "fragment-specifier": {
      pattern: /(\$\w+:)[a-z]+/,
      lookbehind: true,
      alias: "punctuation"
    },
    "variable": /\$\w+/,
    "function-definition": {
      pattern: /(\bfn\s+)\w+/,
      lookbehind: true,
      alias: "function"
    },
    "type-definition": {
      pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
      lookbehind: true,
      alias: "class-name"
    },
    "module-declaration": [{
      pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
      lookbehind: true,
      alias: "namespace"
    }, {
      pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
      lookbehind: true,
      alias: "namespace",
      inside: {
        "punctuation": /::/
      }
    }],
    "keyword": [
      // https://github.com/rust-lang/reference/blob/master/src/keywords.md
      /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
      // primitives and str
      // https://doc.rust-lang.org/stable/rust-by-example/primitives.html
      /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
    ],
    // functions can technically start with an upper-case letter, but this will introduce a lot of false positives
    // and Rust's naming conventions recommend snake_case anyway.
    // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
    "function": /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
    "macro": {
      pattern: /\b\w+!/,
      alias: "property"
    },
    "constant": /\b[A-Z_][A-Z_\d]+\b/,
    "class-name": /\b[A-Z]\w*\b/,
    "namespace": {
      pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
      inside: {
        "punctuation": /::/
      }
    },
    // Hex, oct, bin, dec numbers with visual separators and type suffix
    "number": /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
    "boolean": /\b(?:false|true)\b/,
    "punctuation": /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
    "operator": /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
  };
  Prism2.languages.rust["closure-params"].inside.rest = Prism2.languages.rust;
  Prism2.languages.rust["attribute"].inside["string"] = Prism2.languages.rust["string"];
})(Prism);
(function(Prism2) {
  Prism2.languages.sass = Prism2.languages.extend("css", {
    // Sass comments don't need to be closed, only indented
    "comment": {
      pattern: /^([ \t]*)\/[\/*].*(?:(?:\r?\n|\r)\1[ \t].+)*/m,
      lookbehind: true,
      greedy: true
    }
  });
  Prism2.languages.insertBefore("sass", "atrule", {
    // We want to consume the whole line
    "atrule-line": {
      // Includes support for = and + shortcuts
      pattern: /^(?:[ \t]*)[@+=].+/m,
      greedy: true,
      inside: {
        "atrule": /(?:@[\w-]+|[+=])/
      }
    }
  });
  delete Prism2.languages.sass.atrule;
  var variable = /\$[-\w]+|#\{\$[-\w]+\}/;
  var operator = [/[+*\/%]|[=!]=|<=?|>=?|\b(?:and|not|or)\b/, {
    pattern: /(\s)-(?=\s)/,
    lookbehind: true
  }];
  Prism2.languages.insertBefore("sass", "property", {
    // We want to consume the whole line
    "variable-line": {
      pattern: /^[ \t]*\$.+/m,
      greedy: true,
      inside: {
        "punctuation": /:/,
        "variable": variable,
        "operator": operator
      }
    },
    // We want to consume the whole line
    "property-line": {
      pattern: /^[ \t]*(?:[^:\s]+ *:.*|:[^:\s].*)/m,
      greedy: true,
      inside: {
        "property": [/[^:\s]+(?=\s*:)/, {
          pattern: /(:)[^:\s]+/,
          lookbehind: true
        }],
        "punctuation": /:/,
        "variable": variable,
        "operator": operator,
        "important": Prism2.languages.sass.important
      }
    }
  });
  delete Prism2.languages.sass.property;
  delete Prism2.languages.sass.important;
  Prism2.languages.insertBefore("sass", "punctuation", {
    "selector": {
      pattern: /^([ \t]*)\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*)*/m,
      lookbehind: true,
      greedy: true
    }
  });
})(Prism);
Prism.languages.scss = Prism.languages.extend("css", {
  "comment": {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
    lookbehind: true
  },
  "atrule": {
    pattern: /@[\w-](?:\([^()]+\)|[^()\s]|\s+(?!\s))*?(?=\s+[{;])/,
    inside: {
      "rule": /@[\w-]+/
      // See rest below
    }
  },
  // url, compassified
  "url": /(?:[-a-z]+-)?url(?=\()/i,
  // CSS selector regex is not appropriate for Sass
  // since there can be lot more things (var, @ directive, nesting..)
  // a selector must start at the end of a property or after a brace (end of other rules or nesting)
  // it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable
  // the end of a selector is found when there is no rules in it ( {} or {\s}) or if there is a property (because an interpolated var
  // can "pass" as a selector- e.g: proper#{$erty})
  // this one was hard to do, so please be careful if you edit this one :)
  "selector": {
    // Initial look-ahead is used to prevent matching of blank selectors
    pattern: /(?=\S)[^@;{}()]?(?:[^@;{}()\s]|\s+(?!\s)|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}][^:{}]*[:{][^}]))/,
    inside: {
      "parent": {
        pattern: /&/,
        alias: "important"
      },
      "placeholder": /%[-\w]+/,
      "variable": /\$[-\w]+|#\{\$[-\w]+\}/
    }
  },
  "property": {
    pattern: /(?:[-\w]|\$[-\w]|#\{\$[-\w]+\})+(?=\s*:)/,
    inside: {
      "variable": /\$[-\w]+|#\{\$[-\w]+\}/
    }
  }
});
Prism.languages.insertBefore("scss", "atrule", {
  "keyword": [/@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\b/i, {
    pattern: /( )(?:from|through)(?= )/,
    lookbehind: true
  }]
});
Prism.languages.insertBefore("scss", "important", {
  // var and interpolated vars
  "variable": /\$[-\w]+|#\{\$[-\w]+\}/
});
Prism.languages.insertBefore("scss", "function", {
  "module-modifier": {
    pattern: /\b(?:as|hide|show|with)\b/i,
    alias: "keyword"
  },
  "placeholder": {
    pattern: /%[-\w]+/,
    alias: "selector"
  },
  "statement": {
    pattern: /\B!(?:default|optional)\b/i,
    alias: "keyword"
  },
  "boolean": /\b(?:false|true)\b/,
  "null": {
    pattern: /\bnull\b/,
    alias: "keyword"
  },
  "operator": {
    pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|not|or)(?=\s)/,
    lookbehind: true
  }
});
Prism.languages.scss["atrule"].inside.rest = Prism.languages.scss;
Prism.languages.sql = {
  "comment": {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
    lookbehind: true
  },
  "variable": [{
    pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
    greedy: true
  }, /@[\w.$]+/],
  "string": {
    pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
    greedy: true,
    lookbehind: true
  },
  "identifier": {
    pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
    greedy: true,
    lookbehind: true,
    inside: {
      "punctuation": /^`|`$/
    }
  },
  "function": /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
  // Should we highlight user defined functions too?
  "keyword": /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
  "boolean": /\b(?:FALSE|NULL|TRUE)\b/i,
  "number": /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
  "operator": /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
  "punctuation": /[;[\]()`,.]/
};
Prism.languages.swift = {
  "comment": {
    // Nested comments are supported up to 2 levels
    pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
    lookbehind: true,
    greedy: true
  },
  "string-literal": [
    // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
    {
      pattern: RegExp(/(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "interpolation": {
          pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
          lookbehind: true,
          inside: null
          // see below
        },
        "interpolation-punctuation": {
          pattern: /^\)|\\\($/,
          alias: "punctuation"
        },
        "punctuation": /\\(?=[\r\n])/,
        "string": /[\s\S]+/
      }
    },
    {
      pattern: RegExp(/(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"),
      lookbehind: true,
      greedy: true,
      inside: {
        "interpolation": {
          pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
          lookbehind: true,
          inside: null
          // see below
        },
        "interpolation-punctuation": {
          pattern: /^\)|\\#+\($/,
          alias: "punctuation"
        },
        "string": /[\s\S]+/
      }
    }
  ],
  "directive": {
    // directives with conditions
    pattern: RegExp(/#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"),
    alias: "property",
    inside: {
      "directive-name": /^#\w+/,
      "boolean": /\b(?:false|true)\b/,
      "number": /\b\d+(?:\.\d+)*\b/,
      "operator": /!|&&|\|\||[<>]=?/,
      "punctuation": /[(),]/
    }
  },
  "literal": {
    pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
    alias: "constant"
  },
  "other-directive": {
    pattern: /#\w+\b/,
    alias: "property"
  },
  "attribute": {
    pattern: /@\w+/,
    alias: "atrule"
  },
  "function-definition": {
    pattern: /(\bfunc\s+)\w+/,
    lookbehind: true,
    alias: "function"
  },
  "label": {
    // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
    pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
    lookbehind: true,
    alias: "important"
  },
  "keyword": /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
  "boolean": /\b(?:false|true)\b/,
  "nil": {
    pattern: /\bnil\b/,
    alias: "constant"
  },
  "short-argument": /\$\d+\b/,
  "omit": {
    pattern: /\b_\b/,
    alias: "keyword"
  },
  "number": /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
  // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
  "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
  "function": /\b[a-z_]\w*(?=\s*\()/i,
  "constant": /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
  // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
  // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
  // This regex only supports ASCII operators.
  "operator": /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
  "punctuation": /[{}[\]();,.:\\]/
};
Prism.languages.swift["string-literal"].forEach(function(rule) {
  rule.inside["interpolation"].inside = Prism.languages.swift;
});
(function(Prism2) {
  Prism2.languages.typescript = Prism2.languages.extend("javascript", {
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
      lookbehind: true,
      greedy: true,
      inside: null
      // see below
    },
    "builtin": /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
  });
  Prism2.languages.typescript.keyword.push(
    /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
    // keywords that have to be followed by an identifier
    /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
    // This is for `import type *, {}`
    /\btype\b(?=\s*(?:[\{*]|$))/
  );
  delete Prism2.languages.typescript["parameter"];
  delete Prism2.languages.typescript["literal-property"];
  var typeInside = Prism2.languages.extend("typescript", {});
  delete typeInside["class-name"];
  Prism2.languages.typescript["class-name"].inside = typeInside;
  Prism2.languages.insertBefore("typescript", "function", {
    "decorator": {
      pattern: /@[$\w\xA0-\uFFFF]+/,
      inside: {
        "at": {
          pattern: /^@/,
          alias: "operator"
        },
        "function": /^[\s\S]+/
      }
    },
    "generic-function": {
      // e.g. foo<T extends "bar" | "baz">( ...
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
      greedy: true,
      inside: {
        "function": /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
        "generic": {
          pattern: /<[\s\S]+/,
          // everything after the first <
          alias: "class-name",
          inside: typeInside
        }
      }
    }
  });
  Prism2.languages.ts = Prism2.languages.typescript;
})(Prism);
(function(Prism2) {
  var typescript = Prism2.util.clone(Prism2.languages.typescript);
  Prism2.languages.tsx = Prism2.languages.extend("jsx", typescript);
  delete Prism2.languages.tsx["parameter"];
  delete Prism2.languages.tsx["literal-property"];
  var tag2 = Prism2.languages.tsx.tag;
  tag2.pattern = RegExp(/(^|[^\w$]|(?=<\/))/.source + "(?:" + tag2.pattern.source + ")", tag2.pattern.flags);
  tag2.lookbehind = true;
})(Prism);
Prism.languages.basic = {
  "comment": {
    pattern: /(?:!|REM\b).+/i,
    inside: {
      "keyword": /^REM/i
    }
  },
  "string": {
    pattern: /"(?:""|[!#$%&'()*,\/:;<=>?^\w +\-.])*"/,
    greedy: true
  },
  "number": /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
  "keyword": /\b(?:AS|BEEP|BLOAD|BSAVE|CALL(?: ABSOLUTE)?|CASE|CHAIN|CHDIR|CLEAR|CLOSE|CLS|COM|COMMON|CONST|DATA|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DIM|DO|DOUBLE|ELSE|ELSEIF|END|ENVIRON|ERASE|ERROR|EXIT|FIELD|FILES|FOR|FUNCTION|GET|GOSUB|GOTO|IF|INPUT|INTEGER|IOCTL|KEY|KILL|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|MKDIR|NAME|NEXT|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPTION BASE|OUT|POKE|PUT|READ|REDIM|REM|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SELECT CASE|SHARED|SHELL|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|SUB|SWAP|SYSTEM|THEN|TIMER|TO|TROFF|TRON|TYPE|UNLOCK|UNTIL|USING|VIEW PRINT|WAIT|WEND|WHILE|WRITE)(?:\$|\b)/i,
  "function": /\b(?:ABS|ACCESS|ACOS|ANGLE|AREA|ARITHMETIC|ARRAY|ASIN|ASK|AT|ATN|BASE|BEGIN|BREAK|CAUSE|CEIL|CHR|CLIP|COLLATE|COLOR|CON|COS|COSH|COT|CSC|DATE|DATUM|DEBUG|DECIMAL|DEF|DEG|DEGREES|DELETE|DET|DEVICE|DISPLAY|DOT|ELAPSED|EPS|ERASABLE|EXLINE|EXP|EXTERNAL|EXTYPE|FILETYPE|FIXED|FP|GO|GRAPH|HANDLER|IDN|IMAGE|IN|INT|INTERNAL|IP|IS|KEYED|LBOUND|LCASE|LEFT|LEN|LENGTH|LET|LINE|LINES|LOG|LOG10|LOG2|LTRIM|MARGIN|MAT|MAX|MAXNUM|MID|MIN|MISSING|MOD|NATIVE|NUL|NUMERIC|OF|OPTION|ORD|ORGANIZATION|OUTIN|OUTPUT|PI|POINT|POINTER|POINTS|POS|PRINT|PROGRAM|PROMPT|RAD|RADIANS|RANDOMIZE|RECORD|RECSIZE|RECTYPE|RELATIVE|REMAINDER|REPEAT|REST|RETRY|REWRITE|RIGHT|RND|ROUND|RTRIM|SAME|SEC|SELECT|SEQUENTIAL|SET|SETTER|SGN|SIN|SINH|SIZE|SKIP|SQR|STANDARD|STATUS|STR|STREAM|STYLE|TAB|TAN|TANH|TEMPLATE|TEXT|THERE|TIME|TIMEOUT|TRACE|TRANSFORM|TRUNCATE|UBOUND|UCASE|USE|VAL|VARIABLE|VIEWPORT|WHEN|WINDOW|WITH|ZER|ZONEWIDTH)(?:\$|\b)/i,
  "operator": /<[=>]?|>=?|[+\-*\/^=&]|\b(?:AND|EQV|IMP|NOT|OR|XOR)\b/i,
  "punctuation": /[,;:()]/
};
Prism.languages.vbnet = Prism.languages.extend("basic", {
  "comment": [{
    pattern: /(?:!|REM\b).+/i,
    inside: {
      "keyword": /^REM/i
    }
  }, {
    pattern: /(^|[^\\:])'.*/,
    lookbehind: true,
    greedy: true
  }],
  "string": {
    pattern: /(^|[^"])"(?:""|[^"])*"(?!")/,
    lookbehind: true,
    greedy: true
  },
  "keyword": /(?:\b(?:ADDHANDLER|ADDRESSOF|ALIAS|AND|ANDALSO|AS|BEEP|BLOAD|BOOLEAN|BSAVE|BYREF|BYTE|BYVAL|CALL(?: ABSOLUTE)?|CASE|CATCH|CBOOL|CBYTE|CCHAR|CDATE|CDBL|CDEC|CHAIN|CHAR|CHDIR|CINT|CLASS|CLEAR|CLNG|CLOSE|CLS|COBJ|COM|COMMON|CONST|CONTINUE|CSBYTE|CSHORT|CSNG|CSTR|CTYPE|CUINT|CULNG|CUSHORT|DATA|DATE|DECIMAL|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DEFAULT|DELEGATE|DIM|DIRECTCAST|DO|DOUBLE|ELSE|ELSEIF|END|ENUM|ENVIRON|ERASE|ERROR|EVENT|EXIT|FALSE|FIELD|FILES|FINALLY|FOR(?: EACH)?|FRIEND|FUNCTION|GET|GETTYPE|GETXMLNAMESPACE|GLOBAL|GOSUB|GOTO|HANDLES|IF|IMPLEMENTS|IMPORTS|IN|INHERITS|INPUT|INTEGER|INTERFACE|IOCTL|IS|ISNOT|KEY|KILL|LET|LIB|LIKE|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|ME|MKDIR|MOD|MODULE|MUSTINHERIT|MUSTOVERRIDE|MYBASE|MYCLASS|NAME|NAMESPACE|NARROWING|NEW|NEXT|NOT|NOTHING|NOTINHERITABLE|NOTOVERRIDABLE|OBJECT|OF|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPERATOR|OPTION(?: BASE)?|OPTIONAL|OR|ORELSE|OUT|OVERLOADS|OVERRIDABLE|OVERRIDES|PARAMARRAY|PARTIAL|POKE|PRIVATE|PROPERTY|PROTECTED|PUBLIC|PUT|RAISEEVENT|READ|READONLY|REDIM|REM|REMOVEHANDLER|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SBYTE|SELECT(?: CASE)?|SET|SHADOWS|SHARED|SHELL|SHORT|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|STRUCTURE|SUB|SWAP|SYNCLOCK|SYSTEM|THEN|THROW|TIMER|TO|TROFF|TRON|TRUE|TRY|TRYCAST|TYPE|TYPEOF|UINTEGER|ULONG|UNLOCK|UNTIL|USHORT|USING|VIEW PRINT|WAIT|WEND|WHEN|WHILE|WIDENING|WITH|WITHEVENTS|WRITE|WRITEONLY|XOR)|\B(?:#CONST|#ELSE|#ELSEIF|#END|#IF))(?:\$|\b)/i,
  "punctuation": /[,;:(){}]/
});
function isValidURL(url) {
  return url === (0, import_sanitize_url.sanitizeUrl)(url);
}
var isLinkActive = (editor) => {
  return isElementActive(editor, "link");
};
var wrapLink = (editor, url) => {
  if (isLinkActive(editor)) {
    Transforms.unwrapNodes(editor, {
      match: (n6) => n6.type === "link"
    });
    return;
  }
  const {
    selection
  } = editor;
  const isCollapsed = selection && Range.isCollapsed(selection);
  if (isCollapsed) {
    Transforms.insertNodes(editor, {
      type: "link",
      href: url,
      children: [{
        text: url
      }]
    });
  } else {
    Transforms.wrapNodes(editor, {
      type: "link",
      href: url,
      children: [{
        text: ""
      }]
    }, {
      split: true
    });
  }
};
var LinkElement = ({
  attributes,
  children,
  element: __elementForGettingPath
}) => {
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  const editor = useSlateStatic();
  const [currentElement, setNode] = useElementWithSetNodes(editor, __elementForGettingPath);
  const href = currentElement.href;
  const text7 = Node3.string(currentElement);
  const [dialogOpen, setDialogOpen] = (0, import_react79.useState)(false);
  const activePopoverElement = useActiveBlockPopover();
  const selected = activePopoverElement === __elementForGettingPath;
  (0, import_react79.useEffect)(() => {
    if (selected && !href) {
      setDialogOpen(true);
    }
  }, [href, selected]);
  const unlink = useEventCallback(() => {
    Transforms.unwrapNodes(editor, {
      at: ReactEditor.findPath(editor, __elementForGettingPath)
    });
    ReactEditor.focus(editor);
  });
  return (0, import_jsx_runtime92.jsxs)(import_jsx_runtime92.Fragment, {
    children: [(0, import_jsx_runtime92.jsxs)(BlockPopoverTrigger, {
      element: __elementForGettingPath,
      children: [(0, import_jsx_runtime92.jsx)("a", {
        href,
        ...attributes,
        children
      }), (0, import_jsx_runtime92.jsx)(BlockPopover, {
        placement: "bottom start",
        children: (0, import_jsx_runtime92.jsxs)(Flex, {
          gap: "small",
          padding: "regular",
          children: [(0, import_jsx_runtime92.jsxs)(_TooltipTrigger, {
            children: [(0, import_jsx_runtime92.jsx)(ActionButton, {
              prominence: "low",
              onPress: () => setDialogOpen(true),
              children: (0, import_jsx_runtime92.jsx)(Icon, {
                src: editIcon
              })
            }), (0, import_jsx_runtime92.jsx)(Tooltip, {
              children: stringFormatter.format("edit")
            })]
          }), (0, import_jsx_runtime92.jsxs)(_TooltipTrigger, {
            children: [(0, import_jsx_runtime92.jsx)(ActionButton, {
              prominence: "low",
              onPress: () => {
                window.open(href, "_blank", "noopener,noreferrer");
              },
              children: (0, import_jsx_runtime92.jsx)(Icon, {
                src: externalLinkIcon
              })
            }), (0, import_jsx_runtime92.jsx)(Tooltip, {
              children: (0, import_jsx_runtime92.jsx)(Text2, {
                truncate: 3,
                children: href
              })
            })]
          }), (0, import_jsx_runtime92.jsxs)(_TooltipTrigger, {
            children: [(0, import_jsx_runtime92.jsx)(ActionButton, {
              prominence: "low",
              onPress: unlink,
              children: (0, import_jsx_runtime92.jsx)(Icon, {
                src: unlinkIcon
              })
            }), (0, import_jsx_runtime92.jsx)(Tooltip, {
              children: "Unlink"
            })]
          })]
        })
      })]
    }), (0, import_jsx_runtime92.jsx)(DialogContainer, {
      onDismiss: () => {
        setDialogOpen(false);
        focusWithPreviousSelection(editor);
      },
      children: dialogOpen && (0, import_jsx_runtime92.jsx)(LinkDialog, {
        text: text7,
        href,
        onSubmit: ({
          href: href2
        }) => {
          setNode({
            href: href2
          });
        }
      })
    })]
  });
};
function LinkDialog({
  onSubmit,
  ...props
}) {
  let [href, setHref] = (0, import_react79.useState)(props.href || "");
  let [touched, setTouched] = (0, import_react79.useState)(false);
  let {
    dismiss
  } = useDialogContainer();
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  const showInvalidState = touched && !isValidURL(href);
  return (0, import_jsx_runtime92.jsx)(Dialog, {
    size: "small",
    children: (0, import_jsx_runtime92.jsxs)("form", {
      style: {
        display: "contents"
      },
      onSubmit: (event) => {
        if (event.target !== event.currentTarget)
          return;
        event.preventDefault();
        if (!showInvalidState) {
          dismiss();
          onSubmit({
            href
          });
        }
      },
      children: [(0, import_jsx_runtime92.jsxs)(Heading, {
        children: [props.href ? "Edit" : "Add", " link"]
      }), (0, import_jsx_runtime92.jsx)(Content, {
        children: (0, import_jsx_runtime92.jsxs)(Flex, {
          gap: "large",
          direction: "column",
          children: [(0, import_jsx_runtime92.jsx)(TextField, {
            label: "Text",
            value: props.text,
            isReadOnly: true
          }), (0, import_jsx_runtime92.jsx)(TextField, {
            autoFocus: true,
            isRequired: true,
            onBlur: () => setTouched(true),
            label: "Link",
            onChange: setHref,
            value: href,
            errorMessage: showInvalidState && "Please provide a valid URL."
          })]
        })
      }), (0, import_jsx_runtime92.jsxs)(ButtonGroup, {
        children: [(0, import_jsx_runtime92.jsx)(Button, {
          onPress: dismiss,
          children: stringFormatter.format("cancel")
        }), (0, import_jsx_runtime92.jsx)(Button, {
          prominence: "high",
          type: "submit",
          children: stringFormatter.format("save")
        })]
      })]
    })
  });
}
var _linkIcon = (0, import_jsx_runtime92.jsx)(Icon, {
  src: linkIcon
});
function LinkButton2() {
  const {
    editor,
    links: {
      isDisabled,
      isSelected
    }
  } = useToolbarState();
  return (0, import_react79.useMemo)(() => (0, import_jsx_runtime92.jsx)(ActionButton, {
    prominence: "low",
    isDisabled,
    isSelected,
    onPress: () => {
      wrapLink(editor, "");
      ReactEditor.focus(editor);
    },
    children: _linkIcon
  }), [isSelected, isDisabled, editor]);
}
var linkButton = (0, import_jsx_runtime92.jsxs)(_TooltipTrigger, {
  children: [(0, import_jsx_runtime92.jsx)(LinkButton2, {}), (0, import_jsx_runtime92.jsx)(Tooltip, {
    children: (0, import_jsx_runtime92.jsx)(Text2, {
      children: "Link"
    })
  })]
});
var values2 = {
  start: {
    key: "start",
    label: "Align Start",
    icon: (0, import_jsx_runtime92.jsx)(Icon, {
      src: alignLeftIcon
    })
  },
  center: {
    key: "center",
    label: "Align Center",
    icon: (0, import_jsx_runtime92.jsx)(Icon, {
      src: alignCenterIcon
    })
  },
  end: {
    key: "end",
    label: "Align End",
    icon: (0, import_jsx_runtime92.jsx)(Icon, {
      src: alignRightIcon
    })
  }
};
var TextAlignMenu = ({
  alignment
}) => {
  const toolbarState = useToolbarState();
  const items = (0, import_react79.useMemo)(() => [values2.start, ...Object.keys(alignment).map((x4) => values2[x4])], [alignment]);
  return (0, import_react79.useMemo)(() => (0, import_jsx_runtime92.jsxs)(MenuTrigger, {
    children: [(0, import_jsx_runtime92.jsxs)(_TooltipTrigger, {
      children: [(0, import_jsx_runtime92.jsxs)(ActionButton, {
        prominence: "low",
        children: [values2[toolbarState.alignment.selected].icon, (0, import_jsx_runtime92.jsx)(Icon, {
          src: chevronDownIcon
        })]
      }), (0, import_jsx_runtime92.jsx)(Tooltip, {
        children: (0, import_jsx_runtime92.jsx)(Text2, {
          children: "Text Alignment"
        })
      })]
    }), (0, import_jsx_runtime92.jsx)(_Menu, {
      selectionMode: "single",
      selectedKeys: [toolbarState.alignment.selected],
      items,
      onAction: (key) => {
        if (key === "start") {
          Transforms.unsetNodes(toolbarState.editor, "textAlign", {
            match: (node4) => node4.type === "paragraph" || node4.type === "heading"
          });
        } else {
          Transforms.setNodes(toolbarState.editor, {
            textAlign: key
          }, {
            match: (node4) => node4.type === "paragraph" || node4.type === "heading"
          });
        }
        ReactEditor.focus(toolbarState.editor);
      },
      children: (item2) => {
        return (0, import_jsx_runtime92.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
          textValue: item2.label,
          children: [(0, import_jsx_runtime92.jsx)(Text2, {
            children: item2.label
          }), item2.icon]
        }, item2.key);
      }
    })]
  }), [items, toolbarState.alignment.selected, toolbarState.editor]);
};
var insertBlockquote = (editor) => {
  const isActive = isElementActive(editor, "blockquote");
  if (isActive) {
    Transforms.unwrapNodes(editor, {
      match: (node4) => node4.type === "blockquote"
    });
  } else {
    Transforms.wrapNodes(editor, {
      type: "blockquote",
      children: []
    });
  }
};
var BlockquoteButton = () => {
  const {
    editor,
    blockquote: {
      isDisabled,
      isSelected
    }
  } = useToolbarState();
  return (0, import_react79.useMemo)(() => (0, import_jsx_runtime92.jsx)(ActionButton, {
    prominence: "low",
    isSelected,
    isDisabled,
    onPress: () => {
      insertBlockquote(editor);
      ReactEditor.focus(editor);
    },
    children: (0, import_jsx_runtime92.jsx)(Icon, {
      src: quoteIcon
    })
  }), [editor, isDisabled, isSelected]);
};
var blockquoteButton = (0, import_jsx_runtime92.jsxs)(_TooltipTrigger, {
  children: [(0, import_jsx_runtime92.jsx)(BlockquoteButton, {}), (0, import_jsx_runtime92.jsxs)(Tooltip, {
    children: [(0, import_jsx_runtime92.jsx)(Text2, {
      children: "Quote"
    }), (0, import_jsx_runtime92.jsx)(Kbd, {
      children: ">⎵"
    })]
  })]
});
var languages = [{
  label: "C",
  value: "c"
}, {
  label: "C++",
  value: "cpp"
}, {
  label: "Arduino",
  value: "arduino"
}, {
  label: "Bash",
  value: "bash"
}, {
  label: "C#",
  value: "csharp"
}, {
  label: "CSS",
  value: "css"
}, {
  label: "Diff",
  value: "diff"
}, {
  label: "Go",
  value: "go"
}, {
  label: "INI",
  value: "ini"
}, {
  label: "Java",
  value: "java"
}, {
  label: "JavaScript",
  value: "javascript"
}, {
  label: "JSX",
  value: "jsx"
}, {
  label: "JSON",
  value: "json"
}, {
  label: "Kotlin",
  value: "kotlin"
}, {
  label: "Less",
  value: "less"
}, {
  label: "Lua",
  value: "lua"
}, {
  label: "Makefile",
  value: "makefile"
}, {
  label: "Markdown",
  value: "markdown"
}, {
  label: "Objective-C",
  value: "objectivec"
}, {
  label: "Perl",
  value: "perl"
}, {
  label: "PHP",
  value: "php"
}, {
  label: "Python",
  value: "python"
}, {
  label: "R",
  value: "r"
}, {
  label: "Ruby",
  value: "ruby"
}, {
  label: "Rust",
  value: "rust"
}, {
  label: "Sass",
  value: "sass"
}, {
  label: "SCSS",
  value: "scss"
}, {
  label: "SQL",
  value: "sql"
}, {
  label: "Swift",
  value: "swift"
}, {
  label: "TypeScript",
  value: "typescript"
}, {
  label: "TSX",
  value: "tsx"
}, {
  label: "VB.NET",
  value: "vbnet"
}, {
  label: "YAML",
  value: "yaml"
}];
var canonicalNameToLabel = new Map(languages.map((x4) => [x4.value, x4.label]));
var labelToCanonicalName = new Map(languages.map((x4) => [x4.label, x4.value]));
var languageToCanonicalName = new Map(languages.map((lang) => [Prism.languages[lang.value], lang.value]));
var aliasesToCanonicalName = new Map(Object.keys(Prism.languages).flatMap((lang) => {
  const canonicalName = languageToCanonicalName.get(Prism.languages[lang]);
  if (canonicalName === void 0) {
    return [];
  }
  return [[lang, canonicalName]];
}));
var languagesToAliases = new Map(languages.map((lang) => [lang.value, []]));
for (const [alias, canonicalName] of aliasesToCanonicalName) {
  languagesToAliases.get(canonicalName).push(alias);
}
var languagesWithAliases = [{
  label: "Plain text",
  value: "plain",
  aliases: []
}, ...[...languagesToAliases].map(([canonicalName, aliases]) => ({
  label: canonicalNameToLabel.get(canonicalName),
  value: canonicalName,
  aliases
}))];
var aliasesToLabel = new Map([...aliasesToCanonicalName].map(([alias, canonicalName]) => [alias, canonicalNameToLabel.get(canonicalName)]));
function CustomAttributesDialogInner(props) {
  const editor = useSlateStatic();
  const [state, setState] = (0, import_react79.useState)(() => {
    return getInitialPropsValueFromInitializer(props.schema, Object.fromEntries(Object.keys(props.schema.fields).map((key) => [key, props.element[key]])));
  });
  const [forceValidation, setForceValidation] = (0, import_react79.useState)(false);
  const previewProps = (0, import_react79.useMemo)(() => createGetPreviewProps(props.schema, setState, () => void 0), [props.schema])(state);
  let {
    dismiss
  } = useDialogContainer();
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  return (0, import_jsx_runtime92.jsx)(Dialog, {
    size: "small",
    children: (0, import_jsx_runtime92.jsxs)("form", {
      style: {
        display: "contents"
      },
      onSubmit: (event) => {
        if (event.target !== event.currentTarget)
          return;
        event.preventDefault();
        setForceValidation(true);
        if (clientSideValidateProp(props.schema, state, void 0)) {
          dismiss();
          const path3 = ReactEditor.findPath(editor, props.element);
          console.log(state);
          Transforms.setNodes(editor, state, {
            at: path3
          });
        }
      },
      children: [(0, import_jsx_runtime92.jsxs)(Heading, {
        children: [props.nodeLabel, " details"]
      }), (0, import_jsx_runtime92.jsx)(Content, {
        children: (0, import_jsx_runtime92.jsx)(FormValueContentFromPreviewProps, {
          forceValidation,
          autoFocus: true,
          ...previewProps
        })
      }), (0, import_jsx_runtime92.jsxs)(ButtonGroup, {
        children: [(0, import_jsx_runtime92.jsx)(Button, {
          onPress: dismiss,
          children: stringFormatter.format("cancel")
        }), (0, import_jsx_runtime92.jsx)(Button, {
          prominence: "high",
          type: "submit",
          children: stringFormatter.format("save")
        })]
      })]
    })
  });
}
function CustomAttributesEditButton(props) {
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  return (0, import_jsx_runtime92.jsxs)(_TooltipTrigger, {
    children: [(0, import_jsx_runtime92.jsx)(ActionButton, {
      prominence: "low",
      onPress: props.onPress,
      children: (0, import_jsx_runtime92.jsx)(Icon, {
        src: editIcon
      })
    }), (0, import_jsx_runtime92.jsx)(Tooltip, {
      children: stringFormatter.format("edit")
    })]
  });
}
function CustomAttributesDialog(props) {
  const editor = useSlateStatic();
  return (0, import_jsx_runtime92.jsx)(DialogContainer, {
    onDismiss: () => {
      props.onDismiss();
      focusWithPreviousSelection(editor);
    },
    children: props.isOpen && (0, import_jsx_runtime92.jsx)(CustomAttributesDialogInner, {
      element: props.element,
      nodeLabel: props.nodeLabel,
      schema: props.schema
    })
  });
}
function CodeButton() {
  const {
    editor,
    code: {
      isDisabled,
      isSelected
    }
  } = useToolbarState();
  return (0, import_react79.useMemo)(() => (0, import_jsx_runtime92.jsx)(ActionButton, {
    isSelected,
    isDisabled,
    prominence: "low",
    onPress: () => {
      if (isSelected) {
        Transforms.unwrapNodes(editor, {
          match: (node4) => node4.type === "code"
        });
      } else {
        Transforms.wrapNodes(editor, {
          type: "code",
          children: [{
            text: ""
          }]
        });
      }
      ReactEditor.focus(editor);
    },
    children: (0, import_jsx_runtime92.jsx)(Icon, {
      src: codeIcon
    })
  }), [isDisabled, isSelected, editor]);
}
var codeButton = (0, import_jsx_runtime92.jsxs)(_TooltipTrigger, {
  children: [(0, import_jsx_runtime92.jsx)(CodeButton, {}), (0, import_jsx_runtime92.jsxs)(Tooltip, {
    children: [(0, import_jsx_runtime92.jsx)(Text2, {
      children: "Code block"
    }), (0, import_jsx_runtime92.jsx)(Kbd, {
      children: "```"
    })]
  })]
});
function CodeElement({
  attributes,
  children,
  element: element4
}) {
  var _aliasesToLabel$get;
  const editor = useSlateStatic();
  const triggerRef = (0, import_react79.useRef)(null);
  const [inputValue, setInputValue] = (0, import_react79.useState)(element4.language ? (_aliasesToLabel$get = aliasesToLabel.get(element4.language)) !== null && _aliasesToLabel$get !== void 0 ? _aliasesToLabel$get : element4.language : "Plain text");
  const [dialogOpen, setDialogOpen] = (0, import_react79.useState)(false);
  const {
    documentFeatures
  } = useDocumentEditorConfig();
  const customAttributesSchema = documentFeatures.formatting.blockTypes.code && Object.keys(documentFeatures.formatting.blockTypes.code.schema.fields).length ? documentFeatures.formatting.blockTypes.code.schema : void 0;
  return (0, import_jsx_runtime92.jsxs)(import_jsx_runtime92.Fragment, {
    children: [(0, import_jsx_runtime92.jsx)(BlockWrapper, {
      children: (0, import_jsx_runtime92.jsxs)(BlockPopoverTrigger, {
        element: element4,
        children: [(0, import_jsx_runtime92.jsx)("pre", {
          spellCheck: "false",
          ref: triggerRef,
          children: (0, import_jsx_runtime92.jsx)("code", {
            ...attributes,
            children
          })
        }), (0, import_jsx_runtime92.jsx)(BlockPopover, {
          children: (0, import_jsx_runtime92.jsxs)(Flex, {
            gap: "regular",
            padding: "regular",
            children: [(0, import_jsx_runtime92.jsx)(_Combobox, {
              "aria-label": "Language",
              width: "scale.2000",
              allowsCustomValue: true,
              inputValue,
              onInputChange: setInputValue,
              onBlur: () => {
                const path3 = ReactEditor.findPath(editor, element4);
                const canonicalName = aliasesToCanonicalName.get(inputValue);
                if (canonicalName !== void 0) {
                  if (canonicalName === "plain") {
                    Transforms.unsetNodes(editor, "language", {
                      at: path3
                    });
                    return;
                  }
                  setInputValue(canonicalNameToLabel.get(canonicalName));
                  Transforms.setNodes(editor, {
                    language: canonicalName
                  }, {
                    at: path3
                  });
                  return;
                }
                const nameFromLabel = labelToCanonicalName.get(inputValue);
                if (nameFromLabel !== void 0) {
                  if (nameFromLabel === "plain") {
                    Transforms.unsetNodes(editor, "language", {
                      at: path3
                    });
                    return;
                  }
                  Transforms.setNodes(editor, {
                    language: nameFromLabel
                  }, {
                    at: path3
                  });
                  return;
                }
                if (inputValue === "") {
                  Transforms.unsetNodes(editor, "language", {
                    at: path3
                  });
                  setInputValue("Plain text");
                  return;
                }
                if (inputValue !== element4.language) {
                  Transforms.setNodes(editor, {
                    language: inputValue
                  }, {
                    at: path3
                  });
                }
              },
              onSelectionChange: (selection) => {
                const path3 = ReactEditor.findPath(editor, element4);
                if (aliasesToCanonicalName.has(inputValue)) {
                  selection = aliasesToCanonicalName.get(inputValue);
                }
                if (selection === null) {
                  if (inputValue === "") {
                    Transforms.unsetNodes(editor, "language", {
                      at: path3
                    });
                  } else {
                    Transforms.setNodes(editor, {
                      language: inputValue
                    }, {
                      at: path3
                    });
                  }
                } else if (typeof selection === "string") {
                  if (selection === "plain") {
                    Transforms.unsetNodes(editor, "language", {
                      at: path3
                    });
                    setInputValue("Plain text");
                    return;
                  }
                  Transforms.setNodes(editor, {
                    language: selection
                  }, {
                    at: path3
                  });
                  const label = canonicalNameToLabel.get(selection);
                  if (label) {
                    setInputValue(label);
                  }
                }
              },
              selectedKey: element4.language ? aliasesToCanonicalName.get(element4.language) : "plain",
              items: (0, import_react79.useMemo)(() => inputValue === "Plain text" || labelToCanonicalName.has(inputValue) ? languagesWithAliases : matchSorter(languagesWithAliases, inputValue, {
                keys: ["label", "value", "aliases"]
              }), [inputValue]),
              children: (item2) => (0, import_jsx_runtime92.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
                children: item2.label
              }, item2.value)
            }), (0, import_jsx_runtime92.jsx)(ToolbarSeparator, {}), customAttributesSchema !== void 0 && (0, import_jsx_runtime92.jsx)(CustomAttributesEditButton, {
              onPress: () => setDialogOpen(true)
            }), (0, import_jsx_runtime92.jsxs)(_TooltipTrigger, {
              children: [(0, import_jsx_runtime92.jsx)(ActionButton, {
                prominence: "low",
                onPress: () => {
                  Transforms.removeNodes(editor, {
                    at: ReactEditor.findPath(editor, element4)
                  });
                },
                children: (0, import_jsx_runtime92.jsx)(Icon, {
                  src: trash2Icon
                })
              }), (0, import_jsx_runtime92.jsx)(Tooltip, {
                tone: "critical",
                children: "Remove"
              })]
            })]
          })
        })]
      })
    }), customAttributesSchema !== void 0 && (0, import_jsx_runtime92.jsx)(CustomAttributesDialog, {
      element: element4,
      isOpen: dialogOpen,
      nodeLabel: "Code block",
      schema: customAttributesSchema,
      onDismiss: () => {
        setDialogOpen(false);
      }
    })]
  });
}
function updateComponentBlockElementProps(editor, componentBlock, prevProps, _newProps, basePath, setElement, ignoreChildFields) {
  Editor.withoutNormalizing(editor, () => {
    const propPathsWithNodesToReplace = /* @__PURE__ */ new Map();
    const schema = {
      kind: "object",
      fields: componentBlock.schema
    };
    const newProps = transformProps(schema, _newProps, {
      child(schema2, value2, path3) {
        if (!ignoreChildFields && schema2.options.kind === "block" && value2) {
          try {
            let prevVal = getValueAtPropPath(prevProps, path3);
            if (prevVal === value2) {
              return null;
            }
          } catch {
          }
          propPathsWithNodesToReplace.set(JSON.stringify(path3), value2.map(cloneDescendent));
        }
        return null;
      }
    });
    setElement({
      props: newProps
    });
    const childPropPaths = findChildPropPathsWithPrevious(newProps, prevProps, schema, [], [], []);
    const getNode = () => Node3.get(editor, basePath);
    const elementForChildren = getNode();
    if (childPropPaths.length === 0) {
      const indexes = elementForChildren.children.map((_2, i6) => i6).reverse();
      for (const idx of indexes) {
        Transforms.removeNodes(editor, {
          at: [...basePath, idx]
        });
      }
      Transforms.insertNodes(editor, {
        type: "component-inline-prop",
        propPath: void 0,
        children: [{
          text: ""
        }]
      }, {
        at: [...basePath, 0]
      });
      return;
    }
    const initialPropPathsToEditorPath = /* @__PURE__ */ new Map();
    for (const [idx, node4] of elementForChildren.children.entries()) {
      assert(node4.type === "component-block-prop" || node4.type === "component-inline-prop");
      initialPropPathsToEditorPath.set(node4.propPath === void 0 ? void 0 : JSON.stringify(node4.propPath), idx);
    }
    const childrenLeftToAdd = new Set(childPropPaths);
    for (const childProp of childPropPaths) {
      if (childProp.prevPath === void 0) {
        continue;
      }
      const stringifiedPath = JSON.stringify(childProp.prevPath);
      const idxInChildren = initialPropPathsToEditorPath.get(stringifiedPath);
      if (idxInChildren !== void 0) {
        const prevNode = elementForChildren.children[idxInChildren];
        assert(prevNode.propPath !== void 0);
        if (!areArraysEqual(childProp.path, prevNode.propPath)) {
          Transforms.setNodes(editor, {
            propPath: childProp.path
          }, {
            at: [...basePath, idxInChildren]
          });
        }
        childrenLeftToAdd.delete(childProp);
        initialPropPathsToEditorPath.delete(stringifiedPath);
      }
    }
    let newIdx = getNode().children.length;
    for (const childProp of childrenLeftToAdd) {
      Transforms.insertNodes(editor, {
        type: `component-${childProp.options.kind}-prop`,
        propPath: childProp.path,
        children: [childProp.options.kind === "block" ? {
          type: "paragraph",
          children: [{
            text: ""
          }]
        } : {
          text: ""
        }]
      }, {
        at: [...basePath, newIdx]
      });
      newIdx++;
    }
    const pathsToRemove = [];
    for (const [, idxInChildren] of initialPropPathsToEditorPath) {
      pathsToRemove.push(Editor.pathRef(editor, [...basePath, idxInChildren]));
    }
    for (const pathRef of pathsToRemove) {
      const path3 = pathRef.unref();
      assert(path3 !== null);
      Transforms.removeNodes(editor, {
        at: path3
      });
    }
    const propPathsToExpectedIndexes = /* @__PURE__ */ new Map();
    for (const [idx, thing] of childPropPaths.entries()) {
      propPathsToExpectedIndexes.set(JSON.stringify(thing.path), idx);
    }
    outer:
      while (true) {
        for (const [idx, childNode] of getNode().children.entries()) {
          assert(childNode.type === "component-block-prop" || childNode.type === "component-inline-prop");
          const expectedIndex = propPathsToExpectedIndexes.get(JSON.stringify(childNode.propPath));
          assert(expectedIndex !== void 0);
          if (idx === expectedIndex)
            continue;
          Transforms.moveNodes(editor, {
            at: [...basePath, idx],
            to: [...basePath, expectedIndex]
          });
          continue outer;
        }
        break;
      }
    for (const [propPath, val] of propPathsWithNodesToReplace) {
      const idx = propPathsToExpectedIndexes.get(propPath);
      if (idx !== void 0) {
        Transforms.removeNodes(editor, {
          at: [...basePath, idx]
        });
        Transforms.insertNodes(editor, {
          type: "component-block-prop",
          propPath: JSON.parse(propPath),
          children: val
        }, {
          at: [...basePath, idx]
        });
      }
    }
  });
}
function findChildPropPathsWithPrevious(value2, prevValue, schema, newPath, prevPath, pathWithKeys) {
  switch (schema.kind) {
    case "form":
      return [];
    case "child":
      return [{
        path: newPath,
        prevPath,
        options: schema.options
      }];
    case "conditional":
      const hasChangedDiscriminant = value2.discriminant === prevValue.discriminant;
      return findChildPropPathsWithPrevious(value2.value, hasChangedDiscriminant ? prevValue.value : getInitialPropsValue(schema.values[value2.discriminant]), schema.values[value2.discriminant], newPath.concat("value"), hasChangedDiscriminant ? void 0 : prevPath === null || prevPath === void 0 ? void 0 : prevPath.concat("value"), hasChangedDiscriminant ? void 0 : pathWithKeys === null || pathWithKeys === void 0 ? void 0 : pathWithKeys.concat("value"));
    case "object": {
      const paths = [];
      for (const key of Object.keys(schema.fields)) {
        paths.push(...findChildPropPathsWithPrevious(value2[key], prevValue[key], schema.fields[key], newPath.concat(key), prevPath === null || prevPath === void 0 ? void 0 : prevPath.concat(key), pathWithKeys === null || pathWithKeys === void 0 ? void 0 : pathWithKeys.concat(key)));
      }
      return paths;
    }
    case "array": {
      const paths = [];
      const prevKeys = getKeysForArrayValue(prevValue);
      const keys3 = getKeysForArrayValue(value2);
      for (const [i6, val] of value2.entries()) {
        const key = keys3[i6];
        const prevIdx = prevKeys.indexOf(key);
        let prevVal;
        if (prevIdx === -1) {
          prevVal = getInitialPropsValue(schema.element);
        } else {
          prevVal = prevValue[prevIdx];
        }
        paths.push(...findChildPropPathsWithPrevious(val, prevVal, schema.element, newPath.concat(i6), prevIdx === -1 ? void 0 : prevPath === null || prevPath === void 0 ? void 0 : prevPath.concat(prevIdx), prevIdx === -1 ? void 0 : pathWithKeys === null || pathWithKeys === void 0 ? void 0 : pathWithKeys.concat(key)));
      }
      return paths;
    }
  }
}
var ChildrenByPathContext = import_react79.default.createContext({});
function ChildFieldEditable({
  path: path3
}) {
  const childrenByPath = (0, import_react79.useContext)(ChildrenByPathContext);
  const child = childrenByPath[JSON.stringify(path3)];
  if (child === void 0) {
    return null;
  }
  return child;
}
function ComponentBlockRender({
  componentBlock,
  element: element4,
  onChange: onChange2,
  children,
  onRemove
}) {
  const getPreviewProps = (0, import_react79.useMemo)(() => {
    return createGetPreviewProps({
      kind: "object",
      fields: componentBlock.schema
    }, (cb) => onChange2(cb, true), (path3) => (0, import_jsx_runtime92.jsx)(ChildFieldEditable, {
      path: path3
    }));
  }, [onChange2, componentBlock]);
  const previewProps = getPreviewProps(element4.props);
  const childrenByPath = {};
  let maybeChild;
  let extraChildren = [];
  children.forEach((child) => {
    const propPath = child.props.children.props.element.propPath;
    if (propPath === void 0) {
      maybeChild = child;
    } else {
      const schema = getSchemaAtPropPath(propPath, element4.props, componentBlock.schema);
      if ((schema === null || schema === void 0 ? void 0 : schema.kind) === "child" && schema.options.kind === "block" && schema.options.editIn === "modal") {
        extraChildren.push(child);
        return;
      }
      childrenByPath[JSON.stringify(propPathWithIndiciesToKeys(propPath, element4.props))] = child;
    }
  });
  const ComponentBlockPreview = componentBlock.preview;
  return (0, import_jsx_runtime92.jsxs)(ChildrenByPathContext.Provider, {
    value: childrenByPath,
    children: [(0, import_react79.useMemo)(() => (0, import_jsx_runtime92.jsx)(ComponentBlockPreview, {
      onRemove,
      ...previewProps
    }), [ComponentBlockPreview, onRemove, previewProps]), (0, import_jsx_runtime92.jsxs)("span", {
      className: css({
        caretColor: "transparent",
        "& ::selection": {
          backgroundColor: "transparent"
        },
        overflow: "hidden",
        width: 1,
        height: 1,
        position: "absolute"
      }),
      children: [maybeChild, extraChildren]
    })]
  });
}
function propPathWithIndiciesToKeys(propPath, val) {
  return propPath.map((key) => {
    var _val2;
    if (typeof key === "string") {
      var _val;
      val = (_val = val) === null || _val === void 0 ? void 0 : _val[key];
      return key;
    }
    if (!Array.isArray(val)) {
      val = void 0;
      return "";
    }
    const keys3 = getKeysForArrayValue(val);
    val = (_val2 = val) === null || _val2 === void 0 ? void 0 : _val2[key];
    return keys3[key];
  });
}
function ChromefulComponentBlockElement(props) {
  var _props$componentBlock;
  const selected = useSelected();
  const isValid = (0, import_react79.useMemo)(() => clientSideValidateProp({
    kind: "object",
    fields: props.componentBlock.schema
  }, props.elementProps, void 0), [props.componentBlock, props.elementProps]);
  const [editMode, setEditMode] = (0, import_react79.useState)(false);
  const onCloseEditMode = (0, import_react79.useCallback)(() => {
    setEditMode(false);
  }, []);
  const onShowEditMode = (0, import_react79.useCallback)(() => {
    setEditMode(true);
  }, []);
  const ChromefulToolbar = (_props$componentBlock = props.componentBlock.toolbar) !== null && _props$componentBlock !== void 0 ? _props$componentBlock : DefaultToolbarWithChrome;
  return (0, import_jsx_runtime92.jsx)(BlockPrimitive, {
    selected,
    ...props.attributes,
    children: (0, import_jsx_runtime92.jsxs)(Flex, {
      gap: "medium",
      direction: "column",
      children: [(0, import_jsx_runtime92.jsx)(NotEditable, {
        children: (0, import_jsx_runtime92.jsx)(Text2, {
          casing: "uppercase",
          color: "neutralSecondary",
          weight: "medium",
          size: "small",
          children: props.componentBlock.label
        })
      }), (0, import_jsx_runtime92.jsxs)(import_react79.Fragment, {
        children: [props.renderedBlock, (0, import_jsx_runtime92.jsx)(ChromefulToolbar, {
          isValid,
          onRemove: props.onRemove,
          props: props.previewProps,
          onShowEditMode
        }), (0, import_jsx_runtime92.jsx)(DialogContainer, {
          onDismiss: () => onCloseEditMode(),
          children: (() => {
            if (!editMode) {
              return;
            }
            return (0, import_jsx_runtime92.jsxs)(Dialog, {
              children: [(0, import_jsx_runtime92.jsxs)(Heading, {
                children: ["Edit ", props.componentBlock.label]
              }), (0, import_jsx_runtime92.jsx)(FormValue, {
                props: props.previewProps,
                onClose: onCloseEditMode
              })]
            });
          })()
        })]
      })]
    })
  });
}
var BlockPrimitive = (0, import_react79.forwardRef)(function BlockPrimitive2({
  children,
  selected,
  ...attributes
}, ref) {
  return (0, import_jsx_runtime92.jsx)("div", {
    ...attributes,
    ref,
    className: css(blockElementSpacing, {
      position: "relative",
      paddingInlineStart: tokenSchema.size.space.xlarge,
      marginBottom: tokenSchema.size.space.xlarge,
      "::before": {
        display: "block",
        content: '" "',
        backgroundColor: selected ? tokenSchema.color.alias.borderSelected : tokenSchema.color.alias.borderIdle,
        borderRadius: 4,
        width: 4,
        position: "absolute",
        left: 0,
        top: 0,
        bottom: 0,
        zIndex: 1
      }
    }),
    children
  });
});
function DefaultToolbarWithChrome({
  onShowEditMode,
  onRemove,
  isValid
}) {
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  return (0, import_jsx_runtime92.jsx)(NotEditable, {
    children: (0, import_jsx_runtime92.jsxs)(Flex, {
      direction: "column",
      gap: "medium",
      children: [(0, import_jsx_runtime92.jsxs)(Flex, {
        alignItems: "center",
        gap: "regular",
        UNSAFE_style: {
          userSelect: "none"
        },
        children: [(0, import_jsx_runtime92.jsx)(ActionButton, {
          onPress: () => onShowEditMode(),
          children: stringFormatter.format("edit")
        }), (0, import_jsx_runtime92.jsxs)(_TooltipTrigger, {
          children: [(0, import_jsx_runtime92.jsx)(ActionButton, {
            prominence: "low",
            onPress: onRemove,
            children: (0, import_jsx_runtime92.jsx)(Icon, {
              src: trash2Icon
            })
          }), (0, import_jsx_runtime92.jsx)(Tooltip, {
            tone: "critical",
            children: stringFormatter.format("delete")
          })]
        })]
      }), !isValid && (0, import_jsx_runtime92.jsx)(FieldMessage, {
        children: "Contains invalid fields. Please edit."
      })]
    })
  });
}
function FormValue({
  onClose,
  props
}) {
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  const formId = (0, import_react79.useId)();
  const [forceValidation, setForceValidation] = (0, import_react79.useState)(false);
  const [state, setState] = (0, import_react79.useState)(() => previewPropsToValue(props));
  const previewProps = (0, import_react79.useMemo)(() => createGetPreviewProps(props.schema, setState, () => void 0), [props.schema])(state);
  return (0, import_jsx_runtime92.jsxs)(import_jsx_runtime92.Fragment, {
    children: [(0, import_jsx_runtime92.jsx)(Content, {
      children: (0, import_jsx_runtime92.jsx)(Flex, {
        id: formId,
        elementType: "form",
        onSubmit: (event) => {
          if (event.target !== event.currentTarget)
            return;
          event.preventDefault();
          if (!clientSideValidateProp(props.schema, state, void 0)) {
            setForceValidation(true);
          } else {
            console.log(valueToUpdater(state, props.schema));
            setValueToPreviewProps(state, props);
            onClose();
          }
        },
        direction: "column",
        gap: "xxlarge",
        children: (0, import_jsx_runtime92.jsx)(FormValueContentFromPreviewProps, {
          ...previewProps,
          forceValidation
        })
      })
    }), (0, import_jsx_runtime92.jsxs)(ButtonGroup, {
      children: [(0, import_jsx_runtime92.jsx)(Button, {
        onPress: onClose,
        children: stringFormatter.format("cancel")
      }), (0, import_jsx_runtime92.jsx)(Button, {
        form: formId,
        prominence: "high",
        type: "submit",
        children: "Done"
      })]
    })]
  });
}
function ChromelessComponentBlockElement(props) {
  var _props$componentBlock;
  const hasToolbar = props.componentBlock.toolbar !== null;
  const ChromelessToolbar = (_props$componentBlock = props.componentBlock.toolbar) !== null && _props$componentBlock !== void 0 ? _props$componentBlock : DefaultToolbarWithoutChrome;
  return (0, import_jsx_runtime92.jsx)("div", {
    ...props.attributes,
    className: blockElementSpacing,
    children: hasToolbar ? (0, import_jsx_runtime92.jsxs)(BlockPopoverTrigger, {
      element: props.element,
      children: [(0, import_jsx_runtime92.jsx)("div", {
        children: props.renderedBlock
      }), (0, import_jsx_runtime92.jsx)(BlockPopover, {
        children: (0, import_jsx_runtime92.jsx)(ChromelessToolbar, {
          onRemove: props.onRemove,
          props: props.previewProps
        })
      })]
    }) : (0, import_jsx_runtime92.jsx)("div", {
      children: props.renderedBlock
    })
  });
}
function DefaultToolbarWithoutChrome({
  onRemove
}) {
  return (0, import_jsx_runtime92.jsxs)(_TooltipTrigger, {
    children: [(0, import_jsx_runtime92.jsx)(ActionButton, {
      onPress: onRemove,
      margin: "regular",
      children: (0, import_jsx_runtime92.jsx)(Icon, {
        src: trashIcon
      })
    }), (0, import_jsx_runtime92.jsx)(Tooltip, {
      tone: "critical",
      children: "Remove"
    })]
  });
}
function findChildPropPathsForProp(value2, schema, path3) {
  switch (schema.kind) {
    case "form":
      return [];
    case "child":
      return [{
        path: path3,
        options: schema.options
      }];
    case "conditional":
      return findChildPropPathsForProp(value2.value, schema.values[value2.discriminant], path3.concat("value"));
    case "object": {
      const paths = [];
      Object.keys(schema.fields).forEach((key) => {
        paths.push(...findChildPropPathsForProp(value2[key], schema.fields[key], path3.concat(key)));
      });
      return paths;
    }
    case "array": {
      const paths = [];
      value2.forEach((val, i6) => {
        paths.push(...findChildPropPathsForProp(val, schema.element, path3.concat(i6)));
      });
      return paths;
    }
  }
}
function findChildPropPaths(value2, props) {
  const propPaths = findChildPropPathsForProp(value2, {
    kind: "object",
    fields: props
  }, []);
  if (!propPaths.length) {
    return [{
      path: void 0,
      options: {
        kind: "inline",
        placeholder: ""
      }
    }];
  }
  return propPaths;
}
function getAncestorComponentBlock(editor) {
  if (editor.selection) {
    const ancestorEntry = Editor.above(editor, {
      match: (node4) => isBlock(node4) && node4.type !== "paragraph"
    });
    if (ancestorEntry && (ancestorEntry[0].type === "component-block-prop" || ancestorEntry[0].type === "component-inline-prop")) {
      return {
        isInside: true,
        componentBlock: Editor.parent(editor, ancestorEntry[1]),
        prop: ancestorEntry
      };
    }
  }
  return {
    isInside: false
  };
}
var alreadyNormalizedThings = /* @__PURE__ */ new WeakMap();
function normalizeNodeWithinComponentProp([node4, path3], editor, fieldOptions) {
  let alreadyNormalizedNodes = alreadyNormalizedThings.get(fieldOptions);
  if (!alreadyNormalizedNodes) {
    alreadyNormalizedNodes = /* @__PURE__ */ new WeakSet();
    alreadyNormalizedThings.set(fieldOptions, alreadyNormalizedNodes);
  }
  if (alreadyNormalizedNodes.has(node4)) {
    return false;
  }
  let didNormalization = false;
  if (fieldOptions.inlineMarks !== "inherit" && Text.isText(node4)) {
    didNormalization = normalizeTextBasedOnInlineMarksAndSoftBreaks([node4, path3], editor, fieldOptions.inlineMarks, fieldOptions.softBreaks);
  }
  if (Element2.isElement(node4)) {
    let childrenHasChanged = node4.children.map((node5, i6) => normalizeNodeWithinComponentProp([node5, [...path3, i6]], editor, fieldOptions)).some((x4) => x4);
    if (fieldOptions.kind === "block") {
      if (node4.type === "component-block") {
        if (!fieldOptions.componentBlocks) {
          Transforms.unwrapNodes(editor, {
            at: path3
          });
          didNormalization = true;
        }
      } else {
        didNormalization = normalizeElementBasedOnDocumentFeatures([node4, path3], editor, fieldOptions.documentFeatures) || childrenHasChanged;
      }
    } else {
      didNormalization = normalizeInlineBasedOnLinks([node4, path3], editor, fieldOptions.documentFeatures.links);
    }
  }
  if (didNormalization === false) {
    alreadyNormalizedNodes.add(node4);
  }
  return didNormalization;
}
function canSchemaContainChildField(rootSchema) {
  const queue = /* @__PURE__ */ new Set([rootSchema]);
  for (const schema of queue) {
    if (schema.kind === "form")
      ;
    else if (schema.kind === "child") {
      return true;
    } else if (schema.kind === "array") {
      queue.add(schema.element);
    } else if (schema.kind === "object") {
      for (const innerProp of Object.values(schema.fields)) {
        queue.add(innerProp);
      }
    } else if (schema.kind === "conditional") {
      for (const innerProp of Object.values(schema.values)) {
        queue.add(innerProp);
      }
    } else {
      assertNever(schema);
    }
  }
  return false;
}
function doesSchemaOnlyEverContainASingleChildField(rootSchema) {
  const queue = /* @__PURE__ */ new Set([rootSchema]);
  let hasFoundChildField = false;
  for (const schema of queue) {
    if (schema.kind === "form")
      ;
    else if (schema.kind === "child") {
      if (hasFoundChildField) {
        return false;
      }
      hasFoundChildField = true;
    } else if (schema.kind === "array") {
      if (canSchemaContainChildField(schema.element)) {
        return false;
      }
    } else if (schema.kind === "object") {
      for (const innerProp of Object.values(schema.fields)) {
        queue.add(innerProp);
      }
    } else if (schema.kind === "conditional") {
      for (const innerProp of Object.values(schema.values)) {
        queue.add(innerProp);
      }
    } else {
      assertNever(schema);
    }
  }
  return hasFoundChildField;
}
function findArrayFieldsWithSingleChildField(schema, value2) {
  const propPaths = [];
  traverseProps(schema, value2, (schema2, value3, path3) => {
    if (schema2.kind === "array" && doesSchemaOnlyEverContainASingleChildField(schema2.element)) {
      propPaths.push([path3, schema2]);
    }
  });
  return propPaths;
}
function isEmptyChildFieldNode(element4) {
  const firstChild = element4.children[0];
  return element4.children.length === 1 && (element4.type === "component-inline-prop" && firstChild.type === void 0 && firstChild.text === "" || element4.type === "component-block-prop" && firstChild.type === "paragraph" && firstChild.children.length === 1 && firstChild.children[0].type === void 0 && firstChild.children[0].text === "");
}
function withComponentBlocks(blockComponents, editorDocumentFeatures, editor) {
  const memoizedGetDocumentFeaturesForChildField = weakMemoize((options) => {
    return getDocumentFeaturesForChildField(editorDocumentFeatures, options);
  });
  const {
    normalizeNode,
    deleteBackward,
    insertBreak
  } = editor;
  editor.deleteBackward = (unit) => {
    if (editor.selection) {
      const ancestorComponentBlock = getAncestorComponentBlock(editor);
      if (ancestorComponentBlock.isInside && Range.isCollapsed(editor.selection) && Editor.isStart(editor, editor.selection.anchor, ancestorComponentBlock.prop[1]) && ancestorComponentBlock.prop[1][ancestorComponentBlock.prop[1].length - 1] === 0) {
        Transforms.unwrapNodes(editor, {
          at: ancestorComponentBlock.componentBlock[1]
        });
        return;
      }
    }
    deleteBackward(unit);
  };
  editor.insertBreak = () => {
    const ancestorComponentBlock = getAncestorComponentBlock(editor);
    if (editor.selection && ancestorComponentBlock.isInside) {
      const {
        prop: [componentPropNode, componentPropPath],
        componentBlock: [componentBlockNode, componentBlockPath]
      } = ancestorComponentBlock;
      const isLastProp = componentPropPath[componentPropPath.length - 1] === componentBlockNode.children.length - 1;
      if (componentPropNode.type === "component-block-prop") {
        const [[paragraphNode, paragraphPath]] = Editor.nodes(editor, {
          match: (node4) => node4.type === "paragraph"
        });
        const isLastParagraph = paragraphPath[paragraphPath.length - 1] === componentPropNode.children.length - 1;
        if (Node3.string(paragraphNode) === "" && isLastParagraph) {
          if (isLastProp) {
            Transforms.moveNodes(editor, {
              at: paragraphPath,
              to: Path.next(ancestorComponentBlock.componentBlock[1])
            });
          } else {
            Transforms.move(editor, {
              distance: 1,
              unit: "line"
            });
            Transforms.removeNodes(editor, {
              at: paragraphPath
            });
          }
          return;
        }
      }
      if (componentPropNode.type === "component-inline-prop") {
        Editor.withoutNormalizing(editor, () => {
          const componentBlock = blockComponents[componentBlockNode.component];
          if (componentPropNode.propPath !== void 0 && componentBlock !== void 0) {
            const rootSchema = {
              kind: "object",
              fields: componentBlock.schema
            };
            const ancestorFields = getAncestorSchemas(rootSchema, componentPropNode.propPath, componentBlockNode.props);
            const idx = [...ancestorFields].reverse().findIndex((item2) => item2.kind === "array");
            if (idx !== -1) {
              const arrayFieldIdx = ancestorFields.length - 1 - idx;
              const arrayField = ancestorFields[arrayFieldIdx];
              assert(arrayField.kind === "array");
              const val = getValueAtPropPath(componentBlockNode.props, componentPropNode.propPath.slice(0, arrayFieldIdx));
              if (doesSchemaOnlyEverContainASingleChildField(arrayField.element)) {
                if (Node3.string(componentPropNode) === "" && val.length - 1 === componentPropNode.propPath[arrayFieldIdx]) {
                  Transforms.removeNodes(editor, {
                    at: componentPropPath
                  });
                  if (isLastProp) {
                    Transforms.insertNodes(editor, {
                      type: "paragraph",
                      children: [{
                        text: ""
                      }]
                    }, {
                      at: Path.next(componentBlockPath)
                    });
                    Transforms.select(editor, Path.next(componentBlockPath));
                  } else {
                    Transforms.move(editor, {
                      distance: 1,
                      unit: "line"
                    });
                  }
                } else {
                  insertBreak();
                }
                return;
              }
            }
          }
          Transforms.splitNodes(editor, {
            always: true
          });
          const splitNodePath = Path.next(componentPropPath);
          if (isLastProp) {
            Transforms.moveNodes(editor, {
              at: splitNodePath,
              to: Path.next(componentBlockPath)
            });
          } else {
            moveChildren(editor, splitNodePath, [...Path.next(splitNodePath), 0]);
            Transforms.removeNodes(editor, {
              at: splitNodePath
            });
          }
        });
        return;
      }
    }
    insertBreak();
  };
  editor.normalizeNode = (entry) => {
    const [node4, path3] = entry;
    if (node4.type === "component-inline-prop" && !node4.propPath && (node4.children.length !== 1 || !Text.isText(node4.children[0]) || node4.children[0].text !== "")) {
      Transforms.removeNodes(editor, {
        at: path3
      });
      return;
    }
    if (node4.type === "component-block") {
      const componentBlock = blockComponents[node4.component];
      if (componentBlock) {
        const rootSchema = {
          kind: "object",
          fields: componentBlock.schema
        };
        const updatedProps = addMissingFields(node4.props, rootSchema);
        if (updatedProps !== node4.props) {
          Transforms.setNodes(editor, {
            props: updatedProps
          }, {
            at: path3
          });
          return;
        }
        for (const [propPath, arrayField] of findArrayFieldsWithSingleChildField(rootSchema, node4.props)) {
          if (node4.children.length === 1 && node4.children[0].type === "component-inline-prop" && node4.children[0].propPath === void 0) {
            break;
          }
          const nodesWithin = [];
          for (const [idx, childNode] of node4.children.entries()) {
            if ((childNode.type === "component-block-prop" || childNode.type === "component-inline-prop") && childNode.propPath !== void 0) {
              const subPath = childNode.propPath.concat();
              while (subPath.length) {
                if (typeof subPath.pop() === "number")
                  break;
              }
              if (areArraysEqual(propPath, subPath)) {
                nodesWithin.push([idx, childNode]);
              }
            }
          }
          const arrVal = getValueAtPropPath(node4.props, propPath);
          const prevKeys = getKeysForArrayValue(arrVal);
          const prevKeysSet = new Set(prevKeys);
          const alreadyUsedIndicies = /* @__PURE__ */ new Set();
          const newVal = [];
          const newKeys = [];
          const getNewKey = () => {
            let key = getNewArrayElementKey();
            while (prevKeysSet.has(key)) {
              key = getNewArrayElementKey();
            }
            return key;
          };
          for (const [, node5] of nodesWithin) {
            const idxFromValue = node5.propPath[propPath.length];
            assert(typeof idxFromValue === "number");
            if (arrVal.length <= idxFromValue || alreadyUsedIndicies.has(idxFromValue) && isEmptyChildFieldNode(node5)) {
              newVal.push(getInitialPropsValue(arrayField.element));
              newKeys.push(getNewKey());
            } else {
              alreadyUsedIndicies.add(idxFromValue);
              newVal.push(arrVal[idxFromValue]);
              newKeys.push(alreadyUsedIndicies.has(idxFromValue) ? getNewKey() : prevKeys[idxFromValue]);
            }
          }
          setKeysForArrayValue(newVal, newKeys);
          if (!areArraysEqual(arrVal, newVal)) {
            const transformedProps = replaceValueAtPropPath(rootSchema, node4.props, newVal, propPath);
            Transforms.setNodes(editor, {
              props: transformedProps
            }, {
              at: path3
            });
            for (const [idx, [idxInChildrenOfBlock, nodeWithin]] of nodesWithin.entries()) {
              const newPropPath = [...nodeWithin.propPath];
              newPropPath[propPath.length] = idx;
              Transforms.setNodes(editor, {
                propPath: newPropPath
              }, {
                at: [...path3, idxInChildrenOfBlock]
              });
            }
            return;
          }
        }
        const missingKeys = new Map(findChildPropPaths(node4.props, componentBlock.schema).map((x4) => [JSON.stringify(x4.path), x4.options.kind]));
        node4.children.forEach((node5) => {
          assert(node5.type === "component-block-prop" || node5.type === "component-inline-prop");
          missingKeys.delete(JSON.stringify(node5.propPath));
        });
        if (missingKeys.size) {
          Transforms.insertNodes(editor, [...missingKeys].map(([prop, kind]) => ({
            type: `component-${kind}-prop`,
            propPath: prop ? JSON.parse(prop) : prop,
            children: [{
              text: ""
            }]
          })), {
            at: [...path3, node4.children.length]
          });
          return;
        }
        const foundProps = /* @__PURE__ */ new Set();
        const stringifiedInlinePropPaths = {};
        findChildPropPaths(node4.props, blockComponents[node4.component].schema).forEach((x4, index3) => {
          stringifiedInlinePropPaths[JSON.stringify(x4.path)] = {
            options: x4.options,
            index: index3
          };
        });
        for (const [index3, childNode] of node4.children.entries()) {
          if (
            // children that are not these will be handled by
            // the generic allowedChildren normalization
            childNode.type !== "component-inline-prop" && childNode.type !== "component-block-prop"
          ) {
            continue;
          }
          const childPath = [...path3, index3];
          const stringifiedPropPath = JSON.stringify(childNode.propPath);
          if (stringifiedInlinePropPaths[stringifiedPropPath] === void 0) {
            Transforms.removeNodes(editor, {
              at: childPath
            });
            return;
          }
          if (foundProps.has(stringifiedPropPath)) {
            Transforms.removeNodes(editor, {
              at: childPath
            });
            return;
          }
          foundProps.add(stringifiedPropPath);
          const propInfo = stringifiedInlinePropPaths[stringifiedPropPath];
          const expectedIndex = propInfo.index;
          if (index3 !== expectedIndex) {
            Transforms.moveNodes(editor, {
              at: childPath,
              to: [...path3, expectedIndex]
            });
            return;
          }
          const expectedChildNodeType = `component-${propInfo.options.kind}-prop`;
          if (childNode.type !== expectedChildNodeType) {
            Transforms.setNodes(editor, {
              type: expectedChildNodeType
            }, {
              at: childPath
            });
            return;
          }
          const documentFeatures = memoizedGetDocumentFeaturesForChildField(propInfo.options);
          if (normalizeNodeWithinComponentProp([childNode, childPath], editor, documentFeatures)) {
            return;
          }
        }
      }
    }
    normalizeNode(entry);
  };
  return editor;
}
function addMissingFields(value2, schema) {
  if (schema.kind === "child" || schema.kind === "form") {
    return value2;
  }
  if (schema.kind === "conditional") {
    const conditionalValue = value2;
    const updatedInnerValue = addMissingFields(conditionalValue.value, schema.values[conditionalValue.discriminant.toString()]);
    if (updatedInnerValue === conditionalValue.value) {
      return value2;
    }
    return {
      discriminant: conditionalValue.discriminant,
      value: updatedInnerValue
    };
  }
  if (schema.kind === "array") {
    const arrValue = value2;
    const newArrValue = arrValue.map((x4) => addMissingFields(x4, schema.element));
    if (areArraysEqual(arrValue, newArrValue)) {
      return value2;
    }
    return newArrValue;
  }
  if (schema.kind === "object") {
    const objectValue = value2;
    let hasChanged = false;
    const newObjectValue = {};
    for (const [key, innerSchema] of Object.entries(schema.fields)) {
      const innerValue = objectValue[key];
      if (innerValue === void 0) {
        hasChanged = true;
        newObjectValue[key] = getInitialPropsValue(innerSchema);
        continue;
      }
      const newInnerValue = addMissingFields(innerValue, innerSchema);
      if (newInnerValue !== innerValue) {
        hasChanged = true;
      }
      newObjectValue[key] = newInnerValue;
    }
    if (hasChanged) {
      return newObjectValue;
    }
    return value2;
  }
  assertNever(schema);
}
function ComponentInlineProp(props) {
  return (0, import_jsx_runtime92.jsx)("span", {
    ...props.attributes,
    children: props.children
  });
}
function getInitialValue(type2, componentBlock) {
  const props = getInitialPropsValue({
    kind: "object",
    fields: componentBlock.schema
  });
  return {
    type: "component-block",
    component: type2,
    props,
    children: findChildPropPaths(props, componentBlock.schema).map((x4) => ({
      type: `component-${x4.options.kind}-prop`,
      propPath: x4.path,
      children: [x4.options.kind === "block" ? {
        type: "paragraph",
        children: [{
          text: ""
        }]
      } : {
        text: ""
      }]
    }))
  };
}
function insertComponentBlock(editor, componentBlocks, componentBlock) {
  const node4 = getInitialValue(componentBlock, componentBlocks[componentBlock]);
  insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, node4);
  const componentBlockEntry = Editor.above(editor, {
    match: (node5) => node5.type === "component-block"
  });
  if (componentBlockEntry) {
    const start2 = Editor.start(editor, componentBlockEntry[1]);
    Transforms.setSelection(editor, {
      anchor: start2,
      focus: start2
    });
  }
}
var ComponentBlocksElement = ({
  attributes,
  children,
  element: __elementToGetPath
}) => {
  const editor = useSlateStatic();
  const [currentElement, setElement] = useElementWithSetNodes(editor, __elementToGetPath);
  const blockComponents = useDocumentEditorConfig().componentBlocks;
  const componentBlock = blockComponents[currentElement.component];
  const propsWithChildFields = (0, import_react79.useMemo)(() => {
    if (!componentBlock)
      return;
    const blockChildrenByPath = /* @__PURE__ */ new Map();
    for (const child of currentElement.children) {
      if (child.type === "component-block-prop" && child.propPath) {
        blockChildrenByPath.set(JSON.stringify(child.propPath), child.children);
      }
    }
    if (!blockChildrenByPath.size)
      return currentElement.props;
    return transformProps({
      kind: "object",
      fields: componentBlock.schema
    }, currentElement.props, {
      child(schema, value2, propPath) {
        if (schema.options.kind === "block") {
          const key = JSON.stringify(propPath);
          const children2 = blockChildrenByPath.get(key);
          if (children2) {
            return children2.map(cloneDescendent);
          }
        }
        return value2;
      }
    });
  }, [componentBlock, currentElement]);
  const elementToGetPathRef = (0, import_react79.useRef)({
    __elementToGetPath,
    currentElement,
    propsWithChildFields
  });
  (0, import_react79.useEffect)(() => {
    elementToGetPathRef.current = {
      __elementToGetPath,
      currentElement,
      propsWithChildFields
    };
  });
  const onRemove = useEventCallback(() => {
    const path3 = ReactEditor.findPath(editor, __elementToGetPath);
    Transforms.removeNodes(editor, {
      at: path3
    });
  });
  const onPropsChange = (0, import_react79.useCallback)((cb, ignoreChildFields) => {
    const prevProps = elementToGetPathRef.current.propsWithChildFields;
    updateComponentBlockElementProps(editor, componentBlock, prevProps, cb(prevProps), ReactEditor.findPath(editor, elementToGetPathRef.current.__elementToGetPath), setElement, ignoreChildFields);
  }, [setElement, componentBlock, editor]);
  const getToolbarPreviewProps = (0, import_react79.useMemo)(() => {
    if (!componentBlock) {
      return () => {
        throw new Error("expected component block to exist when called");
      };
    }
    return createGetPreviewProps({
      kind: "object",
      fields: componentBlock.schema
    }, (cb) => onPropsChange(cb, false), () => void 0);
  }, [componentBlock, onPropsChange]);
  if (!componentBlock) {
    return (0, import_jsx_runtime92.jsxs)("div", {
      style: {
        border: "red 4px solid",
        padding: 8
      },
      children: [(0, import_jsx_runtime92.jsx)("pre", {
        contentEditable: false,
        style: {
          userSelect: "none"
        },
        children: `The block "${currentElement.component}" no longer exists.

Props:

${JSON.stringify(currentElement.props, null, 2)}

Content:`
      }), children]
    });
  }
  const toolbarPreviewProps = getToolbarPreviewProps(propsWithChildFields);
  const renderedBlock = (0, import_jsx_runtime92.jsx)(ComponentBlockRender, {
    children,
    componentBlock,
    element: currentElement,
    onChange: onPropsChange,
    onRemove
  });
  return componentBlock.chromeless ? (0, import_jsx_runtime92.jsx)(ChromelessComponentBlockElement, {
    element: __elementToGetPath,
    attributes,
    renderedBlock,
    componentBlock,
    onRemove,
    previewProps: toolbarPreviewProps
  }) : (0, import_jsx_runtime92.jsx)(ChromefulComponentBlockElement, {
    attributes,
    children,
    componentBlock,
    onRemove,
    previewProps: toolbarPreviewProps,
    renderedBlock,
    elementProps: currentElement.props
  });
};
function insertDivider(editor) {
  insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
    type: "divider",
    children: [{
      text: ""
    }]
  });
  Editor.insertNode(editor, {
    type: "paragraph",
    children: [{
      text: ""
    }]
  });
}
var DividerButton = () => {
  const {
    editor,
    dividers: {
      isDisabled
    }
  } = useToolbarState();
  return (0, import_react79.useMemo)(() => (0, import_jsx_runtime92.jsx)(ActionButton, {
    prominence: "low",
    isDisabled,
    onPress: () => {
      insertDivider(editor);
    },
    children: (0, import_jsx_runtime92.jsx)(Icon, {
      src: minusIcon
    })
  }), [editor, isDisabled]);
};
var dividerButton = (0, import_jsx_runtime92.jsxs)(_TooltipTrigger, {
  delay: 200,
  children: [(0, import_jsx_runtime92.jsx)(DividerButton, {}), (0, import_jsx_runtime92.jsxs)(Tooltip, {
    children: [(0, import_jsx_runtime92.jsx)(Text2, {
      children: "Divider"
    }), (0, import_jsx_runtime92.jsx)(Kbd, {
      children: "---"
    })]
  })]
});
function DividerElement({
  attributes,
  children
}) {
  const selected = useSelected();
  return (0, import_jsx_runtime92.jsxs)("div", {
    ...attributes,
    style: {
      caretColor: "transparent"
    },
    children: [(0, import_jsx_runtime92.jsx)("hr", {
      style: {
        backgroundColor: selected ? tokenSchema.color.alias.borderSelected : tokenSchema.color.alias.borderIdle
      }
    }), children]
  });
}
var LayoutContainer = ({
  attributes,
  children,
  element: element4
}) => {
  const editor = useSlateStatic();
  const layout = element4.layout;
  const layoutOptions = useDocumentEditorConfig().documentFeatures.layouts;
  const currentLayoutIndex = layoutOptions.findIndex((x4) => x4.toString() === layout.toString());
  return (0, import_jsx_runtime92.jsx)("div", {
    className: blockElementSpacing,
    ...attributes,
    children: (0, import_jsx_runtime92.jsxs)(BlockPopoverTrigger, {
      element: element4,
      children: [(0, import_jsx_runtime92.jsx)("div", {
        className: css({
          columnGap: tokenSchema.size.space.regular,
          display: "grid"
        }),
        style: {
          gridTemplateColumns: layout.map((x4) => `${x4}fr`).join(" ")
        },
        children
      }), (0, import_jsx_runtime92.jsx)(BlockPopover, {
        children: (0, import_jsx_runtime92.jsxs)(Flex, {
          padding: "regular",
          gap: "regular",
          children: [(0, import_jsx_runtime92.jsx)(_ActionGroup, {
            selectionMode: "single",
            prominence: "low",
            density: "compact",
            onAction: (key) => {
              const path3 = ReactEditor.findPath(editor, element4);
              const layoutOption = layoutOptions[key];
              Transforms.setNodes(editor, {
                type: "layout",
                layout: layoutOption
              }, {
                at: path3
              });
              ReactEditor.focus(editor);
            },
            selectedKeys: currentLayoutIndex !== -1 ? [currentLayoutIndex.toString()] : [],
            children: layoutOptions.map((layoutOption, i6) => (0, import_jsx_runtime92.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
              children: makeLayoutIcon(layoutOption)
            }, i6))
          }), (0, import_jsx_runtime92.jsx)(ToolbarSeparator, {}), (0, import_jsx_runtime92.jsxs)(_TooltipTrigger, {
            children: [(0, import_jsx_runtime92.jsx)(ActionButton, {
              prominence: "low",
              onPress: () => {
                const path3 = ReactEditor.findPath(editor, element4);
                Transforms.removeNodes(editor, {
                  at: path3
                });
              },
              children: (0, import_jsx_runtime92.jsx)(Icon, {
                src: trash2Icon
              })
            }), (0, import_jsx_runtime92.jsx)(Tooltip, {
              tone: "critical",
              children: "Remove"
            })]
          })]
        })
      })]
    })
  });
};
var LayoutArea = ({
  attributes,
  children
}) => {
  return (0, import_jsx_runtime92.jsx)("div", {
    className: css({
      borderColor: tokenSchema.color.border.neutral,
      borderRadius: tokenSchema.size.radius.regular,
      borderStyle: "dashed",
      borderWidth: tokenSchema.size.border.regular,
      padding: tokenSchema.size.space.medium
    }),
    ...attributes,
    children
  });
};
var insertLayout = (editor, layout) => {
  insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, [{
    type: "layout",
    layout,
    children: [{
      type: "layout-area",
      children: [{
        type: "paragraph",
        children: [{
          text: ""
        }]
      }]
    }]
  }]);
  const layoutEntry = Editor.above(editor, {
    match: (x4) => x4.type === "layout"
  });
  if (layoutEntry) {
    Transforms.select(editor, [...layoutEntry[1], 0]);
  }
};
function makeLayoutIcon(ratios) {
  const size3 = 16;
  const element4 = (0, import_jsx_runtime92.jsx)("div", {
    role: "img",
    className: css({
      display: "grid",
      gridTemplateColumns: ratios.map((r7) => `${r7}fr`).join(" "),
      gap: 2,
      width: size3,
      height: size3
    }),
    children: ratios.map((_2, i6) => {
      return (0, import_jsx_runtime92.jsx)("div", {
        className: css({
          backgroundColor: "currentcolor",
          borderRadius: 1
        })
      }, i6);
    })
  });
  return element4;
}
var layoutsIcon = (0, import_jsx_runtime92.jsx)(Icon, {
  src: columnsIcon
});
var LayoutsButton = ({
  layouts
}) => {
  const {
    editor,
    layouts: {
      isSelected
    }
  } = useToolbarState();
  return (0, import_react79.useMemo)(() => (0, import_jsx_runtime92.jsxs)(_TooltipTrigger, {
    children: [(0, import_jsx_runtime92.jsx)(ActionButton, {
      prominence: "low",
      isSelected,
      onPress: () => {
        if (isElementActive(editor, "layout")) {
          Transforms.unwrapNodes(editor, {
            match: (node4) => node4.type === "layout"
          });
        } else {
          insertLayout(editor, layouts[0]);
        }
        ReactEditor.focus(editor);
      },
      children: layoutsIcon
    }), (0, import_jsx_runtime92.jsx)(Tooltip, {
      children: "Layouts"
    })]
  }), [editor, isSelected, layouts]);
};
var toggleList = (editor, format2) => {
  const listAbove = getListTypeAbove(editor);
  const isActive = isElementActive(editor, format2) && (listAbove === "none" || listAbove === format2);
  Editor.withoutNormalizing(editor, () => {
    Transforms.unwrapNodes(editor, {
      match: isListNode,
      split: true,
      mode: isActive ? "all" : "lowest"
    });
    if (!isActive) {
      Transforms.wrapNodes(editor, {
        type: format2,
        children: []
      }, {
        match: (x4) => x4.type !== "list-item-content" && isBlock(x4)
      });
    }
  });
};
function ListButtons(props) {
  const {
    editor,
    lists
  } = useToolbarState();
  return (0, import_react79.useMemo)(() => {
    const disabledKeys = [];
    if (lists.ordered.isDisabled)
      disabledKeys.push("ordered");
    if (lists.unordered.isDisabled)
      disabledKeys.push("unordered");
    const selectedKeys = [];
    if (lists.ordered.isSelected)
      selectedKeys.push("ordered");
    if (lists.unordered.isSelected)
      selectedKeys.push("unordered");
    return (0, import_jsx_runtime92.jsx)(_ActionGroup, {
      flexShrink: 0,
      "aria-label": "Lists",
      selectionMode: "single",
      buttonLabelBehavior: "hide",
      density: "compact",
      prominence: "low",
      summaryIcon: (0, import_jsx_runtime92.jsx)(Icon, {
        src: listIcon
      }),
      selectedKeys,
      disabledKeys,
      onAction: (key) => {
        const format2 = `${key}-list`;
        toggleList(editor, format2);
        ReactEditor.focus(editor);
      },
      children: [props.lists.unordered && (0, import_jsx_runtime92.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
        textValue: "Bullet List (- )",
        children: [(0, import_jsx_runtime92.jsx)(Icon, {
          src: listIcon
        }), (0, import_jsx_runtime92.jsx)(Text2, {
          children: "Bullet List"
        }), (0, import_jsx_runtime92.jsx)(Kbd, {
          children: "-⎵"
        })]
      }, "unordered"), props.lists.ordered && (0, import_jsx_runtime92.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
        textValue: "Numbered List (1.)",
        children: [(0, import_jsx_runtime92.jsx)(Icon, {
          src: listOrderedIcon
        }), (0, import_jsx_runtime92.jsx)(Text2, {
          children: "Numbered List"
        }), (0, import_jsx_runtime92.jsx)(Kbd, {
          children: "1.⎵"
        })]
      }, "ordered")].filter((x4) => x4 !== false)
    });
  }, [editor, lists.ordered.isDisabled, lists.ordered.isSelected, lists.unordered.isDisabled, lists.unordered.isSelected, props.lists.ordered, props.lists.unordered]);
}
function nestList(editor) {
  const block5 = Editor.above(editor, {
    match: isBlock
  });
  if (!block5 || block5[0].type !== "list-item-content") {
    return false;
  }
  const listItemPath = Path.parent(block5[1]);
  if (listItemPath[listItemPath.length - 1] === 0) {
    return false;
  }
  const previousListItemPath = Path.previous(listItemPath);
  const previousListItemNode = Node3.get(editor, previousListItemPath);
  if (previousListItemNode.children.length !== 1) {
    Transforms.moveNodes(editor, {
      at: listItemPath,
      to: [...previousListItemPath, previousListItemNode.children.length - 1, previousListItemNode.children[previousListItemNode.children.length - 1].children.length]
    });
    return true;
  }
  const type2 = Editor.parent(editor, Path.parent(block5[1]))[0].type;
  Editor.withoutNormalizing(editor, () => {
    Transforms.wrapNodes(editor, {
      type: type2,
      children: []
    }, {
      at: listItemPath
    });
    Transforms.moveNodes(editor, {
      to: [...previousListItemPath, previousListItemNode.children.length],
      at: listItemPath
    });
  });
  return true;
}
function unnestList(editor) {
  const block5 = Editor.above(editor, {
    match: isBlock
  });
  if (block5 && block5[0].type === "list-item-content") {
    Transforms.unwrapNodes(editor, {
      match: isListNode,
      split: true
    });
    return true;
  }
  return false;
}
function getUploadedFileObject(accept) {
  return new Promise((resolve3) => {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = accept;
    input.onchange = () => {
      var _input$files;
      const file = (_input$files = input.files) === null || _input$files === void 0 ? void 0 : _input$files[0];
      if (file) {
        resolve3(file);
      }
    };
    document.body.appendChild(input);
    input.click();
  });
}
async function getUploadedFile(accept) {
  const file = await getUploadedFileObject(accept);
  if (!file)
    return void 0;
  return {
    content: new Uint8Array(await file.arrayBuffer()),
    filename: file.name
  };
}
function getUploadedImage() {
  return getUploadedFile("image/*");
}
function useObjectURL(data) {
  const [url, setUrl] = (0, import_react79.useState)(null);
  (0, import_react79.useEffect)(() => {
    if (data) {
      const url2 = URL.createObjectURL(new Blob([data]));
      setUrl(url2);
      return () => URL.revokeObjectURL(url2);
    } else {
      setUrl(null);
    }
  }, [data]);
  return url;
}
function ImageFieldInput(props) {
  var _props$validation, _props$validation2;
  const {
    value: value2
  } = props;
  const [blurred, onBlur] = (0, import_react79.useReducer)(() => true, false);
  const isInEditor = useIsInDocumentEditor();
  const objectUrl = useObjectURL(value2 === null ? null : value2.data);
  const labelId = (0, import_react79.useId)();
  const descriptionId = (0, import_react79.useId)();
  return (0, import_jsx_runtime92.jsxs)(Flex, {
    "aria-describedby": props.description ? descriptionId : void 0,
    "aria-labelledby": labelId,
    direction: "column",
    gap: "medium",
    role: "group",
    children: [(0, import_jsx_runtime92.jsx)(FieldLabel, {
      id: labelId,
      elementType: "span",
      isRequired: (_props$validation = props.validation) === null || _props$validation === void 0 ? void 0 : _props$validation.isRequired,
      children: props.label
    }), props.description && (0, import_jsx_runtime92.jsx)(Text2, {
      size: "small",
      color: "neutralSecondary",
      id: descriptionId,
      children: props.description
    }), (0, import_jsx_runtime92.jsxs)(ButtonGroup, {
      children: [(0, import_jsx_runtime92.jsx)(ActionButton, {
        onPress: async () => {
          const image2 = await getUploadedImage();
          if (image2) {
            var _image$filename$match;
            const extension2 = (_image$filename$match = image2.filename.match(/\.([^.]+$)/)) === null || _image$filename$match === void 0 ? void 0 : _image$filename$match[1];
            if (extension2) {
              props.onChange({
                data: image2.content,
                extension: extension2,
                filename: image2.filename
              });
            }
          }
        },
        children: "Choose file"
      }), value2 !== null && (0, import_jsx_runtime92.jsx)(ActionButton, {
        prominence: "low",
        onPress: () => {
          props.onChange(null);
          onBlur();
        },
        children: "Remove"
      })]
    }), objectUrl && (0, import_jsx_runtime92.jsx)(Box, {
      alignSelf: "start",
      backgroundColor: "canvas",
      borderRadius: "regular",
      border: "neutral",
      padding: "regular",
      children: (0, import_jsx_runtime92.jsx)("img", {
        src: objectUrl,
        alt: "",
        style: {
          display: "block",
          maxHeight: tokenSchema.size.alias.singleLineWidth,
          maxWidth: "100%"
        }
      })
    }), isInEditor && value2 !== null && (0, import_jsx_runtime92.jsx)(TextField, {
      label: "Filename",
      onChange: (filename) => {
        props.onChange({
          ...value2,
          filename
        });
      },
      value: value2.filename
    }), (props.forceValidation || blurred) && ((_props$validation2 = props.validation) === null || _props$validation2 === void 0 ? void 0 : _props$validation2.isRequired) && value2 === null && (0, import_jsx_runtime92.jsxs)(FieldMessage, {
      children: [props.label, " is required"]
    })]
  });
}
var ImageElement = ({
  attributes,
  children,
  element: __elementForGettingPath
}) => {
  const [dialogOpen, setDialogOpen] = (0, import_react79.useState)(false);
  const [aspectRatio, setAspectRatio] = (0, import_react79.useState)();
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  const editor = useSlateStatic();
  const [currentElement, setNode] = useElementWithSetNodes(editor, __elementForGettingPath);
  const objectUrl = useObjectURL(currentElement.src.content);
  const activePopoverElement = useActiveBlockPopover();
  const selected = activePopoverElement === __elementForGettingPath;
  return (0, import_jsx_runtime92.jsxs)(import_jsx_runtime92.Fragment, {
    children: [(0, import_jsx_runtime92.jsxs)(BlockWrapper, {
      attributes,
      children: [children, (0, import_jsx_runtime92.jsxs)(BlockPopoverTrigger, {
        element: __elementForGettingPath,
        children: [(0, import_jsx_runtime92.jsx)("div", {
          style: {
            alignItems: "center",
            display: "flex",
            flexDirection: "column"
          },
          children: (0, import_jsx_runtime92.jsx)(NotEditable, {
            children: (0, import_jsx_runtime92.jsx)("img", {
              ...attributes,
              src: objectUrl,
              alt: currentElement.alt,
              "data-selected": selected,
              onLoad: (e6) => {
                const target = e6.target;
                setAspectRatio(target.width / target.height);
              },
              className: css({
                boxSizing: "border-box",
                borderRadius: tokenSchema.size.radius.regular,
                display: "block",
                maxHeight: tokenSchema.size.scale[3600],
                maxWidth: "100%",
                transition: transition("box-shadow"),
                "&[data-selected=true]": {
                  boxShadow: `0 0 0 ${tokenSchema.size.border.regular} ${tokenSchema.color.alias.borderSelected}`
                }
              })
            })
          })
        }), (0, import_jsx_runtime92.jsx)(BlockPopover, {
          hideArrow: true,
          children: (0, import_jsx_runtime92.jsxs)(Flex, {
            gap: "regular",
            padding: "regular",
            children: [(0, import_jsx_runtime92.jsxs)(Flex, {
              gap: "small",
              children: [(0, import_jsx_runtime92.jsxs)(_TooltipTrigger, {
                children: [(0, import_jsx_runtime92.jsx)(ActionButton, {
                  prominence: "low",
                  onPress: () => setDialogOpen(true),
                  children: (0, import_jsx_runtime92.jsx)(Icon, {
                    src: editIcon
                  })
                }), (0, import_jsx_runtime92.jsx)(Tooltip, {
                  children: stringFormatter.format("edit")
                })]
              }), (0, import_jsx_runtime92.jsxs)(_TooltipTrigger, {
                children: [(0, import_jsx_runtime92.jsx)(ActionButton, {
                  prominence: "low",
                  onPress: async () => {
                    const src = await getUploadedImage();
                    if (src) {
                      setNode({
                        src
                      });
                    }
                  },
                  children: (0, import_jsx_runtime92.jsx)(Icon, {
                    src: fileUpIcon
                  })
                }), (0, import_jsx_runtime92.jsx)(Tooltip, {
                  children: "Choose file"
                })]
              })]
            }), (0, import_jsx_runtime92.jsx)(Divider, {
              orientation: "vertical"
            }), (0, import_jsx_runtime92.jsxs)(_TooltipTrigger, {
              children: [(0, import_jsx_runtime92.jsx)(ActionButton, {
                prominence: "low",
                onPress: () => {
                  Transforms.removeNodes(editor, {
                    at: ReactEditor.findPath(editor, __elementForGettingPath)
                  });
                },
                children: (0, import_jsx_runtime92.jsx)(Icon, {
                  src: trash2Icon
                })
              }), (0, import_jsx_runtime92.jsx)(Tooltip, {
                tone: "critical",
                children: "Remove"
              })]
            })]
          })
        })]
      }, aspectRatio)]
    }), (0, import_jsx_runtime92.jsx)(DialogContainer, {
      onDismiss: () => {
        setDialogOpen(false);
        focusWithPreviousSelection(editor);
      },
      children: dialogOpen && (0, import_jsx_runtime92.jsx)(ImageDialog, {
        alt: currentElement.alt,
        title: currentElement.title,
        filename: currentElement.src.filename,
        onSubmit: ({
          alt,
          filename,
          title
        }) => {
          setNode({
            alt,
            title,
            src: {
              content: currentElement.src.content,
              filename
            }
          });
        }
      })
    })]
  });
};
function ImageDialog(props) {
  const {
    images
  } = useDocumentEditorConfig().documentFeatures;
  if (!images) {
    throw new Error("unexpected image rendered when images are disabled");
  }
  const schema = (0, import_react79.useMemo)(() => object(images.schema), [images]);
  const [state, setState] = (0, import_react79.useState)({
    alt: props.alt,
    title: props.title
  });
  const previewProps = (0, import_react79.useMemo)(() => createGetPreviewProps(schema, setState, () => void 0), [schema])(state);
  const [filenameWithoutExtension, filenameExtension] = splitFilename(props.filename);
  const [forceValidation, setForceValidation] = (0, import_react79.useState)(false);
  let [fileName, setFileName] = (0, import_react79.useState)(filenameWithoutExtension);
  let [fileNameTouched, setFileNameTouched] = (0, import_react79.useState)(false);
  let {
    dismiss
  } = useDialogContainer();
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  return (0, import_jsx_runtime92.jsx)(Dialog, {
    size: "small",
    children: (0, import_jsx_runtime92.jsxs)("form", {
      style: {
        display: "contents"
      },
      onSubmit: (event) => {
        if (event.target !== event.currentTarget)
          return;
        event.preventDefault();
        setForceValidation(true);
        if (fileName && clientSideValidateProp(schema, state, void 0)) {
          dismiss();
          props.onSubmit({
            alt: state.alt,
            title: state.title,
            filename: [fileName, filenameExtension].join(".")
          });
        }
      },
      children: [(0, import_jsx_runtime92.jsx)(Heading, {
        children: "Image details"
      }), (0, import_jsx_runtime92.jsx)(Content, {
        children: (0, import_jsx_runtime92.jsxs)(Flex, {
          gap: "large",
          direction: "column",
          children: [(0, import_jsx_runtime92.jsx)(TextField, {
            label: "File name",
            onChange: setFileName,
            onBlur: () => setFileNameTouched(true),
            value: fileName,
            isRequired: true,
            errorMessage: (fileNameTouched || forceValidation) && !fileName ? "Please provide a file name." : void 0,
            endElement: filenameExtension ? (0, import_jsx_runtime92.jsx)(Flex, {
              alignItems: "center",
              justifyContent: "center",
              paddingEnd: "regular",
              children: (0, import_jsx_runtime92.jsxs)(Text2, {
                color: "neutralTertiary",
                children: [".", filenameExtension]
              })
            }) : null
          }), (0, import_jsx_runtime92.jsx)(FormValueContentFromPreviewProps, {
            forceValidation,
            autoFocus: true,
            ...previewProps
          })]
        })
      }), (0, import_jsx_runtime92.jsxs)(ButtonGroup, {
        children: [(0, import_jsx_runtime92.jsx)(Button, {
          onPress: dismiss,
          children: stringFormatter.format("cancel")
        }), (0, import_jsx_runtime92.jsx)(Button, {
          prominence: "high",
          type: "submit",
          children: stringFormatter.format("save")
        })]
      })]
    })
  });
}
function splitFilename(filename) {
  const dotIndex = filename.lastIndexOf(".");
  if (dotIndex === -1) {
    return [filename, ""];
  }
  return [filename.substring(0, dotIndex), filename.substring(dotIndex + 1)];
}
var _imageIcon = (0, import_jsx_runtime92.jsx)(Icon, {
  src: imageIcon
});
function ImageButton() {
  const editor = useSlateStatic();
  return (0, import_jsx_runtime92.jsx)(import_jsx_runtime92.Fragment, {
    children: (0, import_jsx_runtime92.jsx)(ActionButton, {
      prominence: "low",
      onPress: async () => {
        const src = await getUploadedImage();
        if (src) {
          Transforms.insertNodes(editor, {
            type: "image",
            src,
            alt: "",
            title: "",
            children: [{
              text: ""
            }]
          });
        }
      },
      children: _imageIcon
    })
  });
}
var imageButton = (0, import_jsx_runtime92.jsxs)(_TooltipTrigger, {
  children: [(0, import_jsx_runtime92.jsx)(ImageButton, {}), (0, import_jsx_runtime92.jsx)(Tooltip, {
    children: (0, import_jsx_runtime92.jsx)(Text2, {
      children: "Image"
    })
  })]
});
function withImages(editor) {
  const {
    insertData
  } = editor;
  editor.insertData = (data) => {
    const images = Array.from(data.files).filter((x4) => x4.type.startsWith("image/"));
    if (images.length) {
      Promise.all(images.map(async (file) => ({
        name: file.name,
        data: new Uint8Array(await file.arrayBuffer())
      }))).then((images2) => {
        insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
          type: "image",
          src: {
            content: images2[0].data,
            filename: images2[0].name
          },
          alt: "",
          title: "",
          children: [{
            text: ""
          }]
        });
      });
      return;
    }
    insertData(data);
  };
  return editor;
}
function order(a3, b2) {
  return {
    start: Math.min(a3, b2),
    end: Math.max(a3, b2)
  };
}
function getRelativeRowPath(hasHead, rowIndex) {
  return hasHead ? rowIndex === 0 ? [0, 0] : [1, rowIndex - 1] : [0, rowIndex];
}
function getSelectedTableArea(editor) {
  var _Editor$above, _editor$selection, _Editor$above2, _editor$selection2;
  const anchor = (_Editor$above = Editor.above(editor, {
    match: nodeTypeMatcher("table-cell"),
    at: (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.anchor.path
  })) === null || _Editor$above === void 0 ? void 0 : _Editor$above[1];
  const focus = (_Editor$above2 = Editor.above(editor, {
    match: nodeTypeMatcher("table-cell"),
    at: (_editor$selection2 = editor.selection) === null || _editor$selection2 === void 0 ? void 0 : _editor$selection2.focus.path
  })) === null || _Editor$above2 === void 0 ? void 0 : _Editor$above2[1];
  const table3 = Editor.above(editor, {
    match: nodeTypeMatcher("table")
  });
  if (editor.selection && table3 && Element2.isElement(table3[0].children[0]) && anchor && focus && Path.equals(anchor.slice(0, -3), focus.slice(0, -3))) {
    const [start2, end] = Editor.edges(editor, editor.selection);
    return {
      tablePath: table3[1],
      table: table3[0],
      singleCell: Path.equals(anchor, focus) ? Point.equals(Editor.start(editor, anchor), start2) && Point.equals(Editor.end(editor, anchor), end) && !Point.equals(start2, end) ? "selected" : "not-selected" : "many",
      row: order(anchor[anchor.length - 2] + anchor[anchor.length - 3], focus[focus.length - 2] + focus[anchor.length - 3]),
      column: order(anchor[anchor.length - 1], focus[focus.length - 1])
    };
  }
}
var cell = (header) => ({
  type: "table-cell",
  ...header ? {
    header: true
  } : {},
  children: [{
    type: "paragraph",
    children: [{
      text: ""
    }]
  }]
});
function cloneDescendant(node4) {
  if (Text.isText(node4))
    return {
      ...node4
    };
  return {
    ...node4,
    children: node4.children.map(cloneDescendant)
  };
}
function withTable(editor) {
  const {
    deleteFragment,
    normalizeNode,
    getFragment,
    insertFragment,
    deleteBackward
  } = editor;
  editor.insertFragment = (fragment) => {
    const selectedTableArea = getSelectedTableArea(editor);
    if (!selectedTableArea || fragment.length !== 1 || fragment[0].type !== "table") {
      insertFragment(fragment);
      return;
    }
    const newRows = fragment[0].children.flatMap((child) => child.type === "table-head" || child.type === "table-body" ? child.children : []);
    if (!newRows.every(nodeTypeMatcher("table-row"))) {
      insertFragment(fragment);
      return;
    }
    let {
      row,
      column: column2,
      tablePath,
      table: table3
    } = selectedTableArea;
    const existingBody = selectedTableArea.table.children[selectedTableArea.table.children.length === 1 ? 0 : 1];
    if (newRows[0].type !== "table-row" || existingBody.type !== "table-body" || existingBody.children[0].type !== "table-row") {
      insertFragment(fragment);
      return;
    }
    const hasHead = table3.children[0].type === "table-head";
    if (selectedTableArea.singleCell !== "many") {
      row = {
        start: row.start,
        end: Math.min(row.start + newRows.length - 1, existingBody.children.length - 1 + (hasHead ? 1 : 0))
      };
      column2 = {
        start: column2.start,
        end: Math.min(column2.start + newRows[0].children.length - 1, existingBody.children[0].children.length - 1)
      };
    }
    Editor.withoutNormalizing(editor, () => {
      for (let rowIndex = row.start; rowIndex <= row.end; rowIndex++) {
        const newRow = newRows[(rowIndex - row.start) % newRows.length];
        for (let cellIndex = column2.start; cellIndex <= column2.end; cellIndex++) {
          const relativeCellPath = [...getRelativeRowPath(hasHead, rowIndex), cellIndex];
          const cell2 = Node3.get(table3, relativeCellPath);
          const newCell = newRow.children[(cellIndex - column2.start) % newRow.children.length];
          if (cell2.type !== "table-cell" || newCell.type !== "table-cell") {
            continue;
          }
          const cellPath = [...tablePath, ...relativeCellPath];
          for (const childIdx of [...cell2.children.keys()].reverse()) {
            Transforms.removeNodes(editor, {
              at: [...cellPath, childIdx]
            });
          }
          Transforms.insertNodes(editor, newCell.children.map(cloneDescendant), {
            at: [...cellPath, 0]
          });
        }
      }
      Transforms.setSelection(editor, {
        anchor: Editor.start(editor, [...tablePath, ...getRelativeRowPath(hasHead, row.start), column2.start]),
        focus: Editor.end(editor, [...tablePath, ...getRelativeRowPath(hasHead, row.end), column2.end])
      });
    });
  };
  editor.deleteBackward = (unit) => {
    if (editor.selection && Range.isCollapsed(editor.selection) && editor.selection.anchor.offset === 0) {
      const tableCell = Editor.above(editor, {
        match: nodeTypeMatcher("table-cell")
      });
      if (tableCell && tableCell[0].children[0].type === "paragraph" && tableCell[0].children[0].children[0].type === void 0 && Path.equals(editor.selection.anchor.path, [...tableCell[1], 0, 0])) {
        return;
      }
    }
    deleteBackward(unit);
  };
  editor.getFragment = () => {
    const selectedTableArea = getSelectedTableArea(editor);
    if (selectedTableArea && selectedTableArea.singleCell !== "not-selected") {
      var _table$children$;
      const {
        table: table3
      } = selectedTableArea;
      const first = table3.children[0].type === "table-head" || table3.children[0].type === "table-body" ? table3.children[0] : void 0;
      if (!first) {
        return getFragment();
      }
      const second = ((_table$children$ = table3.children[1]) === null || _table$children$ === void 0 ? void 0 : _table$children$.type) === "table-body" ? table3.children[1] : void 0;
      const body = second || first;
      const hasHead = first.type === "table-head";
      const isSelectionInHead = selectedTableArea.row.start === 0 && !!second;
      const columnLength = selectedTableArea.column.end - selectedTableArea.column.start + 1;
      return [{
        type: "table",
        children: [...isSelectionInHead ? [{
          type: "table-head",
          children: [{
            type: "table-row",
            children: Array.from({
              length: columnLength
            }).map((_2, columnIndex) => first.children[0].children[columnIndex + selectedTableArea.column.start])
          }]
        }] : [], {
          type: "table-body",
          children: Array.from({
            length: selectedTableArea.row.end - selectedTableArea.row.start + (isSelectionInHead ? 0 : 1)
          }).map((_2, rowIndex) => ({
            type: "table-row",
            children: Array.from({
              length: columnLength
            }).map((_3, columnIndex) => body.children[rowIndex + selectedTableArea.row.start - (hasHead && !isSelectionInHead ? 1 : 0)].children[columnIndex + selectedTableArea.column.start])
          }))
        }]
      }];
    }
    return getFragment();
  };
  editor.deleteFragment = (direction) => {
    if (!editor.selection || Range.isCollapsed(editor.selection)) {
      deleteFragment(direction);
      return;
    }
    const selectedTableArea = getSelectedTableArea(editor);
    if (!selectedTableArea || selectedTableArea.singleCell === "not-selected") {
      deleteFragment(direction);
      return;
    }
    const headOrBody = selectedTableArea.table.children[0];
    if (!Element2.isElement(headOrBody) || !Element2.isElement(headOrBody.children[0])) {
      deleteFragment(direction);
      return;
    }
    const maxRowIdx = selectedTableArea.table.children.reduce((sum2, headOrBody2) => sum2 + (headOrBody2.type === "table-head" || headOrBody2.type === "table-body" ? headOrBody2.children.length : 0), 0) - 1;
    const {
      row,
      column: column2,
      tablePath
    } = selectedTableArea;
    const hasWholeColumnSelected = row.start === 0 && row.end === maxRowIdx;
    const hasWholeRowSelected = column2.start === 0 && column2.end === headOrBody.children[0].children.length - 1;
    if (hasWholeColumnSelected && hasWholeRowSelected) {
      Transforms.removeNodes(editor, {
        at: tablePath
      });
      return;
    }
    const hasHead = headOrBody.type === "table-head";
    if (hasWholeRowSelected) {
      Editor.withoutNormalizing(editor, () => {
        for (let i6 = row.end; i6 >= row.start; i6--) {
          if (hasHead) {
            if (i6 === 0) {
              Transforms.removeNodes(editor, {
                at: [...tablePath, 0]
              });
              continue;
            }
            Transforms.removeNodes(editor, {
              at: [...tablePath, 1, i6 - 1]
            });
            continue;
          }
          Transforms.removeNodes(editor, {
            at: [...tablePath, 0, i6]
          });
        }
      });
      return;
    }
    if (hasWholeColumnSelected) {
      Editor.withoutNormalizing(editor, () => {
        for (let i6 = column2.end; i6 >= column2.start; i6--) {
          for (let rowIdx = 0; rowIdx <= maxRowIdx; rowIdx++) {
            Transforms.removeNodes(editor, {
              at: [...tablePath, ...getRelativeRowPath(hasHead, rowIdx), i6]
            });
          }
        }
        const selectionPath = [...tablePath, 0, 0, column2.start];
        const point3 = Editor.start(editor, column2.start === 0 ? selectionPath : Path.previous(selectionPath));
        Transforms.select(editor, point3);
      });
      return;
    }
    const selectionStart = Editor.start(editor, editor.selection).path;
    Editor.withoutNormalizing(editor, () => {
      for (let rowIndex = row.start; rowIndex <= row.end; rowIndex++) {
        for (let cellIndex = column2.start; cellIndex <= column2.end; cellIndex++) {
          const relativeCellPath = [...getRelativeRowPath(hasHead, rowIndex), cellIndex];
          const cell2 = Node3.get(selectedTableArea.table, relativeCellPath);
          if (!Element2.isElement(cell2)) {
            continue;
          }
          const cellPath = [...tablePath, ...relativeCellPath];
          Transforms.insertNodes(editor, {
            type: "paragraph",
            children: [{
              text: ""
            }]
          }, {
            at: [...cellPath, 0]
          });
          for (const childIdx of [...cell2.children.keys()].reverse()) {
            Transforms.removeNodes(editor, {
              at: [...cellPath, childIdx + 1]
            });
          }
        }
      }
      Transforms.select(editor, selectionStart);
    });
  };
  editor.normalizeNode = (entry) => {
    const [node4, path3] = entry;
    if (node4.type === "table-head" && node4.children.length > 1) {
      moveChildren(editor, path3, Path.next(path3), (_2, i6) => i6 !== 0);
      return;
    }
    let didUpdateThings = false;
    for (const parent of ["table-body", "table-head"]) {
      if (node4.type === parent) {
        for (const [rowIdx, row] of node4.children.entries()) {
          if (row.type === "table-row") {
            for (const [cellIdx, cell2] of row.children.entries()) {
              if (cell2.type === "table-cell") {
                const at = [...path3, rowIdx, cellIdx];
                if (cell2.header && parent === "table-body") {
                  Transforms.unsetNodes(editor, "header", {
                    at
                  });
                  didUpdateThings = true;
                }
                if (!cell2.header && parent === "table-head") {
                  Transforms.setNodes(editor, {
                    header: true
                  }, {
                    at
                  });
                  didUpdateThings = true;
                }
              }
            }
          }
        }
      }
    }
    if (didUpdateThings) {
      return;
    }
    if (node4.type === "table") {
      const maxRowCount = node4.children.reduce((max4, node5) => node5.type === "table-head" || node5.type === "table-body" ? node5.children.reduce((max5, node6) => node6.type === "table-row" ? Math.max(max5, node6.children.length) : max5, max4) : max4, 0);
      let didInsert = false;
      for (const [idx, child] of node4.children.entries()) {
        if (child.type === "table-body" || child.type === "table-head") {
          for (const [rowIdx, row] of child.children.entries()) {
            if (row.type === "table-row" && row.children.length !== maxRowCount) {
              Transforms.insertNodes(editor, Array.from({
                length: maxRowCount - row.children.length
              }, () => cell(child.type === "table-head")), {
                at: [...path3, idx, rowIdx, row.children.length]
              });
              didInsert = true;
            }
          }
        }
      }
      if (didInsert) {
        return;
      }
      if (node4.children.length === 1 && node4.children[0].type === "table-head") {
        Transforms.insertNodes(editor, {
          type: "table-body",
          children: Array.from({
            length: node4.children[0].children.length
          }, () => cell(false))
        }, {
          at: [...path3, 1]
        });
        return;
      }
      if (node4.children.length === 2 && node4.children[1].type === "table-head") {
        Transforms.moveNodes(editor, {
          at: [...path3, 1],
          to: [...path3, 0]
        });
        return;
      }
      if (node4.children.length > 2) {
        moveChildren(editor, path3, Path.next(path3), (_2, i6) => i6 !== 0 && i6 !== 1);
        return;
      }
    }
    normalizeNode(entry);
  };
  return editor;
}
var insertTable = (editor) => {
  Transforms.insertNodes(editor, {
    type: "table",
    children: [{
      type: "table-head",
      children: [{
        type: "table-row",
        children: [cell(true), cell(true), cell(true)]
      }]
    }, {
      type: "table-body",
      children: [{
        type: "table-row",
        children: [cell(false), cell(false), cell(false)]
      }, {
        type: "table-row",
        children: [cell(false), cell(false), cell(false)]
      }]
    }]
  });
};
var SelectedCellsContext = (0, import_react79.createContext)(void 0);
function getSelectedCells(table3, row, column2) {
  var _table$children$;
  const selectedCells = /* @__PURE__ */ new Set();
  const first = table3.children[0].type === "table-head" || table3.children[0].type === "table-body" ? table3.children[0] : void 0;
  if (!first)
    return selectedCells;
  const second = ((_table$children$ = table3.children[1]) === null || _table$children$ === void 0 ? void 0 : _table$children$.type) === "table-body" ? table3.children[1] : void 0;
  for (let rowIndex = row.start; rowIndex <= row.end; rowIndex++) {
    const row2 = second ? rowIndex === 0 ? first.children[0] : second.children[rowIndex - 1] : first.children[rowIndex];
    if (!Element2.isElement(row2))
      continue;
    for (let cellIndex = column2.start; cellIndex <= column2.end; cellIndex++) {
      selectedCells.add(row2.children[cellIndex]);
    }
  }
  return selectedCells;
}
function TableSelectionProvider(props) {
  const editor = useSlate();
  const selectedTableArea = getSelectedTableArea(editor);
  if (selectedTableArea) {
    var _Editor$above, _editor$selection;
    return (0, import_jsx_runtime92.jsx)(SelectedCellsContext.Provider, {
      value: {
        cells: selectedTableArea.singleCell === "not-selected" ? /* @__PURE__ */ new Set() : getSelectedCells(selectedTableArea.table, selectedTableArea.row, selectedTableArea.column),
        table: selectedTableArea.table,
        focus: (_Editor$above = Editor.above(editor, {
          match: nodeTypeMatcher("table-cell"),
          at: (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.focus.path
        })) === null || _Editor$above === void 0 ? void 0 : _Editor$above[0]
      },
      children: props.children
    });
  }
  return (0, import_jsx_runtime92.jsx)(SelectedCellsContext.Provider, {
    value: void 0,
    children: props.children
  });
}
var StartElementsContext = (0, import_react79.createContext)({
  top: /* @__PURE__ */ new Map(),
  left: /* @__PURE__ */ new Map()
});
var TableElement = ({
  attributes,
  children,
  element: element4
}) => {
  var _element$children$;
  const editor = useSlateStatic();
  const selectedCellsContext = (0, import_react79.useContext)(SelectedCellsContext);
  const selectedCells = (selectedCellsContext === null || selectedCellsContext === void 0 ? void 0 : selectedCellsContext.table) === element4 ? selectedCellsContext : void 0;
  const startElements = (0, import_react79.useMemo)(() => {
    const firstTableChild = element4.children[0];
    if (!Element2.isElement(firstTableChild) || !Element2.isElement(firstTableChild.children[0])) {
      return {
        top: /* @__PURE__ */ new Map(),
        left: /* @__PURE__ */ new Map()
      };
    }
    const top = /* @__PURE__ */ new Map();
    const left = /* @__PURE__ */ new Map();
    for (const [idx, cell2] of firstTableChild.children[0].children.entries()) {
      if (cell2.type !== "table-cell")
        continue;
      top.set(cell2, element4.children.every((headOrBody) => Element2.isElement(headOrBody) ? headOrBody.children.every((row) => Element2.isElement(row) && (selectedCells === null || selectedCells === void 0 ? void 0 : selectedCells.cells.has(row.children[idx]))) : false));
    }
    for (const headOrBody of element4.children) {
      if (headOrBody.type !== "table-head" && headOrBody.type !== "table-body") {
        continue;
      }
      for (const row of headOrBody.children) {
        if (row.type !== "table-row" || row.children[0].type !== "table-cell") {
          continue;
        }
        left.set(row.children[0], row.children.every((element5) => selectedCells === null || selectedCells === void 0 ? void 0 : selectedCells.cells.has(element5)));
      }
    }
    return {
      top,
      left
    };
  }, [element4, selectedCells]);
  return (0, import_jsx_runtime92.jsx)(StartElementsContext.Provider, {
    value: startElements,
    children: (0, import_jsx_runtime92.jsx)(SelectedCellsContext.Provider, {
      value: selectedCells,
      children: (0, import_jsx_runtime92.jsx)(BlockWrapper, {
        attributes,
        children: (0, import_jsx_runtime92.jsxs)(BlockPopoverTrigger, {
          element: element4,
          children: [(0, import_jsx_runtime92.jsx)("table", {
            className: css({
              width: "100%",
              tableLayout: "fixed",
              position: "relative",
              borderSpacing: 0,
              "& *::selection": selectedCells !== null && selectedCells !== void 0 && selectedCells.cells.size ? {
                backgroundColor: "transparent"
              } : void 0
            }),
            children
          }), (0, import_jsx_runtime92.jsx)(BlockPopover, {
            children: (0, import_jsx_runtime92.jsxs)(Flex, {
              gap: "regular",
              padding: "regular",
              children: [(0, import_jsx_runtime92.jsxs)(_TooltipTrigger, {
                children: [(0, import_jsx_runtime92.jsx)(ActionButton, {
                  prominence: "low",
                  isSelected: ((_element$children$ = element4.children[0]) === null || _element$children$ === void 0 ? void 0 : _element$children$.type) === "table-head",
                  onPress: () => {
                    const tablePath = ReactEditor.findPath(editor, element4);
                    Editor.withoutNormalizing(editor, () => {
                      if (element4.children[0].type === "table-head") {
                        Transforms.moveNodes(editor, {
                          at: [...tablePath, 0, 0],
                          to: [...tablePath, 1, 0]
                        });
                        Transforms.removeNodes(editor, {
                          at: [...tablePath, 0]
                        });
                        return;
                      }
                      Transforms.insertNodes(editor, {
                        type: "table-head",
                        children: []
                      }, {
                        at: [...tablePath, 0]
                      });
                      Transforms.moveNodes(editor, {
                        at: [...tablePath, 1, 0],
                        to: [...tablePath, 0, 0]
                      });
                    });
                  },
                  children: (0, import_jsx_runtime92.jsx)(Icon, {
                    src: sheetIcon
                  })
                }), (0, import_jsx_runtime92.jsx)(Tooltip, {
                  children: "Header row"
                })]
              }), (0, import_jsx_runtime92.jsx)(ToolbarSeparator, {}), (0, import_jsx_runtime92.jsxs)(_TooltipTrigger, {
                children: [(0, import_jsx_runtime92.jsx)(ActionButton, {
                  prominence: "low",
                  onPress: () => {
                    Transforms.removeNodes(editor, {
                      at: ReactEditor.findPath(editor, element4)
                    });
                  },
                  children: (0, import_jsx_runtime92.jsx)(Icon, {
                    src: trash2Icon
                  })
                }), (0, import_jsx_runtime92.jsx)(Tooltip, {
                  tone: "critical",
                  children: "Remove"
                })]
              })]
            })
          })]
        })
      })
    })
  });
};
var TableBodyElement = ({
  attributes,
  children
}) => {
  return (0, import_jsx_runtime92.jsx)("tbody", {
    ...attributes,
    children
  });
};
var TableHeadElement = ({
  attributes,
  children
}) => {
  return (0, import_jsx_runtime92.jsx)("thead", {
    ...attributes,
    children
  });
};
var TableRowElement = ({
  attributes,
  children,
  element: element4
}) => {
  var _useContext, _table$children$index;
  const table3 = (_useContext = (0, import_react79.useContext)(SelectedCellsContext)) === null || _useContext === void 0 ? void 0 : _useContext.table;
  return (0, import_jsx_runtime92.jsx)(RowIndexContext.Provider, {
    value: (_table$children$index = table3 === null || table3 === void 0 ? void 0 : table3.children.indexOf(element4)) !== null && _table$children$index !== void 0 ? _table$children$index : -1,
    children: (0, import_jsx_runtime92.jsx)("tr", {
      ...attributes,
      children
    })
  });
};
var RowIndexContext = (0, import_react79.createContext)(-1);
function TableCellElement({
  attributes,
  children,
  element: element4
}) {
  const editor = useSlateStatic();
  const selectedCellsContext = (0, import_react79.useContext)(SelectedCellsContext);
  const startElements = (0, import_react79.useContext)(StartElementsContext);
  const isSelected = selectedCellsContext === null || selectedCellsContext === void 0 ? void 0 : selectedCellsContext.cells.has(element4);
  const size3 = `calc(100% + 2px)`;
  const ElementType = element4.header ? "th" : "td";
  const borderColor = isSelected ? tokenSchema.color.alias.borderSelected : tokenSchema.color.alias.borderIdle;
  return (0, import_jsx_runtime92.jsxs)(ElementType, {
    className: css({
      borderInlineEnd: `1px solid ${borderColor}`,
      borderBottom: `1px solid ${borderColor}`,
      borderTop: startElements.top.has(element4) ? `1px solid ${borderColor}` : void 0,
      borderInlineStart: startElements.left.has(element4) ? `1px solid ${borderColor}` : void 0,
      backgroundColor: selectedCellsContext !== null && selectedCellsContext !== void 0 && selectedCellsContext.cells.has(element4) ? tokenSchema.color.alias.backgroundSelected : element4.header ? tokenSchema.color.scale.slate3 : void 0,
      position: "relative",
      margin: 0,
      padding: tokenSchema.size.space.regular,
      fontWeight: "inherit",
      boxSizing: "border-box",
      textAlign: "start",
      verticalAlign: "top"
    }),
    ...attributes,
    children: [isSelected && (0, import_jsx_runtime92.jsxs)(import_jsx_runtime92.Fragment, {
      children: [(0, import_jsx_runtime92.jsx)("div", {
        contentEditable: false,
        className: css({
          position: "absolute",
          top: -1,
          insetInlineStart: -1,
          background: tokenSchema.color.alias.borderSelected,
          height: size3,
          width: 1
        })
      }), (0, import_jsx_runtime92.jsx)("div", {
        contentEditable: false,
        className: css({
          position: "absolute",
          top: -1,
          insetInlineStart: -1,
          background: tokenSchema.color.alias.borderSelected,
          height: 1,
          width: size3
        })
      })]
    }), startElements.top.has(element4) && (0, import_jsx_runtime92.jsx)(CellSelection, {
      location: "top",
      selected: !!startElements.top.get(element4),
      label: "Select Column",
      onClick: () => {
        const path3 = ReactEditor.findPath(editor, element4);
        const table3 = Editor.above(editor, {
          match: nodeTypeMatcher("table"),
          at: path3
        });
        if (!table3)
          return;
        const lastTableIndex = table3[0].children.length - 1;
        const tableBody = table3[0].children[lastTableIndex];
        if (tableBody.type !== "table-body")
          return;
        const cellIndex = path3[path3.length - 1];
        const endPath = [...table3[1], table3[0].children.length - 1, tableBody.children.length - 1, cellIndex];
        Transforms.select(editor, {
          anchor: Editor.start(editor, path3),
          focus: Editor.end(editor, endPath)
        });
      }
    }), startElements.left.has(element4) && (0, import_jsx_runtime92.jsx)(CellSelection, {
      location: "left",
      selected: !!startElements.left.get(element4),
      label: "Select Row",
      onClick: () => {
        const path3 = ReactEditor.findPath(editor, element4);
        Transforms.select(editor, {
          anchor: Editor.start(editor, Path.parent(path3)),
          focus: Editor.end(editor, Path.parent(path3))
        });
      }
    }), startElements.left.has(element4) && startElements.top.has(element4) && (0, import_jsx_runtime92.jsx)(CellSelection, {
      location: "top-left",
      selected: !!(startElements.top.get(element4) && startElements.left.get(element4)),
      label: "Select Table",
      onClick: () => {
        const path3 = ReactEditor.findPath(editor, element4);
        const table3 = Editor.above(editor, {
          match: nodeTypeMatcher("table"),
          at: path3
        });
        if (!table3)
          return;
        Transforms.select(editor, {
          anchor: Editor.start(editor, table3[1]),
          focus: Editor.end(editor, table3[1])
        });
      }
    }), (0, import_jsx_runtime92.jsx)("div", {
      children
    }), (selectedCellsContext === null || selectedCellsContext === void 0 ? void 0 : selectedCellsContext.focus) === element4 && (0, import_jsx_runtime92.jsx)(CellMenu, {
      cell: element4,
      table: selectedCellsContext.table
    })]
  });
}
function CellSelection(props) {
  const selectedCellsContext = (0, import_react79.useContext)(SelectedCellsContext);
  const editor = useSlateStatic();
  let {
    location: location2,
    selected
  } = props;
  return (0, import_jsx_runtime92.jsxs)("div", {
    contentEditable: false,
    children: [(0, import_jsx_runtime92.jsx)("button", {
      tabIndex: -1,
      type: "button",
      ...toDataAttributes({
        location: location2,
        selected
      }),
      className: css({
        background: tokenSchema.color.scale.slate3,
        border: `1px solid ${tokenSchema.color.alias.borderIdle}`,
        margin: 0,
        padding: 0,
        position: "absolute",
        ":hover": {
          background: tokenSchema.color.scale.slate4
        },
        // ever so slightly larger hit area
        "::before": {
          content: '""',
          inset: -1,
          position: "absolute"
        },
        // location
        "&[data-location=top]": {
          top: -9,
          insetInlineStart: -1,
          width: "calc(100% + 2px)",
          height: 8
        },
        "&[data-location=left]": {
          top: -1,
          insetInlineStart: -9,
          width: 8,
          height: "calc(100% + 2px)"
        },
        "&[data-location=top-left]": {
          top: -9,
          insetInlineStart: -9,
          width: 8,
          height: 8
        },
        "&:not([data-location=top])": {
          borderInlineEnd: "none"
        },
        "&:not([data-location=left])": {
          borderBottom: "none"
        },
        // state
        "&[data-selected=true]": {
          background: tokenSchema.color.scale.indigo8,
          borderColor: tokenSchema.color.alias.borderSelected
        }
      }),
      style: {
        visibility: selectedCellsContext !== null && selectedCellsContext !== void 0 && selectedCellsContext.focus ? "visible" : "hidden"
      },
      "aria-label": props.label,
      onClick: () => {
        ReactEditor.focus(editor);
        props.onClick();
      }
    }), props.selected && (props.location === "top" ? (0, import_jsx_runtime92.jsx)("div", {
      className: css({
        position: "absolute",
        top: -9,
        insetInlineEnd: -1,
        background: tokenSchema.color.alias.borderSelected,
        height: 8,
        width: 1,
        zIndex: 2
      })
    }) : (0, import_jsx_runtime92.jsx)("div", {
      className: css({
        position: "absolute",
        bottom: -1,
        insetInlineStart: -9,
        background: tokenSchema.color.alias.borderSelected,
        height: 1,
        width: 8,
        zIndex: 2
      })
    }))]
  });
}
var cellActions = {
  deleteRow: {
    label: "Delete row",
    action: (editor, cellPath) => {
      const tablePath = cellPath.slice(0, -3);
      const table3 = Node3.get(editor, tablePath);
      if (table3.type !== "table")
        return;
      const hasHead = table3.children[0].type === "table-head";
      const rowPath = Path.parent(cellPath);
      Transforms.removeNodes(editor, {
        at: hasHead && rowPath[cellPath.length - 3] === 0 ? Path.parent(rowPath) : rowPath
      });
    }
  },
  deleteColumn: {
    label: "Delete column",
    action: (editor, path3) => {
      const cellIndex = path3[path3.length - 1];
      const tablePath = path3.slice(0, -3);
      const table3 = Node3.get(editor, tablePath);
      if (table3.type !== "table")
        return;
      Editor.withoutNormalizing(editor, () => {
        for (const [headOrBodyIdx, headOrBody] of table3.children.entries()) {
          if (headOrBody.type !== "table-head" && headOrBody.type !== "table-body") {
            continue;
          }
          for (const idx of headOrBody.children.keys()) {
            Transforms.removeNodes(editor, {
              at: [...tablePath, headOrBodyIdx, idx, cellIndex]
            });
          }
        }
      });
    }
  },
  insertRowBelow: {
    label: "Insert row below",
    action: (editor, path3) => {
      const tableRow = Node3.get(editor, Path.parent(path3));
      const tablePath = path3.slice(0, -3);
      const table3 = Node3.get(editor, tablePath);
      if (tableRow.type !== "table-row" || table3.type !== "table") {
        return;
      }
      const hasHead = table3.children[0].type === "table-head";
      const newRowPath = [...tablePath, hasHead ? 1 : 0, hasHead && path3[path3.length - 3] === 0 ? 0 : path3[path3.length - 2] + 1];
      Editor.withoutNormalizing(editor, () => {
        Transforms.insertNodes(editor, {
          type: "table-row",
          children: tableRow.children.map(() => cell(false))
        }, {
          at: newRowPath
        });
        Transforms.select(editor, [...newRowPath, path3[path3.length - 1]]);
      });
    }
  },
  insertColumnRight: {
    label: "Insert column right",
    action: (editor, path3) => {
      const newCellIndex = path3[path3.length - 1] + 1;
      const tablePath = path3.slice(0, -3);
      const table3 = Node3.get(editor, tablePath);
      if (table3.type !== "table")
        return;
      Editor.withoutNormalizing(editor, () => {
        for (const [headOrBodyIdx, headOrBody] of table3.children.entries()) {
          if (headOrBody.type !== "table-head" && headOrBody.type !== "table-body") {
            continue;
          }
          for (const rowIdx of headOrBody.children.keys()) {
            Transforms.insertNodes(editor, cell(headOrBody.type === "table-head"), {
              at: [...tablePath, headOrBodyIdx, rowIdx, newCellIndex]
            });
          }
        }
        Transforms.select(editor, Editor.start(editor, Path.next(path3)));
      });
    }
  }
};
var _cellActions = cellActions;
function CellMenu(props) {
  const editor = useSlateStatic();
  const gutter = tokenSchema.size.space.small;
  return (0, import_jsx_runtime92.jsx)("div", {
    contentEditable: false,
    className: css({
      top: gutter,
      insetInlineEnd: gutter,
      position: "absolute"
    }),
    children: (0, import_jsx_runtime92.jsxs)(_TooltipTrigger, {
      children: [(0, import_jsx_runtime92.jsxs)(MenuTrigger, {
        align: "end",
        children: [(0, import_jsx_runtime92.jsx)(ActionButton, {
          prominence: "low",
          UNSAFE_className: css({
            borderRadius: tokenSchema.size.radius.small,
            height: "auto",
            minWidth: 0,
            padding: 0,
            // tiny buttons; increase the hit area
            "&::before": {
              content: '""',
              inset: `calc(${gutter} * -1)`,
              position: "absolute"
            }
          }),
          children: (0, import_jsx_runtime92.jsx)(Icon, {
            src: chevronDownIcon
          })
        }), (0, import_jsx_runtime92.jsx)(_Menu, {
          onAction: (key) => {
            if (key in _cellActions) {
              _cellActions[key].action(editor, ReactEditor.findPath(editor, props.cell));
            }
          },
          items: Object.entries(_cellActions).map(([key, item2]) => ({
            ...item2,
            key
          })),
          children: (item2) => (0, import_jsx_runtime92.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
            children: item2.label
          }, item2.key)
        })]
      }), (0, import_jsx_runtime92.jsx)(Tooltip, {
        children: "Options"
      })]
    })
  });
}
var TableButton = () => {
  const {
    editor,
    blockquote: {
      isDisabled,
      isSelected
    }
  } = useToolbarState();
  return (0, import_react79.useMemo)(() => (0, import_jsx_runtime92.jsx)(ActionButton, {
    prominence: "low",
    isSelected,
    isDisabled,
    onPress: () => {
      insertTable(editor);
      ReactEditor.focus(editor);
    },
    children: (0, import_jsx_runtime92.jsx)(Icon, {
      src: tableIcon
    })
  }), [editor, isDisabled, isSelected]);
};
var tableButton = (0, import_jsx_runtime92.jsxs)(_TooltipTrigger, {
  children: [(0, import_jsx_runtime92.jsx)(TableButton, {}), (0, import_jsx_runtime92.jsx)(Tooltip, {
    children: (0, import_jsx_runtime92.jsx)(Text2, {
      children: "Table"
    })
  })]
});
function getCellPathInDirection(editor, path3, direction) {
  if (direction === "left" || direction === "right") {
    const row = Editor.above(editor, {
      match: nodeTypeMatcher("table-row"),
      at: path3
    });
    if (!row)
      return;
    const currentCellIdx = path3[path3.length - 1];
    const diff2 = direction === "left" ? -1 : 1;
    const nextCellIdx = currentCellIdx + diff2;
    const nextCell = row[0].children[nextCellIdx];
    if (!nextCell)
      return;
    return [...row[1], nextCellIdx];
  }
  const table3 = Editor.above(editor, {
    match: nodeTypeMatcher("table"),
    at: path3
  });
  if (!table3)
    return;
  const diff = direction === "up" ? -1 : 1;
  const rowIndex = path3[path3.length - 3] + path3[path3.length - 2];
  const nextRowIndex = rowIndex + diff;
  const relativeRowPath = getRelativeRowPath(table3[0].children[0].type === "table-head", nextRowIndex);
  if (!Node3.has(table3[0], relativeRowPath))
    return;
  return [...table3[1], ...relativeRowPath, path3[path3.length - 1]];
}
function Toolbar({
  documentFeatures,
  viewState
}) {
  const componentBlocks = useDocumentEditorConfig().componentBlocks;
  let hasComponentBlocksForInsertMenu = false, hasComponentBlocksForToolbar = false;
  for (const componentBlock of Object.values(componentBlocks)) {
    if (componentBlock.toolbarIcon) {
      hasComponentBlocksForToolbar = true;
    }
    if (!componentBlock.toolbarIcon) {
      hasComponentBlocksForInsertMenu = true;
    }
  }
  const hasMarks = Object.values(documentFeatures.formatting.inlineMarks).some((x4) => x4);
  const hasAlignment = documentFeatures.formatting.alignment.center || documentFeatures.formatting.alignment.end;
  const hasLists = documentFeatures.formatting.listTypes.unordered || documentFeatures.formatting.listTypes.ordered;
  return (0, import_jsx_runtime92.jsxs)(ToolbarWrapper, {
    children: [(0, import_jsx_runtime92.jsxs)(ToolbarScrollArea, {
      children: [!!documentFeatures.formatting.headings.levels.length && (0, import_jsx_runtime92.jsx)(HeadingMenu, {
        headingLevels: documentFeatures.formatting.headings.levels
      }), hasMarks && (0, import_jsx_runtime92.jsx)(InlineMarks, {
        marks: documentFeatures.formatting.inlineMarks
      }), (hasAlignment || hasLists) && (0, import_jsx_runtime92.jsxs)(ToolbarGroup, {
        children: [hasAlignment && (0, import_jsx_runtime92.jsx)(TextAlignMenu, {
          alignment: documentFeatures.formatting.alignment
        }), hasLists && (0, import_jsx_runtime92.jsx)(ListButtons, {
          lists: documentFeatures.formatting.listTypes
        })]
      }), (documentFeatures.dividers || documentFeatures.links || !!documentFeatures.images || documentFeatures.formatting.blockTypes.blockquote || documentFeatures.tables || !!documentFeatures.layouts.length || documentFeatures.formatting.blockTypes.code || hasComponentBlocksForToolbar) && (0, import_jsx_runtime92.jsxs)(ToolbarGroup, {
        children: [documentFeatures.dividers && dividerButton, documentFeatures.links && linkButton, documentFeatures.images && imageButton, documentFeatures.formatting.blockTypes.blockquote && blockquoteButton, !!documentFeatures.layouts.length && (0, import_jsx_runtime92.jsx)(LayoutsButton, {
          layouts: documentFeatures.layouts
        }), documentFeatures.formatting.blockTypes.code && codeButton, documentFeatures.tables && tableButton, hasComponentBlocksForInsertMenu && insertBlocksInToolbar]
      }), (0, import_jsx_runtime92.jsx)(Box, {
        flex: true
      })]
    }), (0, import_react79.useMemo)(() => {
      return viewState && (0, import_jsx_runtime92.jsxs)(Flex, {
        gap: "xsmall",
        children: [(0, import_jsx_runtime92.jsx)(ToolbarSeparator, {}), (0, import_jsx_runtime92.jsxs)(_TooltipTrigger, {
          children: [(0, import_jsx_runtime92.jsx)(Button, {
            prominence: "low",
            onPress: () => {
              viewState.toggle();
            },
            children: (0, import_jsx_runtime92.jsx)(Icon, {
              src: viewState.expanded ? minimizeIcon : maximizeIcon
            })
          }), (0, import_jsx_runtime92.jsx)(Tooltip, {
            children: viewState.expanded ? "Collapse" : "Expand"
          })]
        })]
      });
    }, [viewState]), !!hasComponentBlocksForInsertMenu && (0, import_jsx_runtime92.jsx)(InsertBlockMenu, {})]
  });
}
var ToolbarGroup = ({
  children
}) => {
  return (0, import_jsx_runtime92.jsx)(Flex, {
    gap: "regular",
    children
  });
};
var ToolbarContainer = ({
  children
}) => {
  let entryLayoutPane = useEntryLayoutSplitPaneContext();
  if (entryLayoutPane === "main") {
    return (0, import_jsx_runtime92.jsx)("div", {
      className: css({
        boxSizing: "border-box",
        display: "flex",
        paddingInline: tokenSchema.size.space.medium,
        minWidth: 0,
        maxWidth: 800,
        marginInline: "auto",
        [breakpointQueries$1.above.mobile]: {
          paddingInline: tokenSchema.size.space.xlarge
        },
        [breakpointQueries$1.above.tablet]: {
          paddingInline: tokenSchema.size.space.xxlarge
        }
      }),
      children
    });
  }
  return (0, import_jsx_runtime92.jsx)("div", {
    className: css({
      display: "flex"
    }),
    children
  });
};
var ToolbarWrapper = ({
  children
}) => {
  let entryLayoutPane = useEntryLayoutSplitPaneContext();
  return (0, import_jsx_runtime92.jsx)(import_jsx_runtime92.Fragment, {
    children: (0, import_jsx_runtime92.jsx)("div", {
      "data-layout": entryLayoutPane,
      className: css({
        backdropFilter: "blur(8px)",
        backgroundClip: "padding-box",
        backgroundColor: `color-mix(in srgb, transparent, ${tokenSchema.color.background.canvas} 90%)`,
        borderBottom: `${tokenSchema.size.border.regular} solid color-mix(in srgb, transparent, ${tokenSchema.color.foreground.neutral} 10%)`,
        borderStartEndRadius: tokenSchema.size.radius.medium,
        borderStartStartRadius: tokenSchema.size.radius.medium,
        minWidth: 0,
        position: "sticky",
        top: 0,
        zIndex: 2,
        '&[data-layout="main"]': {
          borderRadius: 0
        }
      }),
      children: (0, import_jsx_runtime92.jsx)(ToolbarContainer, {
        children
      })
    })
  });
};
var ToolbarScrollArea = (props) => {
  let entryLayoutPane = useEntryLayoutSplitPaneContext();
  return (0, import_jsx_runtime92.jsx)(Flex, {
    "data-layout": entryLayoutPane,
    paddingY: "regular",
    paddingX: "medium",
    gap: "large",
    flex: true,
    minWidth: 0,
    UNSAFE_className: css({
      msOverflowStyle: "none",
      scrollbarWidth: "none",
      overflowX: "auto",
      /* for Chrome, Safari, and Opera */
      "&::-webkit-scrollbar": {
        display: "none"
      },
      '&[data-layout="main"]': {
        paddingInline: 0
      }
    }),
    ...props
  });
};
var headingMenuVals = /* @__PURE__ */ new Map([["normal", "normal"], ["1", 1], ["2", 2], ["3", 3], ["4", 4], ["5", 5], ["6", 6]]);
var HeadingMenu = ({
  headingLevels
}) => {
  const {
    editor,
    textStyles
  } = useToolbarState();
  const isDisabled = textStyles.allowedHeadingLevels.length === 0;
  const items = (0, import_react79.useMemo)(() => {
    let resolvedItems = [{
      name: "Paragraph",
      id: "normal"
    }];
    headingLevels.forEach((level) => {
      resolvedItems.push({
        name: `Heading ${level}`,
        id: level.toString()
      });
    });
    return resolvedItems;
  }, [headingLevels]);
  const selected = textStyles.selected.toString();
  return (0, import_react79.useMemo)(() => (0, import_jsx_runtime92.jsx)(_Picker, {
    flexShrink: 0,
    width: "scale.1700",
    prominence: "low",
    "aria-label": "Text block",
    items,
    isDisabled,
    selectedKey: selected,
    onSelectionChange: (selected2) => {
      let key = headingMenuVals.get(selected2);
      if (key === "normal") {
        Editor.withoutNormalizing(editor, () => {
          Transforms.unsetNodes(editor, "level", {
            match: (n6) => n6.type === "heading"
          });
          Transforms.setNodes(editor, {
            type: "paragraph"
          }, {
            match: (n6) => n6.type === "heading"
          });
        });
      } else if (key) {
        Transforms.setNodes(editor, {
          type: "heading",
          level: key
        }, {
          match: (node4) => node4.type === "paragraph" || node4.type === "heading"
        });
      }
      ReactEditor.focus(editor);
    },
    children: (item2) => (0, import_jsx_runtime92.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
      children: item2.name
    }, item2.id)
  }), [editor, isDisabled, items, selected]);
};
var insertBlocksInToolbar = (0, import_jsx_runtime92.jsx)(InsertBlocksInToolbar, {});
function InsertBlocksInToolbar() {
  const editor = useSlateStatic();
  const componentBlocks = useDocumentEditorConfig().componentBlocks;
  return Object.entries(componentBlocks).filter(([, val]) => val.toolbarIcon).map(([key, item2]) => {
    return (0, import_jsx_runtime92.jsxs)(_TooltipTrigger, {
      children: [(0, import_jsx_runtime92.jsx)(ActionButton, {
        prominence: "low",
        onPress: () => {
          insertComponentBlock(editor, componentBlocks, key);
          ReactEditor.focus(editor);
        },
        children: (0, import_jsx_runtime92.jsx)(Icon, {
          src: item2.toolbarIcon
        })
      }), (0, import_jsx_runtime92.jsx)(Tooltip, {
        children: item2.label
      })]
    }, key);
  });
}
function InsertBlockMenu() {
  let entryLayoutPane = useEntryLayoutSplitPaneContext();
  const editor = useSlateStatic();
  const componentBlocks = useDocumentEditorConfig().componentBlocks;
  return (0, import_jsx_runtime92.jsxs)(MenuTrigger, {
    align: "end",
    children: [(0, import_jsx_runtime92.jsxs)(_TooltipTrigger, {
      children: [(0, import_jsx_runtime92.jsxs)(ActionButton, {
        marginY: "regular",
        marginEnd: entryLayoutPane === "main" ? void 0 : "medium",
        children: [(0, import_jsx_runtime92.jsx)(Icon, {
          src: plusIcon
        }), (0, import_jsx_runtime92.jsx)(Icon, {
          src: chevronDownIcon
        })]
      }), (0, import_jsx_runtime92.jsxs)(Tooltip, {
        children: [(0, import_jsx_runtime92.jsx)(Text2, {
          children: "Insert"
        }), (0, import_jsx_runtime92.jsx)(Kbd, {
          children: "/"
        })]
      })]
    }), (0, import_jsx_runtime92.jsx)(_Menu, {
      onAction: (key) => {
        insertComponentBlock(editor, componentBlocks, key);
      },
      items: Object.entries(componentBlocks).filter(([, val]) => !val.toolbarIcon),
      children: ([key, item2]) => (0, import_jsx_runtime92.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
        children: item2.label
      }, key)
    })]
  });
}
var inlineMarks = [{
  key: "bold",
  label: "Bold",
  icon: boldIcon,
  shortcut: `B`
}, {
  key: "italic",
  label: "Italic",
  icon: italicIcon,
  shortcut: `I`
}, {
  key: "underline",
  label: "Underline",
  icon: underlineIcon,
  shortcut: `U`
}, {
  key: "strikethrough",
  label: "Strikethrough",
  icon: strikethroughIcon
}, {
  key: "code",
  label: "Code",
  icon: codeIcon
}, {
  key: "superscript",
  label: "Superscript",
  icon: superscriptIcon
}, {
  key: "subscript",
  label: "Subscript",
  icon: subscriptIcon
}, {
  key: "clearFormatting",
  label: "Clear formatting",
  icon: removeFormattingIcon
}];
function InlineMarks({
  marks: _marksShown
}) {
  const {
    editor,
    clearFormatting: {
      isDisabled
    },
    marks
  } = useToolbarState();
  const marksShown = useMemoStringified(_marksShown);
  const selectedKeys = useMemoStringified(Object.keys(marks).filter((key) => marks[key].isSelected));
  const disabledKeys = useMemoStringified(Object.keys(marks).filter((key) => marks[key].isDisabled).concat(isDisabled ? "clearFormatting" : []));
  return (0, import_react79.useMemo)(() => {
    const items = inlineMarks.filter((item2) => item2.key === "clearFormatting" || marksShown[item2.key]);
    return (0, import_jsx_runtime92.jsx)(_ActionGroup, {
      UNSAFE_className: css({
        minWidth: `calc(${tokenSchema.size.element.medium} * 4)`
      }),
      prominence: "low",
      density: "compact",
      buttonLabelBehavior: "hide",
      overflowMode: "collapse",
      summaryIcon: (0, import_jsx_runtime92.jsx)(Icon, {
        src: typeIcon
      }),
      items,
      selectionMode: "multiple",
      selectedKeys,
      disabledKeys,
      onAction: (key) => {
        if (key === "clearFormatting") {
          clearFormatting(editor);
        } else {
          var _Editor$marks;
          const mark = key;
          if ((_Editor$marks = Editor.marks(editor)) !== null && _Editor$marks !== void 0 && _Editor$marks[mark]) {
            Editor.removeMark(editor, mark);
          } else {
            Editor.addMark(editor, mark, true);
          }
        }
        ReactEditor.focus(editor);
      },
      children: (item2) => {
        return (0, import_jsx_runtime92.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
          textValue: item2.label,
          children: [(0, import_jsx_runtime92.jsx)(Text2, {
            children: item2.label
          }), "shortcut" in item2 && (0, import_jsx_runtime92.jsx)(Kbd, {
            meta: true,
            children: item2.shortcut
          }), (0, import_jsx_runtime92.jsx)(Icon, {
            src: item2.icon
          })]
        }, item2.key);
      }
    });
  }, [disabledKeys, editor, marksShown, selectedKeys]);
}
function useMemoStringified(value2) {
  return (0, import_react79.useMemo)(() => value2, [JSON.stringify(value2)]);
}
var HeadingElement = ({
  attributes,
  children,
  element: element4
}) => {
  const ElementType = `h${element4.level}`;
  const editor = useSlateStatic();
  const {
    documentFeatures
  } = useDocumentEditorConfig();
  const [dialogOpen, setDialogOpen] = (0, import_react79.useState)(false);
  if (Object.keys(documentFeatures.formatting.headings.schema.fields).length === 0) {
    return (0, import_jsx_runtime92.jsx)(ElementType, {
      ...attributes,
      style: {
        textAlign: element4.textAlign
      },
      children
    });
  }
  return (0, import_jsx_runtime92.jsxs)(import_jsx_runtime92.Fragment, {
    children: [(0, import_jsx_runtime92.jsx)(ElementType, {
      style: {
        textAlign: element4.textAlign
      },
      children: (0, import_jsx_runtime92.jsxs)(BlockPopoverTrigger, {
        element: element4,
        children: [(0, import_jsx_runtime92.jsx)("div", {
          children
        }), (0, import_jsx_runtime92.jsx)(BlockPopover, {
          children: (0, import_jsx_runtime92.jsxs)(Flex, {
            gap: "regular",
            padding: "regular",
            children: [(0, import_jsx_runtime92.jsx)(CustomAttributesEditButton, {
              onPress: () => setDialogOpen(true)
            }), (0, import_jsx_runtime92.jsxs)(_TooltipTrigger, {
              children: [(0, import_jsx_runtime92.jsx)(ActionButton, {
                prominence: "low",
                onPress: () => {
                  Transforms.removeNodes(editor, {
                    at: ReactEditor.findPath(editor, element4)
                  });
                },
                children: (0, import_jsx_runtime92.jsx)(Icon, {
                  src: trash2Icon
                })
              }), (0, import_jsx_runtime92.jsx)(Tooltip, {
                tone: "critical",
                children: "Remove"
              })]
            })]
          })
        })]
      })
    }), (0, import_jsx_runtime92.jsx)(CustomAttributesDialog, {
      element: element4,
      schema: documentFeatures.formatting.headings.schema,
      isOpen: dialogOpen,
      nodeLabel: "Heading",
      onDismiss: () => setDialogOpen(false)
    })]
  });
};
var renderElement = (props) => {
  switch (props.element.type) {
    case "layout":
      return (0, import_jsx_runtime92.jsx)(LayoutContainer, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    case "layout-area":
      return (0, import_jsx_runtime92.jsx)(LayoutArea, {
        ...props
      });
    case "code":
      return (0, import_jsx_runtime92.jsx)(CodeElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    case "component-block": {
      return (0, import_jsx_runtime92.jsx)(ComponentBlocksElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    }
    case "component-inline-prop":
    case "component-block-prop":
      return (0, import_jsx_runtime92.jsx)(ComponentInlineProp, {
        ...props
      });
    case "heading":
      return (0, import_jsx_runtime92.jsx)(HeadingElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    case "link":
      return (0, import_jsx_runtime92.jsx)(LinkElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    case "ordered-list":
      return (0, import_jsx_runtime92.jsx)("ol", {
        ...props.attributes,
        children: props.children
      });
    case "unordered-list":
      return (0, import_jsx_runtime92.jsx)("ul", {
        ...props.attributes,
        children: props.children
      });
    case "list-item":
      return (0, import_jsx_runtime92.jsx)("li", {
        ...props.attributes,
        children: props.children
      });
    case "list-item-content":
      return (0, import_jsx_runtime92.jsx)("span", {
        ...props.attributes,
        children: props.children
      });
    case "blockquote":
      return (0, import_jsx_runtime92.jsx)("blockquote", {
        ...props.attributes,
        children: props.children
      });
    case "divider":
      return (0, import_jsx_runtime92.jsx)(DividerElement, {
        ...props
      });
    case "image":
      return (0, import_jsx_runtime92.jsx)(ImageElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    case "table":
      return (0, import_jsx_runtime92.jsx)(TableElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    case "table-head":
      return (0, import_jsx_runtime92.jsx)(TableHeadElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    case "table-body":
      return (0, import_jsx_runtime92.jsx)(TableBodyElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    case "table-row":
      return (0, import_jsx_runtime92.jsx)(TableRowElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    case "table-cell":
      return (0, import_jsx_runtime92.jsx)(TableCellElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    default:
      let {
        textAlign
      } = props.element;
      return (0, import_jsx_runtime92.jsx)("p", {
        style: {
          textAlign
        },
        ...props.attributes,
        children: props.children
      });
  }
};
function getOptions2(toolbarState, componentBlocks) {
  const options = [...Object.keys(componentBlocks).map((key) => ({
    label: componentBlocks[key].label,
    insert: (editor) => {
      insertComponentBlock(editor, componentBlocks, key);
    }
  })), ...toolbarState.textStyles.allowedHeadingLevels.filter((a3) => toolbarState.editorDocumentFeatures.formatting.headings.levels.includes(a3)).map((level) => ({
    label: `Heading ${level}`,
    insert(editor) {
      insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
        type: "heading",
        level,
        children: [{
          text: ""
        }]
      });
    }
  })), !toolbarState.blockquote.isDisabled && toolbarState.editorDocumentFeatures.formatting.blockTypes.blockquote && {
    label: "Blockquote",
    insert(editor) {
      insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
        type: "blockquote",
        children: [{
          text: ""
        }]
      });
    }
  }, !toolbarState.code.isDisabled && toolbarState.editorDocumentFeatures.formatting.blockTypes.code && {
    label: "Code block",
    insert(editor) {
      insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
        type: "code",
        children: [{
          text: ""
        }]
      });
    }
  }, !!toolbarState.editorDocumentFeatures.images && {
    label: "Image",
    async insert(editor) {
      const image2 = await getUploadedImage();
      if (image2) {
        insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
          type: "image",
          src: image2,
          alt: "",
          title: "",
          children: [{
            text: ""
          }]
        });
      }
    }
  }, !!toolbarState.editorDocumentFeatures.tables && {
    label: "Table",
    insert: insertTable
  }, !toolbarState.dividers.isDisabled && toolbarState.editorDocumentFeatures.dividers && {
    label: "Divider",
    insert(editor) {
      insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
        type: "divider",
        children: [{
          text: ""
        }]
      });
    }
  }, !!toolbarState.editorDocumentFeatures.layouts.length && {
    label: "Layout",
    insert(editor) {
      insertLayout(editor, toolbarState.editorDocumentFeatures.layouts[0]);
    }
  }, !toolbarState.lists.ordered.isDisabled && toolbarState.editorDocumentFeatures.formatting.listTypes.ordered && {
    label: "Numbered List",
    keywords: ["ordered list"],
    insert(editor) {
      insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
        type: "ordered-list",
        children: [{
          text: ""
        }]
      });
    }
  }, !toolbarState.lists.unordered.isDisabled && toolbarState.editorDocumentFeatures.formatting.listTypes.unordered && {
    label: "Bullet List",
    keywords: ["unordered list"],
    insert(editor) {
      insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
        type: "unordered-list",
        children: [{
          text: ""
        }]
      });
    }
  }];
  return options.filter((x4) => typeof x4 !== "boolean");
}
function insertOption(editor, text7, option) {
  const path3 = ReactEditor.findPath(editor, text7);
  Transforms.delete(editor, {
    at: {
      focus: Editor.start(editor, path3),
      anchor: Editor.end(editor, path3)
    }
  });
  option.insert(editor);
}
function InsertMenu({
  children,
  text: text7
}) {
  const toolbarState = useToolbarState();
  const {
    editor
  } = toolbarState;
  const {
    componentBlocks
  } = useDocumentEditorConfig();
  const options = matchSorter(getOptions2(toolbarState, componentBlocks), text7.text.slice(1), {
    keys: ["label", "keywords"]
  }).map((option, index3) => ({
    ...option,
    index: index3
  }));
  const stateRef = (0, import_react79.useRef)({
    options,
    text: text7
  });
  (0, import_react79.useEffect)(() => {
    stateRef.current = {
      options,
      text: text7
    };
  });
  const listenerRef = (0, import_react79.useRef)((_event) => {
  });
  (0, import_react79.useEffect)(() => {
    listenerRef.current = (event) => {
      if (event.defaultPrevented)
        return;
      switch (event.key) {
        case "ArrowDown": {
          if (stateRef.current.options.length) {
            event.preventDefault();
            state.selectionManager.setFocused(true);
            state.selectionManager.setFocusedKey((Number(state.selectionManager.focusedKey) === stateRef.current.options.length - 1 ? 0 : Number(state.selectionManager.focusedKey) + 1).toString());
          }
          return;
        }
        case "ArrowUp": {
          if (stateRef.current.options.length) {
            event.preventDefault();
            state.selectionManager.setFocused(true);
            state.selectionManager.setFocusedKey((state.selectionManager.focusedKey === "0" ? stateRef.current.options.length - 1 : Number(state.selectionManager.focusedKey) - 1).toString());
          }
          return;
        }
        case "Enter": {
          const option = stateRef.current.options[Number(state.selectionManager.focusedKey)];
          if (option) {
            insertOption(editor, stateRef.current.text, option);
            event.preventDefault();
          }
          return;
        }
        case "Escape": {
          const path3 = ReactEditor.findPath(editor, stateRef.current.text);
          Transforms.unsetNodes(editor, "insertMenu", {
            at: path3
          });
          event.preventDefault();
          return;
        }
      }
    };
  });
  (0, import_react79.useEffect)(() => {
    const domNode = ReactEditor.toDOMNode(editor, editor);
    let listener = (event) => listenerRef.current(event);
    domNode.addEventListener("keydown", listener);
    return () => {
      domNode.removeEventListener("keydown", listener);
    };
  }, [editor]);
  const triggerRef = (0, import_react79.useRef)(null);
  const overlayState = $fc909762b330b746$export$61c6a8c84e605fb6({
    isOpen: true
  });
  const {
    triggerProps: {
      onPress,
      ...triggerProps
    },
    overlayProps
  } = $628037886ba31236$export$f9d5c8beee7d008d({
    type: "listbox"
  }, overlayState, triggerRef);
  let state = $e72dd72e1c76a225$export$2f645645f7bca764({
    items: options,
    children: (item2) => (0, import_jsx_runtime92.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
      children: item2.label
    }, item2.index)
  });
  (0, import_react79.useEffect)(() => {
    if (!state.selectionManager.isFocused && state.collection.size) {
      state.selectionManager.setFocused(true);
      state.selectionManager.setFocusedKey("0");
    }
  }, [state]);
  const scrollableRef = (0, import_react79.useRef)(null);
  (0, import_react79.useEffect)(() => {
    var _scrollableRef$curren;
    const element4 = (_scrollableRef$curren = scrollableRef.current) === null || _scrollableRef$curren === void 0 || (_scrollableRef$curren = _scrollableRef$curren.querySelector('[role="listbox"] [role="presentation"]')) === null || _scrollableRef$curren === void 0 ? void 0 : _scrollableRef$curren.children[state.selectionManager.focusedKey];
    if (element4) {
      e5(element4, {
        scrollMode: "if-needed",
        boundary: scrollableRef.current,
        block: "nearest"
      });
    }
  }, [state.selectionManager.focusedKey]);
  const listboxRef = (0, import_react79.useRef)(null);
  let layout = useListBoxLayout(state);
  return (0, import_jsx_runtime92.jsxs)(import_react79.Fragment, {
    children: [(0, import_jsx_runtime92.jsx)("span", {
      ...triggerProps,
      role: "button",
      className: css({
        color: tokenSchema.color.foreground.accent,
        fontWeight: tokenSchema.typography.fontWeight.medium
      }),
      ref: triggerRef,
      children
    }), (0, import_jsx_runtime92.jsx)(Popover, {
      width: "alias.singleLineWidth",
      placement: "bottom start",
      isNonModal: true,
      hideArrow: true,
      ...overlayProps,
      state: overlayState,
      triggerRef,
      children: (0, import_jsx_runtime92.jsx)("div", {
        className: css({
          overflow: "scroll",
          maxHeight: 300
        }),
        ref: scrollableRef,
        children: (0, import_jsx_runtime92.jsx)(_ListBoxBase, {
          "aria-label": "Insert block",
          state,
          shouldUseVirtualFocus: true,
          layout,
          ref: listboxRef,
          onAction: (key) => {
            insertOption(editor, text7, options[key]);
          }
        })
      })
    })]
  });
}
var nodeListsWithoutInsertMenu = /* @__PURE__ */ new WeakSet();
var nodesWithoutInsertMenu = /* @__PURE__ */ new WeakSet();
function findPathWithInsertMenu(node4, path3) {
  if (Text.isText(node4)) {
    return node4.insertMenu ? path3 : void 0;
  }
  if (nodeListsWithoutInsertMenu.has(node4.children)) {
    return;
  }
  for (const [index3, child] of node4.children.entries()) {
    if (nodesWithoutInsertMenu.has(child))
      continue;
    let maybePath = findPathWithInsertMenu(child, [...path3, index3]);
    if (maybePath) {
      return maybePath;
    }
    nodesWithoutInsertMenu.add(child);
  }
  nodeListsWithoutInsertMenu.add(node4.children);
}
function removeInsertMenuMarkWhenOutsideOfSelection(editor) {
  var _Editor$marks;
  const path3 = findPathWithInsertMenu(editor, []);
  if (path3 && !((_Editor$marks = Editor.marks(editor)) !== null && _Editor$marks !== void 0 && _Editor$marks.insertMenu) && (!editor.selection || !Path.equals(editor.selection.anchor.path, path3) || !Path.equals(editor.selection.focus.path, path3))) {
    Transforms.unsetNodes(editor, "insertMenu", {
      at: path3
    });
    return true;
  }
  return false;
}
function withInsertMenu(editor) {
  const {
    normalizeNode,
    apply,
    insertText: insertText2
  } = editor;
  editor.normalizeNode = ([node4, path3]) => {
    if (Text.isText(node4) && node4.insertMenu) {
      if (node4.text[0] !== "/") {
        Transforms.unsetNodes(editor, "insertMenu", {
          at: path3
        });
        return;
      }
      const whitespaceMatch = /\s/.exec(node4.text);
      if (whitespaceMatch) {
        Transforms.unsetNodes(editor, "insertMenu", {
          at: {
            anchor: {
              path: path3,
              offset: whitespaceMatch.index
            },
            focus: Editor.end(editor, path3)
          },
          match: Text.isText,
          split: true
        });
        return;
      }
    }
    if (Editor.isEditor(editor) && removeInsertMenuMarkWhenOutsideOfSelection(editor)) {
      return;
    }
    normalizeNode([node4, path3]);
  };
  editor.apply = (op) => {
    apply(op);
    if (op.type === "set_selection") {
      removeInsertMenuMarkWhenOutsideOfSelection(editor);
    }
  };
  editor.insertText = (text7) => {
    insertText2(text7);
    if (editor.selection && text7 === "/") {
      const startOfBlock = Editor.start(editor, Editor.above(editor, {
        match: isBlock
      })[1]);
      const before = Editor.before(editor, editor.selection.anchor, {
        unit: "character"
      });
      if (before && (Point.equals(startOfBlock, before) || before.offset !== 0 && /\s/.test(Node3.get(editor, before.path).text[before.offset - 1]))) {
        Transforms.setNodes(editor, {
          insertMenu: true
        }, {
          at: {
            anchor: before,
            focus: editor.selection.anchor
          },
          match: Text.isText,
          split: true
        });
      }
    }
  };
  return editor;
}
function Placeholder({
  placeholder,
  children
}) {
  const [width, setWidth] = (0, import_react79.useState)(0);
  return (0, import_jsx_runtime92.jsxs)("span", {
    className: css({
      position: "relative",
      display: "inline-block",
      width
    }),
    children: [(0, import_jsx_runtime92.jsx)("span", {
      contentEditable: false,
      className: css({
        position: "absolute",
        pointerEvents: "none",
        display: "inline-block",
        left: 0,
        top: 0,
        maxWidth: "100%",
        whiteSpace: "nowrap",
        opacity: "0.5",
        userSelect: "none",
        fontStyle: "normal",
        fontWeight: "normal",
        textDecoration: "none",
        textAlign: "left"
      }),
      children: (0, import_jsx_runtime92.jsx)("span", {
        ref: (node4) => {
          if (node4) {
            const offsetWidth = node4.offsetWidth;
            if (offsetWidth !== width) {
              setWidth(offsetWidth);
            }
          }
        },
        children: placeholder
      })
    }), children]
  });
}
var Leaf2 = ({
  leaf,
  text: text7,
  children,
  attributes
}) => {
  const {
    underline,
    strikethrough,
    bold,
    italic,
    code: code3,
    keyboard,
    superscript,
    subscript,
    placeholder,
    insertMenu,
    ...rest
  } = leaf;
  if (placeholder !== void 0) {
    children = (0, import_jsx_runtime92.jsx)(Placeholder, {
      placeholder,
      children
    });
  }
  if (insertMenu) {
    children = (0, import_jsx_runtime92.jsx)(InsertMenu, {
      text: text7,
      children
    });
  }
  if (code3) {
    children = (0, import_jsx_runtime92.jsx)("code", {
      children
    });
  }
  if (bold) {
    children = (0, import_jsx_runtime92.jsx)("strong", {
      children
    });
  }
  if (strikethrough) {
    children = (0, import_jsx_runtime92.jsx)("s", {
      children
    });
  }
  if (italic) {
    children = (0, import_jsx_runtime92.jsx)("em", {
      children
    });
  }
  if (keyboard) {
    children = (0, import_jsx_runtime92.jsx)("kbd", {
      children
    });
  }
  if (superscript) {
    children = (0, import_jsx_runtime92.jsx)("sup", {
      children
    });
  }
  if (subscript) {
    children = (0, import_jsx_runtime92.jsx)("sub", {
      children
    });
  }
  if (underline) {
    children = (0, import_jsx_runtime92.jsx)("u", {
      children
    });
  }
  const prismClassNames = Object.keys(rest).filter((x4) => x4.startsWith("prism_")).map((x4) => styles$1.get(x4.replace("prism_", "")));
  if (prismClassNames.length) {
    const className = prismClassNames.join(" ");
    children = (0, import_jsx_runtime92.jsx)("span", {
      className,
      children
    });
  }
  return (0, import_jsx_runtime92.jsx)("span", {
    ...attributes,
    children
  });
};
var renderLeaf = (props) => {
  return (0, import_jsx_runtime92.jsx)(Leaf2, {
    ...props
  });
};
var styles$1 = new Map([{
  types: ["comment", "prolog", "doctype", "cdata"],
  style: {
    color: tokenSchema.color.foreground.neutralTertiary,
    fontStyle: "italic"
  }
}, {
  types: ["atrule", "attr-name", "class-name", "selector"],
  style: {
    color: tokenSchema.color.scale.amber11
  }
}, {
  types: ["boolean", "constant", "inserted-sign", "entity", "inserted", "number", "regex", "symbol", "variable"],
  style: {
    color: tokenSchema.color.scale.green11
  }
}, {
  types: ["attr-value", "builtin", "char", "constant", "generics", "url"],
  style: {
    color: tokenSchema.color.scale.pink11
  }
}, {
  types: ["string"],
  style: {
    color: tokenSchema.color.scale.indigo9
  }
}, {
  types: ["annotation", "deleted", "deleted-sign", "decorator", "important", "tag"],
  style: {
    color: tokenSchema.color.scale.red11
  }
}, {
  types: ["function", "function-variable", "operator"],
  style: {
    color: tokenSchema.color.scale.purple11
  }
}, {
  types: ["tag", "selector", "keyword"],
  style: {
    color: tokenSchema.color.scale.indigo11
  }
}, {
  types: ["punctuation"],
  style: {
    color: tokenSchema.color.foreground.neutralSecondary
  }
}].flatMap((style) => {
  const className = css(style.style);
  return style.types.map((x4) => [x4, className]);
}));
var codeBlockShortcutPattern = /^```(\w+)? ?$/;
function withCodeBlock(documentFeatures, componentBlocks, editor) {
  const {
    insertBreak,
    normalizeNode,
    insertText: insertText2
  } = editor;
  function codeBlockShortcut(block5) {
    var _aliasesToCanonicalNa;
    if ((block5 === null || block5 === void 0 ? void 0 : block5[0].type) !== "paragraph" || block5[0].children.length !== 1 || block5[0].children[0].type !== void 0) {
      return false;
    }
    const match3 = codeBlockShortcutPattern.exec(block5[0].children[0].text);
    if (!match3) {
      return false;
    }
    const locationDocumentFeatures = getAncestorComponentChildFieldDocumentFeatures(editor, documentFeatures, componentBlocks);
    if (locationDocumentFeatures && (locationDocumentFeatures.kind === "inline" || !locationDocumentFeatures.documentFeatures.formatting.blockTypes.code)) {
      return false;
    }
    editor.history.undos.push({
      operations: [],
      selectionBefore: editor.selection
    });
    Transforms.select(editor, block5[1]);
    Transforms.delete(editor);
    Transforms.wrapNodes(editor, {
      type: "code",
      ...match3[1] ? {
        language: (_aliasesToCanonicalNa = aliasesToCanonicalName.get(match3[1].toLowerCase())) !== null && _aliasesToCanonicalNa !== void 0 ? _aliasesToCanonicalNa : match3[1]
      } : {},
      children: []
    }, {
      match: (node4) => node4.type === "paragraph"
    });
    return true;
  }
  editor.insertBreak = () => {
    const block5 = Editor.above(editor, {
      match: isBlock
    });
    if ((block5 === null || block5 === void 0 ? void 0 : block5[0].type) === "code" && Text.isText(block5[0].children[0])) {
      const text7 = block5[0].children[0].text;
      if (text7[text7.length - 1] === "\n" && editor.selection && Range.isCollapsed(editor.selection) && Point.equals(Editor.end(editor, block5[1]), editor.selection.anchor)) {
        insertBreak();
        Transforms.setNodes(editor, {
          type: "paragraph",
          children: []
        });
        Transforms.delete(editor, {
          distance: 1,
          at: {
            path: [...block5[1], 0],
            offset: text7.length - 1
          }
        });
        return;
      }
      editor.insertText("\n");
      return;
    }
    if (editor.selection && Range.isCollapsed(editor.selection) && codeBlockShortcut(block5)) {
      return;
    }
    insertBreak();
  };
  editor.insertText = (text7) => {
    insertText2(text7);
    if (text7 === " " && editor.selection && Range.isCollapsed(editor.selection)) {
      codeBlockShortcut(Editor.above(editor, {
        match: isBlock
      }));
    }
  };
  editor.normalizeNode = ([node4, path3]) => {
    if (node4.type === "code" && Element2.isElement(node4)) {
      for (const [index3, childNode] of node4.children.entries()) {
        if (!Text.isText(childNode)) {
          if (editor.isVoid(childNode)) {
            Transforms.removeNodes(editor, {
              at: [...path3, index3]
            });
          } else {
            Transforms.unwrapNodes(editor, {
              at: [...path3, index3]
            });
          }
          return;
        }
        const marks = Object.keys(childNode).filter((x4) => x4 !== "text");
        if (marks.length) {
          Transforms.unsetNodes(editor, marks, {
            at: [...path3, index3]
          });
          return;
        }
      }
    }
    normalizeNode([node4, path3]);
  };
  return editor;
}
var paragraphElement = () => ({
  type: "paragraph",
  children: [{
    text: ""
  }]
});
function withParagraphs(editor) {
  const {
    normalizeNode
  } = editor;
  editor.normalizeNode = (entry) => {
    const [node4, path3] = entry;
    if (Editor.isEditor(node4)) {
      let lastNode = node4.children[node4.children.length - 1];
      if ((lastNode === null || lastNode === void 0 ? void 0 : lastNode.type) !== "paragraph") {
        Transforms.insertNodes(editor, paragraphElement(), {
          at: [...path3, node4.children.length]
        });
        return;
      }
    }
    normalizeNode(entry);
  };
  return editor;
}
function withLayouts(editor) {
  const {
    normalizeNode,
    deleteBackward
  } = editor;
  editor.deleteBackward = (unit) => {
    if (editor.selection && Range.isCollapsed(editor.selection) && // this is just an little optimisation
    // we're only doing things if we're at the start of a layout area
    // and the start of anything will always be offset 0
    // so we'll bailout if we're not at offset 0
    editor.selection.anchor.offset === 0) {
      const [aboveNode, abovePath] = Editor.above(editor, {
        match: (node4) => node4.type === "layout-area"
      }) || [editor, []];
      if (aboveNode.type === "layout-area" && Point.equals(Editor.start(editor, abovePath), editor.selection.anchor)) {
        return;
      }
    }
    deleteBackward(unit);
  };
  editor.normalizeNode = (entry) => {
    const [node4, path3] = entry;
    if (Element2.isElement(node4) && node4.type === "layout") {
      if (node4.layout === void 0) {
        Transforms.unwrapNodes(editor, {
          at: path3
        });
        return;
      }
      if (node4.children.length < node4.layout.length) {
        Transforms.insertNodes(editor, Array.from({
          length: node4.layout.length - node4.children.length
        }).map(() => ({
          type: "layout-area",
          children: [paragraphElement()]
        })), {
          at: [...path3, node4.children.length]
        });
        return;
      }
      if (node4.children.length > node4.layout.length) {
        Array.from({
          length: node4.children.length - node4.layout.length
        }).map((_2, i6) => i6).reverse().forEach((i6) => {
          const layoutAreaToRemovePath = [...path3, i6 + node4.layout.length];
          const child = node4.children[i6 + node4.layout.length];
          moveChildren(editor, layoutAreaToRemovePath, [...path3, node4.layout.length - 1, node4.children[node4.layout.length - 1].children.length], (node5) => node5.type !== "paragraph" || Node3.string(child) !== "");
          Transforms.removeNodes(editor, {
            at: layoutAreaToRemovePath
          });
        });
        return;
      }
    }
    normalizeNode(entry);
  };
  return editor;
}
var markdownLinkPattern = /(^|\s)\[(.+?)\]\((\S+)\)$/;
function withLink(editorDocumentFeatures, componentBlocks, editor) {
  const {
    insertText: insertText2,
    isInline,
    normalizeNode
  } = editor;
  editor.isInline = (element4) => {
    return element4.type === "link" ? true : isInline(element4);
  };
  if (editorDocumentFeatures.links) {
    editor.insertText = (text7) => {
      insertText2(text7);
      if (text7 !== ")" || !editor.selection) {
        return;
      }
      const startOfBlock = Editor.start(editor, Editor.above(editor, {
        match: isBlock
      })[1]);
      const startOfBlockToEndOfShortcutString = Editor.string(editor, {
        anchor: editor.selection.anchor,
        focus: startOfBlock
      });
      const match3 = markdownLinkPattern.exec(startOfBlockToEndOfShortcutString);
      if (!match3) {
        return;
      }
      const ancestorComponentChildFieldDocumentFeatures = getAncestorComponentChildFieldDocumentFeatures(editor, editorDocumentFeatures, componentBlocks);
      if ((ancestorComponentChildFieldDocumentFeatures === null || ancestorComponentChildFieldDocumentFeatures === void 0 ? void 0 : ancestorComponentChildFieldDocumentFeatures.documentFeatures.links) === false) {
        return;
      }
      const [, maybeWhitespace, linkText, href] = match3;
      editor.history.undos.push({
        operations: [],
        selectionBefore: editor.selection
      });
      const startOfShortcut = match3.index === 0 ? startOfBlock : EditorAfterButIgnoringingPointsWithNoContent(editor, startOfBlock, {
        distance: match3.index
      });
      const startOfLinkText = EditorAfterButIgnoringingPointsWithNoContent(editor, startOfShortcut, {
        distance: maybeWhitespace === "" ? 1 : 2
      });
      const endOfLinkText = EditorAfterButIgnoringingPointsWithNoContent(editor, startOfLinkText, {
        distance: linkText.length
      });
      Transforms.delete(editor, {
        at: {
          anchor: endOfLinkText,
          focus: editor.selection.anchor
        }
      });
      Transforms.delete(editor, {
        at: {
          anchor: startOfShortcut,
          focus: startOfLinkText
        }
      });
      Transforms.wrapNodes(editor, {
        type: "link",
        href,
        children: []
      }, {
        at: {
          anchor: editor.selection.anchor,
          focus: startOfShortcut
        },
        split: true
      });
      const nextNode = Editor.next(editor);
      if (nextNode) {
        Transforms.select(editor, nextNode[1]);
      }
    };
  }
  editor.normalizeNode = ([node4, path3]) => {
    if (node4.type === "link") {
      if (Node3.string(node4) === "") {
        Transforms.unwrapNodes(editor, {
          at: path3
        });
        return;
      }
      for (const [idx, child] of node4.children.entries()) {
        if (child.type === "link") {
          Transforms.unwrapNodes(editor, {
            at: [...path3, idx]
          });
          return;
        }
      }
    }
    if (isInlineContainer(node4)) {
      let lastMergableLink = null;
      for (const [idx, child] of node4.children.entries()) {
        var _lastMergableLink;
        if (child.type === "link" && child.href === ((_lastMergableLink = lastMergableLink) === null || _lastMergableLink === void 0 ? void 0 : _lastMergableLink.node.href)) {
          const firstLinkPath = [...path3, lastMergableLink.index];
          const secondLinkPath = [...path3, idx];
          const to = [...firstLinkPath, lastMergableLink.node.children.length];
          for (let i6 = child.children.length - 1; i6 >= 0; i6--) {
            const childPath = [...secondLinkPath, i6];
            Transforms.moveNodes(editor, {
              at: childPath,
              to
            });
          }
          Transforms.removeNodes(editor, {
            at: secondLinkPath
          });
          return;
        }
        if (!Text.isText(child) || child.text !== "") {
          lastMergableLink = null;
        }
        if (child.type === "link") {
          lastMergableLink = {
            index: idx,
            node: child
          };
        }
      }
    }
    normalizeNode([node4, path3]);
  };
  return editor;
}
function createDocumentEditorForNormalization(documentFeatures, componentBlocks) {
  return _createDocumentEditor(createEditor(), documentFeatures, componentBlocks);
}
function _createDocumentEditor(baseEditor, documentFeatures, componentBlocks) {
  return withBlocksSchema(withParagraphs(withLink(documentFeatures, componentBlocks, withList(withTable(withComponentBlocks(componentBlocks, documentFeatures, withVoidElements(withLayouts(withCodeBlock(documentFeatures, componentBlocks, withDocumentFeaturesNormalization(documentFeatures, baseEditor))))))))));
}
function withBlocksSchema(editor) {
  const {
    normalizeNode
  } = editor;
  editor.normalizeNode = ([node4, path3]) => {
    if (!Text.isText(node4) && node4.type !== "link") {
      const nodeType = Editor.isEditor(node4) ? "editor" : node4.type;
      if (typeof nodeType !== "string" || editorSchema[nodeType] === void 0) {
        Transforms.unwrapNodes(editor, {
          at: path3
        });
        return;
      }
      const info = editorSchema[nodeType];
      if (info.kind === "blocks" && node4.children.length !== 0 && node4.children.every((child) => !isBlock(child))) {
        Transforms.wrapNodes(editor, {
          type: info.blockToWrapInlinesIn,
          children: []
        }, {
          at: path3,
          match: (node5) => !isBlock(node5)
        });
        return;
      }
      let didUpdate = false;
      for (const [index3, childNode] of [...node4.children.entries()].reverse()) {
        const childPath = [...path3, index3];
        if (info.kind === "inlines") {
          if (!Text.isText(childNode) && isBlock(childNode)) {
            handleNodeInInvalidPosition(editor, [childNode, childPath], path3);
            didUpdate = true;
            continue;
          }
        } else {
          if (!isBlock(childNode)) {
            Transforms.wrapNodes(editor, {
              type: info.blockToWrapInlinesIn,
              children: []
            }, {
              at: childPath
            });
            didUpdate = true;
            continue;
          }
          if (!info.allowedChildren.has(childNode.type)) {
            handleNodeInInvalidPosition(editor, [childNode, childPath], path3);
            didUpdate = true;
            continue;
          }
        }
      }
      if (didUpdate) {
        return;
      }
    }
    normalizeNode([node4, path3]);
  };
  return editor;
}
function handleNodeInInvalidPosition(editor, [node4, path3], ancestorPath) {
  const nodeType = node4.type;
  const childNodeInfo = editorSchema[nodeType];
  const ancestorNode = Node3.get(editor, ancestorPath);
  const parentNodeType = Editor.isEditor(ancestorNode) ? "editor" : ancestorNode.type;
  const parentNodeInfo = editorSchema[parentNodeType];
  if (!childNodeInfo || childNodeInfo.invalidPositionHandleMode === "unwrap") {
    if (parentNodeInfo.kind === "blocks" && parentNodeInfo.blockToWrapInlinesIn) {
      Transforms.setNodes(editor, {
        type: parentNodeInfo.blockToWrapInlinesIn,
        ...Object.fromEntries(Object.keys(node4).filter((key) => key !== "type" && key !== "children").map((key) => [key, null]))
        // the Slate types don't understand that null is allowed and it will unset properties with setNodes
      }, {
        at: path3
      });
      return;
    }
    Transforms.unwrapNodes(editor, {
      at: path3
    });
    return;
  }
  const info = editorSchema[ancestorNode.type || "editor"];
  if ((info === null || info === void 0 ? void 0 : info.kind) === "blocks" && info.allowedChildren.has(nodeType)) {
    if (ancestorPath.length === 0) {
      Transforms.moveNodes(editor, {
        at: path3,
        to: [path3[0] + 1]
      });
    } else {
      Transforms.moveNodes(editor, {
        at: path3,
        to: Path.next(ancestorPath)
      });
    }
    return;
  }
  if (Editor.isEditor(ancestorNode)) {
    Transforms.moveNodes(editor, {
      at: path3,
      to: [path3[0] + 1]
    });
    Transforms.unwrapNodes(editor, {
      at: [path3[0] + 1]
    });
    return;
  }
  handleNodeInInvalidPosition(editor, [node4, path3], ancestorPath.slice(0, -1));
}
function withVoidElements(editor) {
  const {
    isVoid
  } = editor;
  editor.isVoid = (node4) => {
    return node4.type === "divider" || node4.type === "image" || isVoid(node4);
  };
  return editor;
}
function withBlockMarkdownShortcuts(documentFeatures, componentBlocks, editor) {
  const {
    insertText: insertText2
  } = editor;
  const shortcuts2 = /* @__PURE__ */ Object.create(null);
  const editorDocumentFeaturesForNormalizationToCheck = {
    ...documentFeatures
  };
  let addShortcut = (text7, insert, shouldBeEnabledInComponentBlock, type2 = "paragraph") => {
    if (!shouldBeEnabledInComponentBlock(editorDocumentFeaturesForNormalizationToCheck)) {
      return;
    }
    const trigger2 = text7[text7.length - 1];
    if (!shortcuts2[trigger2]) {
      shortcuts2[trigger2] = /* @__PURE__ */ Object.create(null);
    }
    shortcuts2[trigger2][text7] = {
      insert,
      type: type2,
      shouldBeEnabledInComponentBlock
    };
  };
  addShortcut("1. ", () => {
    Transforms.wrapNodes(editor, {
      type: "ordered-list",
      children: []
    }, {
      match: isBlock
    });
  }, (features) => features.formatting.listTypes.ordered);
  addShortcut("- ", () => {
    Transforms.wrapNodes(editor, {
      type: "unordered-list",
      children: []
    }, {
      match: isBlock
    });
  }, (features) => features.formatting.listTypes.unordered);
  addShortcut("* ", () => {
    Transforms.wrapNodes(editor, {
      type: "unordered-list",
      children: []
    }, {
      match: isBlock
    });
  }, (features) => features.formatting.listTypes.unordered);
  documentFeatures.formatting.headings.levels.forEach((level) => {
    addShortcut("#".repeat(level) + " ", () => {
      Transforms.setNodes(editor, {
        type: "heading",
        level
      }, {
        match: (node4) => node4.type === "paragraph" || node4.type === "heading"
      });
    }, (features) => features.formatting.headings.levels.includes(level), "heading-or-paragraph");
  });
  addShortcut("> ", () => {
    Transforms.wrapNodes(editor, {
      type: "blockquote",
      children: []
    }, {
      match: (node4) => node4.type === "paragraph"
    });
  }, (features) => features.formatting.blockTypes.blockquote);
  addShortcut("---", () => {
    insertDivider(editor);
  }, (features) => features.dividers);
  editor.insertText = (text7) => {
    insertText2(text7);
    const shortcutsForTrigger = shortcuts2[text7];
    if (shortcutsForTrigger && editor.selection && Range.isCollapsed(editor.selection)) {
      const {
        anchor
      } = editor.selection;
      const block5 = Editor.above(editor, {
        match: isBlock
      });
      if (!block5 || block5[0].type !== "paragraph" && block5[0].type !== "heading") {
        return;
      }
      const start2 = Editor.start(editor, block5[1]);
      const range = {
        anchor,
        focus: start2
      };
      const shortcutText = Editor.string(editor, range);
      const shortcut = shortcutsForTrigger[shortcutText];
      if (!shortcut || shortcut.type === "paragraph" && block5[0].type !== "paragraph") {
        return;
      }
      const locationDocumentFeatures = getAncestorComponentChildFieldDocumentFeatures(editor, documentFeatures, componentBlocks);
      if (locationDocumentFeatures && (locationDocumentFeatures.kind === "inline" || !shortcut.shouldBeEnabledInComponentBlock(locationDocumentFeatures.documentFeatures))) {
        return;
      }
      editor.history.undos.push({
        operations: [],
        selectionBefore: editor.selection
      });
      Transforms.select(editor, range);
      Transforms.delete(editor);
      shortcut.insert();
    }
  };
  return editor;
}
function getDirectBlockquoteParentFromSelection(editor) {
  if (!editor.selection)
    return {
      isInside: false
    };
  const [, parentPath] = Editor.parent(editor, editor.selection);
  if (!parentPath.length) {
    return {
      isInside: false
    };
  }
  const [maybeBlockquoteParent, maybeBlockquoteParentPath] = Editor.parent(editor, parentPath);
  const isBlockquote = maybeBlockquoteParent.type === "blockquote";
  return isBlockquote ? {
    isInside: true,
    path: maybeBlockquoteParentPath
  } : {
    isInside: false
  };
}
function withBlockquote(editor) {
  const {
    insertBreak,
    deleteBackward
  } = editor;
  editor.deleteBackward = (unit) => {
    if (editor.selection) {
      const parentBlockquote = getDirectBlockquoteParentFromSelection(editor);
      if (parentBlockquote.isInside && Range.isCollapsed(editor.selection) && // the selection is at the start of the paragraph
      editor.selection.anchor.offset === 0 && // it's the first paragraph in the panel
      editor.selection.anchor.path[editor.selection.anchor.path.length - 2] === 0) {
        Transforms.unwrapNodes(editor, {
          match: (node4) => node4.type === "blockquote",
          split: true
        });
        return;
      }
    }
    deleteBackward(unit);
  };
  editor.insertBreak = () => {
    const panel = getDirectBlockquoteParentFromSelection(editor);
    if (editor.selection && panel.isInside) {
      const [node4, nodePath] = Editor.node(editor, editor.selection);
      if (Path.isDescendant(nodePath, panel.path) && Node3.string(node4) === "") {
        Transforms.unwrapNodes(editor, {
          match: (node5) => node5.type === "blockquote",
          split: true
        });
        return;
      }
    }
    insertBreak();
  };
  return editor;
}
function withHeading(editor) {
  const {
    insertBreak
  } = editor;
  editor.insertBreak = () => {
    insertBreak();
    const entry = Editor.above(editor, {
      match: (n6) => n6.type === "heading"
    });
    if (!entry || !editor.selection || !Range.isCollapsed(editor.selection)) {
      return;
    }
    const path3 = entry[1];
    if (
      // we want to unwrap the heading when the user inserted a break at the end of the heading
      // when the user inserts a break at the end of a heading, the new heading
      // that we want to unwrap will be empty so the end will be equal to the selection
      Point.equals(Editor.end(editor, path3), editor.selection.anchor)
    ) {
      Transforms.unwrapNodes(editor, {
        at: path3
      });
      return;
    }
    if (!Path.hasPrevious(path3)) {
      return;
    }
    const previousPath = Path.previous(path3);
    const previousNode = Node3.get(editor, previousPath);
    if (previousNode.type === "heading" && previousNode.children.length === 1 && Text.isText(previousNode.children[0]) && previousNode.children[0].text === "") {
      Transforms.unwrapNodes(editor, {
        at: previousPath
      });
    }
  };
  return editor;
}
var allMarkdownShortcuts = {
  bold: ["**", "__"],
  italic: ["*", "_"],
  strikethrough: ["~~"],
  code: ["`"]
};
function applyMark(editor, mark, shortcutText, startOfStartPoint) {
  editor.history.undos.push({
    operations: [],
    selectionBefore: editor.selection
  });
  const startPointRef = Editor.pointRef(editor, startOfStartPoint);
  Transforms.delete(editor, {
    at: editor.selection.anchor,
    distance: shortcutText.length,
    reverse: true
  });
  Transforms.delete(editor, {
    at: startOfStartPoint,
    distance: shortcutText.length
  });
  Transforms.setNodes(editor, {
    [mark]: true
  }, {
    match: Text.isText,
    split: true,
    at: {
      anchor: startPointRef.unref(),
      focus: editor.selection.anchor
    }
  });
  editor.removeMark(mark);
}
function withMarks(editorDocumentFeatures, componentBlocks, editor) {
  const {
    insertText: insertText2,
    insertBreak
  } = editor;
  editor.insertBreak = () => {
    insertBreak();
    const marksAfterInsertBreak = Editor.marks(editor);
    if (!marksAfterInsertBreak || !editor.selection)
      return;
    const parentBlock = Editor.above(editor, {
      match: isBlock
    });
    if (!parentBlock)
      return;
    const point3 = EditorAfterButIgnoringingPointsWithNoContent(editor, editor.selection.anchor);
    const marksAfterInsertBreakArr = Object.keys(marksAfterInsertBreak);
    if (!point3 || !Path.isDescendant(point3.path, parentBlock[1])) {
      for (const mark of marksAfterInsertBreakArr) {
        editor.removeMark(mark);
      }
      return;
    }
    const textNode = Node3.get(editor, point3.path);
    for (const mark of marksAfterInsertBreakArr) {
      if (!textNode[mark]) {
        editor.removeMark(mark);
      }
    }
  };
  const selectedMarkdownShortcuts = {};
  const enabledMarks = editorDocumentFeatures.formatting.inlineMarks;
  Object.keys(allMarkdownShortcuts).forEach((mark) => {
    if (enabledMarks[mark]) {
      selectedMarkdownShortcuts[mark] = allMarkdownShortcuts[mark];
    }
  });
  if (Object.keys(selectedMarkdownShortcuts).length === 0)
    return editor;
  editor.insertText = (text7) => {
    insertText2(text7);
    if (editor.selection && Range.isCollapsed(editor.selection)) {
      for (const [mark, shortcuts2] of Object.entries(selectedMarkdownShortcuts)) {
        for (const shortcutText of shortcuts2) {
          if (text7 === shortcutText[shortcutText.length - 1]) {
            const startOfBlock = getStartOfBlock(editor);
            let startOfBlockToEndOfShortcutString = Editor.string(editor, {
              anchor: editor.selection.anchor,
              focus: startOfBlock
            });
            const hasWhitespaceBeforeEndOfShortcut = /\s/.test(startOfBlockToEndOfShortcutString.slice(-shortcutText.length - 1, -shortcutText.length));
            const endOfShortcutContainsExpectedContent = shortcutText === startOfBlockToEndOfShortcutString.slice(-shortcutText.length);
            if (hasWhitespaceBeforeEndOfShortcut || !endOfShortcutContainsExpectedContent) {
              continue;
            }
            const strToMatchOn = startOfBlockToEndOfShortcutString.slice(0, -shortcutText.length - 1);
            for (const [offsetFromStartOfBlock] of [...strToMatchOn].reverse().entries()) {
              const expectedShortcutText = strToMatchOn.slice(offsetFromStartOfBlock, offsetFromStartOfBlock + shortcutText.length);
              if (expectedShortcutText !== shortcutText) {
                continue;
              }
              const startOfStartOfShortcut = offsetFromStartOfBlock === 0 ? startOfBlock : EditorAfterButIgnoringingPointsWithNoContent(editor, startOfBlock, {
                distance: offsetFromStartOfBlock
              });
              const endOfStartOfShortcut = Editor.after(editor, startOfStartOfShortcut, {
                distance: shortcutText.length
              });
              if (offsetFromStartOfBlock !== 0 && !/\s/.test(Editor.string(editor, {
                anchor: Editor.before(editor, startOfStartOfShortcut, {
                  unit: "character"
                }),
                focus: startOfStartOfShortcut
              }))) {
                continue;
              }
              const contentBetweenShortcuts = Editor.string(editor, {
                anchor: endOfStartOfShortcut,
                focus: editor.selection.anchor
              }).slice(0, -shortcutText.length);
              if (contentBetweenShortcuts === "" || /\s/.test(contentBetweenShortcuts[0])) {
                continue;
              }
              if (mark === "italic" && (contentBetweenShortcuts[0] === "_" || contentBetweenShortcuts[0] === "*")) {
                continue;
              }
              if (mark === "code" && contentBetweenShortcuts === "`") {
                continue;
              }
              const ancestorComponentChildFieldDocumentFeatures = getAncestorComponentChildFieldDocumentFeatures(editor, editorDocumentFeatures, componentBlocks);
              if (ancestorComponentChildFieldDocumentFeatures && ancestorComponentChildFieldDocumentFeatures.inlineMarks !== "inherit" && ancestorComponentChildFieldDocumentFeatures.inlineMarks[mark] === false) {
                continue;
              }
              applyMark(editor, mark, shortcutText, startOfStartOfShortcut);
              return;
            }
          }
        }
      }
    }
  };
  return editor;
}
function getStartOfBlock(editor) {
  return Editor.start(editor, Editor.above(editor, {
    match: isBlock
  })[1]);
}
function getAlignmentFromElement(element4) {
  const parent = element4.parentElement;
  const attribute = parent === null || parent === void 0 ? void 0 : parent.getAttribute("data-align");
  if (attribute === "center" || attribute === "end") {
    return attribute;
  }
  if (element4 instanceof HTMLElement) {
    const textAlign = element4.style.textAlign;
    if (textAlign === "center") {
      return "center";
    }
    if (textAlign === "right" || textAlign === "end") {
      return "end";
    }
  }
}
var headings = {
  H1: 1,
  H2: 2,
  H3: 3,
  H4: 4,
  H5: 5,
  H6: 6
};
var TEXT_TAGS = {
  CODE: "code",
  DEL: "strikethrough",
  S: "strikethrough",
  STRIKE: "strikethrough",
  EM: "italic",
  I: "italic",
  STRONG: "bold",
  U: "underline",
  SUP: "superscript",
  SUB: "subscript",
  KBD: "keyboard"
};
function marksFromElementAttributes(element4) {
  const marks = /* @__PURE__ */ new Set();
  const style = element4.style;
  const {
    nodeName
  } = element4;
  const markFromNodeName = TEXT_TAGS[nodeName];
  if (markFromNodeName) {
    marks.add(markFromNodeName);
  }
  const {
    fontWeight,
    textDecoration,
    verticalAlign
  } = style;
  if (textDecoration === "underline") {
    marks.add("underline");
  } else if (textDecoration === "line-through") {
    marks.add("strikethrough");
  }
  if (nodeName === "SPAN" && element4.classList.contains("code")) {
    marks.add("code");
  }
  if (nodeName === "B" && fontWeight !== "normal") {
    marks.add("bold");
  } else if (typeof fontWeight === "string" && (fontWeight === "bold" || fontWeight === "bolder" || fontWeight === "1000" || /^[5-9]\d{2}$/.test(fontWeight))) {
    marks.add("bold");
  }
  if (style.fontStyle === "italic") {
    marks.add("italic");
  }
  if (verticalAlign === "super") {
    marks.add("superscript");
  } else if (verticalAlign === "sub") {
    marks.add("subscript");
  }
  return marks;
}
function deserializeHTML(html) {
  const parsed = new DOMParser().parseFromString(html, "text/html");
  return fixNodesForBlockChildren(deserializeNodes(parsed.body.childNodes));
}
function deserializeHTMLNode(el) {
  if (!(el instanceof globalThis.HTMLElement)) {
    const text7 = el.textContent;
    if (!text7) {
      return [];
    }
    return getInlineNodes(text7);
  }
  if (el.nodeName === "BR") {
    return getInlineNodes("\n");
  }
  if (el.nodeName === "IMG") {
    const alt = el.getAttribute("alt");
    return getInlineNodes(alt !== null && alt !== void 0 ? alt : "");
  }
  if (el.nodeName === "HR") {
    return [{
      type: "divider",
      children: [{
        text: ""
      }]
    }];
  }
  const marks = marksFromElementAttributes(el);
  if (el.classList.contains("listtype-quote")) {
    marks.delete("italic");
    return addMarksToChildren(marks, () => [{
      type: "blockquote",
      children: fixNodesForBlockChildren(deserializeNodes(el.childNodes))
    }]);
  }
  return addMarksToChildren(marks, () => {
    const {
      nodeName
    } = el;
    if (nodeName === "A") {
      const href = el.getAttribute("href");
      if (href) {
        return setLinkForChildren(href, () => forceDisableMarkForChildren("underline", () => deserializeNodes(el.childNodes)));
      }
    }
    if (nodeName === "PRE" && el.textContent) {
      return [{
        type: "code",
        children: [{
          text: el.textContent || ""
        }]
      }];
    }
    const deserialized = deserializeNodes(el.childNodes);
    const children = fixNodesForBlockChildren(deserialized);
    if (nodeName === "LI") {
      let nestedList;
      const listItemContent = {
        type: "list-item-content",
        children: children.filter((node4) => {
          if (nestedList === void 0 && (node4.type === "ordered-list" || node4.type === "unordered-list")) {
            nestedList = node4;
            return false;
          }
          return true;
        })
      };
      const listItemChildren = nestedList ? [listItemContent, nestedList] : [listItemContent];
      return [{
        type: "list-item",
        children: listItemChildren
      }];
    }
    if (nodeName === "P") {
      return [{
        type: "paragraph",
        textAlign: getAlignmentFromElement(el),
        children
      }];
    }
    const headingLevel = headings[nodeName];
    if (typeof headingLevel === "number") {
      return [{
        type: "heading",
        level: headingLevel,
        textAlign: getAlignmentFromElement(el),
        children
      }];
    }
    if (nodeName === "BLOCKQUOTE") {
      return [{
        type: "blockquote",
        children
      }];
    }
    if (nodeName === "OL") {
      return [{
        type: "ordered-list",
        children
      }];
    }
    if (nodeName === "UL") {
      return [{
        type: "unordered-list",
        children
      }];
    }
    if (nodeName === "DIV" && !isBlock(children[0])) {
      return [{
        type: "paragraph",
        children
      }];
    }
    return deserialized;
  });
}
function deserializeNodes(nodes) {
  const outputNodes = [];
  for (const node4 of nodes) {
    outputNodes.push(...deserializeHTMLNode(node4));
  }
  return outputNodes;
}
function fixNodesForBlockChildren(deserializedNodes) {
  if (!deserializedNodes.length) {
    return [{
      text: ""
    }];
  }
  if (deserializedNodes.some(isBlock)) {
    const result = [];
    let queuedInlines = [];
    const flushInlines = () => {
      if (queuedInlines.length) {
        result.push({
          type: "paragraph",
          children: queuedInlines
        });
        queuedInlines = [];
      }
    };
    for (const node4 of deserializedNodes) {
      if (isBlock(node4)) {
        flushInlines();
        result.push(node4);
        continue;
      }
      if (Node3.string(node4).trim() !== "") {
        queuedInlines.push(node4);
      }
    }
    flushInlines();
    return result;
  }
  return deserializedNodes;
}
var markdownConfig = {
  mdastExtensions: [gfmAutolinkLiteralFromMarkdown(), gfmStrikethroughFromMarkdown()],
  extensions: [gfmAutolinkLiteral(), gfmStrikethrough()]
};
function deserializeMarkdown(markdown) {
  const root = fromMarkdown(markdown, markdownConfig);
  let nodes = root.children;
  if (nodes.length === 1 && nodes[0].type === "paragraph") {
    nodes = nodes[0].children;
  }
  return deserializeChildren(nodes, markdown);
}
function deserializeChildren(nodes, input) {
  const outputNodes = [];
  for (const node4 of nodes) {
    const result = deserializeMarkdownNode(node4, input);
    if (result.length) {
      outputNodes.push(...result);
    }
  }
  if (!outputNodes.length) {
    outputNodes.push({
      text: ""
    });
  }
  return outputNodes;
}
function deserializeMarkdownNode(node4, input) {
  switch (node4.type) {
    case "blockquote": {
      return [{
        type: "blockquote",
        children: deserializeChildren(node4.children, input)
      }];
    }
    case "link": {
      return setLinkForChildren(node4.url, () => deserializeChildren(node4.children, input));
    }
    case "code": {
      return [{
        type: "code",
        children: [{
          text: node4.value
        }]
      }];
    }
    case "paragraph": {
      return [{
        type: "paragraph",
        children: deserializeChildren(node4.children, input)
      }];
    }
    case "heading": {
      return [{
        type: "heading",
        level: node4.depth,
        children: deserializeChildren(node4.children, input)
      }];
    }
    case "list": {
      return [{
        type: node4.ordered ? "ordered-list" : "unordered-list",
        children: deserializeChildren(node4.children, input)
      }];
    }
    case "listItem": {
      return [{
        type: "list-item",
        children: deserializeChildren(node4.children, input)
      }];
    }
    case "thematicBreak": {
      return [{
        type: "divider",
        children: [{
          text: ""
        }]
      }];
    }
    case "break": {
      return getInlineNodes("\n");
    }
    case "delete": {
      return addMarkToChildren("strikethrough", () => deserializeChildren(node4.children, input));
    }
    case "strong": {
      return addMarkToChildren("bold", () => deserializeChildren(node4.children, input));
    }
    case "emphasis": {
      return addMarkToChildren("italic", () => deserializeChildren(node4.children, input));
    }
    case "inlineCode": {
      return addMarkToChildren("code", () => getInlineNodes(node4.value));
    }
    case "text": {
      return getInlineNodes(node4.value);
    }
  }
  return getInlineNodes(input.slice(node4.position.start.offset, node4.position.end.offset));
}
var urlPattern = /https?:\/\//;
function insertFragmentButDifferent(editor, nodes) {
  if (isBlock(nodes[0])) {
    insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, nodes);
  } else {
    Transforms.insertFragment(editor, nodes);
  }
}
var clipboardFormatKey = "x-keystatic-fragment";
var getDefaultView2 = (value2) => {
  return value2 && value2.ownerDocument && value2.ownerDocument.defaultView || null;
};
var isDOMNode2 = (value2) => {
  const window2 = getDefaultView2(value2);
  return !!window2 && value2 instanceof window2.Node;
};
var isDOMText2 = (value2) => {
  return isDOMNode2(value2) && value2.nodeType === 3;
};
var isDOMElement2 = (value2) => {
  return isDOMNode2(value2) && value2.nodeType === 1;
};
var getPlainText2 = (domNode) => {
  let text7 = "";
  if (isDOMText2(domNode) && domNode.nodeValue) {
    return domNode.nodeValue;
  }
  if (isDOMElement2(domNode)) {
    for (const childNode of Array.from(domNode.childNodes)) {
      text7 += getPlainText2(childNode);
    }
    const display = getComputedStyle(domNode).getPropertyValue("display");
    if (display === "block" || display === "list" || domNode.tagName === "BR") {
      text7 += "\n";
    }
  }
  return text7;
};
function setFragmentData(e6, data) {
  const {
    selection
  } = e6;
  if (!selection) {
    return;
  }
  const [start2, end] = Range.edges(selection);
  const startVoid = Editor.void(e6, {
    at: start2.path
  });
  const endVoid = Editor.void(e6, {
    at: end.path
  });
  if (Range.isCollapsed(selection) && !startVoid) {
    return;
  }
  const domRange = ReactEditor.toDOMRange(e6, selection);
  let contents = domRange.cloneContents();
  let attach = contents.childNodes[0];
  contents.childNodes.forEach((node4) => {
    if (node4.textContent && node4.textContent.trim() !== "") {
      attach = node4;
    }
  });
  if (endVoid) {
    const [voidNode] = endVoid;
    const r7 = domRange.cloneRange();
    const domNode = ReactEditor.toDOMNode(e6, voidNode);
    r7.setEndAfter(domNode);
    contents = r7.cloneContents();
  }
  if (startVoid) {
    attach = contents.querySelector("[data-slate-spacer]");
  }
  Array.from(contents.querySelectorAll("[data-slate-zero-width]")).forEach((zw) => {
    const isNewline = zw.getAttribute("data-slate-zero-width") === "n";
    zw.textContent = isNewline ? "\n" : "";
  });
  if (isDOMText2(attach)) {
    const span = attach.ownerDocument.createElement("span");
    span.style.whiteSpace = "pre";
    span.appendChild(attach);
    contents.appendChild(span);
    attach = span;
  }
  const fragment = e6.getFragment();
  const string3 = JSON.stringify(fragment, (key, val) => {
    if (val instanceof Uint8Array) {
      return {
        [bytesName]: fromUint8Array(val)
      };
    }
    return val;
  });
  const encoded = window.btoa(encodeURIComponent(string3));
  attach.setAttribute("data-keystatic-fragment", encoded);
  data.setData(`application/${clipboardFormatKey}`, encoded);
  const div2 = contents.ownerDocument.createElement("div");
  div2.appendChild(contents);
  div2.setAttribute("hidden", "true");
  contents.ownerDocument.body.appendChild(div2);
  data.setData("text/html", div2.innerHTML);
  data.setData("text/plain", getPlainText2(div2));
  contents.ownerDocument.body.removeChild(div2);
}
var catchSlateFragment2 = /data-keystatic-fragment="(.+?)"/m;
var getSlateFragmentAttribute2 = (dataTransfer) => {
  const htmlData = dataTransfer.getData("text/html");
  const [, fragment] = htmlData.match(catchSlateFragment2) || [];
  return fragment;
};
var bytesName = "$$keystaticUint8Array$$";
function withPasting(editor) {
  const {
    insertTextData
  } = editor;
  editor.setFragmentData = (data) => {
    setFragmentData(editor, data);
  };
  editor.insertFragmentData = (data) => {
    const fragment = data.getData(`application/${clipboardFormatKey}`) || getSlateFragmentAttribute2(data);
    if (fragment) {
      const decoded = decodeURIComponent(window.atob(fragment));
      const parsed = JSON.parse(decoded, (key, val) => typeof val === "object" && val !== null && bytesName in val && typeof val[bytesName] === "string" ? toUint8Array2(val[bytesName]) : val);
      editor.insertFragment(parsed);
      return true;
    }
    return false;
  };
  editor.insertTextData = (data) => {
    const blockAbove = Editor.above(editor, {
      match: isBlock
    });
    if ((blockAbove === null || blockAbove === void 0 ? void 0 : blockAbove[0].type) === "code") {
      const plain2 = data.getData("text/plain");
      editor.insertText(plain2);
      return true;
    }
    let vsCodeEditorData = data.getData("vscode-editor-data");
    if (vsCodeEditorData) {
      try {
        const vsCodeData = JSON.parse(vsCodeEditorData);
        if ((vsCodeData === null || vsCodeData === void 0 ? void 0 : vsCodeData.mode) === "markdown" || (vsCodeData === null || vsCodeData === void 0 ? void 0 : vsCodeData.mode) === "mdx") {
          const plain2 = data.getData("text/plain");
          if (plain2) {
            const fragment = deserializeMarkdown(plain2);
            insertFragmentButDifferent(editor, fragment);
            return true;
          }
        }
      } catch (err) {
        console.log(err);
      }
    }
    const plain = data.getData("text/plain");
    if (
      // isValidURL is a bit more permissive than a user might expect
      // so for pasting, we'll constrain it to starting with https:// or http://
      urlPattern.test(plain) && isValidURL(plain) && editor.selection && !Range.isCollapsed(editor.selection) && // we only want to turn the selected text into a link if the selection is within the same block
      Editor.above(editor, {
        match: (node4) => isBlock(node4) && !isBlock(node4.children[0])
      }) && // and there is only text(potentially with marks) in the selection
      // no other links
      Editor.nodes(editor, {
        match: (node4) => node4.type === "link"
      }).next().done
    ) {
      Transforms.wrapNodes(editor, {
        type: "link",
        href: plain,
        children: []
      }, {
        split: true
      });
      return true;
    }
    const html = data.getData("text/html");
    if (html) {
      const fragment = deserializeHTML(html);
      insertFragmentButDifferent(editor, fragment);
      return true;
    }
    if (plain) {
      const fragment = deserializeMarkdown(plain);
      insertFragmentButDifferent(editor, fragment);
      return true;
    }
    return insertTextData(data);
  };
  return editor;
}
var shortcuts = {
  "...": "…",
  "-->": "→",
  "->": "→",
  "<-": "←",
  "<--": "←",
  "--": "–"
};
function withShortcuts(editor) {
  const {
    insertText: insertText2
  } = editor;
  editor.insertText = (text7) => {
    insertText2(text7);
    if (text7 === " " && editor.selection && Range.isCollapsed(editor.selection)) {
      const selectionPoint = editor.selection.anchor;
      const ancestorBlock = Editor.above(editor, {
        match: isBlock
      });
      if (ancestorBlock) {
        Object.keys(shortcuts).forEach((shortcut) => {
          const pointBefore = Editor.before(editor, selectionPoint, {
            unit: "character",
            distance: shortcut.length + 1
          });
          if (pointBefore && Path.isDescendant(pointBefore.path, ancestorBlock[1])) {
            const range = {
              anchor: selectionPoint,
              focus: pointBefore
            };
            const str = Editor.string(editor, range);
            if (str.slice(0, shortcut.length) === shortcut) {
              editor.history.undos.push({
                operations: [],
                selectionBefore: editor.selection
              });
              Transforms.select(editor, range);
              editor.insertText(shortcuts[shortcut] + " ");
            }
          }
        });
      }
    }
  };
  return editor;
}
function withSoftBreaks(editor) {
  editor.insertSoftBreak = () => {
    Transforms.insertText(editor, "\n");
  };
  return editor;
}
var HOTKEYS2 = {
  "mod+b": "bold",
  "mod+i": "italic",
  "mod+u": "underline"
};
function isMarkActive(editor, mark) {
  const marks = Editor.marks(editor);
  if (marks !== null && marks !== void 0 && marks[mark]) {
    return true;
  }
  for (const entry of Editor.nodes(editor, {
    match: Text.isText
  })) {
    if (entry[0][mark]) {
      return true;
    }
  }
  return false;
}
var arrowKeyToDirection = /* @__PURE__ */ new Map([["ArrowUp", "up"], ["ArrowDown", "down"], ["ArrowLeft", "left"], ["ArrowRight", "right"]]);
var getKeyDownHandler = (editor, documentFeatures) => (event) => {
  if (event.defaultPrevented)
    return;
  for (const hotkey in HOTKEYS2) {
    if (documentFeatures.formatting.inlineMarks[HOTKEYS2[hotkey]] && (0, import_is_hotkey2.isHotkey)(hotkey, event.nativeEvent)) {
      event.preventDefault();
      const mark = HOTKEYS2[hotkey];
      const isActive = isMarkActive(editor, mark);
      if (isActive) {
        Editor.removeMark(editor, mark);
      } else {
        Editor.addMark(editor, mark, true);
      }
      return;
    }
  }
  if ((0, import_is_hotkey2.isHotkey)("mod+\\", event.nativeEvent)) {
    clearFormatting(editor);
    return;
  }
  if (documentFeatures.links && (0, import_is_hotkey2.isHotkey)("mod+k", event.nativeEvent)) {
    event.preventDefault();
    wrapLink(editor, "");
    return;
  }
  if (event.key === "Tab") {
    const didAction = event.shiftKey ? unnestList(editor) : nestList(editor);
    if (didAction) {
      event.preventDefault();
      return;
    }
  }
  if (event.key === "Tab" && editor.selection) {
    const layoutArea = Editor.above(editor, {
      match: (node4) => node4.type === "layout-area" || node4.type === "table-cell"
    });
    if (layoutArea) {
      const layoutAreaToEnter = event.shiftKey ? Editor.before(editor, layoutArea[1], {
        unit: "block"
      }) : Editor.after(editor, layoutArea[1], {
        unit: "block"
      });
      Transforms.setSelection(editor, {
        anchor: layoutAreaToEnter,
        focus: layoutAreaToEnter
      });
      event.preventDefault();
    }
  }
  if ((0, import_is_hotkey2.isHotkey)("mod+a", event)) {
    const parentTable = Editor.above(editor, {
      match: nodeTypeMatcher("table")
    });
    if (parentTable) {
      Transforms.select(editor, parentTable[1]);
      event.preventDefault();
      return;
    }
  }
  const direction = arrowKeyToDirection.get(event.key);
  const {
    selection
  } = editor;
  if (direction && selection) {
    const selectedTableArea = getSelectedTableArea(editor);
    if (selectedTableArea) {
      var _Editor$above, _Editor$above2;
      const focusCellPath = (_Editor$above = Editor.above(editor, {
        match: nodeTypeMatcher("table-cell"),
        at: selection.focus.path
      })) === null || _Editor$above === void 0 ? void 0 : _Editor$above[1];
      const anchorCellPath = (_Editor$above2 = Editor.above(editor, {
        match: nodeTypeMatcher("table-cell"),
        at: selection.anchor.path
      })) === null || _Editor$above2 === void 0 ? void 0 : _Editor$above2[1];
      if (!focusCellPath || !anchorCellPath)
        return;
      const newCellPath = getCellPathInDirection(editor, focusCellPath, direction);
      if (newCellPath) {
        if (selectedTableArea.singleCell === "not-selected") {
          if (direction !== "up" && direction !== "down")
            return;
          const [node4, offset] = ReactEditor.toDOMPoint(editor, selection.focus);
          const blockElement = Editor.above(editor, {
            match: isBlock,
            at: selection.focus.path
          });
          if (!blockElement)
            return;
          if (direction === "up" && blockElement[1].slice(focusCellPath.length).some((idx) => idx !== 0)) {
            return;
          }
          if (direction === "down") {
            const [parentNode] = Editor.parent(editor, blockElement[1]);
            if (parentNode.children.length - 1 !== blockElement[1][blockElement[1].length - 1]) {
              return;
            }
            for (const [node5, path3] of Node3.ancestors(editor, blockElement[1], {
              reverse: true
            })) {
              if (node5.type === "table-cell")
                break;
              const [parentNode2] = Editor.parent(editor, path3);
              if (parentNode2.children.length - 1 === path3[path3.length - 1]) {
                continue;
              }
              return;
            }
          }
          const domNodeForBlockElement = ReactEditor.toDOMNode(editor, blockElement[0]);
          const rangeOfWholeBlock = document.createRange();
          rangeOfWholeBlock.selectNodeContents(domNodeForBlockElement);
          const rectsOfRangeOfWholeBlock = Array.from(rangeOfWholeBlock.getClientRects());
          const newRange = document.createRange();
          newRange.setStart(node4, offset);
          newRange.setEnd(node4, offset);
          const rangeRects = Array.from(newRange.getClientRects());
          const lastRangeRect = rangeRects[rangeRects.length - 1];
          const key = direction === "up" ? "top" : "bottom";
          const expected = key === "top" ? Math.min(...rectsOfRangeOfWholeBlock.map((x4) => x4.top)) : Math.max(...rectsOfRangeOfWholeBlock.map((x4) => x4.bottom));
          if (lastRangeRect[key] === expected) {
            const focus = Editor[direction === "up" ? "end" : "start"](editor, newCellPath);
            Transforms.select(editor, {
              focus,
              anchor: event.shiftKey ? selection.anchor : focus
            });
            event.preventDefault();
          }
          return;
        }
        if (!event.shiftKey)
          return;
        if (Path.equals(newCellPath, anchorCellPath)) {
          Transforms.select(editor, newCellPath);
        } else {
          Transforms.select(editor, {
            anchor: selection.anchor,
            focus: Editor.start(editor, newCellPath)
          });
        }
        event.preventDefault();
      }
    }
  }
};
function createDocumentEditor(documentFeatures, componentBlocks) {
  return withPasting(withImages(withSoftBreaks(withInsertMenu(withShortcuts(withHeading(withBlockquote(withMarks(documentFeatures, componentBlocks, withBlockMarkdownShortcuts(documentFeatures, componentBlocks, _createDocumentEditor(withHistory(withReact(createEditor())), documentFeatures, componentBlocks))))))))));
}
function DocumentEditor({
  onChange: onChange2,
  value: value2,
  componentBlocks,
  documentFeatures,
  ...props
}) {
  let entryLayoutPane = useEntryLayoutSplitPaneContext();
  const editor = (0, import_react79.useMemo)(() => createDocumentEditor(documentFeatures, componentBlocks), [documentFeatures, componentBlocks]);
  return (0, import_jsx_runtime92.jsx)("div", {
    "data-layout": entryLayoutPane,
    className: classNames(css({
      backgroundColor: tokenSchema.color.background.canvas,
      minWidth: 0,
      '&[data-layout="main"]': {
        flex: 1,
        display: "flex",
        flexDirection: "column"
      },
      '&:not([data-layout="main"])': {
        border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.neutral}`,
        borderRadius: tokenSchema.size.radius.medium
      }
    }), "keystar-document-editor"),
    children: (0, import_jsx_runtime92.jsxs)(DocumentEditorProvider, {
      componentBlocks,
      documentFeatures,
      editor,
      value: value2,
      onChange: (value3) => {
        onChange2 === null || onChange2 === void 0 || onChange2(value3);
        const selection = window.getSelection();
        if (selection && !ReactEditor.isFocused(editor)) {
          const editorNode = ReactEditor.toDOMNode(editor, editor);
          if (selection.anchorNode === editorNode) {
            ReactEditor.focus(editor);
          }
        }
      },
      children: [
        (0, import_react79.useMemo)(() => onChange2 !== void 0 && (0, import_jsx_runtime92.jsx)(Toolbar, {
          documentFeatures
        }), [documentFeatures, onChange2]),
        (0, import_jsx_runtime92.jsx)(DocumentEditorEditable, {
          ...props,
          readOnly: onChange2 === void 0
        }),
        // for debugging
        false
      ]
    })
  });
}
var IsInEditorContext = (0, import_react79.createContext)(false);
function useIsInDocumentEditor() {
  return (0, import_react79.useContext)(IsInEditorContext);
}
function DocumentEditorProvider({
  children,
  editor,
  onChange: onChange2,
  value: value2,
  componentBlocks,
  documentFeatures
}) {
  const identity3 = (0, import_react79.useMemo)(() => Math.random().toString(36), [editor]);
  return (0, import_jsx_runtime92.jsx)(IsInEditorContext.Provider, {
    value: true,
    children: (0, import_jsx_runtime92.jsx)(
      Slate,
      {
        editor,
        value: value2,
        onChange: (value3) => {
          onChange2(value3);
          const selection = window.getSelection();
          if (selection && !ReactEditor.isFocused(editor)) {
            const editorNode = ReactEditor.toDOMNode(editor, editor);
            if (selection.anchorNode === editorNode) {
              ReactEditor.focus(editor);
            }
          }
        },
        children: (0, import_jsx_runtime92.jsx)(TableSelectionProvider, {
          children: (0, import_jsx_runtime92.jsx)(ToolbarStateProvider, {
            componentBlocks,
            editorDocumentFeatures: documentFeatures,
            children
          })
        })
      },
      identity3
    )
  });
}
function getPrismTokenLength(token2) {
  if (typeof token2 === "string") {
    return token2.length;
  } else if (Array.isArray(token2.content)) {
    return token2.content.reduce((l7, t5) => l7 + getPrismTokenLength(t5), 0);
  } else {
    return getPrismTokenLength(token2.content);
  }
}
function DocumentEditorEditable(props) {
  const containerSize = useContentPanelSize();
  const entryLayoutPane = useEntryLayoutSplitPaneContext();
  const editor = useSlate();
  const {
    componentBlocks,
    documentFeatures
  } = useDocumentEditorConfig();
  const onKeyDown = (0, import_react79.useMemo)(() => getKeyDownHandler(editor, documentFeatures), [editor, documentFeatures]);
  return (0, import_jsx_runtime92.jsx)(ActiveBlockPopoverProvider, {
    editor,
    children: (0, import_jsx_runtime92.jsx)(Prose, {
      size: entryLayoutPane === "main" ? "medium" : "regular",
      children: (0, import_jsx_runtime92.jsx)(Editable, {
        placeholder: 'Start writing or press "/" for commands...',
        decorate: (0, import_react79.useCallback)(([node4, path3]) => {
          let decorations = [];
          if (node4.type === "component-block") {
            if (node4.children.length === 1 && Element2.isElement(node4.children[0]) && node4.children[0].type === "component-inline-prop" && node4.children[0].propPath === void 0) {
              return decorations;
            }
            node4.children.forEach((child, index3) => {
              if (Node3.string(child) === "" && Element2.isElement(child) && (child.type === "component-block-prop" || child.type === "component-inline-prop") && child.propPath !== void 0) {
                const start2 = Editor.start(editor, [...path3, index3]);
                const placeholder = getPlaceholderTextForPropPath(child.propPath, componentBlocks[node4.component].schema, node4.props);
                if (placeholder) {
                  decorations.push({
                    placeholder,
                    anchor: start2,
                    focus: start2
                  });
                }
              }
            });
          }
          if (node4.type === "code" && node4.children.length === 1 && node4.children[0].type === void 0 && node4.language && node4.language in Prism.languages) {
            let consumeTokens = function(start2, tokens2) {
              for (const token2 of tokens2) {
                const length4 = getPrismTokenLength(token2);
                const end = start2 + length4;
                if (typeof token2 !== "string") {
                  decorations.push({
                    ["prism_" + token2.type]: true,
                    anchor: {
                      path: textPath,
                      offset: start2
                    },
                    focus: {
                      path: textPath,
                      offset: end
                    }
                  });
                  consumeTokens(start2, Array.isArray(token2.content) ? token2.content : [token2.content]);
                }
                start2 = end;
              }
            };
            const textPath = [...path3, 0];
            const tokens = Prism.tokenize(node4.children[0].text, Prism.languages[node4.language]);
            consumeTokens(0, tokens);
          }
          return decorations;
        }, [editor, componentBlocks]),
        onKeyDown,
        renderElement,
        renderLeaf,
        ...props,
        ...toDataAttributes({
          container: containerSize,
          layout: entryLayoutPane
        }),
        className: classNames(editableStyles, props.className)
      })
    })
  });
}
var styles = {
  flex: 1,
  height: "auto",
  minHeight: tokenSchema.size.scale[2e3],
  minWidth: 0,
  padding: tokenSchema.size.space.medium,
  '&[data-layout="main"]': {
    boxSizing: "border-box",
    height: "100%",
    padding: 0,
    paddingTop: tokenSchema.size.space.medium,
    minHeight: 0,
    minWidth: 0,
    maxWidth: 800,
    marginInline: "auto",
    [breakpointQueries$1.above.mobile]: {
      padding: tokenSchema.size.space.xlarge
    },
    [breakpointQueries$1.above.tablet]: {
      padding: tokenSchema.size.space.xxlarge
    },
    '&[data-container="wide"]': {
      padding: tokenSchema.size.scale[600]
    }
  }
};
var editableStyles = css({
  ...styles,
  a: {
    color: tokenSchema.color.foreground.accent
  }
});
var emptyObj = {};
var i$1 = 0;
function newKey$1() {
  return i$1++;
}
function InnerChildFieldInput(props) {
  const outerConfig = useDocumentEditorConfig();
  const [state, setState] = (0, import_react79.useState)(() => ({
    key: newKey$1(),
    value: props.value
  }));
  const documentFeatures = (0, import_react79.useMemo)(() => {
    return getWholeDocumentFeaturesForChildField(outerConfig.documentFeatures, props.schema.options);
  }, [props.schema, outerConfig.documentFeatures]);
  if (state.value !== props.value) {
    setState({
      key: newKey$1(),
      value: props.value
    });
  }
  return (0, import_jsx_runtime92.jsx)(ResetEntryLayoutContext, {
    children: (0, import_jsx_runtime92.jsx)(Field, {
      label: props.schema.options.label,
      children: (inputProps) => (0, import_react79.createElement)(DocumentEditor, {
        ...inputProps,
        key: state.key,
        componentBlocks: props.schema.options.componentBlocks === "inherit" ? outerConfig.componentBlocks : emptyObj,
        documentFeatures,
        onChange: (val) => {
          setState((state2) => ({
            key: state2.key,
            value: val
          }));
          props.onChange(val);
        },
        value: state.value
      })
    })
  });
}
function ChildFieldInput(props) {
  const data = getChildFieldData(props);
  if (props.schema.options.kind === "block" && (props.schema.options.editIn === "both" || props.schema.options.editIn === "modal") && data.value) {
    return (0, import_jsx_runtime92.jsx)(InnerChildFieldInput, {
      schema: props.schema,
      ...data
    });
  }
  return null;
}
function getInputComponent(schema) {
  if (schema.kind === "object") {
    var _schema$Input;
    return (_schema$Input = schema.Input) !== null && _schema$Input !== void 0 ? _schema$Input : ObjectFieldInput;
  }
  if (schema.kind === "conditional") {
    var _schema$Input2;
    return (_schema$Input2 = schema.Input) !== null && _schema$Input2 !== void 0 ? _schema$Input2 : ConditionalFieldInput;
  }
  if (schema.kind === "array") {
    var _schema$Input3;
    return (_schema$Input3 = schema.Input) !== null && _schema$Input3 !== void 0 ? _schema$Input3 : ArrayFieldInput;
  }
  if (schema.kind === "child") {
    return ChildFieldInput;
  }
  return schema.Input;
}
var InnerFormValueContentFromPreviewProps = (0, import_react79.memo)(function InnerFormValueContentFromPreview(props) {
  let Input = getInputComponent(props.schema);
  return (0, import_jsx_runtime92.jsx)(Input, {
    ...props,
    autoFocus: !!props.autoFocus,
    forceValidation: !!props.forceValidation
  });
});
var emptyArray$1 = [];
var FormValueContentFromPreviewProps = (0, import_react79.memo)(function FormValueContentFromPreview({
  slugField,
  ...props
}) {
  let Input = getInputComponent(props.schema);
  return (0, import_jsx_runtime92.jsx)(PathContextProvider, {
    value: emptyArray$1,
    children: (0, import_jsx_runtime92.jsx)(SlugFieldProvider, {
      value: slugField,
      children: (0, import_jsx_runtime92.jsx)(Input, {
        ...props,
        autoFocus: !!props.autoFocus,
        forceValidation: !!props.forceValidation
      })
    })
  });
});
var emptyArray = [];
var RESPONSIVE_PADDING = {
  mobile: "medium",
  tablet: "xlarge",
  desktop: "xxlarge"
};
function containerWidthForEntryLayout(config3) {
  return config3.entryLayout === "content" ? "none" : "medium";
}
var EntryLayoutSplitPaneContext = (0, import_react79.createContext)(null);
function useEntryLayoutSplitPaneContext() {
  return (0, import_react79.useContext)(EntryLayoutSplitPaneContext);
}
function ResetEntryLayoutContext(props) {
  return (0, import_jsx_runtime92.jsx)(EntryLayoutSplitPaneContext.Provider, {
    value: null,
    children: props.children
  });
}
function FormForEntry({
  formatInfo,
  forceValidation,
  slugField,
  entryLayout,
  previewProps: props
}) {
  const isAboveMobile = useContentPanelQuery({
    above: "mobile"
  });
  if (entryLayout === "content" && formatInfo.contentField && isAboveMobile) {
    const {
      contentField
    } = formatInfo;
    return (0, import_jsx_runtime92.jsx)(PathContextProvider, {
      value: emptyArray,
      children: (0, import_jsx_runtime92.jsx)(SlugFieldProvider, {
        value: slugField,
        children: (0, import_jsx_runtime92.jsxs)(SplitView, {
          autoSaveId: "keystatic-content-split-view",
          defaultSize: 320,
          minSize: 240,
          maxSize: 480,
          flex: true,
          children: [(0, import_jsx_runtime92.jsx)(SplitPaneSecondary, {
            children: (0, import_jsx_runtime92.jsx)(EntryLayoutSplitPaneContext.Provider, {
              value: "main",
              children: (0, import_jsx_runtime92.jsx)(ScrollView3, {
                children: (0, import_jsx_runtime92.jsx)(AddToPathProvider, {
                  part: contentField.key,
                  children: (0, import_jsx_runtime92.jsx)(InnerFormValueContentFromPreviewProps, {
                    forceValidation,
                    ...props.fields[contentField.key]
                  })
                })
              })
            })
          }), (0, import_jsx_runtime92.jsx)(SplitPanePrimary, {
            children: (0, import_jsx_runtime92.jsx)(EntryLayoutSplitPaneContext.Provider, {
              value: "side",
              children: (0, import_jsx_runtime92.jsx)(ScrollView3, {
                children: (0, import_jsx_runtime92.jsx)(Grid, {
                  gap: "xlarge",
                  padding: RESPONSIVE_PADDING,
                  children: Object.entries(props.fields).map(([key, propVal]) => key === contentField.key ? null : (0, import_jsx_runtime92.jsx)(AddToPathProvider, {
                    part: key,
                    children: (0, import_jsx_runtime92.jsx)(InnerFormValueContentFromPreviewProps, {
                      forceValidation,
                      ...propVal
                    })
                  }, key))
                })
              })
            })
          })]
        })
      })
    });
  }
  return (0, import_jsx_runtime92.jsx)(ScrollView3, {
    children: (0, import_jsx_runtime92.jsx)(PageContainer, {
      paddingY: RESPONSIVE_PADDING,
      children: (0, import_jsx_runtime92.jsx)(
        FormValueContentFromPreviewProps,
        {
          forceValidation,
          slugField,
          ...props
        }
      )
    })
  });
}
var i5 = 0;
function newKey() {
  return i5++;
}
function DocumentFieldInput(props) {
  let entryLayoutPane = useEntryLayoutSplitPaneContext();
  const [state, setState] = (0, import_react79.useState)(() => ({
    key: newKey(),
    value: props.value
  }));
  if (state.value !== props.value) {
    setState({
      key: newKey(),
      value: props.value
    });
  }
  let fieldProps = {
    label: props.label,
    labelElementType: "span",
    // the editor element isn't an input, so we need to use a span for the label
    description: props.description
  };
  if (entryLayoutPane === "main") {
    fieldProps = {
      "aria-label": props.label
      // `aria-description` is still in W3C Editor's Draft for ARIA 1.3.
    };
  }
  return (0, import_jsx_runtime92.jsx)(Field, {
    height: entryLayoutPane === "main" ? "100%" : void 0,
    ...fieldProps,
    children: (inputProps) => (0, import_react79.createElement)(DocumentEditor, {
      ...inputProps,
      key: state.key,
      componentBlocks: props.componentBlocks,
      documentFeatures: props.documentFeatures,
      onChange: (val) => {
        setState((state2) => ({
          key: state2.key,
          value: val
        }));
        props.onChange(val);
      },
      value: state.value
    })
  });
}
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder();
var defaultAltField = text6({
  label: "Alt text",
  description: "This text will be used by screen readers and search engines."
});
var emptyTitleField = basicFormFieldWithSimpleReaderParse({
  Input() {
    return null;
  },
  defaultValue() {
    return "";
  },
  parse(value2) {
    if (value2 === void 0)
      return "";
    if (typeof value2 !== "string") {
      throw new FieldDataError("Must be string");
    }
    return value2;
  },
  validate(value2) {
    return value2;
  },
  serialize(value2) {
    return {
      value: value2
    };
  },
  label: "Title"
});
function normaliseDocumentFeatures(config3) {
  var _config$formatting, _formatting$alignment, _formatting$alignment2, _formatting$blockType, _formatting$inlineMar, _formatting$inlineMar2, _formatting$inlineMar3, _formatting$inlineMar4, _formatting$inlineMar5, _formatting$inlineMar6, _formatting$inlineMar7, _formatting$inlineMar8, _formatting$listTypes, _formatting$listTypes2, _imagesConfig$schema$, _imagesConfig$schema, _imagesConfig$schema$2, _imagesConfig$schema2;
  const formatting = config3.formatting === true ? {
    // alignment: true, // not supported natively in markdown
    blockTypes: true,
    headingLevels: true,
    inlineMarks: true,
    listTypes: true,
    softBreaks: true
  } : (_config$formatting = config3.formatting) !== null && _config$formatting !== void 0 ? _config$formatting : {};
  const imagesConfig = config3.images === true ? {} : config3.images;
  return {
    formatting: {
      alignment: formatting.alignment === true ? {
        center: true,
        end: true
      } : {
        center: !!((_formatting$alignment = formatting.alignment) !== null && _formatting$alignment !== void 0 && _formatting$alignment.center),
        end: !!((_formatting$alignment2 = formatting.alignment) !== null && _formatting$alignment2 !== void 0 && _formatting$alignment2.end)
      },
      blockTypes: (formatting === null || formatting === void 0 ? void 0 : formatting.blockTypes) === true ? {
        blockquote: true,
        code: {
          schema: object({})
        }
      } : {
        blockquote: !!((_formatting$blockType = formatting.blockTypes) !== null && _formatting$blockType !== void 0 && _formatting$blockType.blockquote),
        code: ((_formatting$blockType2) => {
          if (((_formatting$blockType2 = formatting.blockTypes) === null || _formatting$blockType2 === void 0 ? void 0 : _formatting$blockType2.code) === void 0) {
            return false;
          }
          if (formatting.blockTypes.code === true || !formatting.blockTypes.code.schema) {
            return {
              schema: object({})
            };
          }
          for (const key of ["type", "children", "language"]) {
            if (key in formatting.blockTypes.code.schema) {
              throw new Error(`"${key}" cannot be a key in the schema for code blocks`);
            }
          }
          return {
            schema: object(formatting.blockTypes.code.schema)
          };
        })()
      },
      headings: ((_obj$schema) => {
        const opt = formatting === null || formatting === void 0 ? void 0 : formatting.headingLevels;
        const obj = typeof opt === "object" && "levels" in opt ? opt : {
          levels: opt,
          schema: void 0
        };
        if (obj.schema) {
          for (const key of ["type", "children", "level", "textAlign"]) {
            if (key in obj.schema) {
              throw new Error(`"${key}" cannot be a key in the schema for headings`);
            }
          }
        }
        return {
          levels: [...new Set(obj.levels === true ? [1, 2, 3, 4, 5, 6] : obj.levels)],
          schema: object((_obj$schema = obj.schema) !== null && _obj$schema !== void 0 ? _obj$schema : {})
        };
      })(),
      inlineMarks: formatting.inlineMarks === true ? {
        bold: true,
        code: true,
        italic: true,
        keyboard: false,
        // not supported natively in markdown
        strikethrough: true,
        subscript: false,
        // not supported natively in markdown
        superscript: false,
        // not supported natively in markdown
        underline: false
        // not supported natively in markdown
      } : {
        bold: !!((_formatting$inlineMar = formatting.inlineMarks) !== null && _formatting$inlineMar !== void 0 && _formatting$inlineMar.bold),
        code: !!((_formatting$inlineMar2 = formatting.inlineMarks) !== null && _formatting$inlineMar2 !== void 0 && _formatting$inlineMar2.code),
        italic: !!((_formatting$inlineMar3 = formatting.inlineMarks) !== null && _formatting$inlineMar3 !== void 0 && _formatting$inlineMar3.italic),
        strikethrough: !!((_formatting$inlineMar4 = formatting.inlineMarks) !== null && _formatting$inlineMar4 !== void 0 && _formatting$inlineMar4.strikethrough),
        underline: !!((_formatting$inlineMar5 = formatting.inlineMarks) !== null && _formatting$inlineMar5 !== void 0 && _formatting$inlineMar5.underline),
        keyboard: !!((_formatting$inlineMar6 = formatting.inlineMarks) !== null && _formatting$inlineMar6 !== void 0 && _formatting$inlineMar6.keyboard),
        subscript: !!((_formatting$inlineMar7 = formatting.inlineMarks) !== null && _formatting$inlineMar7 !== void 0 && _formatting$inlineMar7.subscript),
        superscript: !!((_formatting$inlineMar8 = formatting.inlineMarks) !== null && _formatting$inlineMar8 !== void 0 && _formatting$inlineMar8.superscript)
      },
      listTypes: formatting.listTypes === true ? {
        ordered: true,
        unordered: true
      } : {
        ordered: !!((_formatting$listTypes = formatting.listTypes) !== null && _formatting$listTypes !== void 0 && _formatting$listTypes.ordered),
        unordered: !!((_formatting$listTypes2 = formatting.listTypes) !== null && _formatting$listTypes2 !== void 0 && _formatting$listTypes2.unordered)
      },
      softBreaks: !!formatting.softBreaks
    },
    links: !!config3.links,
    layouts: [...new Set((config3.layouts || []).map((x4) => JSON.stringify(x4)))].map((x4) => JSON.parse(x4)),
    dividers: !!config3.dividers,
    images: imagesConfig === void 0 ? false : {
      ...imagesConfig,
      schema: {
        alt: (_imagesConfig$schema$ = (_imagesConfig$schema = imagesConfig.schema) === null || _imagesConfig$schema === void 0 ? void 0 : _imagesConfig$schema.alt) !== null && _imagesConfig$schema$ !== void 0 ? _imagesConfig$schema$ : defaultAltField,
        title: (_imagesConfig$schema$2 = (_imagesConfig$schema2 = imagesConfig.schema) === null || _imagesConfig$schema2 === void 0 ? void 0 : _imagesConfig$schema2.title) !== null && _imagesConfig$schema$2 !== void 0 ? _imagesConfig$schema$2 : emptyTitleField
      }
    },
    tables: !!config3.tables
  };
}
function document$1({
  label,
  componentBlocks = {},
  description,
  ...documentFeaturesConfig
}) {
  const documentFeatures = normaliseDocumentFeatures(documentFeaturesConfig);
  const parse8 = (mode) => (_value, data) => {
    const markdoc = textDecoder.decode(data.content);
    const document5 = fromMarkdoc(Markdoc.parse(markdoc), componentBlocks);
    const editor = createDocumentEditorForNormalization(documentFeatures, componentBlocks);
    editor.children = document5;
    Editor.normalize(editor, {
      force: true
    });
    return deserializeFiles(editor.children, componentBlocks, data.other, data.external || /* @__PURE__ */ new Map(), mode, documentFeatures, data.slug);
  };
  return {
    kind: "form",
    formKind: "content",
    defaultValue() {
      return [{
        type: "paragraph",
        children: [{
          text: ""
        }]
      }];
    },
    Input(props) {
      return (0, import_jsx_runtime92.jsx)(DocumentFieldInput, {
        componentBlocks,
        description,
        label,
        documentFeatures,
        ...props
      });
    },
    parse: parse8("edit"),
    contentExtension: ".mdoc",
    validate(value2) {
      return value2;
    },
    directories: [...collectDirectoriesUsedInSchema(object(Object.fromEntries(Object.entries(componentBlocks).map(([name2, block5]) => [name2, object(block5.schema)])))), ...typeof documentFeatures.images === "object" && typeof documentFeatures.images.directory === "string" ? [fixPath(documentFeatures.images.directory)] : []],
    serialize(value2, opts) {
      const {
        extraFiles,
        node: node4
      } = toMarkdocDocument(value2, {
        componentBlocks,
        documentFeatures,
        slug: opts.slug
      });
      const other = /* @__PURE__ */ new Map();
      const external2 = /* @__PURE__ */ new Map();
      for (const file of extraFiles) {
        if (file.parent === void 0) {
          other.set(file.path, file.contents);
          continue;
        }
        if (!external2.has(file.parent)) {
          external2.set(file.parent, /* @__PURE__ */ new Map());
        }
        external2.get(file.parent).set(file.path, file.contents);
      }
      return {
        content: textEncoder.encode(Markdoc.format(Markdoc.parse(Markdoc.format(node4)))),
        other,
        external: external2,
        value: void 0
      };
    },
    reader: {
      parse: parse8("read")
    }
  };
}

// node_modules/@keystatic/core/dist/useSlugsInCollection-77ed63be.js
var import_react80 = __toESM(require_react(), 1);
function useSlugsInCollection(collection2) {
  const config3 = useConfig();
  const tree2 = useTree().current;
  return (0, import_react80.useMemo)(() => {
    const loadedTree = tree2.kind === "loaded" ? tree2.data.tree : /* @__PURE__ */ new Map();
    return getEntriesInCollectionWithTreeKey(config3, collection2, loadedTree).map((x4) => x4.slug);
  }, [config3, tree2, collection2]);
}

export {
  assert,
  isNumber,
  Doc,
  AbstractType,
  fromUint8Array,
  $458b0a5536c1a7cf$export$40bfa8c7b0832715,
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c,
  $1dbecbe27a04f9af$export$14d238f342723f25,
  $bdb11010cef70236$export$f680877a34711e37,
  $bdb11010cef70236$export$b4cc09c592e8fdb8,
  $ff5963eb1fccf552$export$e08e3b67e392101e,
  $3ef42575df84b30b$export$9d1611c77c2fe928,
  $65484d02dcb7eb3e$export$457c3d6518dd4c6f,
  $c87311424ea30a05$export$a11b0059900ceec8,
  $ea8dcbcb9ea1b556$export$51437d503373d223,
  $df56164dff5785e2$export$4338b53315abf666,
  $4f58c5f72bcf79f7$export$496315a1608d9602,
  $9daab02d461809db$export$683480f191c0e3ea,
  $ef06256079686ba0$export$f8aeda7b10753fa1,
  $f6c31cce2adf654f$export$45712eceda6fad21,
  $6179b936705e76d3$export$ae780daf29e6d456,
  injectGlobal,
  css,
  $9bf71ea28793e738$export$20e40289641fbbb6,
  $f7dceffc5ad7768b$export$4e328f61c538687f,
  $e6afbd83fe6ebbd2$export$4c014de7c8940b4c,
  tokenSchema,
  transition,
  classNames,
  ClassList,
  breakpointQueries$1,
  containerQueries,
  toDataAttributes,
  FocusRing,
  useMediaQuery,
  useStyleProps,
  SlotProvider,
  Content,
  Box,
  Divider,
  minmax,
  Flex,
  Grid,
  VStack,
  useHasChild,
  isReactText,
  $5c3e21d68f1c4674$export$439d29a4e110a164,
  $18f2051aff69b9bf$export$43bb16f9c6d9e3f7,
  $fca6afa0e843324b$export$f12b703ca79dfbb1,
  $325a3faab7a68acd$export$a16aca283550c30d,
  Heading,
  Text2 as Text,
  alertTriangleIcon,
  Icon,
  FieldLabel,
  FieldMessage,
  $2d73ec29415bd339$export$712718f7aec83d5,
  TextFieldPrimitive,
  TextField,
  TextArea,
  SplitView,
  SplitPanePrimary,
  SplitPaneSecondary,
  useProviderProps,
  KeystarProvider,
  ClientSideOnlyDocumentElement,
  $298d61e98472621b$export$dcf14c9974fe2767,
  ButtonGroup,
  Button,
  ActionButton,
  ClearButton,
  Dialog,
  AlertDialog,
  DialogContainer,
  useDialogContainer,
  _DialogTrigger,
  $319e236875307eab$export$a9b970dcc4ae71a9,
  trash2Icon,
  $c1d7fb2ec91bae71$export$6d08773d2e66f8f2,
  $7613b1592d41b092$export$6cd28814d92fa9c9,
  $c5a24bc478652b5f$export$1005530eda016c13,
  $c5a24bc478652b5f$export$fbdeaa6a76694f71,
  $c5a24bc478652b5f$export$5f3398f8733f90e2,
  $c5a24bc478652b5f$export$7475b2c64539e4cf,
  $fc0b13b484ac1194$export$1505db82fe357e65,
  $d1c300d9c497e402$export$de9feff04fda126e,
  $83c6e2eafa584c67$export$f6b86a04e5d66d90,
  $e45487f8ba1cbdbf$export$d3037f5d3f3e51bf,
  $4159a7a9cbb0cc18$export$96357d5a73f686fa,
  $ab90dcbc1b5466d0$export$c7e10bfc0c59f67c,
  $7cb39d07f245a780$export$70e2eed1a92976ad,
  $ce415dc67314b753$export$ed5fd5ffe5ab0ac,
  $44a6ee657928b002$export$5665e3d6be6adea,
  $ccf8a0a04e4175ae$export$6796df8ba7398521,
  $ccf8a0a04e4175ae$export$1481e64fbe01b8b3,
  $6d0a5c394373ae64$export$dd6d526d88b5a137,
  $a152112e902709bf$export$62444c3c724b1b20,
  $7af3f5b51489e0b5$export$253fe78d46329472,
  $d496c0a20b6e58ec$export$6c8a5aaad13c9852,
  ProgressCircle,
  Checkbox,
  chevronLeftIcon,
  chevronRightIcon,
  Tooltip,
  _TooltipTrigger,
  require_lib3 as require_lib,
  externalLinkIcon,
  require_dist,
  _Menu,
  MenuTrigger,
  _ActionGroup,
  plusIcon,
  _Picker,
  _Combobox,
  NumberField,
  decimal_default,
  filter,
  lib_default2 as lib_default,
  e2 as e,
  valueFromASTUntyped2 as valueFromASTUntyped,
  filter2,
  map3 as map,
  mergeMap,
  merge3 as merge,
  onStart,
  share,
  take,
  takeUntil,
  r4 as r,
  makeSubject,
  empty,
  fromPromise,
  toPromise,
  stringifyVariables,
  stringifyDocument,
  createRequest,
  makeErrorResult,
  formatDocument,
  makeOperation,
  fetchExchange,
  j2 as j,
  f4 as f,
  useClient,
  useMutation,
  lru_cache_default,
  require_slugify,
  TextLink3 as TextLink,
  Badge,
  Avatar,
  gitPullRequestIcon,
  gitBranchPlusIcon,
  githubIcon,
  gitBranchIcon,
  checkCircle2Icon,
  infoIcon,
  Toaster,
  toastQueue,
  l10nMessages,
  RouterProvider,
  useRouter,
  fixPath,
  getCollectionPath,
  getCollectionFormat,
  getSingletonFormat,
  getCollectionItemPath,
  getEntryDataFilepath,
  getSlugGlobForCollection,
  getSingletonPath,
  getDataFileExtension,
  getPathPrefix,
  blobSha,
  getTreeNodeAtPath,
  treeSha,
  updateTreeWithChanges,
  LOADING,
  useData,
  getDirectoriesForTreeKey,
  getTreeKey,
  object,
  pluralize,
  getBranchPrefix,
  isGitHubConfig,
  isLocalConfig,
  isCloudConfig,
  getRepoUrl,
  getSlugFromState,
  getEntriesInCollectionWithTreeKey,
  KEYSTATIC_CLOUD_API_URL,
  KEYSTATIC_CLOUD_HEADERS,
  redirectToCloudAuth,
  getSyncAuth,
  getAuth,
  useViewer,
  parseRepoConfig,
  serializeRepoConfig,
  assertValidRepoConfig,
  scopeEntriesWithPathPrefix,
  setBlobToPersistedCache,
  getBlobFromPersistedCache,
  useYjs,
  useYjsIfAvailable,
  useSetTreeSha,
  LocalAppShellProvider,
  useCloudInfo,
  CloudInfoProvider,
  GitHubAppShellDataContext,
  GitHubAppShellDataProvider,
  GitHubAppShellProvider,
  AppShellErrorContext,
  useTree,
  useCurrentUnscopedTree,
  useBaseCommit,
  useIsRepoPrivate,
  useRepositoryId,
  CloudAppShellQuery,
  GitHubAppShellQuery,
  hydrateTreeCacheWithEntries,
  fetchGitHubTreeData,
  RepoWithWriteAccessContext,
  BranchInfoContext,
  useBranchInfo,
  config2 as config,
  collection,
  singleton,
  ConfigContext,
  useConfig,
  AppStateContext,
  ContentPanelProvider,
  useContentPanelState,
  useNavItems,
  CreateBranchDialog,
  prettyErrorForCreateBranchMutation,
  useCreateBranchMutation,
  ThemeProvider,
  useTheme,
  useEventCallback,
  BlockWrapper,
  NotEditable,
  ToolbarSeparator,
  parseImageData,
  loadImageData,
  ImageDimensionsInput,
  emptyImageData,
  useImageLibraryURL,
  showDraftRestoredToast,
  setDraft,
  delDraft,
  getDraft,
  useSidebar,
  SidebarProvider,
  SidebarPanel,
  SidebarDialog,
  PageRoot,
  PageHeader,
  PageBody,
  FieldDataError,
  assertRequired,
  basicFormFieldWithSimpleReaderParse,
  getKeysForArrayValue,
  setKeysForArrayValue,
  getNewArrayElementKey,
  getInitialPropsValue,
  getInitialPropsValueFromInitializer,
  updateValue,
  getYjsValFromParsedValue,
  yjsToVal,
  parsedValToYjs,
  getSrcPrefix,
  serializeProps,
  validateText,
  SlugFieldContext,
  PathContext,
  text6 as text,
  useFieldContext,
  createGetPreviewProps,
  valueToUpdater,
  parseProps,
  toFormattedFormDataError,
  clientSideValidateProp,
  ArrayFieldValidationMessages,
  ArrayFieldListView,
  isValidURL,
  getUploadedFile,
  useObjectURL,
  ImageFieldInput,
  useIsInDocumentEditor,
  FormValueContentFromPreviewProps,
  containerWidthForEntryLayout,
  FormForEntry,
  document$1,
  useSlugsInCollection
};
/*! Bundled license information:

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

is-plain-object/dist/is-plain-object.mjs:
  (*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

match-sorter/dist/match-sorter.esm.js:
  (**
   * @name match-sorter
   * @license MIT license.
   * @copyright (c) 2020 Kent C. Dodds
   * @author Kent C. Dodds <me@kentcdodds.com> (https://kentcdodds.com)
   *)

decimal.js/decimal.mjs:
  (*!
   *  decimal.js v10.4.3
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   *)

partysocket/dist/chunk-TPTC3KUF.mjs:
  (*!
   * Reconnecting WebSocket
   * by Pedro Ladaria <pedro.ladaria@gmail.com>
   * https://github.com/pladaria/reconnecting-websocket
   * License MIT
   *)

@keystatic/core/dist/index-172a6993.js:
  (**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   *)
*/
//# sourceMappingURL=chunk-MDNGFAXE.js.map
