import {
  $18f2051aff69b9bf$export$43bb16f9c6d9e3f7,
  $1dbecbe27a04f9af$export$14d238f342723f25,
  $298d61e98472621b$export$dcf14c9974fe2767,
  $2d73ec29415bd339$export$712718f7aec83d5,
  $319e236875307eab$export$a9b970dcc4ae71a9,
  $325a3faab7a68acd$export$a16aca283550c30d,
  $3ef42575df84b30b$export$9d1611c77c2fe928,
  $4159a7a9cbb0cc18$export$96357d5a73f686fa,
  $44a6ee657928b002$export$5665e3d6be6adea,
  $458b0a5536c1a7cf$export$40bfa8c7b0832715,
  $4f58c5f72bcf79f7$export$496315a1608d9602,
  $5c3e21d68f1c4674$export$439d29a4e110a164,
  $6179b936705e76d3$export$ae780daf29e6d456,
  $65484d02dcb7eb3e$export$457c3d6518dd4c6f,
  $6d0a5c394373ae64$export$dd6d526d88b5a137,
  $7613b1592d41b092$export$6cd28814d92fa9c9,
  $7af3f5b51489e0b5$export$253fe78d46329472,
  $7cb39d07f245a780$export$70e2eed1a92976ad,
  $83c6e2eafa584c67$export$f6b86a04e5d66d90,
  $9bf71ea28793e738$export$20e40289641fbbb6,
  $9daab02d461809db$export$683480f191c0e3ea,
  $a152112e902709bf$export$62444c3c724b1b20,
  $ab90dcbc1b5466d0$export$c7e10bfc0c59f67c,
  $bdb11010cef70236$export$b4cc09c592e8fdb8,
  $bdb11010cef70236$export$f680877a34711e37,
  $c1d7fb2ec91bae71$export$6d08773d2e66f8f2,
  $c5a24bc478652b5f$export$1005530eda016c13,
  $c5a24bc478652b5f$export$5f3398f8733f90e2,
  $c5a24bc478652b5f$export$7475b2c64539e4cf,
  $c5a24bc478652b5f$export$fbdeaa6a76694f71,
  $c87311424ea30a05$export$a11b0059900ceec8,
  $ccf8a0a04e4175ae$export$1481e64fbe01b8b3,
  $ccf8a0a04e4175ae$export$6796df8ba7398521,
  $ce415dc67314b753$export$ed5fd5ffe5ab0ac,
  $d1c300d9c497e402$export$de9feff04fda126e,
  $d496c0a20b6e58ec$export$6c8a5aaad13c9852,
  $df56164dff5785e2$export$4338b53315abf666,
  $e45487f8ba1cbdbf$export$d3037f5d3f3e51bf,
  $e6afbd83fe6ebbd2$export$4c014de7c8940b4c,
  $ea8dcbcb9ea1b556$export$51437d503373d223,
  $ef06256079686ba0$export$f8aeda7b10753fa1,
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c,
  $f6c31cce2adf654f$export$45712eceda6fad21,
  $f7dceffc5ad7768b$export$4e328f61c538687f,
  $fc0b13b484ac1194$export$1505db82fe357e65,
  $fca6afa0e843324b$export$f12b703ca79dfbb1,
  $ff5963eb1fccf552$export$e08e3b67e392101e,
  AbstractType,
  ActionButton,
  AlertDialog,
  AppShellErrorContext,
  AppStateContext,
  Avatar,
  Badge,
  Box,
  BranchInfoContext,
  Button,
  ButtonGroup,
  Checkbox,
  ClassList,
  ClearButton,
  ClientSideOnlyDocumentElement,
  CloudAppShellQuery,
  CloudInfoProvider,
  ConfigContext,
  Content,
  ContentPanelProvider,
  CreateBranchDialog,
  Dialog,
  DialogContainer,
  Divider,
  Doc,
  Flex,
  FocusRing,
  FormForEntry,
  GitHubAppShellDataContext,
  GitHubAppShellDataProvider,
  GitHubAppShellProvider,
  GitHubAppShellQuery,
  Grid,
  Heading,
  Icon,
  KEYSTATIC_CLOUD_API_URL,
  KEYSTATIC_CLOUD_HEADERS,
  KeystarProvider,
  LOADING,
  LocalAppShellProvider,
  MenuTrigger,
  PageBody,
  PageHeader,
  PageRoot,
  ProgressCircle,
  RepoWithWriteAccessContext,
  RouterProvider,
  SidebarDialog,
  SidebarPanel,
  SidebarProvider,
  SlotProvider,
  SplitPanePrimary,
  SplitPaneSecondary,
  SplitView,
  Text,
  TextField,
  TextFieldPrimitive,
  TextLink,
  ThemeProvider,
  Toaster,
  Tooltip,
  VStack,
  _ActionGroup,
  _DialogTrigger,
  _Menu,
  _TooltipTrigger,
  alertTriangleIcon,
  assert,
  assertValidRepoConfig,
  blobSha,
  breakpointQueries$1,
  checkCircle2Icon,
  chevronLeftIcon,
  chevronRightIcon,
  classNames,
  clientSideValidateProp,
  containerQueries,
  containerWidthForEntryLayout,
  createGetPreviewProps,
  createRequest,
  css,
  delDraft,
  e,
  empty,
  externalLinkIcon,
  f,
  fetchExchange,
  fetchGitHubTreeData,
  filter2 as filter,
  formatDocument,
  fromPromise,
  fromUint8Array,
  getAuth,
  getBlobFromPersistedCache,
  getBranchPrefix,
  getCollectionFormat,
  getCollectionItemPath,
  getCollectionPath,
  getDataFileExtension,
  getDirectoriesForTreeKey,
  getDraft,
  getEntriesInCollectionWithTreeKey,
  getEntryDataFilepath,
  getInitialPropsValue,
  getInitialPropsValueFromInitializer,
  getKeysForArrayValue,
  getNewArrayElementKey,
  getPathPrefix,
  getRepoUrl,
  getSingletonFormat,
  getSingletonPath,
  getSlugFromState,
  getSlugGlobForCollection,
  getSyncAuth,
  getTreeKey,
  getTreeNodeAtPath,
  getYjsValFromParsedValue,
  gitBranchIcon,
  gitBranchPlusIcon,
  gitPullRequestIcon,
  githubIcon,
  hydrateTreeCacheWithEntries,
  infoIcon,
  injectGlobal,
  isCloudConfig,
  isGitHubConfig,
  isLocalConfig,
  isNumber,
  isReactText,
  j,
  l10nMessages,
  lib_default,
  lru_cache_default,
  makeErrorResult,
  makeOperation,
  makeSubject,
  map,
  merge,
  mergeMap,
  minmax,
  object,
  onStart,
  parseProps,
  parseRepoConfig,
  parsedValToYjs,
  pluralize,
  plusIcon,
  prettyErrorForCreateBranchMutation,
  r,
  redirectToCloudAuth,
  require_dist,
  require_lib,
  require_slugify,
  scopeEntriesWithPathPrefix,
  serializeProps,
  serializeRepoConfig,
  setBlobToPersistedCache,
  setDraft,
  setKeysForArrayValue,
  share,
  showDraftRestoredToast,
  stringifyDocument,
  stringifyVariables,
  take,
  takeUntil,
  toDataAttributes,
  toFormattedFormDataError,
  toPromise,
  toastQueue,
  tokenSchema,
  transition,
  trash2Icon,
  treeSha,
  updateTreeWithChanges,
  updateValue,
  useBaseCommit,
  useBranchInfo,
  useClient,
  useCloudInfo,
  useConfig,
  useContentPanelState,
  useCreateBranchMutation,
  useCurrentUnscopedTree,
  useData,
  useEventCallback,
  useHasChild,
  useIsRepoPrivate,
  useMediaQuery,
  useMutation,
  useNavItems,
  useProviderProps,
  useRepositoryId,
  useRouter,
  useSetTreeSha,
  useSidebar,
  useSlugsInCollection,
  useStyleProps,
  useTheme,
  useTree,
  useViewer,
  useYjs,
  useYjsIfAvailable,
  valueFromASTUntyped,
  yjsToVal
} from "./chunk-MDNGFAXE.js";
import {
  require_cookie,
  z
} from "./chunk-CO6I4FWO.js";
import {
  require_jsx_runtime
} from "./chunk-6Y4BSO2J.js";
import {
  require_react
} from "./chunk-ZVHPWISC.js";
import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateSet,
  __require,
  __toESM
} from "./chunk-UF6YC252.js";

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal(a, b2) {
      if (a === b2)
        return true;
      if (a && b2 && typeof a == "object" && typeof b2 == "object") {
        if (a.constructor !== b2.constructor)
          return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b2.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b2[i]))
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b2.source && a.flags === b2.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b2.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b2.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b2).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b2, keys[i]))
            return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b2[key]))
            return false;
        }
        return true;
      }
      return a !== a && b2 !== b2;
    };
  }
});

// node_modules/@keystatic/core/dist/keystatic-core-ui.js
var import_react8 = __toESM(require_react());

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-fileX2Icon.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var fileX2Icon = (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
  children: [(0, import_jsx_runtime.jsx)("path", {
    d: "M4 22h14a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v4"
  }), (0, import_jsx_runtime.jsx)("path", {
    d: "M14 2v4a2 2 0 0 0 2 2h4M8 12.5l-5 5M3 12.5l5 5"
  })]
});

// node_modules/@keystatic/core/dist/keystatic-core-ui.js
var import_is_hotkey = __toESM(require_lib());

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-alertCircleIcon.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var alertCircleIcon = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
  children: [(0, import_jsx_runtime2.jsx)("circle", {
    cx: 12,
    cy: 12,
    r: 10
  }), (0, import_jsx_runtime2.jsx)("path", {
    d: "M12 8v4M12 16h.01"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-listXIcon.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var listXIcon = (0, import_jsx_runtime3.jsx)("path", {
  d: "M11 12H3M16 6H3M16 18H3M19 10l-4 4M15 10l4 4"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-searchIcon.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var searchIcon = (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, {
  children: [(0, import_jsx_runtime4.jsx)("circle", {
    cx: 11,
    cy: 11,
    r: 8
  }), (0, import_jsx_runtime4.jsx)("path", {
    d: "m21 21-4.3-4.3"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-searchXIcon.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var searchXIcon = (0, import_jsx_runtime5.jsxs)(import_jsx_runtime5.Fragment, {
  children: [(0, import_jsx_runtime5.jsx)("path", {
    d: "m13.5 8.5-5 5M8.5 8.5l5 5"
  }), (0, import_jsx_runtime5.jsx)("circle", {
    cx: 11,
    cy: 11,
    r: 8
  }), (0, import_jsx_runtime5.jsx)("path", {
    d: "m21 21-4.3-4.3"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-diffIcon.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var diffIcon = (0, import_jsx_runtime6.jsx)("path", {
  d: "M12 3v14M5 10h14M5 21h14"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-plusSquareIcon.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var plusSquareIcon = (0, import_jsx_runtime7.jsxs)(import_jsx_runtime7.Fragment, {
  children: [(0, import_jsx_runtime7.jsx)("rect", {
    width: 18,
    height: 18,
    x: 3,
    y: 3,
    rx: 2
  }), (0, import_jsx_runtime7.jsx)("path", {
    d: "M8 12h8M12 8v8"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-dotSquareIcon.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var dotSquareIcon = (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, {
  children: [(0, import_jsx_runtime8.jsx)("rect", {
    width: 18,
    height: 18,
    x: 3,
    y: 3,
    rx: 2
  }), (0, import_jsx_runtime8.jsx)("circle", {
    cx: 12,
    cy: 12,
    r: 1
  })]
});

// node_modules/@react-aria/searchfield/dist/ar-AE.mjs
var $03c9a1a10de12f06$exports = {};
$03c9a1a10de12f06$exports = {
  "Clear search": `مسح البحث`
};

// node_modules/@react-aria/searchfield/dist/bg-BG.mjs
var $4da0c2ffa4ba4159$exports = {};
$4da0c2ffa4ba4159$exports = {
  "Clear search": `Изчистване на търсене`
};

// node_modules/@react-aria/searchfield/dist/cs-CZ.mjs
var $8c59fd0c2c96821b$exports = {};
$8c59fd0c2c96821b$exports = {
  "Clear search": `Vymazat hledání`
};

// node_modules/@react-aria/searchfield/dist/da-DK.mjs
var $0a371f9c1df8120f$exports = {};
$0a371f9c1df8120f$exports = {
  "Clear search": `Ryd søgning`
};

// node_modules/@react-aria/searchfield/dist/de-DE.mjs
var $67f4d0b0de9f8a52$exports = {};
$67f4d0b0de9f8a52$exports = {
  "Clear search": `Suche zurücksetzen`
};

// node_modules/@react-aria/searchfield/dist/el-GR.mjs
var $72a312d948f0214b$exports = {};
$72a312d948f0214b$exports = {
  "Clear search": `Απαλοιφή αναζήτησης`
};

// node_modules/@react-aria/searchfield/dist/en-US.mjs
var $5012d21d933388c1$exports = {};
$5012d21d933388c1$exports = {
  "Clear search": `Clear search`
};

// node_modules/@react-aria/searchfield/dist/es-ES.mjs
var $0159854399308e2e$exports = {};
$0159854399308e2e$exports = {
  "Clear search": `Borrar búsqueda`
};

// node_modules/@react-aria/searchfield/dist/et-EE.mjs
var $390613981d970276$exports = {};
$390613981d970276$exports = {
  "Clear search": `Tühjenda otsing`
};

// node_modules/@react-aria/searchfield/dist/fi-FI.mjs
var $961ae0833f811705$exports = {};
$961ae0833f811705$exports = {
  "Clear search": `Tyhjennä haku`
};

// node_modules/@react-aria/searchfield/dist/fr-FR.mjs
var $26d76742decfd829$exports = {};
$26d76742decfd829$exports = {
  "Clear search": `Effacer la recherche`
};

// node_modules/@react-aria/searchfield/dist/he-IL.mjs
var $92ef254c82a5c769$exports = {};
$92ef254c82a5c769$exports = {
  "Clear search": `נקה חיפוש`
};

// node_modules/@react-aria/searchfield/dist/hr-HR.mjs
var $e0321b43bdefb8b3$exports = {};
$e0321b43bdefb8b3$exports = {
  "Clear search": `Obriši pretragu`
};

// node_modules/@react-aria/searchfield/dist/hu-HU.mjs
var $0c1ee0b8d50940d9$exports = {};
$0c1ee0b8d50940d9$exports = {
  "Clear search": `Keresés törlése`
};

// node_modules/@react-aria/searchfield/dist/it-IT.mjs
var $b09198915a38946f$exports = {};
$b09198915a38946f$exports = {
  "Clear search": `Cancella ricerca`
};

// node_modules/@react-aria/searchfield/dist/ja-JP.mjs
var $3a9a3d180c3145c0$exports = {};
$3a9a3d180c3145c0$exports = {
  "Clear search": `検索をクリア`
};

// node_modules/@react-aria/searchfield/dist/ko-KR.mjs
var $b7a611726449f4a3$exports = {};
$b7a611726449f4a3$exports = {
  "Clear search": `검색 지우기`
};

// node_modules/@react-aria/searchfield/dist/lt-LT.mjs
var $d9a3d49db610dd5c$exports = {};
$d9a3d49db610dd5c$exports = {
  "Clear search": `Išvalyti iešką`
};

// node_modules/@react-aria/searchfield/dist/lv-LV.mjs
var $3ab64b73ea27c23a$exports = {};
$3ab64b73ea27c23a$exports = {
  "Clear search": `Notīrīt meklēšanu`
};

// node_modules/@react-aria/searchfield/dist/nb-NO.mjs
var $bf5cce1b47d23baf$exports = {};
$bf5cce1b47d23baf$exports = {
  "Clear search": `Tøm søk`
};

// node_modules/@react-aria/searchfield/dist/nl-NL.mjs
var $4e0c9a9a010e4598$exports = {};
$4e0c9a9a010e4598$exports = {
  "Clear search": `Zoekactie wissen`
};

// node_modules/@react-aria/searchfield/dist/pl-PL.mjs
var $63cf4a75ec270508$exports = {};
$63cf4a75ec270508$exports = {
  "Clear search": `Wyczyść zawartość wyszukiwania`
};

// node_modules/@react-aria/searchfield/dist/pt-BR.mjs
var $083b0cad27fdbd06$exports = {};
$083b0cad27fdbd06$exports = {
  "Clear search": `Limpar pesquisa`
};

// node_modules/@react-aria/searchfield/dist/pt-PT.mjs
var $1b7f0864d830ba6d$exports = {};
$1b7f0864d830ba6d$exports = {
  "Clear search": `Limpar pesquisa`
};

// node_modules/@react-aria/searchfield/dist/ro-RO.mjs
var $d6d2588377fc9718$exports = {};
$d6d2588377fc9718$exports = {
  "Clear search": `Ştergeţi căutarea`
};

// node_modules/@react-aria/searchfield/dist/ru-RU.mjs
var $701c918a4653e946$exports = {};
$701c918a4653e946$exports = {
  "Clear search": `Очистить поиск`
};

// node_modules/@react-aria/searchfield/dist/sk-SK.mjs
var $7cacc29a1e5f4fbe$exports = {};
$7cacc29a1e5f4fbe$exports = {
  "Clear search": `Vymazať vyhľadávanie`
};

// node_modules/@react-aria/searchfield/dist/sl-SI.mjs
var $c63231bcc300d0df$exports = {};
$c63231bcc300d0df$exports = {
  "Clear search": `Počisti iskanje`
};

// node_modules/@react-aria/searchfield/dist/sr-SP.mjs
var $b61510478bc0e6f6$exports = {};
$b61510478bc0e6f6$exports = {
  "Clear search": `Obriši pretragu`
};

// node_modules/@react-aria/searchfield/dist/sv-SE.mjs
var $ce325e6dd3f9c37a$exports = {};
$ce325e6dd3f9c37a$exports = {
  "Clear search": `Rensa sökning`
};

// node_modules/@react-aria/searchfield/dist/tr-TR.mjs
var $1f7e1cf2285af2b2$exports = {};
$1f7e1cf2285af2b2$exports = {
  "Clear search": `Aramayı temizle`
};

// node_modules/@react-aria/searchfield/dist/uk-UA.mjs
var $2d999353ca652e34$exports = {};
$2d999353ca652e34$exports = {
  "Clear search": `Очистити пошук`
};

// node_modules/@react-aria/searchfield/dist/zh-CN.mjs
var $117b536bfb1ae554$exports = {};
$117b536bfb1ae554$exports = {
  "Clear search": `清除搜索`
};

// node_modules/@react-aria/searchfield/dist/zh-TW.mjs
var $525f6fa4ac26e278$exports = {};
$525f6fa4ac26e278$exports = {
  "Clear search": `清除搜尋條件`
};

// node_modules/@react-aria/searchfield/dist/import.mjs
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
var $8112f8b883c0272d$exports = {};
$8112f8b883c0272d$exports = {
  "ar-AE": $03c9a1a10de12f06$exports,
  "bg-BG": $4da0c2ffa4ba4159$exports,
  "cs-CZ": $8c59fd0c2c96821b$exports,
  "da-DK": $0a371f9c1df8120f$exports,
  "de-DE": $67f4d0b0de9f8a52$exports,
  "el-GR": $72a312d948f0214b$exports,
  "en-US": $5012d21d933388c1$exports,
  "es-ES": $0159854399308e2e$exports,
  "et-EE": $390613981d970276$exports,
  "fi-FI": $961ae0833f811705$exports,
  "fr-FR": $26d76742decfd829$exports,
  "he-IL": $92ef254c82a5c769$exports,
  "hr-HR": $e0321b43bdefb8b3$exports,
  "hu-HU": $0c1ee0b8d50940d9$exports,
  "it-IT": $b09198915a38946f$exports,
  "ja-JP": $3a9a3d180c3145c0$exports,
  "ko-KR": $b7a611726449f4a3$exports,
  "lt-LT": $d9a3d49db610dd5c$exports,
  "lv-LV": $3ab64b73ea27c23a$exports,
  "nb-NO": $bf5cce1b47d23baf$exports,
  "nl-NL": $4e0c9a9a010e4598$exports,
  "pl-PL": $63cf4a75ec270508$exports,
  "pt-BR": $083b0cad27fdbd06$exports,
  "pt-PT": $1b7f0864d830ba6d$exports,
  "ro-RO": $d6d2588377fc9718$exports,
  "ru-RU": $701c918a4653e946$exports,
  "sk-SK": $7cacc29a1e5f4fbe$exports,
  "sl-SI": $c63231bcc300d0df$exports,
  "sr-SP": $b61510478bc0e6f6$exports,
  "sv-SE": $ce325e6dd3f9c37a$exports,
  "tr-TR": $1f7e1cf2285af2b2$exports,
  "uk-UA": $2d999353ca652e34$exports,
  "zh-CN": $117b536bfb1ae554$exports,
  "zh-TW": $525f6fa4ac26e278$exports
};
function $4d52238874b24f86$export$9bb30bbe003b82e0(props, state, inputRef) {
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault($8112f8b883c0272d$exports)), "@react-aria/searchfield");
  let { isDisabled, isReadOnly, onSubmit = () => {
  }, onClear, type: type2 = "search" } = props;
  let onKeyDown = (e2) => {
    const key = e2.key;
    if (key === "Enter")
      e2.preventDefault();
    if (isDisabled || isReadOnly)
      return;
    if (key === "Enter")
      onSubmit(state.value);
    if (key === "Escape") {
      if (state.value === "")
        e2.continuePropagation();
      else {
        state.setValue("");
        if (onClear)
          onClear();
      }
    }
  };
  let onClearButtonClick = () => {
    state.setValue("");
    if (onClear)
      onClear();
  };
  let onPressStart = () => {
    var _inputRef_current;
    (_inputRef_current = inputRef.current) === null || _inputRef_current === void 0 ? void 0 : _inputRef_current.focus();
  };
  let { labelProps, inputProps, descriptionProps, errorMessageProps, ...validation } = (0, $2d73ec29415bd339$export$712718f7aec83d5)({
    ...props,
    value: state.value,
    onChange: state.setValue,
    onKeyDown: !isReadOnly ? (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(onKeyDown, props.onKeyDown) : props.onKeyDown,
    type: type2
  }, inputRef);
  return {
    labelProps,
    inputProps: {
      ...inputProps,
      // already handled by useSearchFieldState
      defaultValue: void 0
    },
    clearButtonProps: {
      "aria-label": stringFormatter.format("Clear search"),
      excludeFromTabOrder: true,
      // @ts-ignore
      preventFocusOnPress: true,
      isDisabled: isDisabled || isReadOnly,
      onPress: onClearButtonClick,
      onPressStart
    },
    descriptionProps,
    errorMessageProps,
    ...validation
  };
}

// node_modules/@react-stately/searchfield/dist/import.mjs
function $0b2218c4e3fe7d7e$export$3f8be18b0f41eaf2(props) {
  let [value, setValue] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)($0b2218c4e3fe7d7e$var$toString(props.value), $0b2218c4e3fe7d7e$var$toString(props.defaultValue) || "", props.onChange);
  return {
    value,
    setValue
  };
}
function $0b2218c4e3fe7d7e$var$toString(val) {
  if (val == null)
    return;
  return val.toString();
}

// node_modules/@keystar/ui/dist/keystar-ui-search-field.js
var import_react = __toESM(require_react());
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
var SearchField = (0, import_react.forwardRef)(function SearchField2(props, forwardedRef) {
  const {
    autoFocus,
    description,
    errorMessage,
    id,
    isDisabled,
    isReadOnly,
    isRequired,
    label,
    showIcon = true,
    ...styleProps
  } = props;
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let state = $0b2218c4e3fe7d7e$export$3f8be18b0f41eaf2(props);
  let {
    labelProps,
    inputProps,
    clearButtonProps,
    descriptionProps,
    errorMessageProps
  } = $4d52238874b24f86$export$9bb30bbe003b82e0(props, state, domRef);
  let clearButtonVisible = state.value !== "" && !props.isReadOnly;
  let clearButton = (0, import_jsx_runtime9.jsx)(ClearButton, {
    ...clearButtonProps,
    preventFocus: true,
    isDisabled
  });
  let startElement = (0, import_jsx_runtime9.jsx)(Flex, {
    alignItems: "center",
    flexShrink: 0,
    justifyContent: "center",
    pointerEvents: "none",
    width: "element.regular",
    children: (0, import_jsx_runtime9.jsx)(Icon, {
      src: searchIcon,
      color: props.isDisabled ? "color.alias.foregroundDisabled" : "neutralSecondary"
    })
  });
  return (0, import_jsx_runtime9.jsx)(TextFieldPrimitive, {
    ref: domRef,
    ...styleProps,
    isDisabled,
    isReadOnly,
    isRequired,
    label,
    labelProps,
    inputProps,
    inputWrapperProps: {
      className: css({
        input: {
          '&[data-adornment="start"]': {
            paddingInlineStart: 0
          },
          '&[data-adornment="end"]': {
            paddingInlineEnd: 0
          },
          '&[data-adornment="both"]': {
            paddingInline: 0
          }
        }
      })
    },
    description,
    descriptionProps,
    errorMessage,
    errorMessageProps,
    startElement: showIcon && startElement,
    endElement: clearButtonVisible && clearButton
  });
});

// node_modules/@react-stately/table/dist/import.mjs
var import_react3 = __toESM(require_react(), 1);

// node_modules/@react-stately/grid/dist/import.mjs
var import_react2 = __toESM(require_react(), 1);
function $62967d126f3aa823$export$4007ac09ff9c68ed(props) {
  let { collection, focusMode } = props;
  let selectionState = (0, $7af3f5b51489e0b5$export$253fe78d46329472)(props);
  let disabledKeys = (0, import_react2.useMemo)(() => props.disabledKeys ? new Set(props.disabledKeys) : /* @__PURE__ */ new Set(), [
    props.disabledKeys
  ]);
  let setFocusedKey = selectionState.setFocusedKey;
  selectionState.setFocusedKey = (key, child) => {
    if (focusMode === "cell" && key != null) {
      let item = collection.getItem(key);
      if ((item === null || item === void 0 ? void 0 : item.type) === "item") {
        var _getLastItem, _getFirstItem;
        let children = (0, $c5a24bc478652b5f$export$1005530eda016c13)(item, collection);
        if (child === "last")
          key = (_getLastItem = (0, $c5a24bc478652b5f$export$7475b2c64539e4cf)(children)) === null || _getLastItem === void 0 ? void 0 : _getLastItem.key;
        else
          key = (_getFirstItem = (0, $c5a24bc478652b5f$export$fbdeaa6a76694f71)(children)) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key;
      }
    }
    setFocusedKey(key, child);
  };
  let selectionManager = (0, import_react2.useMemo)(() => new (0, $d496c0a20b6e58ec$export$6c8a5aaad13c9852)(collection, selectionState), [
    collection,
    selectionState
  ]);
  const cachedCollection = (0, import_react2.useRef)(null);
  (0, import_react2.useEffect)(() => {
    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {
      const node = cachedCollection.current.getItem(selectionState.focusedKey);
      const parentNode = node.parentKey != null && (node.type === "cell" || node.type === "rowheader" || node.type === "column") ? cachedCollection.current.getItem(node.parentKey) : node;
      const cachedRows = cachedCollection.current.rows;
      const rows = collection.rows;
      const diff = cachedRows.length - rows.length;
      let index = Math.min(diff > 1 ? Math.max(parentNode.index - diff + 1, 0) : parentNode.index, rows.length - 1);
      let newRow;
      while (index >= 0) {
        if (!selectionManager.isDisabled(rows[index].key) && rows[index].type !== "headerrow") {
          newRow = rows[index];
          break;
        }
        if (index < rows.length - 1)
          index++;
        else {
          if (index > parentNode.index)
            index = parentNode.index;
          index--;
        }
      }
      if (newRow) {
        const childNodes = newRow.hasChildNodes ? [
          ...(0, $c5a24bc478652b5f$export$1005530eda016c13)(newRow, collection)
        ] : [];
        const keyToFocus = newRow.hasChildNodes && parentNode !== node && node.index < childNodes.length ? childNodes[node.index].key : newRow.key;
        selectionState.setFocusedKey(keyToFocus);
      } else
        selectionState.setFocusedKey(null);
    }
    cachedCollection.current = collection;
  }, [
    collection,
    selectionManager,
    selectionState,
    selectionState.focusedKey
  ]);
  return {
    collection,
    disabledKeys,
    isKeyboardNavigationDisabled: false,
    selectionManager
  };
}
var $16805b1b18093c5f$export$de3fdf6493c353d = class {
  *[Symbol.iterator]() {
    yield* [
      ...this.rows
    ];
  }
  get size() {
    return [
      ...this.rows
    ].length;
  }
  getKeys() {
    return this.keyMap.keys();
  }
  getKeyBefore(key) {
    let node = this.keyMap.get(key);
    return node ? node.prevKey : null;
  }
  getKeyAfter(key) {
    let node = this.keyMap.get(key);
    return node ? node.nextKey : null;
  }
  getFirstKey() {
    var _2;
    return (_2 = [
      ...this.rows
    ][0]) === null || _2 === void 0 ? void 0 : _2.key;
  }
  getLastKey() {
    var _rows_;
    let rows = [
      ...this.rows
    ];
    return (_rows_ = rows[rows.length - 1]) === null || _rows_ === void 0 ? void 0 : _rows_.key;
  }
  getItem(key) {
    return this.keyMap.get(key);
  }
  at(idx) {
    const keys = [
      ...this.getKeys()
    ];
    return this.getItem(keys[idx]);
  }
  getChildren(key) {
    let node = this.keyMap.get(key);
    return (node === null || node === void 0 ? void 0 : node.childNodes) || [];
  }
  constructor(opts) {
    this.keyMap = /* @__PURE__ */ new Map();
    this.keyMap = /* @__PURE__ */ new Map();
    this.columnCount = opts === null || opts === void 0 ? void 0 : opts.columnCount;
    this.rows = [];
    let visit = (node) => {
      let prevNode = this.keyMap.get(node.key);
      if (opts.visitNode)
        node = opts.visitNode(node);
      this.keyMap.set(node.key, node);
      let childKeys = /* @__PURE__ */ new Set();
      let last2;
      for (let child of node.childNodes) {
        if (child.type === "cell" && child.parentKey == null)
          child.parentKey = node.key;
        childKeys.add(child.key);
        if (last2) {
          last2.nextKey = child.key;
          child.prevKey = last2.key;
        } else
          child.prevKey = null;
        visit(child);
        last2 = child;
      }
      if (last2)
        last2.nextKey = null;
      if (prevNode) {
        for (let child of prevNode.childNodes)
          if (!childKeys.has(child.key))
            remove(child);
      }
    };
    let remove = (node) => {
      this.keyMap.delete(node.key);
      for (let child of node.childNodes)
        if (this.keyMap.get(child.key) === child)
          remove(child);
    };
    let last;
    opts.items.forEach((node, i) => {
      let rowNode = {
        level: 0,
        key: "row-" + i,
        type: "row",
        value: void 0,
        hasChildNodes: true,
        childNodes: [
          ...node.childNodes
        ],
        rendered: void 0,
        textValue: void 0,
        ...node
      };
      if (last) {
        last.nextKey = rowNode.key;
        rowNode.prevKey = last.key;
      } else
        rowNode.prevKey = null;
      this.rows.push(rowNode);
      visit(rowNode);
      last = rowNode;
    });
    if (last)
      last.nextKey = null;
  }
};

// node_modules/@react-stately/flags/dist/import.mjs
var $f4e2df6bd15f8569$var$_tableNestedRows = false;
function $f4e2df6bd15f8569$export$1b00cb14a96194e6() {
  return $f4e2df6bd15f8569$var$_tableNestedRows;
}

// node_modules/@react-stately/table/dist/import.mjs
function $6818b1c4fc67028d$export$1994a077b98ee0d5(width) {
  return width != null && (!isNaN(width) || String(width).match(/^(\d+)(?=%$)/) !== null);
}
function $6818b1c4fc67028d$export$9078bad4c3934604(width) {
  if (!width)
    return 1;
  let match = width.match(/^(.+)(?=fr$)/);
  if (!match) {
    console.warn(`width: ${width} is not a supported format, width should be a number (ex. 150), percentage (ex. '50%') or fr unit (ex. '2fr')`, "defaulting to '1fr'");
    return 1;
  }
  return parseFloat(match[0]);
}
function $6818b1c4fc67028d$export$7bbad27896f7ae9f(width, tableWidth) {
  if (typeof width === "string") {
    let match = width.match(/^(\d+)(?=%$)/);
    if (!match)
      throw new Error("Only percentages or numbers are supported for static column widths");
    return tableWidth * (parseFloat(match[0]) / 100);
  }
  return width;
}
function $6818b1c4fc67028d$export$59185c62a7544aa0(maxWidth, tableWidth) {
  return maxWidth != null ? $6818b1c4fc67028d$export$7bbad27896f7ae9f(maxWidth, tableWidth) : Number.MAX_SAFE_INTEGER;
}
function $6818b1c4fc67028d$export$f556054ce4358701(minWidth, tableWidth) {
  return minWidth != null ? $6818b1c4fc67028d$export$7bbad27896f7ae9f(minWidth, tableWidth) : 0;
}
function $6818b1c4fc67028d$export$55d50dc687385491(availableWidth, columns, changedColumns, getDefaultWidth, getDefaultMinWidth) {
  let hasNonFrozenItems = false;
  let flexItems = columns.map((column, index) => {
    var _column_width, _ref, _ref1;
    let width = changedColumns.get(column.key) != null ? changedColumns.get(column.key) : (_ref1 = (_ref = (_column_width = column.width) !== null && _column_width !== void 0 ? _column_width : column.defaultWidth) !== null && _ref !== void 0 ? _ref : getDefaultWidth === null || getDefaultWidth === void 0 ? void 0 : getDefaultWidth(index)) !== null && _ref1 !== void 0 ? _ref1 : "1fr";
    let frozen = false;
    let baseSize = 0;
    let flex = 0;
    let targetMainSize = null;
    if ($6818b1c4fc67028d$export$1994a077b98ee0d5(width)) {
      baseSize = $6818b1c4fc67028d$export$7bbad27896f7ae9f(width, availableWidth);
      frozen = true;
    } else {
      flex = $6818b1c4fc67028d$export$9078bad4c3934604(width);
      if (flex <= 0)
        frozen = true;
    }
    var _column_minWidth, _ref2;
    let min = $6818b1c4fc67028d$export$f556054ce4358701((_ref2 = (_column_minWidth = column.minWidth) !== null && _column_minWidth !== void 0 ? _column_minWidth : getDefaultMinWidth === null || getDefaultMinWidth === void 0 ? void 0 : getDefaultMinWidth(index)) !== null && _ref2 !== void 0 ? _ref2 : 0, availableWidth);
    let max = $6818b1c4fc67028d$export$59185c62a7544aa0(column.maxWidth, availableWidth);
    let hypotheticalMainSize = Math.max(min, Math.min(baseSize, max));
    if (frozen)
      targetMainSize = hypotheticalMainSize;
    else if (baseSize > hypotheticalMainSize) {
      frozen = true;
      targetMainSize = hypotheticalMainSize;
    }
    if (!frozen)
      hasNonFrozenItems = true;
    return {
      frozen,
      baseSize,
      hypotheticalMainSize,
      min,
      max,
      flex,
      targetMainSize,
      violation: 0
    };
  });
  while (hasNonFrozenItems) {
    let usedWidth = 0;
    let flexFactors = 0;
    flexItems.forEach((item) => {
      if (item.frozen)
        usedWidth += item.targetMainSize;
      else {
        usedWidth += item.baseSize;
        flexFactors += item.flex;
      }
    });
    let remainingFreeSpace = availableWidth - usedWidth;
    if (remainingFreeSpace > 0)
      flexItems.forEach((item) => {
        if (!item.frozen) {
          let ratio = item.flex / flexFactors;
          item.targetMainSize = item.baseSize + ratio * remainingFreeSpace;
        }
      });
    let totalViolation = 0;
    flexItems.forEach((item) => {
      item.violation = 0;
      if (!item.frozen) {
        let { min, max, targetMainSize } = item;
        item.targetMainSize = Math.max(min, Math.min(targetMainSize, max));
        item.violation = item.targetMainSize - targetMainSize;
        totalViolation += item.violation;
      }
    });
    hasNonFrozenItems = false;
    flexItems.forEach((item) => {
      if (totalViolation === 0 || Math.sign(totalViolation) === Math.sign(item.violation))
        item.frozen = true;
      else if (!item.frozen)
        hasNonFrozenItems = true;
    });
  }
  return $6818b1c4fc67028d$var$cascadeRounding(flexItems);
}
function $6818b1c4fc67028d$var$cascadeRounding(flexItems) {
  let fpTotal = 0;
  let intTotal = 0;
  let roundedArray = [];
  flexItems.forEach(function(item) {
    let float2 = item.targetMainSize;
    let integer = Math.round(float2 + fpTotal) - intTotal;
    fpTotal += float2;
    intTotal += integer;
    roundedArray.push(integer);
  });
  return roundedArray;
}
var $a9e7ae544a4e41dd$export$7ff77a162970b30e = class {
  /** Takes an array of columns and splits it into 2 maps of columns with controlled and columns with uncontrolled widths. */
  splitColumnsIntoControlledAndUncontrolled(columns) {
    return columns.reduce((acc, col) => {
      if (col.props.width != null)
        acc[0].set(col.key, col);
      else
        acc[1].set(col.key, col);
      return acc;
    }, [
      /* @__PURE__ */ new Map(),
      /* @__PURE__ */ new Map()
    ]);
  }
  /** Takes uncontrolled and controlled widths and joins them into a single Map. */
  recombineColumns(columns, uncontrolledWidths, uncontrolledColumns, controlledColumns) {
    return new Map(columns.map((col) => {
      if (uncontrolledColumns.has(col.key))
        return [
          col.key,
          uncontrolledWidths.get(col.key)
        ];
      else
        return [
          col.key,
          controlledColumns.get(col.key).props.width
        ];
    }));
  }
  /** Used to make an initial Map of the uncontrolled widths based on default widths. */
  getInitialUncontrolledWidths(uncontrolledColumns) {
    return new Map(Array.from(uncontrolledColumns).map(([key, col]) => {
      var _this_getDefaultWidth, _this;
      var _col_props_defaultWidth, _ref;
      return [
        key,
        (_ref = (_col_props_defaultWidth = col.props.defaultWidth) !== null && _col_props_defaultWidth !== void 0 ? _col_props_defaultWidth : (_this_getDefaultWidth = (_this = this).getDefaultWidth) === null || _this_getDefaultWidth === void 0 ? void 0 : _this_getDefaultWidth.call(_this, col)) !== null && _ref !== void 0 ? _ref : "1fr"
      ];
    }));
  }
  getColumnWidth(key) {
    var _this_columnWidths_get;
    return (_this_columnWidths_get = this.columnWidths.get(key)) !== null && _this_columnWidths_get !== void 0 ? _this_columnWidths_get : 0;
  }
  getColumnMinWidth(key) {
    var _this_columnMinWidths_get;
    return (_this_columnMinWidths_get = this.columnMinWidths.get(key)) !== null && _this_columnMinWidths_get !== void 0 ? _this_columnMinWidths_get : 0;
  }
  getColumnMaxWidth(key) {
    var _this_columnMaxWidths_get;
    return (_this_columnMaxWidths_get = this.columnMaxWidths.get(key)) !== null && _this_columnMaxWidths_get !== void 0 ? _this_columnMaxWidths_get : 0;
  }
  resizeColumnWidth(tableWidth, collection, controlledWidths, uncontrolledWidths, col = null, width) {
    let prevColumnWidths = this.columnWidths;
    let resizeIndex = Infinity;
    let resizingChanged = new Map([
      ...controlledWidths,
      ...uncontrolledWidths
    ]);
    let percentKeys = /* @__PURE__ */ new Map();
    let frKeysToTheRight = /* @__PURE__ */ new Map();
    let minWidths = /* @__PURE__ */ new Map();
    collection.columns.forEach((column, i) => {
      var _column_props_width_endsWith, _column_props_width;
      let frKey;
      let frValue;
      minWidths.set(column.key, this.getDefaultMinWidth(collection.columns[i]));
      if (col !== column.key && !column.props.width && !(0, $6818b1c4fc67028d$export$1994a077b98ee0d5)(uncontrolledWidths.get(column.key))) {
        frKey = column.key;
        frValue = (0, $6818b1c4fc67028d$export$9078bad4c3934604)(uncontrolledWidths.get(column.key));
      } else if (col !== column.key && !(0, $6818b1c4fc67028d$export$1994a077b98ee0d5)(column.props.width) && !uncontrolledWidths.get(column.key)) {
        frKey = column.key;
        frValue = (0, $6818b1c4fc67028d$export$9078bad4c3934604)(column.props.width);
      } else if (col !== column.key && ((_column_props_width = column.props.width) === null || _column_props_width === void 0 ? void 0 : (_column_props_width_endsWith = _column_props_width.endsWith) === null || _column_props_width_endsWith === void 0 ? void 0 : _column_props_width_endsWith.call(_column_props_width, "%")))
        percentKeys.set(column.key, column.props.width);
      if (resizeIndex < i) {
        if (frKey)
          frKeysToTheRight.set(frKey, frValue);
        return;
      }
      if (column.key === col) {
        resizeIndex = i;
        resizingChanged.set(column.key, Math.floor(width));
        return;
      }
      resizingChanged.set(column.key, prevColumnWidths.get(column.key));
    });
    let columnWidths = (0, $6818b1c4fc67028d$export$55d50dc687385491)(tableWidth, collection.columns.map((col2) => ({
      ...col2.props,
      key: col2.key
    })), resizingChanged, (i) => this.getDefaultWidth(collection.columns[i]), (i) => this.getDefaultMinWidth(collection.columns[i]));
    let newWidths = /* @__PURE__ */ new Map();
    columnWidths.forEach((width2, index) => {
      let key = collection.columns[index].key;
      newWidths.set(key, width2);
    });
    Array.from(frKeysToTheRight).forEach(([key]) => {
      newWidths.set(key, `${frKeysToTheRight.get(key)}fr`);
    });
    Array.from(percentKeys).forEach(([key, width2]) => {
      if (key === col)
        return;
      newWidths.set(key, width2);
    });
    return newWidths;
  }
  buildColumnWidths(tableWidth, collection, widths) {
    this.columnWidths = /* @__PURE__ */ new Map();
    this.columnMinWidths = /* @__PURE__ */ new Map();
    this.columnMaxWidths = /* @__PURE__ */ new Map();
    let columnWidths = (0, $6818b1c4fc67028d$export$55d50dc687385491)(tableWidth, collection.columns.map((col) => ({
      ...col.props,
      key: col.key
    })), widths, (i) => this.getDefaultWidth(collection.columns[i]), (i) => this.getDefaultMinWidth(collection.columns[i]));
    columnWidths.forEach((width, index) => {
      let key = collection.columns[index].key;
      let column = collection.columns[index];
      this.columnWidths.set(key, width);
      var _column_props_minWidth;
      this.columnMinWidths.set(key, (0, $6818b1c4fc67028d$export$f556054ce4358701)((_column_props_minWidth = column.props.minWidth) !== null && _column_props_minWidth !== void 0 ? _column_props_minWidth : this.getDefaultMinWidth(column), tableWidth));
      this.columnMaxWidths.set(key, (0, $6818b1c4fc67028d$export$59185c62a7544aa0)(column.props.maxWidth, tableWidth));
    });
    return this.columnWidths;
  }
  constructor(options) {
    this.columnWidths = /* @__PURE__ */ new Map();
    this.columnMinWidths = /* @__PURE__ */ new Map();
    this.columnMaxWidths = /* @__PURE__ */ new Map();
    var _options_getDefaultWidth;
    this.getDefaultWidth = (_options_getDefaultWidth = options === null || options === void 0 ? void 0 : options.getDefaultWidth) !== null && _options_getDefaultWidth !== void 0 ? _options_getDefaultWidth : () => "1fr";
    var _options_getDefaultMinWidth;
    this.getDefaultMinWidth = (_options_getDefaultMinWidth = options === null || options === void 0 ? void 0 : options.getDefaultMinWidth) !== null && _options_getDefaultMinWidth !== void 0 ? _options_getDefaultMinWidth : () => 75;
  }
};
var $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY = "row-header-column-" + Math.random().toString(36).slice(2);
var $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG = "row-header-column-" + Math.random().toString(36).slice(2);
while ($788781baa30117fa$var$ROW_HEADER_COLUMN_KEY === $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG)
  $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG = "row-header-column-" + Math.random().toString(36).slice(2);
function $788781baa30117fa$export$7c127db850d4e81e(keyMap, columnNodes) {
  if (columnNodes.length === 0)
    return [];
  let columns = [];
  let seen = /* @__PURE__ */ new Map();
  for (let column of columnNodes) {
    let parentKey = column.parentKey;
    let col = [
      column
    ];
    while (parentKey) {
      let parent = keyMap.get(parentKey);
      if (!parent)
        break;
      if (seen.has(parent)) {
        parent.colspan++;
        let { column: column2, index } = seen.get(parent);
        if (index > col.length)
          break;
        for (let i2 = index; i2 < col.length; i2++)
          column2.splice(i2, 0, null);
        for (let i2 = col.length; i2 < column2.length; i2++)
          if (column2[i2] && seen.has(column2[i2]))
            seen.get(column2[i2]).index = i2;
      } else {
        parent.colspan = 1;
        col.push(parent);
        seen.set(parent, {
          column: col,
          index: col.length - 1
        });
      }
      parentKey = parent.parentKey;
    }
    columns.push(col);
    column.index = columns.length - 1;
  }
  let maxLength = Math.max(...columns.map((c) => c.length));
  let headerRows = Array(maxLength).fill(0).map(() => []);
  let colIndex = 0;
  for (let column of columns) {
    let i2 = maxLength - 1;
    for (let item of column) {
      if (item) {
        let row = headerRows[i2];
        let rowLength = row.reduce((p2, c) => p2 + c.colspan, 0);
        if (rowLength < colIndex) {
          let placeholder = {
            type: "placeholder",
            key: "placeholder-" + item.key,
            colspan: colIndex - rowLength,
            index: rowLength,
            value: null,
            rendered: null,
            level: i2,
            hasChildNodes: false,
            childNodes: [],
            textValue: null
          };
          if (row.length > 0) {
            row[row.length - 1].nextKey = placeholder.key;
            placeholder.prevKey = row[row.length - 1].key;
          }
          row.push(placeholder);
        }
        if (row.length > 0) {
          row[row.length - 1].nextKey = item.key;
          item.prevKey = row[row.length - 1].key;
        }
        item.level = i2;
        item.colIndex = colIndex;
        row.push(item);
      }
      i2--;
    }
    colIndex++;
  }
  let i = 0;
  for (let row of headerRows) {
    let rowLength = row.reduce((p2, c) => p2 + c.colspan, 0);
    if (rowLength < columnNodes.length) {
      let placeholder = {
        type: "placeholder",
        key: "placeholder-" + row[row.length - 1].key,
        colspan: columnNodes.length - rowLength,
        index: rowLength,
        value: null,
        rendered: null,
        level: i,
        hasChildNodes: false,
        childNodes: [],
        textValue: null,
        prevKey: row[row.length - 1].key
      };
      row.push(placeholder);
    }
    i++;
  }
  return headerRows.map((childNodes, index) => {
    let row = {
      type: "headerrow",
      key: "headerrow-" + index,
      index,
      value: null,
      rendered: null,
      level: 0,
      hasChildNodes: true,
      childNodes,
      textValue: null
    };
    return row;
  });
}
var $788781baa30117fa$export$596e1b2e2cf93690 = class extends (0, $16805b1b18093c5f$export$de3fdf6493c353d) {
  *[Symbol.iterator]() {
    yield* this.body.childNodes;
  }
  get size() {
    return this._size;
  }
  getKeys() {
    return this.keyMap.keys();
  }
  getKeyBefore(key) {
    let node = this.keyMap.get(key);
    return node ? node.prevKey : null;
  }
  getKeyAfter(key) {
    let node = this.keyMap.get(key);
    return node ? node.nextKey : null;
  }
  getFirstKey() {
    var _getFirstItem;
    return (_getFirstItem = (0, $c5a24bc478652b5f$export$fbdeaa6a76694f71)(this.body.childNodes)) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key;
  }
  getLastKey() {
    var _getLastItem;
    return (_getLastItem = (0, $c5a24bc478652b5f$export$7475b2c64539e4cf)(this.body.childNodes)) === null || _getLastItem === void 0 ? void 0 : _getLastItem.key;
  }
  getItem(key) {
    return this.keyMap.get(key);
  }
  at(idx) {
    const keys = [
      ...this.getKeys()
    ];
    return this.getItem(keys[idx]);
  }
  getTextValue(key) {
    let row = this.getItem(key);
    if (!row)
      return "";
    if (row.textValue)
      return row.textValue;
    let rowHeaderColumnKeys = this.rowHeaderColumnKeys;
    if (rowHeaderColumnKeys) {
      let text = [];
      for (let cell of row.childNodes) {
        let column = this.columns[cell.index];
        if (rowHeaderColumnKeys.has(column.key) && cell.textValue)
          text.push(cell.textValue);
        if (text.length === rowHeaderColumnKeys.size)
          break;
      }
      return text.join(" ");
    }
    return "";
  }
  constructor(nodes, prev, opts) {
    let rowHeaderColumnKeys = /* @__PURE__ */ new Set();
    let body;
    let columns = [];
    if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) {
      let rowHeaderColumn = {
        type: "column",
        key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY,
        value: null,
        textValue: "",
        level: 0,
        index: (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) ? 1 : 0,
        hasChildNodes: false,
        rendered: null,
        childNodes: [],
        props: {
          isSelectionCell: true
        }
      };
      columns.unshift(rowHeaderColumn);
    }
    if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) {
      let rowHeaderColumn = {
        type: "column",
        key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG,
        value: null,
        textValue: "",
        level: 0,
        index: 0,
        hasChildNodes: false,
        rendered: null,
        childNodes: [],
        props: {
          isDragButtonCell: true
        }
      };
      columns.unshift(rowHeaderColumn);
    }
    let rows = [];
    let columnKeyMap = /* @__PURE__ */ new Map();
    let visit = (node) => {
      switch (node.type) {
        case "body":
          body = node;
          break;
        case "column":
          columnKeyMap.set(node.key, node);
          if (!node.hasChildNodes) {
            columns.push(node);
            if (node.props.isRowHeader)
              rowHeaderColumnKeys.add(node.key);
          }
          break;
        case "item":
          rows.push(node);
          return;
      }
      for (let child of node.childNodes)
        visit(child);
    };
    for (let node of nodes)
      visit(node);
    let headerRows = $788781baa30117fa$export$7c127db850d4e81e(columnKeyMap, columns);
    headerRows.forEach((row, i) => rows.splice(i, 0, row));
    super({
      columnCount: columns.length,
      items: rows,
      visitNode: (node) => {
        node.column = columns[node.index];
        return node;
      }
    });
    this._size = 0;
    this.columns = columns;
    this.rowHeaderColumnKeys = rowHeaderColumnKeys;
    this.body = body;
    this.headerRows = headerRows;
    this._size = [
      ...body.childNodes
    ].length;
    if (this.rowHeaderColumnKeys.size === 0)
      this.rowHeaderColumnKeys.add(this.columns.find((column) => {
        var _column_props, _column_props1;
        return !((_column_props = column.props) === null || _column_props === void 0 ? void 0 : _column_props.isDragButtonCell) && !((_column_props1 = column.props) === null || _column_props1 === void 0 ? void 0 : _column_props1.isSelectionCell);
      }).key);
  }
};
var $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION = {
  ascending: "descending",
  descending: "ascending"
};
function $4a0dd036d492cee4$export$907bcc6c48325fd6(props) {
  let [isKeyboardNavigationDisabled, setKeyboardNavigationDisabled] = (0, import_react3.useState)(false);
  let { selectionMode = "none", showSelectionCheckboxes, showDragButtons } = props;
  let context = (0, import_react3.useMemo)(() => ({
    showSelectionCheckboxes: showSelectionCheckboxes && selectionMode !== "none",
    showDragButtons,
    selectionMode,
    columns: []
  }), [
    props.children,
    showSelectionCheckboxes,
    selectionMode,
    showDragButtons
  ]);
  let collection = (0, $7613b1592d41b092$export$6cd28814d92fa9c9)(props, (0, import_react3.useCallback)((nodes) => new (0, $788781baa30117fa$export$596e1b2e2cf93690)(nodes, null, context), [
    context
  ]), context);
  let { disabledKeys, selectionManager } = (0, $62967d126f3aa823$export$4007ac09ff9c68ed)({
    ...props,
    collection,
    disabledBehavior: props.disabledBehavior || "selection"
  });
  return {
    collection,
    disabledKeys,
    selectionManager,
    showSelectionCheckboxes: props.showSelectionCheckboxes || false,
    sortDescriptor: props.sortDescriptor,
    isKeyboardNavigationDisabled: collection.size === 0 || isKeyboardNavigationDisabled,
    setKeyboardNavigationDisabled,
    sort(columnKey, direction) {
      var _props_sortDescriptor;
      props.onSortChange({
        column: columnKey,
        direction: direction !== null && direction !== void 0 ? direction : ((_props_sortDescriptor = props.sortDescriptor) === null || _props_sortDescriptor === void 0 ? void 0 : _props_sortDescriptor.column) === columnKey ? $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION[props.sortDescriptor.direction] : "ascending"
      });
    }
  };
}
function $312ae3b56a94a86e$var$TableHeader(props) {
  return null;
}
$312ae3b56a94a86e$var$TableHeader.getCollectionNode = function* getCollectionNode(props, context) {
  let { children, columns } = props;
  context.columns = [];
  if (typeof children === "function") {
    if (!columns)
      throw new Error("props.children was a function but props.columns is missing");
    for (let column of columns)
      yield {
        type: "column",
        value: column,
        renderer: children
      };
  } else {
    let columns2 = [];
    (0, import_react3.default).Children.forEach(children, (column) => {
      columns2.push({
        type: "column",
        element: column
      });
    });
    yield* columns2;
  }
};
var $312ae3b56a94a86e$export$f850895b287ef28e = $312ae3b56a94a86e$var$TableHeader;
function $4ae5314bf50db1a3$var$TableBody(props) {
  return null;
}
$4ae5314bf50db1a3$var$TableBody.getCollectionNode = function* getCollectionNode2(props) {
  let { children, items } = props;
  yield {
    type: "body",
    hasChildNodes: true,
    props,
    *childNodes() {
      if (typeof children === "function") {
        if (!items)
          throw new Error("props.children was a function but props.items is missing");
        for (let item of items)
          yield {
            type: "item",
            value: item,
            renderer: children
          };
      } else {
        let items2 = [];
        (0, import_react3.default).Children.forEach(children, (item) => {
          items2.push({
            type: "item",
            element: item
          });
        });
        yield* items2;
      }
    }
  };
};
var $4ae5314bf50db1a3$export$76ccd210b9029917 = $4ae5314bf50db1a3$var$TableBody;
function $1cd244557c2f97d5$var$Column(props) {
  return null;
}
$1cd244557c2f97d5$var$Column.getCollectionNode = function* getCollectionNode3(props, context) {
  let { title, children, childColumns } = props;
  let rendered = title || children;
  let textValue = props.textValue || (typeof rendered === "string" ? rendered : "") || props["aria-label"];
  let fullNodes = yield {
    type: "column",
    hasChildNodes: !!childColumns || title && (0, import_react3.default).Children.count(children) > 0,
    rendered,
    textValue,
    props,
    *childNodes() {
      if (childColumns)
        for (let child of childColumns)
          yield {
            type: "column",
            value: child
          };
      else if (title) {
        let childColumns2 = [];
        (0, import_react3.default).Children.forEach(children, (child) => {
          childColumns2.push({
            type: "column",
            element: child
          });
        });
        yield* childColumns2;
      }
    },
    shouldInvalidate(newContext) {
      updateContext2(newContext);
      return false;
    }
  };
  let updateContext2 = (context2) => {
    for (let node of fullNodes)
      if (!node.hasChildNodes)
        context2.columns.push(node);
  };
  updateContext2(context);
};
var $1cd244557c2f97d5$export$816b5d811295e6bc = $1cd244557c2f97d5$var$Column;
function $70d70eb16ea48428$var$Row(props) {
  return null;
}
$70d70eb16ea48428$var$Row.getCollectionNode = function* getCollectionNode4(props, context) {
  let { children, textValue, UNSTABLE_childItems } = props;
  yield {
    type: "item",
    props,
    textValue,
    "aria-label": props["aria-label"],
    hasChildNodes: true,
    *childNodes() {
      if (context.showDragButtons)
        yield {
          type: "cell",
          key: "header-drag",
          props: {
            isDragButtonCell: true
          }
        };
      if (context.showSelectionCheckboxes && context.selectionMode !== "none")
        yield {
          type: "cell",
          key: "header",
          props: {
            isSelectionCell: true
          }
        };
      if (typeof children === "function") {
        for (let column of context.columns)
          yield {
            type: "cell",
            element: children(column.key),
            key: column.key
            // this is combined with the row key by CollectionBuilder
          };
        if (UNSTABLE_childItems)
          for (let child of UNSTABLE_childItems)
            yield {
              type: "item",
              value: child
            };
      } else {
        let cells = [];
        let childRows = [];
        (0, import_react3.default).Children.forEach(children, (node) => {
          if (node.type === $70d70eb16ea48428$var$Row) {
            if (cells.length < context.columns.length)
              throw new Error("All of a Row's child Cells must be positioned before any child Rows.");
            childRows.push({
              type: "item",
              element: node
            });
          } else
            cells.push({
              type: "cell",
              element: node
            });
        });
        if (cells.length !== context.columns.length)
          throw new Error(`Cell count must match column count. Found ${cells.length} cells and ${context.columns.length} columns.`);
        yield* cells;
        yield* childRows;
      }
    },
    shouldInvalidate(newContext) {
      return newContext.columns.length !== context.columns.length || newContext.columns.some((c, i) => c.key !== context.columns[i].key) || newContext.showSelectionCheckboxes !== context.showSelectionCheckboxes || newContext.showDragButtons !== context.showDragButtons || newContext.selectionMode !== context.selectionMode;
    }
  };
};
var $70d70eb16ea48428$export$b59bdbef9ce70de2 = $70d70eb16ea48428$var$Row;
function $941d1d9a6a28982a$var$Cell(props) {
  return null;
}
$941d1d9a6a28982a$var$Cell.getCollectionNode = function* getCollectionNode5(props) {
  let { children } = props;
  let textValue = props.textValue || (typeof children === "string" ? children : "") || props["aria-label"] || "";
  yield {
    type: "cell",
    props,
    rendered: children,
    textValue,
    "aria-label": props["aria-label"],
    hasChildNodes: false
  };
};
var $941d1d9a6a28982a$export$f6f0c3fe4ec306ea = $941d1d9a6a28982a$var$Cell;

// node_modules/@keystar/ui/dist/keystar-ui-table.js
var import_react5 = __toESM(require_react());

// node_modules/@react-aria/table/dist/ar-AE.mjs
var $ce3de3ff2fd66848$exports = {};
$ce3de3ff2fd66848$exports = {
  "ascending": `تصاعدي`,
  "ascendingSort": (args) => `ترتيب حسب العمود ${args.columnName} بترتيب تصاعدي`,
  "columnSize": (args) => `${args.value} بالبكسل`,
  "descending": `تنازلي`,
  "descendingSort": (args) => `ترتيب حسب العمود ${args.columnName} بترتيب تنازلي`,
  "resizerDescription": `اضغط على مفتاح Enter لبدء تغيير الحجم`,
  "select": `تحديد`,
  "selectAll": `تحديد الكل`,
  "sortable": `عمود قابل للترتيب`
};

// node_modules/@react-aria/table/dist/bg-BG.mjs
var $cb80dcce530985b9$exports = {};
$cb80dcce530985b9$exports = {
  "ascending": `възходящ`,
  "ascendingSort": (args) => `сортирано по колона ${args.columnName} във възходящ ред`,
  "columnSize": (args) => `${args.value} пиксела`,
  "descending": `низходящ`,
  "descendingSort": (args) => `сортирано по колона ${args.columnName} в низходящ ред`,
  "resizerDescription": `Натиснете „Enter“, за да започнете да преоразмерявате`,
  "select": `Изберете`,
  "selectAll": `Изберете всичко`,
  "sortable": `сортираща колона`
};

// node_modules/@react-aria/table/dist/cs-CZ.mjs
var $68ac86749db4c0fb$exports = {};
$68ac86749db4c0fb$exports = {
  "ascending": `vzestupně`,
  "ascendingSort": (args) => `řazeno vzestupně podle sloupce ${args.columnName}`,
  "columnSize": (args) => `${args.value} pixelů`,
  "descending": `sestupně`,
  "descendingSort": (args) => `řazeno sestupně podle sloupce ${args.columnName}`,
  "resizerDescription": `Stisknutím klávesy Enter začnete měnit velikost`,
  "select": `Vybrat`,
  "selectAll": `Vybrat vše`,
  "sortable": `sloupec s možností řazení`
};

// node_modules/@react-aria/table/dist/da-DK.mjs
var $9a6cbac08487e661$exports = {};
$9a6cbac08487e661$exports = {
  "ascending": `stigende`,
  "ascendingSort": (args) => `sorteret efter kolonne ${args.columnName} i stigende rækkefølge`,
  "columnSize": (args) => `${args.value} pixels`,
  "descending": `faldende`,
  "descendingSort": (args) => `sorteret efter kolonne ${args.columnName} i faldende rækkefølge`,
  "resizerDescription": `Tryk på Enter for at ændre størrelse`,
  "select": `Vælg`,
  "selectAll": `Vælg alle`,
  "sortable": `sorterbar kolonne`
};

// node_modules/@react-aria/table/dist/de-DE.mjs
var $c963661d89486e72$exports = {};
$c963661d89486e72$exports = {
  "ascending": `aufsteigend`,
  "ascendingSort": (args) => `sortiert nach Spalte ${args.columnName} in aufsteigender Reihenfolge`,
  "columnSize": (args) => `${args.value} Pixel`,
  "descending": `absteigend`,
  "descendingSort": (args) => `sortiert nach Spalte ${args.columnName} in absteigender Reihenfolge`,
  "resizerDescription": `Eingabetaste zum Starten der Größenänderung drücken`,
  "select": `Auswählen`,
  "selectAll": `Alles auswählen`,
  "sortable": `sortierbare Spalte`
};

// node_modules/@react-aria/table/dist/el-GR.mjs
var $ac03861c6e8605f4$exports = {};
$ac03861c6e8605f4$exports = {
  "ascending": `αύξουσα`,
  "ascendingSort": (args) => `διαλογή ανά στήλη ${args.columnName} σε αύξουσα σειρά`,
  "columnSize": (args) => `${args.value} pixel`,
  "descending": `φθίνουσα`,
  "descendingSort": (args) => `διαλογή ανά στήλη ${args.columnName} σε φθίνουσα σειρά`,
  "resizerDescription": `Πατήστε Enter για έναρξη της αλλαγής μεγέθους`,
  "select": `Επιλογή`,
  "selectAll": `Επιλογή όλων`,
  "sortable": `Στήλη διαλογής`
};

// node_modules/@react-aria/table/dist/en-US.mjs
var $09e6b82e0d6e466a$exports = {};
$09e6b82e0d6e466a$exports = {
  "select": `Select`,
  "selectAll": `Select All`,
  "sortable": `sortable column`,
  "ascending": `ascending`,
  "descending": `descending`,
  "ascendingSort": (args) => `sorted by column ${args.columnName} in ascending order`,
  "descendingSort": (args) => `sorted by column ${args.columnName} in descending order`,
  "columnSize": (args) => `${args.value} pixels`,
  "resizerDescription": `Press Enter to start resizing`
};

// node_modules/@react-aria/table/dist/es-ES.mjs
var $8cc39eb66c2bf220$exports = {};
$8cc39eb66c2bf220$exports = {
  "ascending": `de subida`,
  "ascendingSort": (args) => `ordenado por columna ${args.columnName} en orden de subida`,
  "columnSize": (args) => `${args.value} píxeles`,
  "descending": `de bajada`,
  "descendingSort": (args) => `ordenado por columna ${args.columnName} en orden de bajada`,
  "resizerDescription": `Pulse Intro para empezar a redimensionar`,
  "select": `Seleccionar`,
  "selectAll": `Seleccionar todos`,
  "sortable": `columna ordenable`
};

// node_modules/@react-aria/table/dist/et-EE.mjs
var $4e11db3c25a38112$exports = {};
$4e11db3c25a38112$exports = {
  "ascending": `tõusev järjestus`,
  "ascendingSort": (args) => `sorditud veeru järgi ${args.columnName} tõusvas järjestuses`,
  "columnSize": (args) => `${args.value} pikslit`,
  "descending": `laskuv järjestus`,
  "descendingSort": (args) => `sorditud veeru järgi ${args.columnName} laskuvas järjestuses`,
  "resizerDescription": `Suuruse muutmise alustamiseks vajutage klahvi Enter`,
  "select": `Vali`,
  "selectAll": `Vali kõik`,
  "sortable": `sorditav veerg`
};

// node_modules/@react-aria/table/dist/fi-FI.mjs
var $da1e751a92575e02$exports = {};
$da1e751a92575e02$exports = {
  "ascending": `nouseva`,
  "ascendingSort": (args) => `lajiteltu sarakkeen ${args.columnName} mukaan nousevassa järjestyksessä`,
  "columnSize": (args) => `${args.value} pikseliä`,
  "descending": `laskeva`,
  "descendingSort": (args) => `lajiteltu sarakkeen ${args.columnName} mukaan laskevassa järjestyksessä`,
  "resizerDescription": `Aloita koon muutos painamalla Enter-näppäintä`,
  "select": `Valitse`,
  "selectAll": `Valitse kaikki`,
  "sortable": `lajiteltava sarake`
};

// node_modules/@react-aria/table/dist/fr-FR.mjs
var $1b5d6c6c47d55106$exports = {};
$1b5d6c6c47d55106$exports = {
  "ascending": `croissant`,
  "ascendingSort": (args) => `trié en fonction de la colonne ${args.columnName} par ordre croissant`,
  "columnSize": (args) => `${args.value} pixels`,
  "descending": `décroissant`,
  "descendingSort": (args) => `trié en fonction de la colonne ${args.columnName} par ordre décroissant`,
  "resizerDescription": `Appuyez sur Entrée pour commencer le redimensionnement.`,
  "select": `Sélectionner`,
  "selectAll": `Sélectionner tout`,
  "sortable": `colonne triable`
};

// node_modules/@react-aria/table/dist/he-IL.mjs
var $7c18ba27b86d3308$exports = {};
$7c18ba27b86d3308$exports = {
  "ascending": `עולה`,
  "ascendingSort": (args) => `מוין לפי עמודה ${args.columnName} בסדר עולה`,
  "columnSize": (args) => `${args.value} פיקסלים`,
  "descending": `יורד`,
  "descendingSort": (args) => `מוין לפי עמודה ${args.columnName} בסדר יורד`,
  "resizerDescription": `הקש Enter כדי לשנות את הגודל`,
  "select": `בחר`,
  "selectAll": `בחר הכול`,
  "sortable": `עמודה שניתן למיין`
};

// node_modules/@react-aria/table/dist/hr-HR.mjs
var $2cb40998e20e8a46$exports = {};
$2cb40998e20e8a46$exports = {
  "ascending": `rastući`,
  "ascendingSort": (args) => `razvrstano po stupcima ${args.columnName} rastućem redoslijedom`,
  "columnSize": (args) => `${args.value} piksela`,
  "descending": `padajući`,
  "descendingSort": (args) => `razvrstano po stupcima ${args.columnName} padajućim redoslijedom`,
  "resizerDescription": `Pritisnite Enter da biste započeli promenu veličine`,
  "select": `Odaberite`,
  "selectAll": `Odaberite sve`,
  "sortable": `stupac koji se može razvrstati`
};

// node_modules/@react-aria/table/dist/hu-HU.mjs
var $189e23eec1d6aa3a$exports = {};
$189e23eec1d6aa3a$exports = {
  "ascending": `növekvő`,
  "ascendingSort": (args) => `rendezve a(z) ${args.columnName} oszlop szerint, növekvő sorrendben`,
  "columnSize": (args) => `${args.value} képpont`,
  "descending": `csökkenő`,
  "descendingSort": (args) => `rendezve a(z) ${args.columnName} oszlop szerint, csökkenő sorrendben`,
  "resizerDescription": `Nyomja le az Enter billentyűt az átméretezés megkezdéséhez`,
  "select": `Kijelölés`,
  "selectAll": `Összes kijelölése`,
  "sortable": `rendezendő oszlop`
};

// node_modules/@react-aria/table/dist/it-IT.mjs
var $3c5ec8e4f015dfd0$exports = {};
$3c5ec8e4f015dfd0$exports = {
  "ascending": `crescente`,
  "ascendingSort": (args) => `in ordine crescente in base alla colonna ${args.columnName}`,
  "columnSize": (args) => `${args.value} pixel`,
  "descending": `decrescente`,
  "descendingSort": (args) => `in ordine decrescente in base alla colonna ${args.columnName}`,
  "resizerDescription": `Premi Invio per iniziare a ridimensionare`,
  "select": `Seleziona`,
  "selectAll": `Seleziona tutto`,
  "sortable": `colonna ordinabile`
};

// node_modules/@react-aria/table/dist/ja-JP.mjs
var $d021d50e6b315ebb$exports = {};
$d021d50e6b315ebb$exports = {
  "ascending": `昇順`,
  "ascendingSort": (args) => `列 ${args.columnName} を昇順で並べ替え`,
  "columnSize": (args) => `${args.value} ピクセル`,
  "descending": `降順`,
  "descendingSort": (args) => `列 ${args.columnName} を降順で並べ替え`,
  "resizerDescription": `Enter キーを押してサイズ変更を開始`,
  "select": `選択`,
  "selectAll": `すべて選択`,
  "sortable": `並べ替え可能な列`
};

// node_modules/@react-aria/table/dist/ko-KR.mjs
var $52535c35c24ec937$exports = {};
$52535c35c24ec937$exports = {
  "ascending": `오름차순`,
  "ascendingSort": (args) => `${args.columnName} 열을 기준으로 오름차순으로 정렬됨`,
  "columnSize": (args) => `${args.value} 픽셀`,
  "descending": `내림차순`,
  "descendingSort": (args) => `${args.columnName} 열을 기준으로 내림차순으로 정렬됨`,
  "resizerDescription": `크기 조정을 시작하려면 Enter를 누르세요.`,
  "select": `선택`,
  "selectAll": `모두 선택`,
  "sortable": `정렬 가능한 열`
};

// node_modules/@react-aria/table/dist/lt-LT.mjs
var $b37ee03672edfd1d$exports = {};
$b37ee03672edfd1d$exports = {
  "ascending": `didėjančia tvarka`,
  "ascendingSort": (args) => `surikiuota pagal stulpelį ${args.columnName} didėjančia tvarka`,
  "columnSize": (args) => `${args.value} piks.`,
  "descending": `mažėjančia tvarka`,
  "descendingSort": (args) => `surikiuota pagal stulpelį ${args.columnName} mažėjančia tvarka`,
  "resizerDescription": `Paspauskite „Enter“, kad pradėtumėte keisti dydį`,
  "select": `Pasirinkti`,
  "selectAll": `Pasirinkti viską`,
  "sortable": `rikiuojamas stulpelis`
};

// node_modules/@react-aria/table/dist/lv-LV.mjs
var $c7df6686b4189d56$exports = {};
$c7df6686b4189d56$exports = {
  "ascending": `augošā secībā`,
  "ascendingSort": (args) => `kārtots pēc kolonnas ${args.columnName} augošā secībā`,
  "columnSize": (args) => `${args.value} pikseļi`,
  "descending": `dilstošā secībā`,
  "descendingSort": (args) => `kārtots pēc kolonnas ${args.columnName} dilstošā secībā`,
  "resizerDescription": `Nospiediet Enter, lai sāktu izmēru mainīšanu`,
  "select": `Atlasīt`,
  "selectAll": `Atlasīt visu`,
  "sortable": `kārtojamā kolonna`
};

// node_modules/@react-aria/table/dist/nb-NO.mjs
var $da07fe8ec87e6b68$exports = {};
$da07fe8ec87e6b68$exports = {
  "ascending": `stigende`,
  "ascendingSort": (args) => `sortert etter kolonne ${args.columnName} i stigende rekkefølge`,
  "columnSize": (args) => `${args.value} piksler`,
  "descending": `synkende`,
  "descendingSort": (args) => `sortert etter kolonne ${args.columnName} i synkende rekkefølge`,
  "resizerDescription": `Trykk på Enter for å starte størrelsesendring`,
  "select": `Velg`,
  "selectAll": `Velg alle`,
  "sortable": `kolonne som kan sorteres`
};

// node_modules/@react-aria/table/dist/nl-NL.mjs
var $64b7e390f5791490$exports = {};
$64b7e390f5791490$exports = {
  "ascending": `oplopend`,
  "ascendingSort": (args) => `gesorteerd in oplopende volgorde in kolom ${args.columnName}`,
  "columnSize": (args) => `${args.value} pixels`,
  "descending": `aflopend`,
  "descendingSort": (args) => `gesorteerd in aflopende volgorde in kolom ${args.columnName}`,
  "resizerDescription": `Druk op Enter om het formaat te wijzigen`,
  "select": `Selecteren`,
  "selectAll": `Alles selecteren`,
  "sortable": `sorteerbare kolom`
};

// node_modules/@react-aria/table/dist/pl-PL.mjs
var $2a03621e773f1678$exports = {};
$2a03621e773f1678$exports = {
  "ascending": `rosnąco`,
  "ascendingSort": (args) => `posortowano według kolumny ${args.columnName} w porządku rosnącym`,
  "columnSize": (args) => `Liczba pikseli: ${args.value}`,
  "descending": `malejąco`,
  "descendingSort": (args) => `posortowano według kolumny ${args.columnName} w porządku malejącym`,
  "resizerDescription": `Naciśnij Enter, aby rozpocząć zmienianie rozmiaru`,
  "select": `Zaznacz`,
  "selectAll": `Zaznacz wszystko`,
  "sortable": `kolumna z możliwością sortowania`
};

// node_modules/@react-aria/table/dist/pt-BR.mjs
var $0a79c0aba9e5ecc6$exports = {};
$0a79c0aba9e5ecc6$exports = {
  "ascending": `crescente`,
  "ascendingSort": (args) => `classificado pela coluna ${args.columnName} em ordem crescente`,
  "columnSize": (args) => `${args.value} pixels`,
  "descending": `decrescente`,
  "descendingSort": (args) => `classificado pela coluna ${args.columnName} em ordem decrescente`,
  "resizerDescription": `Pressione Enter para começar a redimensionar`,
  "select": `Selecionar`,
  "selectAll": `Selecionar tudo`,
  "sortable": `coluna classificável`
};

// node_modules/@react-aria/table/dist/pt-PT.mjs
var $de7b4d0f7dc86fc8$exports = {};
$de7b4d0f7dc86fc8$exports = {
  "ascending": `ascendente`,
  "ascendingSort": (args) => `Ordenar por coluna ${args.columnName} em ordem ascendente`,
  "columnSize": (args) => `${args.value} pixels`,
  "descending": `descendente`,
  "descendingSort": (args) => `Ordenar por coluna ${args.columnName} em ordem descendente`,
  "resizerDescription": `Prima Enter para iniciar o redimensionamento`,
  "select": `Selecionar`,
  "selectAll": `Selecionar tudo`,
  "sortable": `Coluna ordenável`
};

// node_modules/@react-aria/table/dist/ro-RO.mjs
var $28ea7e849d77bd1c$exports = {};
$28ea7e849d77bd1c$exports = {
  "ascending": `crescătoare`,
  "ascendingSort": (args) => `sortate după coloana ${args.columnName} în ordine crescătoare`,
  "columnSize": (args) => `${args.value} pixeli`,
  "descending": `descrescătoare`,
  "descendingSort": (args) => `sortate după coloana ${args.columnName} în ordine descrescătoare`,
  "resizerDescription": `Apăsați pe Enter pentru a începe redimensionarea`,
  "select": `Selectare`,
  "selectAll": `Selectare totală`,
  "sortable": `coloană sortabilă`
};

// node_modules/@react-aria/table/dist/ru-RU.mjs
var $9a09321cf046b187$exports = {};
$9a09321cf046b187$exports = {
  "ascending": `возрастание`,
  "ascendingSort": (args) => `сортировать столбец ${args.columnName} в порядке возрастания`,
  "columnSize": (args) => `${args.value} пикс.`,
  "descending": `убывание`,
  "descendingSort": (args) => `сортировать столбец ${args.columnName} в порядке убывания`,
  "resizerDescription": `Нажмите клавишу Enter для начала изменения размеров`,
  "select": `Выбрать`,
  "selectAll": `Выбрать все`,
  "sortable": `сортируемый столбец`
};

// node_modules/@react-aria/table/dist/sk-SK.mjs
var $5afe469a63fcac7b$exports = {};
$5afe469a63fcac7b$exports = {
  "ascending": `vzostupne`,
  "ascendingSort": (args) => `zoradené zostupne podľa stĺpca ${args.columnName}`,
  "columnSize": (args) => `Počet pixelov: ${args.value}`,
  "descending": `zostupne`,
  "descendingSort": (args) => `zoradené zostupne podľa stĺpca ${args.columnName}`,
  "resizerDescription": `Stlačením klávesu Enter začnete zmenu veľkosti`,
  "select": `Vybrať`,
  "selectAll": `Vybrať všetko`,
  "sortable": `zoraditeľný stĺpec`
};

// node_modules/@react-aria/table/dist/sl-SI.mjs
var $2956757ac31a7ce2$exports = {};
$2956757ac31a7ce2$exports = {
  "ascending": `naraščajoče`,
  "ascendingSort": (args) => `razvrščeno po stolpcu ${args.columnName} v naraščajočem vrstnem redu`,
  "columnSize": (args) => `${args.value} slikovnih pik`,
  "descending": `padajoče`,
  "descendingSort": (args) => `razvrščeno po stolpcu ${args.columnName} v padajočem vrstnem redu`,
  "resizerDescription": `Pritisnite tipko Enter da začnete spreminjati velikost`,
  "select": `Izberite`,
  "selectAll": `Izberite vse`,
  "sortable": `razvrstljivi stolpec`
};

// node_modules/@react-aria/table/dist/sr-SP.mjs
var $cedee0e66b175529$exports = {};
$cedee0e66b175529$exports = {
  "ascending": `rastući`,
  "ascendingSort": (args) => `sortirano po kolonama ${args.columnName} rastućim redosledom`,
  "columnSize": (args) => `${args.value} piksela`,
  "descending": `padajući`,
  "descendingSort": (args) => `sortirano po kolonama ${args.columnName} padajućim redosledom`,
  "resizerDescription": `Pritisnite Enter da biste započeli promenu veličine`,
  "select": `Izaberite`,
  "selectAll": `Izaberite sve`,
  "sortable": `kolona koja se može sortirati`
};

// node_modules/@react-aria/table/dist/sv-SE.mjs
var $6db19998ba4427da$exports = {};
$6db19998ba4427da$exports = {
  "ascending": `stigande`,
  "ascendingSort": (args) => `sorterat på kolumn ${args.columnName} i stigande ordning`,
  "columnSize": (args) => `${args.value} pixlar`,
  "descending": `fallande`,
  "descendingSort": (args) => `sorterat på kolumn ${args.columnName} i fallande ordning`,
  "resizerDescription": `Tryck på Retur för att börja ändra storlek`,
  "select": `Markera`,
  "selectAll": `Markera allt`,
  "sortable": `sorterbar kolumn`
};

// node_modules/@react-aria/table/dist/tr-TR.mjs
var $166b7c9cc1adb1a1$exports = {};
$166b7c9cc1adb1a1$exports = {
  "ascending": `artan sırada`,
  "ascendingSort": (args) => `${args.columnName} sütuna göre artan düzende sırala`,
  "columnSize": (args) => `${args.value} piksel`,
  "descending": `azalan sırada`,
  "descendingSort": (args) => `${args.columnName} sütuna göre azalan düzende sırala`,
  "resizerDescription": `Yeniden boyutlandırmak için Enter'a basın`,
  "select": `Seç`,
  "selectAll": `Tümünü Seç`,
  "sortable": `Sıralanabilir sütun`
};

// node_modules/@react-aria/table/dist/uk-UA.mjs
var $c7ab180b401e49ff$exports = {};
$c7ab180b401e49ff$exports = {
  "ascending": `висхідний`,
  "ascendingSort": (args) => `відсортовано за стовпцем ${args.columnName} у висхідному порядку`,
  "columnSize": (args) => `${args.value} пікс.`,
  "descending": `низхідний`,
  "descendingSort": (args) => `відсортовано за стовпцем ${args.columnName} у низхідному порядку`,
  "resizerDescription": `Натисніть Enter, щоб почати зміну розміру`,
  "select": `Вибрати`,
  "selectAll": `Вибрати все`,
  "sortable": `сортувальний стовпець`
};

// node_modules/@react-aria/table/dist/zh-CN.mjs
var $1648ec00941567f3$exports = {};
$1648ec00941567f3$exports = {
  "ascending": `升序`,
  "ascendingSort": (args) => `按列 ${args.columnName} 升序排序`,
  "columnSize": (args) => `${args.value} 像素`,
  "descending": `降序`,
  "descendingSort": (args) => `按列 ${args.columnName} 降序排序`,
  "resizerDescription": `按“输入”键开始调整大小。`,
  "select": `选择`,
  "selectAll": `全选`,
  "sortable": `可排序的列`
};

// node_modules/@react-aria/table/dist/zh-TW.mjs
var $b26f22384b3c1526$exports = {};
$b26f22384b3c1526$exports = {
  "ascending": `遞增`,
  "ascendingSort": (args) => `已依據「${args.columnName}」欄遞增排序`,
  "columnSize": (args) => `${args.value} 像素`,
  "descending": `遞減`,
  "descendingSort": (args) => `已依據「${args.columnName}」欄遞減排序`,
  "resizerDescription": `按 Enter 鍵以開始調整大小`,
  "select": `選取`,
  "selectAll": `全選`,
  "sortable": `可排序的欄`
};

// node_modules/@react-aria/table/dist/import.mjs
var import_react4 = __toESM(require_react(), 1);
function $parcel$interopDefault2(a) {
  return a && a.__esModule ? a.default : a;
}
var $2140fb2337097f2d$export$552312adfd451dab = /* @__PURE__ */ new WeakMap();
function $2140fb2337097f2d$var$normalizeKey(key) {
  if (typeof key === "string")
    return key.replace(/\s*/g, "");
  return "" + key;
}
function $2140fb2337097f2d$export$37cd4213f2ad742e(state, columnKey) {
  let gridId = $2140fb2337097f2d$export$552312adfd451dab.get(state);
  if (!gridId)
    throw new Error("Unknown grid");
  return `${gridId}-${$2140fb2337097f2d$var$normalizeKey(columnKey)}`;
}
function $2140fb2337097f2d$export$19baff3266315d44(state, rowKey, columnKey) {
  let gridId = $2140fb2337097f2d$export$552312adfd451dab.get(state);
  if (!gridId)
    throw new Error("Unknown grid");
  return `${gridId}-${$2140fb2337097f2d$var$normalizeKey(rowKey)}-${$2140fb2337097f2d$var$normalizeKey(columnKey)}`;
}
function $2140fb2337097f2d$export$85069b70317f543(state, rowKey) {
  return [
    ...state.collection.rowHeaderColumnKeys
  ].map((columnKey) => $2140fb2337097f2d$export$19baff3266315d44(state, rowKey, columnKey)).join(" ");
}
var $7476b46781682bf5$exports = {};
$7476b46781682bf5$exports = {
  "ar-AE": $ce3de3ff2fd66848$exports,
  "bg-BG": $cb80dcce530985b9$exports,
  "cs-CZ": $68ac86749db4c0fb$exports,
  "da-DK": $9a6cbac08487e661$exports,
  "de-DE": $c963661d89486e72$exports,
  "el-GR": $ac03861c6e8605f4$exports,
  "en-US": $09e6b82e0d6e466a$exports,
  "es-ES": $8cc39eb66c2bf220$exports,
  "et-EE": $4e11db3c25a38112$exports,
  "fi-FI": $da1e751a92575e02$exports,
  "fr-FR": $1b5d6c6c47d55106$exports,
  "he-IL": $7c18ba27b86d3308$exports,
  "hr-HR": $2cb40998e20e8a46$exports,
  "hu-HU": $189e23eec1d6aa3a$exports,
  "it-IT": $3c5ec8e4f015dfd0$exports,
  "ja-JP": $d021d50e6b315ebb$exports,
  "ko-KR": $52535c35c24ec937$exports,
  "lt-LT": $b37ee03672edfd1d$exports,
  "lv-LV": $c7df6686b4189d56$exports,
  "nb-NO": $da07fe8ec87e6b68$exports,
  "nl-NL": $64b7e390f5791490$exports,
  "pl-PL": $2a03621e773f1678$exports,
  "pt-BR": $0a79c0aba9e5ecc6$exports,
  "pt-PT": $de7b4d0f7dc86fc8$exports,
  "ro-RO": $28ea7e849d77bd1c$exports,
  "ru-RU": $9a09321cf046b187$exports,
  "sk-SK": $5afe469a63fcac7b$exports,
  "sl-SI": $2956757ac31a7ce2$exports,
  "sr-SP": $cedee0e66b175529$exports,
  "sv-SE": $6db19998ba4427da$exports,
  "tr-TR": $166b7c9cc1adb1a1$exports,
  "uk-UA": $c7ab180b401e49ff$exports,
  "zh-CN": $1648ec00941567f3$exports,
  "zh-TW": $b26f22384b3c1526$exports
};
var $0ba3c81c7f1caedd$export$da43f8f5cb04028d = class extends (0, $d1c300d9c497e402$export$de9feff04fda126e) {
  isCell(node) {
    return node.type === "cell" || node.type === "rowheader" || node.type === "column";
  }
  getKeyBelow(key) {
    let startItem = this.collection.getItem(key);
    if (!startItem)
      return;
    if (startItem.type === "column") {
      let child = (0, $c5a24bc478652b5f$export$fbdeaa6a76694f71)((0, $c5a24bc478652b5f$export$1005530eda016c13)(startItem, this.collection));
      if (child)
        return child.key;
      let firstKey = this.getFirstKey();
      if (firstKey == null)
        return;
      let firstItem = this.collection.getItem(firstKey);
      return (0, $c5a24bc478652b5f$export$5f3398f8733f90e2)((0, $c5a24bc478652b5f$export$1005530eda016c13)(firstItem, this.collection), startItem.index).key;
    }
    return super.getKeyBelow(key);
  }
  getKeyAbove(key) {
    let startItem = this.collection.getItem(key);
    if (!startItem)
      return;
    if (startItem.type === "column") {
      let parent = this.collection.getItem(startItem.parentKey);
      if (parent && parent.type === "column")
        return parent.key;
      return;
    }
    let superKey = super.getKeyAbove(key);
    if (superKey != null && this.collection.getItem(superKey).type !== "headerrow")
      return superKey;
    if (this.isCell(startItem))
      return this.collection.columns[startItem.index].key;
    return this.collection.columns[0].key;
  }
  findNextColumnKey(column) {
    let key = this.findNextKey(column.key, (item) => item.type === "column");
    if (key != null)
      return key;
    let row = this.collection.headerRows[column.level];
    for (let item of (0, $c5a24bc478652b5f$export$1005530eda016c13)(row, this.collection)) {
      if (item.type === "column")
        return item.key;
    }
  }
  findPreviousColumnKey(column) {
    let key = this.findPreviousKey(column.key, (item) => item.type === "column");
    if (key != null)
      return key;
    let row = this.collection.headerRows[column.level];
    let childNodes = [
      ...(0, $c5a24bc478652b5f$export$1005530eda016c13)(row, this.collection)
    ];
    for (let i = childNodes.length - 1; i >= 0; i--) {
      let item = childNodes[i];
      if (item.type === "column")
        return item.key;
    }
  }
  getKeyRightOf(key) {
    let item = this.collection.getItem(key);
    if (!item)
      return;
    if (item.type === "column")
      return this.direction === "rtl" ? this.findPreviousColumnKey(item) : this.findNextColumnKey(item);
    return super.getKeyRightOf(key);
  }
  getKeyLeftOf(key) {
    let item = this.collection.getItem(key);
    if (!item)
      return;
    if (item.type === "column")
      return this.direction === "rtl" ? this.findNextColumnKey(item) : this.findPreviousColumnKey(item);
    return super.getKeyLeftOf(key);
  }
  getKeyForSearch(search, fromKey) {
    if (!this.collator)
      return null;
    let collection = this.collection;
    let key = fromKey !== null && fromKey !== void 0 ? fromKey : this.getFirstKey();
    if (key == null)
      return null;
    let startItem = collection.getItem(key);
    if (startItem.type === "cell")
      key = startItem.parentKey;
    let hasWrapped = false;
    while (key != null) {
      let item = collection.getItem(key);
      for (let cell of (0, $c5a24bc478652b5f$export$1005530eda016c13)(item, this.collection)) {
        let column = collection.columns[cell.index];
        if (collection.rowHeaderColumnKeys.has(column.key) && cell.textValue) {
          let substring = cell.textValue.slice(0, search.length);
          if (this.collator.compare(substring, search) === 0) {
            let fromItem = fromKey != null ? collection.getItem(fromKey) : startItem;
            return fromItem.type === "cell" ? cell.key : item.key;
          }
        }
      }
      key = this.getKeyBelow(key);
      if (key == null && !hasWrapped) {
        key = this.getFirstKey();
        hasWrapped = true;
      }
    }
    return null;
  }
};
function $6e31608fbba75bab$export$25bceaac3c7e4dc7(props, state, ref) {
  let { keyboardDelegate, isVirtualized, layout } = props;
  let collator2 = (0, $325a3faab7a68acd$export$a16aca283550c30d)({
    usage: "search",
    sensitivity: "base"
  });
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let disabledBehavior = state.selectionManager.disabledBehavior;
  let delegate = (0, import_react4.useMemo)(() => keyboardDelegate || new (0, $0ba3c81c7f1caedd$export$da43f8f5cb04028d)({
    collection: state.collection,
    disabledKeys: disabledBehavior === "selection" ? /* @__PURE__ */ new Set() : state.disabledKeys,
    ref,
    direction,
    collator: collator2,
    layout
  }), [
    keyboardDelegate,
    state.collection,
    state.disabledKeys,
    disabledBehavior,
    ref,
    direction,
    collator2,
    layout
  ]);
  let id = (0, $bdb11010cef70236$export$f680877a34711e37)(props.id);
  (0, $2140fb2337097f2d$export$552312adfd451dab).set(state, id);
  let { gridProps } = (0, $83c6e2eafa584c67$export$f6b86a04e5d66d90)({
    ...props,
    id,
    keyboardDelegate: delegate
  }, state, ref);
  if (isVirtualized)
    gridProps["aria-rowcount"] = state.collection.size + state.collection.headerRows.length;
  if ((0, $f4e2df6bd15f8569$export$1b00cb14a96194e6)() && "expandedKeys" in state)
    gridProps.role = "treegrid";
  let { column, direction: sortDirection } = state.sortDescriptor || {};
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault2($7476b46781682bf5$exports)), "@react-aria/table");
  let sortDescription = (0, import_react4.useMemo)(() => {
    var _state_collection_columns_find;
    let columnName = (_state_collection_columns_find = state.collection.columns.find((c) => c.key === column)) === null || _state_collection_columns_find === void 0 ? void 0 : _state_collection_columns_find.textValue;
    return sortDirection && column ? stringFormatter.format(`${sortDirection}Sort`, {
      columnName
    }) : void 0;
  }, [
    sortDirection,
    column,
    state.collection.columns
  ]);
  let descriptionProps = (0, $ef06256079686ba0$export$f8aeda7b10753fa1)(sortDescription);
  (0, $4f58c5f72bcf79f7$export$496315a1608d9602)(() => {
    (0, $319e236875307eab$export$a9b970dcc4ae71a9)(sortDescription, "assertive", 500);
  }, [
    sortDescription
  ]);
  return {
    gridProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(gridProps, descriptionProps, {
      // merge sort description with long press information
      "aria-describedby": [
        descriptionProps["aria-describedby"],
        gridProps["aria-describedby"]
      ].filter(Boolean).join(" ")
    })
  };
}
function $f329116d8ad0aba0$export$9514819a8c81e960(props, state, ref) {
  var _state_sortDescriptor, _state_sortDescriptor1;
  let { node } = props;
  let allowsSorting = node.props.allowsSorting;
  let { gridCellProps } = (0, $ab90dcbc1b5466d0$export$c7e10bfc0c59f67c)({
    ...props,
    focusMode: "child"
  }, state, ref);
  let isSelectionCellDisabled = node.props.isSelectionCell && state.selectionManager.selectionMode === "single";
  let { pressProps } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    isDisabled: !allowsSorting || isSelectionCellDisabled,
    onPress() {
      state.sort(node.key);
    },
    ref
  });
  let { focusableProps } = (0, $e6afbd83fe6ebbd2$export$4c014de7c8940b4c)({}, ref);
  let ariaSort = null;
  let isSortedColumn = ((_state_sortDescriptor = state.sortDescriptor) === null || _state_sortDescriptor === void 0 ? void 0 : _state_sortDescriptor.column) === node.key;
  let sortDirection = (_state_sortDescriptor1 = state.sortDescriptor) === null || _state_sortDescriptor1 === void 0 ? void 0 : _state_sortDescriptor1.direction;
  if (node.props.allowsSorting && !(0, $c87311424ea30a05$export$a11b0059900ceec8)())
    ariaSort = isSortedColumn ? sortDirection : "none";
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault2($7476b46781682bf5$exports)), "@react-aria/table");
  let sortDescription;
  if (allowsSorting) {
    sortDescription = `${stringFormatter.format("sortable")}`;
    if (isSortedColumn && sortDirection && (0, $c87311424ea30a05$export$a11b0059900ceec8)())
      sortDescription = `${sortDescription}, ${stringFormatter.format(sortDirection)}`;
  }
  let descriptionProps = (0, $ef06256079686ba0$export$f8aeda7b10753fa1)(sortDescription);
  let shouldDisableFocus = state.collection.size === 0;
  (0, import_react4.useEffect)(() => {
    if (shouldDisableFocus && state.selectionManager.focusedKey === node.key)
      state.selectionManager.setFocusedKey(null);
  }, [
    shouldDisableFocus,
    state.selectionManager,
    node.key
  ]);
  return {
    columnHeaderProps: {
      ...(0, $3ef42575df84b30b$export$9d1611c77c2fe928)(
        gridCellProps,
        pressProps,
        focusableProps,
        descriptionProps,
        // If the table is empty, make all column headers untabbable
        shouldDisableFocus && {
          tabIndex: -1
        }
      ),
      role: "columnheader",
      id: (0, $2140fb2337097f2d$export$37cd4213f2ad742e)(state, node.key),
      "aria-colspan": node.colspan && node.colspan > 1 ? node.colspan : null,
      "aria-sort": ariaSort
    }
  };
}
var $b2db214c022798eb$var$EXPANSION_KEYS = {
  expand: {
    ltr: "ArrowRight",
    rtl: "ArrowLeft"
  },
  "collapse": {
    ltr: "ArrowLeft",
    rtl: "ArrowRight"
  }
};
function $b2db214c022798eb$export$7f2f6ae19e707aa5(props, state, ref) {
  let { node, isVirtualized } = props;
  let { rowProps, ...states } = (0, $4159a7a9cbb0cc18$export$96357d5a73f686fa)(props, state, ref);
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  if (isVirtualized && !((0, $f4e2df6bd15f8569$export$1b00cb14a96194e6)() && "expandedKeys" in state))
    rowProps["aria-rowindex"] = node.index + 1 + state.collection.headerRows.length;
  else
    delete rowProps["aria-rowindex"];
  let treeGridRowProps = {};
  if ((0, $f4e2df6bd15f8569$export$1b00cb14a96194e6)() && "expandedKeys" in state) {
    let treeNode = state.keyMap.get(node.key);
    if (treeNode != null) {
      var _treeNode_props, _treeNode_props_children, _treeNode_props1;
      let hasChildRows = ((_treeNode_props = treeNode.props) === null || _treeNode_props === void 0 ? void 0 : _treeNode_props.UNSTABLE_childItems) || ((_treeNode_props1 = treeNode.props) === null || _treeNode_props1 === void 0 ? void 0 : (_treeNode_props_children = _treeNode_props1.children) === null || _treeNode_props_children === void 0 ? void 0 : _treeNode_props_children.length) > state.userColumnCount;
      treeGridRowProps = {
        onKeyDown: (e2) => {
          if (e2.key === $b2db214c022798eb$var$EXPANSION_KEYS["expand"][direction] && state.selectionManager.focusedKey === treeNode.key && hasChildRows && state.expandedKeys !== "all" && !state.expandedKeys.has(treeNode.key)) {
            state.toggleKey(treeNode.key);
            e2.stopPropagation();
          } else if (e2.key === $b2db214c022798eb$var$EXPANSION_KEYS["collapse"][direction] && state.selectionManager.focusedKey === treeNode.key && hasChildRows && (state.expandedKeys === "all" || state.expandedKeys.has(treeNode.key))) {
            state.toggleKey(treeNode.key);
            e2.stopPropagation();
          }
        },
        "aria-expanded": hasChildRows ? state.expandedKeys === "all" || state.expandedKeys.has(node.key) : void 0,
        "aria-level": treeNode.level,
        "aria-posinset": treeNode.indexOfType + 1,
        "aria-setsize": treeNode.level > 1 ? (0, $c5a24bc478652b5f$export$7475b2c64539e4cf)(state.keyMap.get(treeNode === null || treeNode === void 0 ? void 0 : treeNode.parentKey).childNodes).indexOfType + 1 : (0, $c5a24bc478652b5f$export$7475b2c64539e4cf)(state.keyMap.get(state.collection.body.key).childNodes).indexOfType + 1
      };
    }
  }
  let linkProps = states.hasAction ? (0, $ea8dcbcb9ea1b556$export$51437d503373d223)(node.props) : {};
  return {
    rowProps: {
      ...(0, $3ef42575df84b30b$export$9d1611c77c2fe928)(rowProps, treeGridRowProps, linkProps),
      "aria-labelledby": (0, $2140fb2337097f2d$export$85069b70317f543)(state, node.key)
    },
    ...states
  };
}
function $f917ee10f4c32dab$export$1b95a7d2d517b841(props, state, ref) {
  let { node, isVirtualized } = props;
  let rowProps = {
    role: "row"
  };
  if (isVirtualized && !((0, $f4e2df6bd15f8569$export$1b00cb14a96194e6)() && "expandedKeys" in state))
    rowProps["aria-rowindex"] = node.index + 1;
  return {
    rowProps
  };
}
function $7713593715703b24$export$49571c903d73624c(props, state, ref) {
  let { gridCellProps, isPressed } = (0, $ab90dcbc1b5466d0$export$c7e10bfc0c59f67c)(props, state, ref);
  let columnKey = props.node.column.key;
  if (state.collection.rowHeaderColumnKeys.has(columnKey)) {
    gridCellProps.role = "rowheader";
    gridCellProps.id = (0, $2140fb2337097f2d$export$19baff3266315d44)(state, props.node.parentKey, columnKey);
  }
  return {
    gridCellProps,
    isPressed
  };
}
function $2a795c53a101c542$export$16ea7f650bd7c1bb(props, state) {
  let { key } = props;
  const { checkboxProps } = (0, $7cb39d07f245a780$export$70e2eed1a92976ad)(props, state);
  return {
    checkboxProps: {
      ...checkboxProps,
      "aria-labelledby": `${checkboxProps.id} ${(0, $2140fb2337097f2d$export$85069b70317f543)(state, key)}`
    }
  };
}
function $2a795c53a101c542$export$1003db6a7e384b99(state) {
  let { isEmpty, isSelectAll, selectionMode } = state.selectionManager;
  const stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault2($7476b46781682bf5$exports)), "@react-aria/table");
  return {
    checkboxProps: {
      "aria-label": stringFormatter.format(selectionMode === "single" ? "select" : "selectAll"),
      isSelected: isSelectAll,
      isDisabled: selectionMode !== "multiple" || state.collection.size === 0,
      isIndeterminate: !isEmpty && !isSelectAll,
      onChange: () => state.selectionManager.toggleSelectAll()
    }
  };
}
function $0047e6c294ea075f$export$6fb1613bd7b28198() {
  return (0, $e45487f8ba1cbdbf$export$d3037f5d3f3e51bf)();
}

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-arrowUpIcon.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
var arrowUpIcon = (0, import_jsx_runtime10.jsx)("path", {
  d: "m5 12 7-7 7 7M12 19V5"
});

// node_modules/@keystar/ui/dist/keystar-ui-table.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
var localizedMessages = {
  "ar-AE": {
    loading: "جارٍ التحميل...",
    loadingMore: "جارٍ تحميل المزيد..."
  },
  "bg-BG": {
    loading: "Зареждане...",
    loadingMore: "Зареждане на още..."
  },
  "cs-CZ": {
    loading: "Načítání...",
    loadingMore: "Načítání dalších..."
  },
  "da-DK": {
    loading: "Indlæser...",
    loadingMore: "Indlæser flere..."
  },
  "de-DE": {
    loading: "Laden...",
    loadingMore: "Mehr laden ..."
  },
  "el-GR": {
    loading: "Φόρτωση...",
    loadingMore: "Φόρτωση περισσότερων..."
  },
  "en-US": {
    loading: "Loading…",
    loadingMore: "Loading more…"
  },
  "es-ES": {
    loading: "Cargando…",
    loadingMore: "Cargando más…"
  },
  "et-EE": {
    loading: "Laadimine...",
    loadingMore: "Laadi rohkem..."
  },
  "fi-FI": {
    loading: "Ladataan…",
    loadingMore: "Ladataan lisää…"
  },
  "fr-FR": {
    loading: "Chargement...",
    loadingMore: "Chargement supplémentaire..."
  },
  "he-IL": {
    loading: "טוען...",
    loadingMore: "טוען עוד..."
  },
  "hr-HR": {
    loading: "Učitavam...",
    loadingMore: "Učitavam još..."
  },
  "hu-HU": {
    loading: "Betöltés folyamatban…",
    loadingMore: "Továbbiak betöltése folyamatban…"
  },
  "it-IT": {
    loading: "Caricamento...",
    loadingMore: "Caricamento altri..."
  },
  "ja-JP": {
    loading: "読み込み中...",
    loadingMore: "さらに読み込み中..."
  },
  "ko-KR": {
    loading: "로드 중…",
    loadingMore: "추가 로드 중…"
  },
  "lt-LT": {
    loading: "Įkeliama...",
    loadingMore: "Įkeliama daugiau..."
  },
  "lv-LV": {
    loading: "Notiek ielāde...",
    loadingMore: "Tiek ielādēts vēl..."
  },
  "nb-NO": {
    loading: "Laster inn ...",
    loadingMore: "Laster inn flere ..."
  },
  "nl-NL": {
    loading: "Laden...",
    loadingMore: "Meer laden..."
  },
  "pl-PL": {
    loading: "Ładowanie...",
    loadingMore: "Wczytywanie większej liczby..."
  },
  "pt-BR": {
    loading: "Carregando...",
    loadingMore: "Carregando mais..."
  },
  "pt-PT": {
    loading: "A carregar...",
    loadingMore: "A carregar mais..."
  },
  "ro-RO": {
    loading: "Se încarcă...",
    loadingMore: "Se încarcă mai multe..."
  },
  "ru-RU": {
    loading: "Загрузка...",
    loadingMore: "Дополнительная загрузка..."
  },
  "sk-SK": {
    loading: "Načítava sa...",
    loadingMore: "Načítava sa viac..."
  },
  "sl-SI": {
    loading: "Nalaganje ...",
    loadingMore: "Nalaganje več vsebine ..."
  },
  "sr-SP": {
    loading: "Učitavam...",
    loadingMore: "Učitavam još..."
  },
  "sv-SE": {
    loading: "Läser in...",
    loadingMore: "Läser in mer..."
  },
  "tr-TR": {
    loading: "Yükleniyor...",
    loadingMore: "Daha fazla yükleniyor..."
  },
  "uk-UA": {
    loading: "Завантаження…",
    loadingMore: "Завантаження інших об’єктів..."
  },
  "zh-CN": {
    loading: "正在加载...",
    loadingMore: "正在加载更多..."
  },
  "zh-T": {
    loading: "載入中…",
    loadingMore: "正在載入更多…"
  }
};
var tableViewClassList = new ClassList("TableView", ["cell", "cell-wrapper", "row"]);
var SortIndicator = () => {
  let labelHeight = tokenSchema.typography.text.regular.capheight;
  return (0, import_jsx_runtime11.jsx)("span", {
    "aria-hidden": "true",
    className: css({
      alignItems: "center",
      display: "flex",
      flexShrink: 0,
      height: labelHeight,
      justifyContent: "center",
      marginInline: tokenSchema.size.space.small,
      opacity: 0,
      position: "relative",
      transition: transition(["opacity", "transform"], {
        easing: "easeOut"
      }),
      width: labelHeight,
      svg: {
        position: "absolute"
      },
      ['[aria-sort="ascending"] &, [aria-sort="descending"] &']: {
        opacity: 1
      },
      ['[aria-sort="descending"] &']: {
        transform: "rotate(180deg)"
      }
    }),
    children: (0, import_jsx_runtime11.jsx)(Icon, {
      src: arrowUpIcon
    })
  });
};
function useTableStyleProps(props) {
  let {
    density,
    overflowMode,
    prominence
  } = props;
  let styleProps = useStyleProps(props);
  return {
    ...toDataAttributes({
      density,
      overflowMode,
      prominence
    }),
    className: classNames(tableViewClassList.element("root"), styleProps.className, css({
      display: "flex",
      flexDirection: "column",
      isolation: "isolate",
      minHeight: 0,
      minWidth: 0,
      outline: "none",
      position: "relative",
      userSelect: "none"
    })),
    style: styleProps.style
  };
}
function useHeaderWrapperStyleProps({
  style
} = {}) {
  return {
    className: css({
      overflow: "hidden",
      position: "relative",
      boxSizing: "content-box",
      flex: "none",
      // keep aligned with the border of the body
      [`${tableViewClassList.selector("root")}:not([data-prominence="low"]) &`]: {
        borderLeft: `${tokenSchema.size.border.regular} solid transparent`,
        borderRight: `${tokenSchema.size.border.regular} solid transparent`
      }
    }),
    style
  };
}
function useHeadStyleProps({
  style
} = {}) {
  return {
    className: css({
      boxSizing: "border-box",
      display: "flex",
      flexDirection: "column"
    }),
    style
  };
}
function useBodyStyleProps({
  style
} = {}) {
  return {
    className: css({
      [`${tableViewClassList.selector("root")}[data-prominence="low"] &`]: {
        borderBlock: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.muted}`
      },
      [`${tableViewClassList.selector("root")}:not([data-prominence="low"]) &`]: {
        backgroundColor: tokenSchema.color.background.canvas,
        border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.muted}`,
        borderRadius: tokenSchema.size.radius.medium,
        /* Fix scrollbars on iOS with sticky row headers */
        transform: "translate3d(0, 0, 0)"
      }
    }),
    style
  };
}
var commonCellStyles = {
  // borderBottom: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.neutral}`,
  boxSizing: "border-box",
  cursor: "default",
  display: "flex",
  height: "100%",
  justifyContent: "flex-start",
  minWidth: 0,
  outline: 0,
  paddingInline: tokenSchema.size.space.medium,
  position: "relative",
  // Density
  paddingBlock: tokenSchema.size.space.medium,
  [`${tableViewClassList.selector("root")}[data-density="compact"] &:not([role="columnheader"])`]: {
    paddingBlock: tokenSchema.size.space.regular
  },
  [`${tableViewClassList.selector("root")}[data-density="spacious"] &:not([role="columnheader"])`]: {
    paddingBlock: tokenSchema.size.space.large
  },
  // wrapping text shouldn't be centered
  alignItems: "center",
  [`${tableViewClassList.selector("root")}[data-overflow-mode="wrap"] &:not([role="columnheader"])`]: {
    alignItems: "start"
  }
};
function useCellStyleProps(props, state) {
  const className = classNames(tableViewClassList.element("cell"), css([commonCellStyles, {
    // Alignment
    '&[data-align="end"]': {
      justifyContent: "flex-end",
      textAlign: "end"
    },
    '&[data-align="center"]': {
      justifyContent: "center",
      textAlign: "center"
    },
    // focus ring
    '&[data-focus="visible"]::after': {
      borderRadius: tokenSchema.size.radius.small,
      boxShadow: `inset 0 0 0 ${tokenSchema.size.alias.focusRing} ${tokenSchema.color.alias.focusRing}`,
      content: '""',
      inset: 0,
      position: "absolute",
      transition: transition(["box-shadow", "margin"], {
        easing: "easeOut"
      })
    },
    // HEADERS
    '&[role="columnheader"]': {
      color: tokenSchema.color.foreground.neutralSecondary,
      ["&[aria-sort]"]: {
        cursor: "default",
        '&:hover, &[data-focus="visible"]': {
          color: tokenSchema.color.foreground.neutralEmphasis
        }
      }
    }
  }]));
  return {
    ...toDataAttributes({
      focus: state !== null && state !== void 0 && state.isFocusVisible ? "visible" : void 0,
      align: props === null || props === void 0 ? void 0 : props.align
    }),
    className
    // style: getStyleFromColumn(props),
  };
}
function useSelectionCellStyleProps() {
  return {
    className: classNames(tableViewClassList.element("cell"), css(commonCellStyles, {
      alignItems: "center",
      flex: "0 0 auto",
      paddingInlineStart: tokenSchema.size.space.medium,
      width: "auto"
    }))
  };
}
function useRowStyleProps(props, state) {
  let {
    style
  } = props;
  let calculatedRadius = `calc(${tokenSchema.size.radius.medium} - ${tokenSchema.size.border.regular})`;
  const className = css({
    boxSizing: "border-box",
    display: "flex",
    position: "relative",
    outline: 0,
    // separators
    "&:not(:last-child)": {
      backgroundColor: tokenSchema.color.border.muted,
      paddingBottom: 1
    },
    // prominence
    [`${tableViewClassList.selector("root")}:not([data-prominence="low"]) &`]: {
      "&:first-child": {
        borderStartStartRadius: calculatedRadius,
        borderStartEndRadius: calculatedRadius
      },
      "&:last-child": {
        borderEndStartRadius: calculatedRadius,
        borderEndEndRadius: calculatedRadius
      }
    },
    // focus indicator
    '&[data-focus="visible"]': {
      "&::before": {
        backgroundColor: tokenSchema.color.background.accentEmphasis,
        borderRadius: tokenSchema.size.space.small,
        content: '""',
        insetInlineStart: tokenSchema.size.space.xsmall,
        marginBlock: tokenSchema.size.space.xsmall,
        marginInlineEnd: `calc(${tokenSchema.size.space.small} * -1)`,
        position: "sticky",
        width: tokenSchema.size.space.small,
        zIndex: 4
      }
    },
    // interactions
    [`&[data-interaction="hover"] ${tableViewClassList.selector("cell")}`]: {
      backgroundColor: tokenSchema.color.scale.slate2
    },
    [`&[data-interaction="press"] ${tableViewClassList.selector("cell")}`]: {
      backgroundColor: tokenSchema.color.scale.slate3
      // backgroundColor: tokenSchema.color.alias.backgroundPressed,
    },
    // selected
    [`&[aria-selected="true"] ${tableViewClassList.selector("cell")}`]: {
      backgroundColor: tokenSchema.color.alias.backgroundSelected
    },
    [`&[aria-selected="true"][data-interaction="hover"] ${tableViewClassList.selector("cell")}`]: {
      backgroundColor: tokenSchema.color.alias.backgroundSelectedHovered
    }
  });
  return {
    ...toDataAttributes({
      focus: state.isFocusVisible ? "visible" : state.isFocusWithin ? "within" : void 0,
      interaction: state.isPressed ? "press" : state.isHovered ? "hover" : void 0
    }),
    className: classNames(tableViewClassList.element("row"), className),
    style
  };
}
function useRowHeaderStyleProps({
  style
}) {
  const className = css({
    display: "flex"
  });
  return {
    className,
    style
  };
}
var DEFAULT_HEADER_HEIGHT = 34;
var DEFAULT_HIDE_HEADER_CELL_WIDTH = 34;
var SELECTION_CELL_DEFAULT_WIDTH = 34;
var ROW_HEIGHTS = {
  compact: 26,
  regular: 34,
  spacious: 42
};
var TableContext = (0, import_react5.createContext)(null);
function useTableContext() {
  return (0, import_react5.useContext)(TableContext);
}
function TableView(props) {
  let domRef = (0, import_react5.useRef)(null);
  let headerRef = (0, import_react5.useRef)(null);
  let bodyRef = (0, import_react5.useRef)(null);
  let {
    direction
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages);
  let {
    density = "regular",
    overflowMode
  } = props;
  let renderWrapper = (parent, reusableView, children, renderChildren) => {
    let style = $ccf8a0a04e4175ae$export$1481e64fbe01b8b3(reusableView.layoutInfo, direction, parent && parent.layoutInfo);
    if (style.overflow === "hidden") {
      style.overflow = "visible";
    }
    if (reusableView.viewType === "rowgroup") {
      return (0, import_jsx_runtime11.jsx)(TableBody, {
        style,
        children: renderChildren(children)
      }, reusableView.key);
    }
    if (reusableView.viewType === "header") {
      return (0, import_jsx_runtime11.jsx)(TableHead, {
        style,
        children: renderChildren(children)
      }, reusableView.key);
    }
    if (reusableView.viewType === "row") {
      return (0, import_jsx_runtime11.jsx)(TableRow, {
        item: reusableView.content,
        style,
        hasAction: !!props.onRowAction,
        children: renderChildren(children)
      }, reusableView.key);
    }
    if (reusableView.viewType === "headerrow") {
      return (0, import_jsx_runtime11.jsx)(TableHeaderRow, {
        style,
        item: reusableView.content,
        children: renderChildren(children)
      }, reusableView.key);
    }
    return (0, import_jsx_runtime11.jsx)($ccf8a0a04e4175ae$export$6796df8ba7398521, {
      layoutInfo: reusableView.layoutInfo,
      virtualizer: reusableView.virtualizer,
      parent: parent === null || parent === void 0 ? void 0 : parent.layoutInfo,
      className: classNames(tableViewClassList.element("cell-wrapper"), css({
        backgroundColor: tokenSchema.color.background.canvas
      })),
      children: reusableView.rendered
    }, reusableView.key);
  };
  let renderView = (type2, item) => {
    var _item$index, _item$colspan;
    switch (type2) {
      case "header":
      case "rowgroup":
      case "section":
      case "row":
      case "headerrow":
        return null;
      case "cell": {
        if (item.props.isSelectionCell) {
          return (0, import_jsx_runtime11.jsx)(TableCheckboxCell, {
            cell: item
          });
        }
        return (0, import_jsx_runtime11.jsx)(TableCell, {
          cell: item,
          overflowMode
        });
      }
      case "placeholder":
        return (0, import_jsx_runtime11.jsx)("div", {
          role: "gridcell",
          "aria-colindex": ((_item$index = item.index) !== null && _item$index !== void 0 ? _item$index : 0) + 1,
          "aria-colspan": ((_item$colspan = item.colspan) !== null && _item$colspan !== void 0 ? _item$colspan : 0) > 1 ? item.colspan : void 0
        });
      case "column":
        if (item.props.isSelectionCell) {
          return (0, import_jsx_runtime11.jsx)(TableSelectAllCell, {
            column: item
          });
        }
        if (item.props.hideHeader) {
          return (0, import_jsx_runtime11.jsxs)(_TooltipTrigger, {
            placement: "top",
            trigger: "focus",
            children: [(0, import_jsx_runtime11.jsx)(TableColumnHeader, {
              column: item
            }), (0, import_jsx_runtime11.jsx)(Tooltip, {
              children: item.rendered
            })]
          });
        }
        return (0, import_jsx_runtime11.jsx)(TableColumnHeader, {
          column: item
        });
      case "loader":
        return (0, import_jsx_runtime11.jsx)(CenteredWrapper, {
          children: (0, import_jsx_runtime11.jsx)(ProgressCircle, {
            isIndeterminate: true,
            "aria-label": state.collection.size > 0 ? stringFormatter.format("loadingMore") : stringFormatter.format("loading")
          })
        });
      case "empty": {
        let emptyState = props.renderEmptyState ? props.renderEmptyState() : null;
        if (emptyState == null) {
          return null;
        }
        return (0, import_jsx_runtime11.jsx)(CenteredWrapper, {
          children: emptyState
        });
      }
    }
  };
  let state = $4a0dd036d492cee4$export$907bcc6c48325fd6({
    ...props,
    showSelectionCheckboxes: props.selectionMode === "multiple"
  });
  const getDefaultWidth = (0, import_react5.useCallback)(({
    props: {
      hideHeader,
      isSelectionCell
    }
  }) => {
    if (hideHeader) {
      return DEFAULT_HIDE_HEADER_CELL_WIDTH;
    } else if (isSelectionCell) {
      return SELECTION_CELL_DEFAULT_WIDTH;
    }
  }, []);
  const getDefaultMinWidth = (0, import_react5.useCallback)(({
    props: {
      hideHeader,
      isSelectionCell
    }
  }) => {
    if (hideHeader) {
      return DEFAULT_HIDE_HEADER_CELL_WIDTH;
    } else if (isSelectionCell) {
      return SELECTION_CELL_DEFAULT_WIDTH;
    }
    return 75;
  }, []);
  let columnLayout = (0, import_react5.useMemo)(() => new $a9e7ae544a4e41dd$export$7ff77a162970b30e({
    getDefaultWidth,
    getDefaultMinWidth
  }), [getDefaultWidth, getDefaultMinWidth]);
  let tableLayout = (0, import_react5.useMemo)(
    () => new $a152112e902709bf$export$62444c3c724b1b20({
      // If props.rowHeight is auto, then use estimated heights, otherwise use fixed heights.
      rowHeight: overflowMode === "wrap" ? void 0 : ROW_HEIGHTS[density],
      estimatedRowHeight: overflowMode === "wrap" ? ROW_HEIGHTS[density] : void 0,
      headingHeight: overflowMode === "wrap" ? void 0 : DEFAULT_HEADER_HEIGHT,
      estimatedHeadingHeight: overflowMode === "wrap" ? DEFAULT_HEADER_HEIGHT : void 0,
      columnLayout,
      initialCollection: state.collection
    }),
    // don't recompute when state.collection changes, only used for initial value
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [overflowMode, density, columnLayout]
  );
  let layout = (0, import_react5.useMemo)(() => {
    let proxy = new Proxy(tableLayout, {
      get(target, prop, receiver) {
        return prop === "tableState" ? state : Reflect.get(target, prop, receiver);
      }
    });
    return proxy;
  }, [state, tableLayout]);
  let {
    gridProps
  } = $6e31608fbba75bab$export$25bceaac3c7e4dc7({
    ...props,
    isVirtualized: true,
    layout
  }, state, domRef);
  const isEmpty = state.collection.size === 0;
  return (0, import_jsx_runtime11.jsx)(TableContext.Provider, {
    value: {
      isEmpty,
      layout,
      state
    },
    children: (0, import_jsx_runtime11.jsx)(TableVirtualizer, {
      layout,
      collection: state.collection,
      renderView,
      renderWrapper,
      bodyRef,
      domRef,
      headerRef,
      ...gridProps,
      ...props
    })
  });
}
function TableVirtualizer(props) {
  var _layout$getLayoutInfo;
  let {
    layout,
    collection,
    // focusedKey,
    renderView,
    renderWrapper,
    domRef,
    bodyRef,
    headerRef,
    disallowEmptySelection: UNUSED_disallowEmptySelection,
    onRowAction: UNUSED_onRowAction,
    onSelectionChange: UNUSED_onSelectionChange,
    onSortChange: UNUSED_onSortChange,
    overflowMode: UNUSED_overflowMode,
    renderEmptyState: UNUSED_renderEmptyState,
    selectedKeys: UNUSED_selectedKeys,
    sortDescriptor: UNUSED_sortDescriptor,
    selectionMode,
    ...otherProps
  } = props;
  let {
    direction
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let loadingState = collection.body.props.loadingState;
  let isLoading = loadingState === "loading" || loadingState === "loadingMore";
  let onLoadMore = collection.body.props.onLoadMore;
  let virtualizerState = $fc0b13b484ac1194$export$1505db82fe357e65({
    layout,
    collection,
    renderView,
    renderWrapper,
    onVisibleRectChange(rect) {
      let bodyEl = bodyRef.current;
      if (bodyEl) {
        bodyEl.scrollTop = rect.y;
        $ce415dc67314b753$export$ed5fd5ffe5ab0ac(bodyEl, direction, rect.x);
      }
    }
  });
  let styleProps = useTableStyleProps(props);
  let syncScroll = (0, import_react5.useCallback)(() => {
    let bodyEl = bodyRef.current;
    let headerEl = headerRef.current;
    if (bodyEl && headerEl) {
      headerEl.scrollLeft = bodyEl.scrollLeft;
    }
  }, [bodyRef, headerRef]);
  let scrollToItem = (0, import_react5.useCallback)((key) => {
    let item = collection.getItem(key);
    let column = collection.columns[0];
    let virtualizer = virtualizerState.virtualizer;
    virtualizer.scrollToItem(key, {
      duration: 0,
      // Prevent scrolling to the top when clicking on column headers.
      shouldScrollY: (item === null || item === void 0 ? void 0 : item.type) !== "column",
      // Offset scroll position by width of selection cell
      // (which is sticky and will overlap the cell we're scrolling to).
      offsetX: column.props.isSelectionCell || column.props.isDragButtonCell ? layout.getColumnWidth(column.key) : 0
    });
    syncScroll();
  }, [collection, layout, syncScroll, virtualizerState.virtualizer]);
  let memoedVirtualizerProps = (0, import_react5.useMemo)(() => ({
    scrollToItem,
    isLoading,
    onLoadMore
  }), [scrollToItem, isLoading, onLoadMore]);
  let {
    virtualizerProps,
    scrollViewProps
  } = $6d0a5c394373ae64$export$dd6d526d88b5a137(memoedVirtualizerProps, virtualizerState, domRef);
  let mergedProps = $3ef42575df84b30b$export$9d1611c77c2fe928($65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps), virtualizerProps);
  const [headerView, bodyView] = virtualizerState.visibleViews;
  let headerHeight = ((_layout$getLayoutInfo = layout.getLayoutInfo("header")) === null || _layout$getLayoutInfo === void 0 ? void 0 : _layout$getLayoutInfo.rect.height) || 0;
  let bodyStyleProps = useBodyStyleProps({
    style: {
      flex: 1
    }
  });
  return (0, import_jsx_runtime11.jsx)($9bf71ea28793e738$export$20e40289641fbbb6, {
    children: (0, import_jsx_runtime11.jsxs)("div", {
      ...mergedProps,
      ...styleProps,
      ref: domRef,
      children: [(0, import_jsx_runtime11.jsx)(TableHeaderWrapper, {
        ref: headerRef,
        style: {
          height: headerHeight,
          willChange: virtualizerState.isScrolling ? "scroll-position" : void 0
        },
        children: headerView
      }), (0, import_jsx_runtime11.jsx)($44a6ee657928b002$export$5665e3d6be6adea, {
        ...scrollViewProps,
        ...bodyStyleProps,
        role: "presentation",
        innerStyle: {
          overflow: "visible"
        },
        ref: bodyRef,
        contentSize: virtualizerState.contentSize,
        onScrollStart: virtualizerState.startScrolling,
        onScrollEnd: virtualizerState.endScrolling,
        onScroll: syncScroll,
        children: bodyView
      })]
    })
  });
}
function TableHead({
  children,
  style
}) {
  let {
    rowGroupProps
  } = $0047e6c294ea075f$export$6fb1613bd7b28198();
  let styleProps = useHeadStyleProps({
    style
  });
  return (0, import_jsx_runtime11.jsx)("div", {
    ...rowGroupProps,
    ...styleProps,
    children
  });
}
function TableBody(props) {
  let {
    rowGroupProps
  } = $0047e6c294ea075f$export$6fb1613bd7b28198();
  return (0, import_jsx_runtime11.jsx)("div", {
    ...rowGroupProps,
    ...props
  });
}
var TableHeaderWrapper = (0, import_react5.forwardRef)(function TableHeaderWrapper2(props, ref) {
  let styleProps = useHeaderWrapperStyleProps(props);
  return (0, import_jsx_runtime11.jsx)("div", {
    ref,
    role: "presentation",
    ...styleProps,
    children: props.children
  });
});
function TableHeaderRow(props) {
  let ref = (0, import_react5.useRef)(null);
  let {
    state
  } = useTableContext();
  let {
    rowProps
  } = $f917ee10f4c32dab$export$1b95a7d2d517b841({
    node: props.item,
    isVirtualized: true
  }, state, ref);
  let styleProps = useRowHeaderStyleProps(props);
  return (0, import_jsx_runtime11.jsx)("div", {
    ...rowProps,
    ...styleProps,
    ref,
    children: props.children
  });
}
function TableColumnHeader({
  column
}) {
  let ref = (0, import_react5.useRef)(null);
  let {
    state
  } = useTableContext();
  let {
    columnHeaderProps
  } = $f329116d8ad0aba0$export$9514819a8c81e960({
    node: column,
    isVirtualized: true
  }, state, ref);
  let {
    isFocusVisible,
    focusProps
  } = $f7dceffc5ad7768b$export$4e328f61c538687f();
  let columnProps = column.props;
  let cellStyleProps = useCellStyleProps(columnProps, {
    isFocusVisible
  });
  return (0, import_jsx_runtime11.jsxs)("div", {
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(columnHeaderProps, focusProps),
    ...cellStyleProps,
    ref,
    children: [columnProps.allowsSorting && columnProps.align === "end" && (0, import_jsx_runtime11.jsx)(SortIndicator, {}), columnProps.hideHeader ? (0, import_jsx_runtime11.jsx)($5c3e21d68f1c4674$export$439d29a4e110a164, {
      children: column.rendered
    }) : isReactText(column.rendered) ? (0, import_jsx_runtime11.jsx)(Text, {
      color: "inherit",
      weight: "semibold",
      truncate: true,
      children: column.rendered
    }) : column.rendered, columnProps.allowsSorting && columnProps.align !== "end" && (0, import_jsx_runtime11.jsx)(SortIndicator, {})]
  });
}
function TableRow({
  children,
  hasAction,
  item,
  style
}) {
  let ref = (0, import_react5.useRef)(null);
  let {
    state
  } = useTableContext();
  let allowsInteraction = state.selectionManager.selectionMode !== "none" || hasAction;
  let isDisabled = !allowsInteraction || state.disabledKeys.has(item.key);
  let {
    rowProps
  } = $b2db214c022798eb$export$7f2f6ae19e707aa5({
    node: item,
    isVirtualized: true
  }, state, ref);
  let {
    isFocusVisible: isFocusWithin,
    focusProps: focusWithinProps
  } = $f7dceffc5ad7768b$export$4e328f61c538687f({
    within: true
  });
  let {
    isFocusVisible,
    focusProps
  } = $f7dceffc5ad7768b$export$4e328f61c538687f();
  let {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    isDisabled
  });
  let {
    pressProps,
    isPressed
  } = $f6c31cce2adf654f$export$45712eceda6fad21({
    isDisabled
  });
  let styleProps = useRowStyleProps({
    style
  }, {
    isFocusVisible,
    isFocusWithin,
    isHovered,
    isPressed
  });
  return (0, import_jsx_runtime11.jsx)("div", {
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(rowProps, focusWithinProps, focusProps, hoverProps, pressProps),
    ...styleProps,
    ref,
    children
  });
}
function TableCell({
  cell,
  overflowMode
}) {
  let ref = (0, import_react5.useRef)(null);
  let {
    state
  } = useTableContext();
  let {
    gridCellProps
  } = $7713593715703b24$export$49571c903d73624c({
    node: cell,
    isVirtualized: true
  }, state, ref);
  let {
    isFocusVisible,
    focusProps
  } = $f7dceffc5ad7768b$export$4e328f61c538687f();
  let styleProps = useCellStyleProps(cell.column.props, {
    isFocusVisible
  });
  return (0, import_jsx_runtime11.jsx)("div", {
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(gridCellProps, focusProps),
    ...styleProps,
    ref,
    children: (0, import_jsx_runtime11.jsx)(SlotProvider, {
      slots: {
        text: {
          truncate: overflowMode === "truncate"
        }
      },
      children: isReactText(cell.rendered) ? (0, import_jsx_runtime11.jsx)(Text, {
        children: cell.rendered
      }) : cell.rendered
    })
  });
}
function TableCheckboxCell({
  cell
}) {
  let ref = (0, import_react5.useRef)(null);
  let {
    state
  } = useTableContext();
  let {
    gridCellProps
  } = $7713593715703b24$export$49571c903d73624c({
    node: cell,
    isVirtualized: true
  }, state, ref);
  let {
    checkboxProps
  } = $2a795c53a101c542$export$16ea7f650bd7c1bb({
    key: cell.parentKey
  }, state);
  let styleProps = useSelectionCellStyleProps();
  return (0, import_jsx_runtime11.jsx)("div", {
    ...styleProps,
    ...gridCellProps,
    ref,
    children: (0, import_jsx_runtime11.jsx)(Checkbox, {
      ...checkboxProps
    })
  });
}
function TableSelectAllCell({
  column
}) {
  let ref = (0, import_react5.useRef)(null);
  let {
    state
  } = useTableContext();
  let {
    columnHeaderProps
  } = $f329116d8ad0aba0$export$9514819a8c81e960({
    node: column,
    isVirtualized: true
  }, state, ref);
  let {
    checkboxProps
  } = $2a795c53a101c542$export$1003db6a7e384b99(state);
  let styleProps = useSelectionCellStyleProps();
  return (0, import_jsx_runtime11.jsx)("div", {
    ...styleProps,
    ...columnHeaderProps,
    ref,
    children: state.selectionManager.selectionMode === "single" ? (0, import_jsx_runtime11.jsx)(Text, {
      visuallyHidden: true,
      children: checkboxProps["aria-label"]
    }) : (0, import_jsx_runtime11.jsx)(Checkbox, {
      ...checkboxProps
    })
  });
}
function CenteredWrapper({
  children
}) {
  let {
    state
  } = useTableContext();
  return (0, import_jsx_runtime11.jsx)("div", {
    role: "row",
    "aria-rowindex": state.collection.headerRows.length + state.collection.size + 1,
    style: {
      alignItems: "center",
      display: "flex",
      height: "100%",
      justifyContent: "center",
      width: "100%"
    },
    children: (0, import_jsx_runtime11.jsx)("div", {
      role: "rowheader",
      "aria-colspan": state.collection.columns.length,
      children
    })
  });
}
var VoussoirColumn = $1cd244557c2f97d5$export$816b5d811295e6bc;

// node_modules/@keystatic/core/dist/keystatic-core-ui.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime());
var import_slugify = __toESM(require_slugify());
var import_sanitize_url = __toESM(require_dist());

// node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence))
    return sequence;
  else if (isNothing(sequence))
    return [];
  return [sequence];
}
function extend(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark)
    return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$1;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "→") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string, max) {
  return common.repeat(" ", max - string.length) + string;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer)
    return null;
  if (!options.maxLength)
    options.maxLength = 79;
  if (typeof options.indent !== "number")
    options.indent = 1;
  if (typeof options.linesBefore !== "number")
    options.linesBefore = 3;
  if (typeof options.linesAfter !== "number")
    options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0)
    foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map3) {
  var result = {};
  if (map3 !== null) {
    Object.keys(map3).forEach(function(style) {
      map3[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit)
      implicit = implicit.concat(definition.implicit);
    if (definition.explicit)
      explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var map2 = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map2
  ]
});
function resolveYamlNull(data) {
  if (data === null)
    return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object2) {
  return object2 === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null)
    return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object2) {
  return Object.prototype.toString.call(object2) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object2) {
      return object2 ? "true" : "false";
    },
    uppercase: function(object2) {
      return object2 ? "TRUE" : "FALSE";
    },
    camelcase: function(object2) {
      return object2 ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null)
    return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max)
    return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max)
      return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (ch !== "0" && ch !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isHexCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_")
    return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_")
      continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_")
    return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-")
      sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0")
    return 0;
  if (ch === "0") {
    if (value[1] === "b")
      return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x")
      return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o")
      return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object2) {
  return Object.prototype.toString.call(object2) === "[object Number]" && (object2 % 1 === 0 && !common.isNegativeZero(object2));
}
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  if (data === null)
    return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object2, style) {
  var res;
  if (isNaN(object2)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object2) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object2) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object2)) {
    return "-0.0";
  }
  res = object2.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object2) {
  return Object.prototype.toString.call(object2) === "[object Number]" && (object2 % 1 !== 0 || common.isNegativeZero(object2));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data) {
  if (data === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null)
    match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null)
    throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-")
      delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta)
    date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object2) {
  return object2.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge2 = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null)
    return false;
  var code, idx, bitlen = 0, max = data.length, map3 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map3.indexOf(data.charAt(idx));
    if (code > 64)
      continue;
    if (code < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map3 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map3.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object2) {
  var result = "", bits = 0, idx, tail, max = object2.length, map3 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map3[bits >> 18 & 63];
      result += map3[bits >> 12 & 63];
      result += map3[bits >> 6 & 63];
      result += map3[bits & 63];
    }
    bits = (bits << 8) + object2[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map3[bits >> 18 & 63];
    result += map3[bits >> 12 & 63];
    result += map3[bits >> 6 & 63];
    result += map3[bits & 63];
  } else if (tail === 2) {
    result += map3[bits >> 10 & 63];
    result += map3[bits >> 4 & 63];
    result += map3[bits << 2 & 63];
    result += map3[64];
  } else if (tail === 1) {
    result += map3[bits >> 2 & 63];
    result += map3[bits << 4 & 63];
    result += map3[64];
    result += map3[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null)
    return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object2 = data;
  for (index = 0, length = object2.length; index < length; index += 1) {
    pair = object2[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null)
    return true;
  var index, length, pair, keys, result, object2 = data;
  result = new Array(object2.length);
  for (index = 0, length = object2.length; index < length; index += 1) {
    pair = object2[index];
    if (_toString$1.call(pair) !== "[object Object]")
      return false;
    keys = Object.keys(pair);
    if (keys.length !== 1)
      return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null)
    return [];
  var index, length, pair, keys, result, object2 = data;
  result = new Array(object2.length);
  for (index = 0, length = object2.length; index < length; index += 1) {
    pair = object2[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null)
    return true;
  var key, object2 = data;
  for (key in object2) {
    if (_hasOwnProperty$2.call(object2, key)) {
      if (object2[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge2
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "" : c === 95 ? " " : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
var i;
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33)
    return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38)
    return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42)
    return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch))
        break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0)
      readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map3) {
  var result, keys, index, length, tag, style, type2;
  if (map3 === null)
    return {};
  result = {};
  keys = Object.keys(map3);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map3[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1;
var QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n")
      result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index, length, type2;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type2 = state.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function() {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(
      string,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ")
    return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 65536)
        result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object2) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object2.length; index < length; index += 1) {
    value = object2[index];
    if (state.replacer) {
      value = state.replacer.call(object2, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "")
        _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object2, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object2.length; index < length; index += 1) {
    value = object2[index];
    if (state.replacer) {
      value = state.replacer.call(object2, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object2) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object2), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "")
      pairBuffer += ", ";
    if (state.condenseFlow)
      pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object2[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object2, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024)
      pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object2, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object2), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object2[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object2, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object2, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object2 === "object" && object2 instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object2))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object2);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object2, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object2, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object2, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object2;
  if (!detectType(state, object2, false)) {
    detectType(state, object2, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object2);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid)
        return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object2, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object2, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object2, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object2 !== null && typeof object2 === "object") {
    index = objects.indexOf(object2);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object2);
      if (Array.isArray(object2)) {
        for (index = 0, length = object2.length; index < length; index += 1) {
          inspectNode(object2[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object2);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object2[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs)
    getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true))
    return state.dump + "\n";
  return "";
}
var dump_1 = dump$1;
var dumper = {
  dump: dump_1
};
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var load = loader.load;
var loadAll = loader.loadAll;
var dump = dumper.dump;
var safeLoad = renamed("safeLoad", "load");
var safeLoadAll = renamed("safeLoadAll", "loadAll");
var safeDump = renamed("safeDump", "dump");

// node_modules/@keystatic/core/dist/required-files-0baba55b.js
var textDecoder = new TextDecoder();
var textEncoder = new TextEncoder();
function splitFrontmatter(data) {
  const str2 = textDecoder.decode(data);
  const match = str2.match(/^---(?:\r?\n([^]*?))?\r?\n---\r?\n?/);
  if (match) {
    var _match$;
    const encoded = textEncoder.encode(match[0]);
    return {
      frontmatter: (_match$ = match[1]) !== null && _match$ !== void 0 ? _match$ : "",
      content: data.slice(encoded.byteLength)
    };
  }
  return null;
}
function loadDataFile(data, formatInfo) {
  const parse = formatInfo.data === "json" ? JSON.parse : load;
  if (!formatInfo.contentField) {
    const dataFile = textDecoder.decode(data);
    return {
      loaded: parse(dataFile)
    };
  }
  const res = splitFrontmatter(data);
  assert(res !== null, "frontmatter not found");
  return {
    loaded: parse(res.frontmatter),
    extraFakeFile: {
      path: `${formatInfo.contentField.key}${formatInfo.contentField.config.contentExtension}`,
      contents: res.content
    }
  };
}

// node_modules/@react-aria/breadcrumbs/dist/ar-AE.mjs
var $b91590b2dc47de39$exports = {};
$b91590b2dc47de39$exports = {
  "breadcrumbs": `عناصر الواجهة`
};

// node_modules/@react-aria/breadcrumbs/dist/bg-BG.mjs
var $55b0693b2cf3fe91$exports = {};
$55b0693b2cf3fe91$exports = {
  "breadcrumbs": `Трохи хляб`
};

// node_modules/@react-aria/breadcrumbs/dist/cs-CZ.mjs
var $6ec1ed7729e948cc$exports = {};
$6ec1ed7729e948cc$exports = {
  "breadcrumbs": `Popis cesty`
};

// node_modules/@react-aria/breadcrumbs/dist/da-DK.mjs
var $5a41bb2baa6861e4$exports = {};
$5a41bb2baa6861e4$exports = {
  "breadcrumbs": `Brødkrummer`
};

// node_modules/@react-aria/breadcrumbs/dist/de-DE.mjs
var $f28bbea439e87eca$exports = {};
$f28bbea439e87eca$exports = {
  "breadcrumbs": `Breadcrumbs`
};

// node_modules/@react-aria/breadcrumbs/dist/el-GR.mjs
var $b3eca51cb720961a$exports = {};
$b3eca51cb720961a$exports = {
  "breadcrumbs": `Πλοηγήσεις breadcrumb`
};

// node_modules/@react-aria/breadcrumbs/dist/en-US.mjs
var $0b39b205118db415$exports = {};
$0b39b205118db415$exports = {
  "breadcrumbs": `Breadcrumbs`
};

// node_modules/@react-aria/breadcrumbs/dist/es-ES.mjs
var $f467c0ee7bfb0950$exports = {};
$f467c0ee7bfb0950$exports = {
  "breadcrumbs": `Migas de pan`
};

// node_modules/@react-aria/breadcrumbs/dist/et-EE.mjs
var $ab711d2ffb4cdf3d$exports = {};
$ab711d2ffb4cdf3d$exports = {
  "breadcrumbs": `Lingiread`
};

// node_modules/@react-aria/breadcrumbs/dist/fi-FI.mjs
var $b63105d663e6f9d5$exports = {};
$b63105d663e6f9d5$exports = {
  "breadcrumbs": `Navigointilinkit`
};

// node_modules/@react-aria/breadcrumbs/dist/fr-FR.mjs
var $9d2ed7be7fcdc2a1$exports = {};
$9d2ed7be7fcdc2a1$exports = {
  "breadcrumbs": `Chemin de navigation`
};

// node_modules/@react-aria/breadcrumbs/dist/he-IL.mjs
var $c5704294d85c7b5d$exports = {};
$c5704294d85c7b5d$exports = {
  "breadcrumbs": `שבילי ניווט`
};

// node_modules/@react-aria/breadcrumbs/dist/hr-HR.mjs
var $20c975671d6bbc63$exports = {};
$20c975671d6bbc63$exports = {
  "breadcrumbs": `Navigacijski putovi`
};

// node_modules/@react-aria/breadcrumbs/dist/hu-HU.mjs
var $2569ca3917233115$exports = {};
$2569ca3917233115$exports = {
  "breadcrumbs": `Morzsamenü`
};

// node_modules/@react-aria/breadcrumbs/dist/it-IT.mjs
var $caa152f7f8e96c85$exports = {};
$caa152f7f8e96c85$exports = {
  "breadcrumbs": `Breadcrumb`
};

// node_modules/@react-aria/breadcrumbs/dist/ja-JP.mjs
var $cbc6af0cc98fad10$exports = {};
$cbc6af0cc98fad10$exports = {
  "breadcrumbs": `パンくずリスト`
};

// node_modules/@react-aria/breadcrumbs/dist/ko-KR.mjs
var $ad9be5d332b4d607$exports = {};
$ad9be5d332b4d607$exports = {
  "breadcrumbs": `탐색 표시`
};

// node_modules/@react-aria/breadcrumbs/dist/lt-LT.mjs
var $659de19a00ff9617$exports = {};
$659de19a00ff9617$exports = {
  "breadcrumbs": `Naršymo kelias`
};

// node_modules/@react-aria/breadcrumbs/dist/lv-LV.mjs
var $173e9fb4d14fe309$exports = {};
$173e9fb4d14fe309$exports = {
  "breadcrumbs": `Atpakaļceļi`
};

// node_modules/@react-aria/breadcrumbs/dist/nb-NO.mjs
var $d8e2640a066567a9$exports = {};
$d8e2640a066567a9$exports = {
  "breadcrumbs": `Navigasjonsstier`
};

// node_modules/@react-aria/breadcrumbs/dist/nl-NL.mjs
var $d71fd764236c0d12$exports = {};
$d71fd764236c0d12$exports = {
  "breadcrumbs": `Broodkruimels`
};

// node_modules/@react-aria/breadcrumbs/dist/pl-PL.mjs
var $f4ad3faf9f4aaec6$exports = {};
$f4ad3faf9f4aaec6$exports = {
  "breadcrumbs": `Struktura nawigacyjna`
};

// node_modules/@react-aria/breadcrumbs/dist/pt-BR.mjs
var $9703be9d55d8e9c2$exports = {};
$9703be9d55d8e9c2$exports = {
  "breadcrumbs": `Caminho detalhado`
};

// node_modules/@react-aria/breadcrumbs/dist/pt-PT.mjs
var $7e23baec8a14f309$exports = {};
$7e23baec8a14f309$exports = {
  "breadcrumbs": `Categorias`
};

// node_modules/@react-aria/breadcrumbs/dist/ro-RO.mjs
var $568f95594049d56e$exports = {};
$568f95594049d56e$exports = {
  "breadcrumbs": `Miez de pâine`
};

// node_modules/@react-aria/breadcrumbs/dist/ru-RU.mjs
var $625df06cecc70764$exports = {};
$625df06cecc70764$exports = {
  "breadcrumbs": `Навигация`
};

// node_modules/@react-aria/breadcrumbs/dist/sk-SK.mjs
var $b5a67525f3a2f594$exports = {};
$b5a67525f3a2f594$exports = {
  "breadcrumbs": `Navigačné prvky Breadcrumbs`
};

// node_modules/@react-aria/breadcrumbs/dist/sl-SI.mjs
var $16125922964febca$exports = {};
$16125922964febca$exports = {
  "breadcrumbs": `Drobtine`
};

// node_modules/@react-aria/breadcrumbs/dist/sr-SP.mjs
var $de104bf355206bcf$exports = {};
$de104bf355206bcf$exports = {
  "breadcrumbs": `Putanje navigacije`
};

// node_modules/@react-aria/breadcrumbs/dist/sv-SE.mjs
var $d5ab76bcbadc9c07$exports = {};
$d5ab76bcbadc9c07$exports = {
  "breadcrumbs": `Sökvägar`
};

// node_modules/@react-aria/breadcrumbs/dist/tr-TR.mjs
var $a6a1af5968159b55$exports = {};
$a6a1af5968159b55$exports = {
  "breadcrumbs": `İçerik haritaları`
};

// node_modules/@react-aria/breadcrumbs/dist/uk-UA.mjs
var $5204a30f0d17ffec$exports = {};
$5204a30f0d17ffec$exports = {
  "breadcrumbs": `Навігаційна стежка`
};

// node_modules/@react-aria/breadcrumbs/dist/zh-CN.mjs
var $8d15e736e12d3dfd$exports = {};
$8d15e736e12d3dfd$exports = {
  "breadcrumbs": `导航栏`
};

// node_modules/@react-aria/breadcrumbs/dist/zh-TW.mjs
var $f8c49dd804b75140$exports = {};
$f8c49dd804b75140$exports = {
  "breadcrumbs": `導覽列`
};

// node_modules/@react-aria/breadcrumbs/dist/import.mjs
function $parcel$interopDefault3(a) {
  return a && a.__esModule ? a.default : a;
}
function $dafd15390222438a$export$452b38fce62c9384(props, ref) {
  let { isCurrent, isDisabled, "aria-current": ariaCurrent, elementType = "a", ...otherProps } = props;
  let { linkProps } = (0, $298d61e98472621b$export$dcf14c9974fe2767)({
    isDisabled: isDisabled || isCurrent,
    elementType,
    ...otherProps
  }, ref);
  let isHeading = /^h[1-6]$/.test(elementType);
  let itemProps = {};
  if (!isHeading)
    itemProps = linkProps;
  if (isCurrent) {
    itemProps["aria-current"] = ariaCurrent || "page";
    itemProps.tabIndex = props.autoFocus ? -1 : void 0;
  }
  return {
    itemProps: {
      "aria-disabled": isDisabled,
      ...itemProps
    }
  };
}
var $8229b34715874f89$exports = {};
$8229b34715874f89$exports = {
  "ar-AE": $b91590b2dc47de39$exports,
  "bg-BG": $55b0693b2cf3fe91$exports,
  "cs-CZ": $6ec1ed7729e948cc$exports,
  "da-DK": $5a41bb2baa6861e4$exports,
  "de-DE": $f28bbea439e87eca$exports,
  "el-GR": $b3eca51cb720961a$exports,
  "en-US": $0b39b205118db415$exports,
  "es-ES": $f467c0ee7bfb0950$exports,
  "et-EE": $ab711d2ffb4cdf3d$exports,
  "fi-FI": $b63105d663e6f9d5$exports,
  "fr-FR": $9d2ed7be7fcdc2a1$exports,
  "he-IL": $c5704294d85c7b5d$exports,
  "hr-HR": $20c975671d6bbc63$exports,
  "hu-HU": $2569ca3917233115$exports,
  "it-IT": $caa152f7f8e96c85$exports,
  "ja-JP": $cbc6af0cc98fad10$exports,
  "ko-KR": $ad9be5d332b4d607$exports,
  "lt-LT": $659de19a00ff9617$exports,
  "lv-LV": $173e9fb4d14fe309$exports,
  "nb-NO": $d8e2640a066567a9$exports,
  "nl-NL": $d71fd764236c0d12$exports,
  "pl-PL": $f4ad3faf9f4aaec6$exports,
  "pt-BR": $9703be9d55d8e9c2$exports,
  "pt-PT": $7e23baec8a14f309$exports,
  "ro-RO": $568f95594049d56e$exports,
  "ru-RU": $625df06cecc70764$exports,
  "sk-SK": $b5a67525f3a2f594$exports,
  "sl-SI": $16125922964febca$exports,
  "sr-SP": $de104bf355206bcf$exports,
  "sv-SE": $d5ab76bcbadc9c07$exports,
  "tr-TR": $a6a1af5968159b55$exports,
  "uk-UA": $5204a30f0d17ffec$exports,
  "zh-CN": $8d15e736e12d3dfd$exports,
  "zh-TW": $f8c49dd804b75140$exports
};
function $848231d7a2b3998e$export$8cefe241bd876ca0(props) {
  let { "aria-label": ariaLabel, ...otherProps } = props;
  let strings = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault3($8229b34715874f89$exports)), "@react-aria/breadcrumbs");
  return {
    navProps: {
      ...(0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(otherProps, {
        labelable: true
      }),
      "aria-label": ariaLabel || strings.format("breadcrumbs")
    }
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-breadcrumbs.js
var import_react6 = __toESM(require_react());

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-folderClosedIcon.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime());
var folderClosedIcon = (0, import_jsx_runtime12.jsx)("path", {
  d: "M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2ZM2 10h20"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-folderOpenIcon.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime());
var folderOpenIcon = (0, import_jsx_runtime13.jsx)("path", {
  d: "m6 14 1.5-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.54 6a2 2 0 0 1-1.95 1.5H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H18a2 2 0 0 1 2 2v2"
});

// node_modules/@keystar/ui/dist/keystar-ui-breadcrumbs.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime());
var breadcrumbsClassList = new ClassList("Breadcrumbs", ["item", "link", "list", "separator"]);
function BreadcrumbItem(props) {
  let {
    children,
    isCurrent,
    isDisabled,
    size = "regular"
  } = props;
  let {
    direction
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let ref = (0, import_react6.useRef)(null);
  let {
    itemProps
  } = $dafd15390222438a$export$452b38fce62c9384({
    ...props,
    elementType: "span"
  }, ref);
  let {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456(props);
  let icon = (0, import_react6.useMemo)(() => {
    return direction === "rtl" ? chevronLeftIcon : chevronRightIcon;
  }, [direction]);
  return (0, import_jsx_runtime14.jsxs)(import_react6.Fragment, {
    children: [(0, import_jsx_runtime14.jsx)(FocusRing, {
      children: (0, import_jsx_runtime14.jsx)("span", {
        ...$3ef42575df84b30b$export$9d1611c77c2fe928(itemProps, hoverProps),
        ...toDataAttributes({
          size: size !== "regular" ? size : void 0,
          interaction: isHovered ? "hover" : void 0
        }),
        ref,
        className: classNames(breadcrumbsClassList.element("link"), css({
          color: tokenSchema.color.foreground.neutral,
          cursor: "default",
          fontSize: tokenSchema.typography.text.regular.size,
          fontFamily: tokenSchema.typography.fontFamily.base,
          fontWeight: tokenSchema.typography.fontWeight.medium,
          MozOsxFontSmoothing: "auto",
          WebkitFontSmoothing: "auto",
          "&[data-size=small]": {
            fontSize: tokenSchema.typography.text.small.size
          },
          "&[data-size=medium]": {
            fontSize: tokenSchema.typography.text.medium.size
          },
          "&[data-size=large]": {
            fontSize: tokenSchema.typography.text.large.size
          },
          "&:not([aria-current=page])": {
            "&:not([aria-disabled=true])": {
              cursor: "pointer"
            },
            "&[data-interaction=hover]": {
              color: tokenSchema.color.foreground.neutralEmphasis,
              textDecoration: "underline"
            },
            "&[aria-disabled=true]": {
              color: tokenSchema.color.alias.foregroundDisabled
            }
          },
          "&[aria-current=page]": {
            color: tokenSchema.color.foreground.neutralEmphasis,
            fontWeight: tokenSchema.typography.fontWeight.semibold,
            overflow: "hidden",
            textOverflow: "ellipsis"
          }
        }), {
          "is-hovered": isHovered
        }),
        children
      })
    }), !isCurrent && (0, import_jsx_runtime14.jsx)(Icon, {
      src: icon,
      color: isDisabled ? "color.alias.foregroundDisabled" : "neutralSecondary",
      marginX: "small",
      UNSAFE_className: breadcrumbsClassList.element("separator")
    })]
  });
}
var MIN_VISIBLE_ITEMS = 1;
var MAX_VISIBLE_ITEMS = 4;
function Breadcrumbs(props, ref) {
  props = useProviderProps(props);
  let {
    children,
    showRoot,
    size = "regular",
    isDisabled,
    onAction,
    ...otherProps
  } = props;
  let childArray = [];
  import_react6.Children.forEach(children, (child) => {
    if ((0, import_react6.isValidElement)(child)) {
      childArray.push(child);
    }
  });
  let domRef = $df56164dff5785e2$export$4338b53315abf666(ref);
  let listRef = (0, import_react6.useRef)(null);
  let [menuIsOpen, setMenuOpen] = (0, import_react6.useState)(false);
  let [visibleItems, setVisibleItems] = $1dbecbe27a04f9af$export$14d238f342723f25(childArray.length);
  let {
    navProps
  } = $848231d7a2b3998e$export$8cefe241bd876ca0(props);
  let styleProps = useStyleProps(otherProps);
  let updateOverflow = (0, import_react6.useCallback)(() => {
    let computeVisibleItems = (visibleItems2) => {
      let currListRef = listRef.current;
      if (!currListRef) {
        return;
      }
      let listItems = Array.from(currListRef.children);
      let containerWidth = currListRef.offsetWidth;
      let isShowingMenu = childArray.length > visibleItems2;
      let calculatedWidth = 0;
      let newVisibleItems = 0;
      let maxVisibleItems = MAX_VISIBLE_ITEMS;
      if (showRoot) {
        let el = listItems.shift();
        if (el) {
          calculatedWidth += el.offsetWidth;
          newVisibleItems++;
        }
      }
      if (isShowingMenu) {
        let el = listItems.shift();
        if (el) {
          calculatedWidth += el.offsetWidth;
          maxVisibleItems--;
        }
      }
      if (showRoot && calculatedWidth >= containerWidth) {
        newVisibleItems--;
      }
      if (listItems.length > 0) {
        let last = listItems.pop();
        if (last) {
          last.style.overflow = "visible";
          calculatedWidth += last.offsetWidth;
          if (calculatedWidth < containerWidth) {
            newVisibleItems++;
          }
          last.style.overflow = "";
        }
      }
      for (let breadcrumb of listItems.reverse()) {
        calculatedWidth += breadcrumb.offsetWidth;
        if (calculatedWidth < containerWidth) {
          newVisibleItems++;
        }
      }
      return Math.max(MIN_VISIBLE_ITEMS, Math.min(maxVisibleItems, newVisibleItems));
    };
    setVisibleItems(function* () {
      yield childArray.length;
      let newVisibleItems = computeVisibleItems(childArray.length);
      yield newVisibleItems;
      if (isNumber(newVisibleItems) && newVisibleItems < childArray.length && newVisibleItems > 1) {
        yield computeVisibleItems(newVisibleItems);
      }
    });
  }, [childArray.length, setVisibleItems, showRoot]);
  $9daab02d461809db$export$683480f191c0e3ea({
    ref: domRef,
    onResize: updateOverflow
  });
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(updateOverflow, [children]);
  let contents = childArray;
  if (childArray.length > visibleItems) {
    var _selectedItem$key;
    let selectedItem = childArray[childArray.length - 1];
    let selectedKey = (_selectedItem$key = selectedItem.key) !== null && _selectedItem$key !== void 0 ? _selectedItem$key : childArray.length - 1;
    let onMenuAction = (key) => {
      if (key !== selectedKey && onAction) {
        onAction(key);
      }
    };
    let menuItem = (0, import_jsx_runtime14.jsx)(BreadcrumbItem, {
      children: (0, import_jsx_runtime14.jsxs)(MenuTrigger, {
        onOpenChange: setMenuOpen,
        children: [(0, import_jsx_runtime14.jsx)(ActionButton, {
          "aria-label": "…",
          prominence: "low",
          isDisabled,
          children: (0, import_jsx_runtime14.jsx)(Icon, {
            src: menuIsOpen ? folderOpenIcon : folderClosedIcon
          })
        }), (0, import_jsx_runtime14.jsx)(_Menu, {
          selectionMode: "single",
          selectedKeys: [selectedKey],
          onAction: onMenuAction,
          children: childArray
        })]
      })
    }, "menu");
    contents = [menuItem];
    let breadcrumbs = [...childArray];
    let endItems = visibleItems;
    if (showRoot && visibleItems > 1) {
      let el = breadcrumbs.shift();
      if (el) {
        contents.unshift(el);
        endItems--;
      }
    }
    contents.push(...breadcrumbs.slice(-endItems));
  }
  let lastIndex = contents.length - 1;
  let breadcrumbItems = contents.map((child, index) => {
    var _child$key;
    let isCurrent = index === lastIndex;
    let key = (_child$key = child.key) !== null && _child$key !== void 0 ? _child$key : index;
    let onPress = () => {
      if (onAction) {
        onAction(key);
      }
    };
    return (0, import_jsx_runtime14.jsx)("li", {
      className: classNames(breadcrumbsClassList.element("item"), css({
        alignItems: "center",
        display: "inline-flex",
        whiteSpace: "nowrap",
        "&:last-child": {
          overflow: "hidden"
        }
      })),
      children: (0, import_jsx_runtime14.jsx)(BreadcrumbItem, {
        isCurrent,
        isDisabled,
        onPress,
        size,
        children: child.props.children
      }, key)
    }, index);
  });
  return (0, import_jsx_runtime14.jsx)("nav", {
    ...navProps,
    ...styleProps,
    ref: domRef,
    className: classNames(breadcrumbsClassList.element("root"), styleProps.className),
    children: (0, import_jsx_runtime14.jsx)("ul", {
      ref: listRef,
      className: classNames(breadcrumbsClassList.element("list"), css({
        display: "flex",
        height: tokenSchema.size.element.regular,
        justifyContent: "flex-start"
      })),
      children: breadcrumbItems
    })
  });
}
var _Breadcrumbs = (0, import_react6.forwardRef)(Breadcrumbs);

// node_modules/@keystar/ui/dist/keystar-ui-notice.js
var import_react7 = __toESM(require_react());
var import_jsx_runtime15 = __toESM(require_jsx_runtime());
var noticeClassList = new ClassList("Notice", ["heading"]);
var toneToIcon = {
  caution: alertTriangleIcon,
  critical: alertTriangleIcon,
  neutral: infoIcon,
  positive: checkCircle2Icon
};
var toneToRole = {
  caution: "alert",
  critical: "alert",
  neutral: "status",
  positive: "status"
};
function Notice(props) {
  const {
    children,
    tone = "neutral",
    ...otherProps
  } = props;
  const ref = (0, import_react7.useRef)(null);
  const styleProps = useStyleProps(otherProps);
  const headingClassName = noticeClassList.element("heading");
  const headingId = $bdb11010cef70236$export$b4cc09c592e8fdb8();
  const contentId = $bdb11010cef70236$export$b4cc09c592e8fdb8();
  const hasHeading = useHasChild(noticeClassList.selector("heading"), ref);
  const coercedTone = tone === "neutral" ? "accent" : tone;
  const icon = toneToIcon[tone];
  const contentStyles = css({
    display: "grid",
    gap: tokenSchema.size.space.large
  });
  const slots = (0, import_react7.useMemo)(() => ({
    content: {
      elementType: "div",
      gridArea: hasHeading ? "content" : "heading-start / heading-start / content-end / content-end",
      id: contentId,
      paddingY: hasHeading ? "regular" : void 0,
      UNSAFE_className: contentStyles
    },
    heading: {
      elementType: "div",
      gridArea: "heading",
      id: headingId,
      UNSAFE_className: headingClassName,
      size: "small"
    },
    text: {
      color: coercedTone,
      weight: "medium"
    }
  }), [coercedTone, contentId, contentStyles, hasHeading, headingClassName, headingId]);
  return (0, import_jsx_runtime15.jsxs)(Grid, {
    "aria-live": "polite",
    "aria-labelledby": headingId,
    "aria-describedby": contentId,
    role: toneToRole[tone],
    ref,
    tabIndex: 0,
    UNSAFE_className: styleProps.className,
    UNSAFE_style: styleProps.style,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
    // appearance
    backgroundColor: coercedTone,
    border: coercedTone,
    borderRadius: "medium",
    minWidth: 0,
    padding: "medium",
    width: "100%",
    alignItems: "center",
    areas: ["icon heading", "icon content"],
    columnGap: "medium",
    columns: ["icon.medium", "auto"],
    rows: `${minmax("icon.medium", "auto")} auto`,
    children: [(0, import_jsx_runtime15.jsx)(Icon, {
      src: icon,
      size: "medium",
      color: coercedTone,
      gridArea: "icon",
      alignSelf: "start"
    }), (0, import_jsx_runtime15.jsx)(SlotProvider, {
      slots,
      children: isReactText(children) ? (0, import_jsx_runtime15.jsx)(Content, {
        children: (0, import_jsx_runtime15.jsx)(Text, {
          children
        })
      }) : children
    })]
  });
}

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-copyPlusIcon.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime());
var copyPlusIcon = (0, import_jsx_runtime16.jsxs)(import_jsx_runtime16.Fragment, {
  children: [(0, import_jsx_runtime16.jsx)("path", {
    d: "M15 12v6M12 15h6"
  }), (0, import_jsx_runtime16.jsx)("rect", {
    width: 14,
    height: 14,
    x: 8,
    y: 8,
    rx: 2,
    ry: 2
  }), (0, import_jsx_runtime16.jsx)("path", {
    d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-historyIcon.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime());
var historyIcon = (0, import_jsx_runtime17.jsxs)(import_jsx_runtime17.Fragment, {
  children: [(0, import_jsx_runtime17.jsx)("path", {
    d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"
  }), (0, import_jsx_runtime17.jsx)("path", {
    d: "M3 3v5h5M12 7v5l4 2"
  })]
});

// node_modules/@urql/exchange-graphcache/dist/urql-exchange-graphcache.mjs
var h = "\nhttps://bit.ly/2XbVrpR#";
var m = /* @__PURE__ */ new Set();
var g = [];
var popDebugNode = () => g.pop();
var pushDebugNode = (e2, r3) => {
  var t = "";
  if (r3.kind === e.INLINE_FRAGMENT) {
    t = e2 ? `Inline Fragment on "${e2}"` : "Inline Fragment";
  } else if (r3.kind === e.OPERATION_DEFINITION) {
    t = `${r3.name ? `"${r3.name.value}"` : "Unnamed"} ${r3.operation}`;
  } else if (r3.kind === e.FRAGMENT_DEFINITION) {
    t = `"${r3.name.value}" Fragment`;
  }
  if (t) {
    g.push(t);
  }
};
var getDebugOutput = () => g.length ? "\n(Caused At: " + g.join(", ") + ")" : "";
function invariant(e2, r3, t) {
  if (!e2) {
    var a = r3 || "Minfied Error #" + t + "\n";
    if (true) {
      a += getDebugOutput();
    }
    var i = new Error(a + h + t);
    i.name = "Graphcache Error";
    throw i;
  }
}
function warn(e2, r3, t) {
  if (!m.has(e2)) {
    if (t) {
      t("warn", e2 + getDebugOutput() + h + r3);
    } else {
      console.warn(e2 + getDebugOutput() + h + r3);
    }
    m.add(e2);
  }
}
var N = {};
var getDirectives = (e2) => e2._directives || N;
var getName = (e2) => e2.name.value;
var getFragmentTypeName = (e2) => e2.typeCondition.name.value;
var getFieldAlias = (e2) => e2.alias ? e2.alias.value : e2.name.value;
var _ = [];
var getSelectionSet = (e2) => e2.selectionSet ? e2.selectionSet.selections : _;
var getTypeCondition = (e2) => e2.typeCondition ? e2.typeCondition.name.value : null;
var getFieldArguments = (e2, r3) => {
  var t = null;
  if (e2.arguments) {
    for (var a = 0, i = e2.arguments.length; a < i; a++) {
      var n = e2.arguments[a];
      var s = valueFromASTUntyped(n.value, r3);
      if (null != s) {
        if (!t) {
          t = {};
        }
        t[getName(n)] = s;
      }
    }
  }
  return t;
};
var filterVariables = (e2, r3) => {
  if (!r3 || !e2.variableDefinitions) {
    return;
  }
  var t = {};
  for (var a = 0, i = e2.variableDefinitions.length; a < i; a++) {
    var n = getName(e2.variableDefinitions[a].variable);
    t[n] = r3[n];
  }
  return t;
};
var normalizeVariables = (e2, r3) => {
  var t = {};
  if (!r3) {
    return t;
  }
  if (e2.variableDefinitions) {
    for (var a = 0, i = e2.variableDefinitions.length; a < i; a++) {
      var n = e2.variableDefinitions[a];
      var s = getName(n.variable);
      t[s] = void 0 === r3[s] && n.defaultValue ? valueFromASTUntyped(n.defaultValue, r3) : r3[s];
    }
  }
  for (var l in r3) {
    if (!(l in t)) {
      t[l] = r3[l];
    }
  }
  return t;
};
function getMainOperation(e2) {
  for (var r3 = 0; r3 < e2.definitions.length; r3++) {
    if (e2.definitions[r3].kind === e.OPERATION_DEFINITION) {
      return e2.definitions[r3];
    }
  }
  invariant(false, true ? "Invalid GraphQL document: All GraphQL documents must contain an OperationDefinitionnode for a query, subscription, or mutation." : "", 1);
}
var getFragments = (e2) => {
  var r3 = {};
  for (var t = 0; t < e2.definitions.length; t++) {
    var a = e2.definitions[t];
    if (a.kind === e.FRAGMENT_DEFINITION) {
      r3[getName(a)] = a;
    }
  }
  return r3;
};
var shouldInclude = (e2, r3) => {
  var t = getDirectives(e2);
  if (t.include || t.skip) {
    for (var a in t) {
      var i = t[a];
      if (i && ("include" === a || "skip" === a) && i.arguments && i.arguments[0] && "if" === getName(i.arguments[0])) {
        var n = valueFromASTUntyped(i.arguments[0].value, r3);
        return "include" === a ? !!n : !n;
      }
    }
  }
  return true;
};
var isDeferred = (e2, r3) => {
  var { defer: t } = getDirectives(e2);
  if (t) {
    for (var a of t.arguments || []) {
      if ("if" === getName(a)) {
        return !!valueFromASTUntyped(a.value, r3);
      }
    }
    return true;
  }
  return false;
};
var k = "__";
var isFieldNullable = (e2, r3, t, a) => {
  var i = getField(e2, r3, t, a);
  return !!i && "NON_NULL" !== i.type.kind;
};
var isListNullable = (e2, r3, t, a) => {
  var i = getField(e2, r3, t, a);
  if (!i) {
    return false;
  }
  var n = "NON_NULL" === i.type.kind ? i.type.ofType : i.type;
  return "LIST" === n.kind && "NON_NULL" !== n.ofType.kind;
};
var isFieldAvailableOnType = (e2, r3, t, a) => 0 === t.indexOf(k) || 0 === r3.indexOf(k) || !!getField(e2, r3, t, a);
var isInterfaceOfType = (e2, r3, t) => {
  if (!t) {
    return false;
  }
  var a = getTypeCondition(r3);
  if (!a || t === a) {
    return true;
  } else if (e2.types.has(a) && "OBJECT" === e2.types.get(a).kind) {
    return a === t;
  }
  !function expectAbstractType(e3, r4) {
    invariant(e3.types.has(r4) && ("INTERFACE" === e3.types.get(r4).kind || "UNION" === e3.types.get(r4).kind), true ? "Invalid Abstract type: The type `" + r4 + "` is not an Interface or Union type in the defined schema, but a fragment in the GraphQL document is using it as a type condition." : "", 5);
  }(e2, a);
  expectObjectType(e2, t);
  return e2.isSubType(a, t);
};
var getField = (e2, r3, t, a) => {
  if (0 === t.indexOf(k) || 0 === r3.indexOf(k)) {
    return;
  }
  expectObjectType(e2, r3);
  var i = e2.types.get(r3).fields()[t];
  if (true) {
    if (!i) {
      warn("Invalid field: The field `" + t + "` does not exist on `" + r3 + "`, but the GraphQL document expects it to exist.\nTraversal will continue, however this may lead to undefined behavior!", 4, a);
    }
  }
  return i;
};
function expectObjectType(e2, r3) {
  invariant(e2.types.has(r3) && "OBJECT" === e2.types.get(r3).kind, true ? "Invalid Object type: The type `" + r3 + "` is not an object in the defined schema, but the GraphQL document is traversing it." : "", 3);
}
function warnAboutResolver(e2, r3) {
  warn(`Invalid resolver: \`${e2}\` is not in the defined schema, but the \`resolvers\` option is referencing it.`, 23, r3);
}
function warnAboutAbstractResolver(e2, r3, t) {
  warn(`Invalid resolver: \`${e2}\` does not match to a concrete type in the schema, but the \`resolvers\` option is referencing it. Implement the resolver for the types that ${"UNION" === r3 ? "make up the union" : "implement the interface"} instead.`, 26, t);
}
var keyOfField = (r3, t) => t ? `${r3}(${stringifyVariables(t)})` : r3;
var joinKeys = (e2, r3) => `${e2}.${r3}`;
var fieldInfoOfKey = (e2) => {
  var r3 = e2.indexOf("(");
  if (r3 > -1) {
    return {
      fieldKey: e2,
      fieldName: e2.slice(0, r3),
      arguments: JSON.parse(e2.slice(r3 + 1, -1))
    };
  } else {
    return {
      fieldKey: e2,
      fieldName: e2,
      arguments: null
    };
  }
};
var deserializeKeyInfo = (e2) => {
  var r3 = e2.indexOf(".");
  return {
    entityKey: e2.slice(0, r3).replace(/%2e/g, "."),
    fieldKey: e2.slice(r3 + 1)
  };
};
var E = null;
var O = null;
var w = null;
var b = null;
var D = null;
var x = null;
var V = false;
var I = false;
function makeData(e2, r3) {
  var t;
  if (e2) {
    if (E.has(e2)) {
      return e2;
    }
    t = O.get(e2);
  }
  if (null == t) {
    t = r3 ? [] : {};
  }
  if (e2) {
    O.set(e2, t);
  }
  E.add(t);
  return t;
}
var ownsData = (e2) => !!e2 && E.has(e2);
var initDataState = (e2, r3, t, a, i) => {
  E = /* @__PURE__ */ new WeakSet();
  O = /* @__PURE__ */ new WeakMap();
  D = e2;
  w = r3;
  x = /* @__PURE__ */ new Set();
  I = !!a;
  V = !!i;
  if (true) {
    g.length = 0;
  }
  if (!t) {
    b = null;
  } else if ("read" === D) {
    b = t;
  } else if (a || r3.hydrating || r3.optimisticOrder.length > 1) {
    if (!a && !r3.commutativeKeys.has(t)) {
      reserveLayer(r3, t);
    } else if (a) {
      if (-1 !== r3.optimisticOrder.indexOf(t) && !r3.commutativeKeys.has(t)) {
        r3.optimisticOrder.splice(r3.optimisticOrder.indexOf(t), 1);
      }
      r3.commutativeKeys.delete(t);
    }
    b = t;
    createLayer(r3, t);
  } else {
    b = null;
    deleteLayer(r3, t);
  }
};
var clearDataState = () => {
  if (true) {
    getCurrentDependencies();
  }
  var e2 = w;
  var r3 = b;
  I = false;
  b = null;
  if (!e2.hydrating && r3 && e2.optimisticOrder.indexOf(r3) > -1) {
    var t = e2.optimisticOrder.length;
    while (--t >= 0 && e2.dirtyKeys.has(e2.optimisticOrder[t]) && e2.commutativeKeys.has(e2.optimisticOrder[t])) {
      squashLayer(e2.optimisticOrder[t]);
    }
  }
  E = null;
  O = null;
  D = null;
  w = null;
  x = null;
  if (true) {
    g.length = 0;
  }
  if (true) {
    if (!e2.defer && (e2.storage || !e2.optimisticOrder.length)) {
      e2.defer = true;
      setTimeout(() => {
        initDataState("read", e2, null);
        gc();
        persistData();
        clearDataState();
        e2.defer = false;
      });
    }
  }
};
var noopDataState = (e2, r3, t) => {
  if (r3 && !t) {
    e2.deferredKeys.delete(r3);
  }
  initDataState("write", e2, r3, t);
  clearDataState();
};
var getCurrentDependencies = () => {
  invariant(null !== x, true ? "Invalid Cache call: The cache may only be accessed or mutated duringoperations like write or query, or as part of its resolvers, updaters, or optimistic configs." : "", 2);
  return x;
};
var setNode = (e2, r3, t, a) => {
  if (true) {
    invariant("read" !== D, true ? "Invalid Cache write: You may not write to the cache during cache reads.  Accesses to `cache.writeFragment`, `cache.updateQuery`, and `cache.link` may  not be made inside `resolvers` for instance." : "", 27);
  }
  var i = b ? e2.optimistic.get(b) : e2.base;
  var n = i.get(r3);
  if (void 0 === n) {
    i.set(r3, n = /* @__PURE__ */ Object.create(null));
  }
  if (void 0 === a && !b) {
    delete n[t];
  } else {
    n[t] = a;
  }
};
var getNode = (e2, r3, t) => {
  var a;
  var i = !I && "read" === D && b && w.commutativeKeys.has(b);
  for (var n = 0, o = w.optimisticOrder.length; n < o; n++) {
    var s = w.optimisticOrder[n];
    var l = e2.optimistic.get(s);
    i = i && s !== b;
    if (l && (!i || !w.commutativeKeys.has(s)) && (!I || "write" === D || w.commutativeKeys.has(s)) && void 0 !== (a = l.get(r3)) && t in a) {
      return a[t];
    }
  }
  return void 0 !== (a = e2.base.get(r3)) ? a[t] : void 0;
};
var updateRCForLink = (e2, r3) => {
  if (Array.isArray(e2)) {
    for (var t = 0, a = e2.length; t < a; t++) {
      updateRCForLink(e2[t], r3);
    }
  } else if ("string" == typeof e2) {
    ((e3, r4) => {
      var t2 = w.refCount.get(e3) || 0;
      var a2 = t2 + r4 > 0 ? t2 + r4 : 0;
      w.refCount.set(e3, a2);
      if (!a2) {
        w.gc.add(e3);
      } else if (!t2 && a2) {
        w.gc.delete(e3);
      }
    })(e2, r3);
  }
};
var extractNodeFields = (e2, r3, t) => {
  if (void 0 !== t) {
    for (var a in t) {
      if (!r3.has(a)) {
        e2.push(fieldInfoOfKey(a));
        r3.add(a);
      }
    }
  }
};
var extractNodeMapFields = (e2, r3, t, a) => {
  extractNodeFields(e2, r3, a.base.get(t));
  for (var i = 0, n = w.optimisticOrder.length; i < n; i++) {
    var o = a.optimistic.get(w.optimisticOrder[i]);
    if (void 0 !== o) {
      extractNodeFields(e2, r3, o.get(t));
    }
  }
};
var gc = () => {
  if (w.optimisticOrder.length) {
    return;
  }
  for (var e2 of w.gc.keys()) {
    w.gc.delete(e2);
    if ((w.refCount.get(e2) || 0) > 0) {
      continue;
    }
    w.refCount.delete(e2);
    w.records.base.delete(e2);
    var r3 = w.links.base.get(e2);
    if (r3) {
      w.links.base.delete(e2);
      for (var t in r3) {
        updateRCForLink(r3[t], -1);
      }
    }
  }
};
var updateDependencies = (e2, r3) => {
  if (e2 !== w.queryRootKey) {
    x.add(e2);
  } else if (void 0 !== r3 && "__typename" !== r3) {
    x.add(joinKeys(e2, r3));
  }
};
var updatePersist = (e2, r3) => {
  if (!I && w.storage) {
    w.persist.add(((e3, r4) => `${e3.replace(/\./g, "%2e")}.${r4}`)(e2, r3));
  }
};
var readRecord = (e2, r3) => {
  updateDependencies(e2, r3);
  return getNode(w.records, e2, r3);
};
var readLink = (e2, r3) => {
  updateDependencies(e2, r3);
  return getNode(w.links, e2, r3);
};
var writeRecord = (e2, r3, t) => {
  updateDependencies(e2, r3);
  updatePersist(e2, r3);
  setNode(w.records, e2, r3, t);
};
var hasField = (e2, r3) => void 0 !== readRecord(e2, r3) || void 0 !== readLink(e2, r3);
var writeLink = (e2, r3, t) => {
  var a = b ? w.links.optimistic.get(b) : w.links.base;
  if (!b) {
    var i = a && a.get(e2);
    updateRCForLink(i && i[r3], -1);
    updateRCForLink(t, 1);
  }
  updateDependencies(e2, r3);
  updatePersist(e2, r3);
  setNode(w.links, e2, r3, t);
};
var reserveLayer = (e2, r3, t) => {
  var a = e2.optimisticOrder.indexOf(r3);
  if (a > -1) {
    e2.optimisticOrder.splice(a, 1);
  }
  if (t) {
    e2.deferredKeys.add(r3);
    for (a = a > -1 ? a : 0; a < e2.optimisticOrder.length && !e2.deferredKeys.has(e2.optimisticOrder[a]) && (!e2.dirtyKeys.has(e2.optimisticOrder[a]) || !e2.commutativeKeys.has(e2.optimisticOrder[a])); a++) {
    }
  } else {
    e2.deferredKeys.delete(r3);
    if (a > -1 && !e2.commutativeKeys.has(r3)) {
      clearLayer(e2, r3);
    }
    a = 0;
  }
  e2.optimisticOrder.splice(a, 0, r3);
  e2.commutativeKeys.add(r3);
};
var createLayer = (e2, r3) => {
  if (-1 === e2.optimisticOrder.indexOf(r3)) {
    e2.optimisticOrder.unshift(r3);
  }
  if (!e2.dirtyKeys.has(r3)) {
    e2.dirtyKeys.add(r3);
    e2.links.optimistic.set(r3, /* @__PURE__ */ new Map());
    e2.records.optimistic.set(r3, /* @__PURE__ */ new Map());
  }
};
var clearLayer = (e2, r3) => {
  if (e2.dirtyKeys.has(r3)) {
    e2.dirtyKeys.delete(r3);
    e2.records.optimistic.delete(r3);
    e2.links.optimistic.delete(r3);
    e2.deferredKeys.delete(r3);
  }
};
var deleteLayer = (e2, r3) => {
  var t = e2.optimisticOrder.indexOf(r3);
  if (t > -1) {
    e2.optimisticOrder.splice(t, 1);
    e2.commutativeKeys.delete(r3);
  }
  clearLayer(e2, r3);
};
var squashLayer = (e2) => {
  var r3 = x;
  x = /* @__PURE__ */ new Set();
  D = "write";
  var t = w.links.optimistic.get(e2);
  if (t) {
    for (var a of t.entries()) {
      var i = a[0];
      var n = a[1];
      for (var o in n) {
        writeLink(i, o, n[o]);
      }
    }
  }
  var s = w.records.optimistic.get(e2);
  if (s) {
    for (var l of s.entries()) {
      var v = l[0];
      var d2 = l[1];
      for (var u in d2) {
        writeRecord(v, u, d2[u]);
      }
    }
  }
  x = r3;
  deleteLayer(w, e2);
};
var inspectFields = (e2) => {
  var { links: r3, records: t } = w;
  var a = [];
  var i = /* @__PURE__ */ new Set();
  updateDependencies(e2);
  extractNodeMapFields(a, i, e2, r3);
  extractNodeMapFields(a, i, e2, t);
  return a;
};
var persistData = () => {
  if (w.storage) {
    I = true;
    D = "read";
    var r3 = {};
    for (var t of w.persist.keys()) {
      var { entityKey: a, fieldKey: i } = deserializeKeyInfo(t);
      var n = void 0;
      if (void 0 !== (n = readLink(a, i))) {
        r3[t] = `:${stringifyVariables(n)}`;
      } else if (void 0 !== (n = readRecord(a, i))) {
        r3[t] = stringifyVariables(n);
      } else {
        r3[t] = void 0;
      }
    }
    I = false;
    w.storage.writeData(r3);
    w.persist.clear();
  }
};
var q = null;
var T = false;
var getFieldError = (e2) => e2.__internal.path.length > 0 && e2.__internal.errorMap ? e2.__internal.errorMap[e2.__internal.path.join(".")] : void 0;
var makeContext = (e2, r3, t, a, i, n) => {
  T = false;
  var o = {
    store: e2,
    variables: r3,
    fragments: t,
    parent: {
      __typename: a
    },
    parentTypeName: a,
    parentKey: i,
    parentFieldKey: "",
    fieldName: "",
    error: void 0,
    partial: false,
    hasNext: false,
    optimistic: I,
    __internal: {
      path: [],
      errorMap: void 0
    }
  };
  if (n && n.graphQLErrors) {
    for (var s = 0; s < n.graphQLErrors.length; s++) {
      var l = n.graphQLErrors[s];
      if (l.path && l.path.length) {
        if (!o.__internal.errorMap) {
          o.__internal.errorMap = /* @__PURE__ */ Object.create(null);
        }
        o.__internal.errorMap[l.path.join(".")] = l;
      }
    }
  }
  return o;
};
var updateContext = (e2, r3, t, a, i, n) => {
  q = e2;
  e2.parent = r3;
  e2.parentTypeName = t;
  e2.parentKey = a;
  e2.parentFieldKey = i;
  e2.fieldName = n;
  e2.error = getFieldError(e2);
};
var isFragmentHeuristicallyMatching = (e2, r3, t, a, i) => {
  if (!r3) {
    return false;
  }
  var o = getTypeCondition(e2);
  if (!o || r3 === o) {
    return true;
  }
  warn("Heuristic Fragment Matching: A fragment is trying to match against the `" + r3 + "` type, but the type condition is `" + o + "`. Since GraphQL allows for interfaces `" + o + "` may be an interface.\nA schema needs to be defined for this match to be deterministic, otherwise the fragment will be matched heuristically!", 16, i);
  return "write" === D || !getSelectionSet(e2).some((e3) => {
    if (e3.kind !== e.FIELD) {
      return false;
    }
    var r4 = keyOfField(getName(e3), getFieldArguments(e3, a));
    return !hasField(t, r4);
  });
};
var makeSelectionIterator = (e2, r3, t, a, i) => {
  var o;
  var s = 0;
  return function next() {
    var l;
    while (o || s < a.length) {
      l = void 0;
      T = t;
      if (o) {
        if (l = o()) {
          return l;
        } else {
          o = void 0;
          if (true) {
            popDebugNode();
          }
        }
      } else {
        var v = a[s++];
        if (!shouldInclude(v, i.variables)) {
        } else if (v.kind !== e.FIELD) {
          var d2 = v.kind !== e.INLINE_FRAGMENT ? i.fragments[getName(v)] : v;
          if (d2) {
            if (!d2.typeCondition || (i.store.schema ? isInterfaceOfType(i.store.schema, d2, e2) : isFragmentHeuristicallyMatching(d2, e2, r3, i.variables, i.store.logger))) {
              if (true) {
                pushDebugNode(e2, d2);
              }
              o = makeSelectionIterator(e2, r3, t || isDeferred(v, i.variables), getSelectionSet(d2), i);
            }
          }
        } else if ("write" === D || !v._generated) {
          return v;
        }
      }
    }
  };
};
var ensureData = (e2) => null == e2 ? null : e2;
var ensureLink = (e2, r3) => {
  if (!r3) {
    return r3 || null;
  } else if (Array.isArray(r3)) {
    var t = new Array(r3.length);
    for (var a = 0, i = t.length; a < i; a++) {
      t[a] = ensureLink(e2, r3[a]);
    }
    return t;
  }
  var n = e2.keyOfEntity(r3);
  if (true) {
    if (!n && r3 && "object" == typeof r3) {
      warn("Can't generate a key for link(...) item.\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `" + r3.__typename + "`.", 12, e2.logger);
    }
  }
  return n;
};
var _query = (e2, t, a, i) => {
  var n = formatDocument(t.query);
  var o = getMainOperation(n);
  var s = e2.rootFields[o.operation];
  var l = getSelectionSet(o);
  var v = makeContext(e2, normalizeVariables(o, t.variables), getFragments(n), s, s, i);
  if (true) {
    pushDebugNode(s, o);
  }
  var d2 = s !== v.store.rootFields.query ? readRoot(v, s, l, a || makeData()) : readSelection(v, s, l, a || makeData());
  if (true) {
    popDebugNode();
    getCurrentDependencies();
  }
  return {
    dependencies: x,
    partial: v.partial || !d2,
    hasNext: v.hasNext,
    data: d2 || null
  };
};
var readRoot = (e2, r3, t, a) => {
  if ("string" != typeof (e2.store.rootNames[r3] ? r3 : a.__typename)) {
    return a;
  }
  var i = makeSelectionIterator(r3, r3, T, t, e2);
  var n;
  var o = V;
  var s = makeData(a);
  while (n = i()) {
    var l = getFieldAlias(n);
    var v = a[l];
    e2.__internal.path.push(l);
    var d2 = void 0;
    if (n.selectionSet && null !== v) {
      d2 = readRootField(e2, getSelectionSet(n), ensureData(v));
    } else {
      d2 = v;
    }
    o = o || d2 !== v;
    if (void 0 !== d2) {
      s[l] = d2;
    }
    e2.__internal.path.pop();
  }
  return o ? s : a;
};
var readRootField = (e2, r3, t) => {
  if (Array.isArray(t)) {
    var a = new Array(t.length);
    var i = V;
    for (var n = 0, o = t.length; n < o; n++) {
      e2.__internal.path.push(n);
      a[n] = readRootField(e2, r3, t[n]);
      i = i || a[n] !== t[n];
      e2.__internal.path.pop();
    }
    return i ? a : t;
  } else if (null === t) {
    return null;
  }
  var s = e2.store.keyOfEntity(t);
  if (null !== s) {
    return readSelection(e2, s, r3, t) || null;
  } else {
    return readRoot(e2, t.__typename, r3, t);
  }
};
function getFieldResolver(e2, r3, t, a) {
  var i = a.store.resolvers[r3];
  var n = i && i[t];
  var o;
  for (var s in e2) {
    var l = e2[s];
    if (l && "include" !== s && "skip" !== s && a.store.directives[s]) {
      o = a.store.directives[s](getFieldArguments(l, a.variables));
      if (false) {
        return o;
      }
      break;
    }
  }
  if (true) {
    if (n && o) {
      warn(`A resolver and directive is being used at "${r3}.${t}" simultaneously. Only the directive will apply.`, 28, a.store.logger);
    }
  }
  return o || n;
}
var readSelection = (e2, r3, t, a, i) => {
  var { store: n } = e2;
  var o = r3 === n.rootFields.query;
  var s = i && n.keyOfEntity(i) || r3;
  if (true) {
    if (!o && e2.store.rootNames[s]) {
      warn("Invalid root traversal: A selection was being read on `" + s + "` which is an uncached root type.\nThe `" + e2.store.rootFields.mutation + "` and `" + e2.store.rootFields.subscription + "` types are special Operation Root Types and cannot be read back from the cache.", 25, n.logger);
    }
  }
  var l = !o ? readRecord(s, "__typename") || i && i.__typename : r3;
  if ("string" != typeof l) {
    return;
  } else if (i && l !== i.__typename) {
    warn("Invalid resolver data: The resolver at `" + s + "` returned an invalid typename that could not be reconciled with the cache.", 8, n.logger);
    return;
  }
  var v = makeSelectionIterator(l, s, T, t, e2);
  var d2 = false;
  var u = false;
  var c = V;
  var p2;
  var f2 = e2.partial;
  var y = makeData(a);
  while (void 0 !== (p2 = v())) {
    var h2 = getName(p2);
    var m2 = getFieldArguments(p2, e2.variables);
    var g2 = getFieldAlias(p2);
    var N2 = getDirectives(p2);
    var _2 = getFieldResolver(N2, l, h2, e2);
    var k2 = keyOfField(h2, m2);
    var E2 = joinKeys(s, k2);
    var O2 = readRecord(s, k2);
    var w2 = i ? i[h2] : void 0;
    if (n.schema && l) {
      isFieldAvailableOnType(n.schema, l, h2, e2.store.logger);
    }
    e2.__internal.path.push(g2);
    var b2 = void 0;
    if ("__typename" === h2) {
      b2 = l;
    } else if (void 0 !== w2 && void 0 === p2.selectionSet) {
      b2 = w2;
    } else if ("read" === D && _2) {
      var x2 = y;
      if (void 0 === p2.selectionSet && void 0 !== O2) {
        x2 = {
          ...y,
          [g2]: O2,
          [h2]: O2
        };
      }
      updateContext(e2, x2, l, s, k2, h2);
      b2 = _2(x2, m2 || {}, n, e2);
      if (p2.selectionSet) {
        b2 = resolveResolverResult(e2, l, h2, E2, getSelectionSet(p2), void 0 !== y[g2] ? y[g2] : a[g2], b2, ownsData(a));
      }
      if (n.schema && null === b2 && !isFieldNullable(n.schema, l, h2, e2.store.logger)) {
        return;
      }
    } else if (!p2.selectionSet) {
      b2 = O2;
    } else if (void 0 !== w2) {
      b2 = resolveResolverResult(e2, l, h2, E2, getSelectionSet(p2), void 0 !== y[g2] ? y[g2] : a[g2], w2, ownsData(a));
    } else {
      var I2 = readLink(s, k2);
      if (void 0 !== I2) {
        b2 = resolveLink(e2, I2, l, h2, getSelectionSet(p2), void 0 !== y[g2] ? y[g2] : a[g2], ownsData(a));
      } else if ("object" == typeof O2 && null !== O2) {
        b2 = O2;
      }
    }
    if (!T && void 0 === b2 && (N2.optional || getFieldError(e2) || n.schema && isFieldNullable(n.schema, l, h2, e2.store.logger))) {
      e2.partial = true;
      b2 = null;
    } else if (null === b2 && N2.required) {
      if (e2.store.logger && true && "read" === D) {
        e2.store.logger("debug", `Got value "null" for required field "${h2}"${m2 ? ` with args ${JSON.stringify(m2)}` : ""} on entity "${s}"`);
      }
      b2 = void 0;
    } else {
      d2 = d2 || "__typename" !== h2;
    }
    e2.__internal.path.pop();
    c = c || b2 !== a[g2];
    if (void 0 !== b2) {
      y[g2] = b2;
    } else if (T) {
      u = true;
    } else {
      if (e2.store.logger && true && "read" === D) {
        e2.store.logger("debug", `No value for field "${h2}"${m2 ? ` with args ${JSON.stringify(m2)}` : ""} on entity "${s}"`);
      }
      e2.partial = f2;
      return;
    }
  }
  e2.partial = e2.partial || f2;
  e2.hasNext = e2.hasNext || u;
  return o && e2.partial && !d2 ? void 0 : c ? y : a;
};
var resolveResolverResult = (e2, r3, t, a, i, n, o, s) => {
  if (Array.isArray(o)) {
    var { store: l } = e2;
    var v = l.schema ? isListNullable(l.schema, r3, t, e2.store.logger) : false;
    var d2 = e2.partial;
    var u = makeData(n, true);
    var c = V || !Array.isArray(n) || o.length !== n.length;
    for (var p2 = 0, f2 = o.length; p2 < f2; p2++) {
      e2.__internal.path.push(p2);
      var y = resolveResolverResult(e2, r3, t, joinKeys(a, `${p2}`), i, null != n ? n[p2] : void 0, o[p2], s);
      e2.__internal.path.pop();
      if (void 0 === y && !v) {
        e2.partial = d2;
        return;
      } else {
        e2.partial = e2.partial || void 0 === y && v;
        u[p2] = null != y ? y : null;
        c = c || u[p2] !== n[p2];
      }
    }
    return c ? u : n;
  } else if (null == o) {
    return o;
  } else if (s && null === n) {
    return null;
  } else if (isDataOrKey(o)) {
    var h2 = n || makeData(n);
    return "string" == typeof o ? readSelection(e2, o, i, h2) : readSelection(e2, a, i, h2, o);
  } else {
    warn("Invalid resolver value: The field at `" + a + "` is a scalar (number, boolean, etc), but the GraphQL query expects a selection set for this field.", 9, e2.store.logger);
    return;
  }
};
var resolveLink = (e2, r3, t, a, i, n, o) => {
  if (Array.isArray(r3)) {
    var { store: s } = e2;
    var l = s.schema ? isListNullable(s.schema, t, a, e2.store.logger) : false;
    var v = makeData(n, true);
    var d2 = e2.partial;
    var u = V || !Array.isArray(n) || r3.length !== n.length;
    for (var c = 0, p2 = r3.length; c < p2; c++) {
      e2.__internal.path.push(c);
      var f2 = resolveLink(e2, r3[c], t, a, i, null != n ? n[c] : void 0, o);
      e2.__internal.path.pop();
      if (void 0 === f2 && !l) {
        e2.partial = d2;
        return;
      } else {
        e2.partial = e2.partial || void 0 === f2 && l;
        v[c] = f2 || null;
        u = u || v[c] !== n[c];
      }
    }
    return u ? v : n;
  } else if (null === r3 || null === n && o) {
    return null;
  }
  return readSelection(e2, r3, i, n || makeData(n));
};
var isDataOrKey = (e2) => "string" == typeof e2 || "object" == typeof e2 && "string" == typeof e2.__typename;
var _write = (e2, t, a, i) => {
  if (true) {
    getCurrentDependencies();
  }
  var n = formatDocument(t.query);
  var o = getMainOperation(n);
  var s = {
    data: a || makeData(),
    dependencies: x
  };
  var l = e2.rootFields[o.operation];
  var v = makeContext(e2, normalizeVariables(o, t.variables), getFragments(n), l, l, i);
  if (true) {
    pushDebugNode(l, o);
  }
  writeSelection(v, l, getSelectionSet(o), s.data);
  if (true) {
    popDebugNode();
  }
  return s;
};
var writeSelection = (e2, r3, t, a) => {
  var i = e2.store.rootNames[r3] || "query";
  var n = !!e2.store.rootNames[r3];
  var o = n ? r3 : a.__typename;
  if (!o && r3 && e2.optimistic) {
    o = readRecord(r3, "__typename");
  }
  if (!o) {
    warn("Couldn't find __typename when writing.\nIf you're writing to the cache manually have to pass a `__typename` property on each entity in your data.", 14, e2.store.logger);
    return;
  } else if (!n && r3) {
    writeRecord(r3, "__typename", o);
  }
  var s = e2.store.updates[o];
  var l = makeSelectionIterator(o, r3 || o, T, t, e2);
  var v;
  while (v = l()) {
    var d2 = getName(v);
    var u = getFieldArguments(v, e2.variables);
    var c = keyOfField(d2, u);
    var p2 = getFieldAlias(v);
    var f2 = a[e2.optimistic ? d2 : p2];
    if ("__typename" === d2 || void 0 === f2 && (T || e2.optimistic && "query" === i)) {
      continue;
    }
    if (true) {
      if (e2.store.schema && o && "__typename" !== d2) {
        isFieldAvailableOnType(e2.store.schema, o, d2, e2.store.logger);
      }
    }
    e2.__internal.path.push(p2);
    var y = void 0;
    if (e2.optimistic && "mutation" === i) {
      if (!(y = e2.store.optimisticMutations[d2])) {
        continue;
      }
    } else if (e2.optimistic && "function" == typeof f2) {
      y = f2;
    }
    if (y) {
      updateContext(e2, a, o, r3 || o, c, d2);
      f2 = ensureData(y(u || {}, e2.store, e2));
    }
    if (void 0 === f2) {
      if (true) {
        if (!r3 || !hasField(r3, c) || e2.optimistic && !readRecord(r3, "__typename")) {
          warn("Invalid undefined: The field at `" + c + "` is `undefined`, but the GraphQL query expects a " + (void 0 === v.selectionSet ? "scalar (number, boolean, etc)" : "selection set") + " for this field.", 13, e2.store.logger);
        }
      }
      continue;
    }
    if (v.selectionSet) {
      if (r3 && "query" === i) {
        var h2 = joinKeys(r3, c);
        var m2 = writeField(e2, getSelectionSet(v), ensureData(f2), h2, e2.optimistic ? readLink(r3 || o, c) : void 0);
        writeLink(r3 || o, c, m2);
      } else {
        writeField(e2, getSelectionSet(v), ensureData(f2));
      }
    } else if (r3 && "query" === i) {
      writeRecord(r3 || o, c, null !== f2 || !getFieldError(e2) ? f2 : void 0);
    }
    var g2 = s && s[d2];
    if (g2) {
      updateContext(e2, a, o, r3 || o, c, d2);
      a[d2] = f2;
      g2(a, u || {}, e2.store, e2);
    }
    e2.__internal.path.pop();
  }
};
var A = /^__|PageInfo|(Connection|Edge)$/;
var writeField = (e2, r3, t, a, i) => {
  if (Array.isArray(t)) {
    var n = new Array(t.length);
    for (var o = 0, s = t.length; o < s; o++) {
      e2.__internal.path.push(o);
      var l = a ? joinKeys(a, `${o}`) : void 0;
      var v = writeField(e2, r3, t[o], l, null != i ? i[o] : void 0);
      n[o] = v;
      e2.__internal.path.pop();
    }
    return n;
  } else if (null === t) {
    return getFieldError(e2) ? void 0 : null;
  }
  var d2 = e2.store.keyOfEntity(t) || ("string" == typeof i ? i : null);
  var u = t.__typename;
  if (true) {
    if (a && !e2.store.keys[t.__typename] && null === d2 && "string" == typeof u && !A.test(u)) {
      warn("Invalid key: The GraphQL query at the field at `" + a + "` has a selection set, but no key could be generated for the data at this field.\nYou have to request `id` or `_id` fields for all selection sets or create a custom `keys` config for `" + u + "`.\nEntities without keys will be embedded directly on the parent entity. If this is intentional, create a `keys` config for `" + u + "` that always returns null.", 15, e2.store.logger);
    }
  }
  var c = d2 || a;
  writeSelection(e2, c, r3, t);
  return c || null;
};
var Store = class {
  constructor(e2) {
    if (!e2) {
      e2 = {};
    }
    this.logger = e2.logger;
    this.resolvers = e2.resolvers || {};
    this.directives = e2.directives || {};
    this.optimisticMutations = e2.optimistic || {};
    this.keys = e2.keys || {};
    this.globalIDs = Array.isArray(e2.globalIDs) ? new Set(e2.globalIDs) : !!e2.globalIDs;
    var r3 = "Query";
    var t = "Mutation";
    var a = "Subscription";
    if (e2.schema) {
      var i = (({ __schema: e3 }) => {
        var r4 = /* @__PURE__ */ new Map();
        var buildNameMap = (e4) => {
          var r5;
          return () => {
            if (!r5) {
              r5 = {};
              for (var t3 = 0; t3 < e4.length; t3++) {
                r5[e4[t3].name] = e4[t3];
              }
            }
            return r5;
          };
        };
        var buildType = (e4) => {
          switch (e4.kind) {
            case "OBJECT":
            case "INTERFACE":
              return {
                name: e4.name,
                kind: e4.kind,
                interfaces: buildNameMap(e4.interfaces || []),
                fields: buildNameMap(e4.fields.map((e5) => ({
                  name: e5.name,
                  type: e5.type,
                  args: buildNameMap(e5.args)
                })))
              };
            case "UNION":
              return {
                name: e4.name,
                kind: e4.kind,
                types: buildNameMap(e4.possibleTypes || [])
              };
          }
        };
        var t2 = {
          query: e3.queryType ? e3.queryType.name : null,
          mutation: e3.mutationType ? e3.mutationType.name : null,
          subscription: e3.subscriptionType ? e3.subscriptionType.name : null,
          types: void 0,
          isSubType(e4, t3) {
            var a3 = r4.get(e4);
            var i3 = r4.get(t3);
            if (!a3 || !i3) {
              return false;
            } else if ("UNION" === a3.kind) {
              return !!a3.types()[t3];
            } else if ("OBJECT" !== a3.kind && "OBJECT" === i3.kind) {
              return !!i3.interfaces()[e4];
            } else {
              return e4 === t3;
            }
          }
        };
        if (e3.types) {
          t2.types = r4;
          for (var a2 = 0; a2 < e3.types.length; a2++) {
            var i2 = e3.types[a2];
            if (i2 && i2.name) {
              var n2 = buildType(i2);
              if (n2) {
                r4.set(i2.name, n2);
              }
            }
          }
        }
        return t2;
      })(e2.schema);
      r3 = i.query || r3;
      t = i.mutation || t;
      a = i.subscription || a;
      if (i.types) {
        this.schema = i;
      }
    }
    this.updates = e2.updates || {};
    this.rootFields = {
      query: r3,
      mutation: t,
      subscription: a
    };
    this.rootNames = {
      [r3]: "query",
      [t]: "mutation",
      [a]: "subscription"
    };
    this.data = (n = r3, {
      hydrating: false,
      defer: false,
      gc: /* @__PURE__ */ new Set(),
      persist: /* @__PURE__ */ new Set(),
      queryRootKey: n,
      refCount: /* @__PURE__ */ new Map(),
      links: {
        optimistic: /* @__PURE__ */ new Map(),
        base: /* @__PURE__ */ new Map()
      },
      records: {
        optimistic: /* @__PURE__ */ new Map(),
        base: /* @__PURE__ */ new Map()
      },
      deferredKeys: /* @__PURE__ */ new Set(),
      commutativeKeys: /* @__PURE__ */ new Set(),
      dirtyKeys: /* @__PURE__ */ new Set(),
      optimisticOrder: [],
      storage: null
    });
    var n;
    if (this.schema && true) {
      !function expectValidKeyingConfig(e3, r4, t2) {
        if (true) {
          for (var a2 in r4) {
            if (true) {
              if (!e3.types.has(a2)) {
                warn("Invalid Object type: The type `" + a2 + "` is not an object in the defined schema, but the `keys` option is referencing it.", 20, t2);
              }
            }
          }
        }
      }(this.schema, this.keys, this.logger);
      !function expectValidUpdatesConfig(e3, r4, t2) {
        if (false) {
          return;
        }
        for (var a2 in r4) {
          if (!r4[a2]) {
            continue;
          } else if (!e3.types.has(a2)) {
            var i2 = "";
            if ("Mutation" === a2 && e3.mutation && "Mutation" !== e3.mutation) {
              i2 += "\nMaybe your config should reference `" + e3.mutation + "`?";
            } else if ("Subscription" === a2 && e3.subscription && "Subscription" !== e3.subscription) {
              i2 += "\nMaybe your config should reference `" + e3.subscription + "`?";
            }
            return true ? warn("Invalid updates type: The type `" + a2 + "` is not an object in the defined schema, but the `updates` config is referencing it." + i2, 21, t2) : void 0;
          }
          var n2 = e3.types.get(a2).fields();
          for (var o in r4[a2]) {
            if (true) {
              if (!n2[o]) {
                warn("Invalid updates field: `" + o + "` on `" + a2 + "` is not in the defined schema, but the `updates` config is referencing it.", 22, t2);
              }
            }
          }
        }
      }(this.schema, this.updates, this.logger);
      !function expectValidResolversConfig(e3, r4, t2) {
        if (false) {
          return;
        }
        for (var a2 in r4) {
          if ("Query" === a2) {
            if (e3.query) {
              var i2 = e3.types.get(e3.query).fields();
              for (var n2 in r4.Query || {}) {
                if (!i2[n2]) {
                  warnAboutResolver("Query." + n2, t2);
                }
              }
            } else {
              warnAboutResolver("Query", t2);
            }
          } else if (!e3.types.has(a2)) {
            warnAboutResolver(a2, t2);
          } else if ("INTERFACE" === e3.types.get(a2).kind || "UNION" === e3.types.get(a2).kind) {
            warnAboutAbstractResolver(a2, e3.types.get(a2).kind, t2);
          } else {
            var o = e3.types.get(a2).fields();
            for (var s in r4[a2] || {}) {
              if (!o[s]) {
                warnAboutResolver(a2 + "." + s, t2);
              }
            }
          }
        }
      }(this.schema, this.resolvers, this.logger);
      !function expectValidOptimisticMutationsConfig(e3, r4, t2) {
        if (false) {
          return;
        }
        if (e3.mutation) {
          var a2 = e3.types.get(e3.mutation).fields();
          for (var i2 in r4) {
            if (true) {
              if (!a2[i2]) {
                warn(`Invalid optimistic mutation field: \`${i2}\` is not a mutation field in the defined schema, but the \`optimistic\` option is referencing it.`, 24, t2);
              }
            }
          }
        }
      }(this.schema, this.optimisticMutations, this.logger);
    }
  }
  keyOfField(e2, r3) {
    return keyOfField(e2, r3);
  }
  keyOfEntity(e2) {
    if (q && e2 === q.parent) {
      return q.parentKey;
    } else if (null == e2 || "string" == typeof e2) {
      return e2 || null;
    } else if (!e2.__typename) {
      return null;
    } else if (this.rootNames[e2.__typename]) {
      return e2.__typename;
    }
    var r3 = null;
    if (this.keys[e2.__typename]) {
      r3 = this.keys[e2.__typename](e2) || null;
    } else if (null != e2.id) {
      r3 = `${e2.id}`;
    } else if (null != e2._id) {
      r3 = `${e2._id}`;
    }
    var t = e2.__typename;
    return true === this.globalIDs || this.globalIDs && this.globalIDs.has(t) || !r3 ? r3 : `${t}:${r3}`;
  }
  resolve(e2, r3, t) {
    var a = null;
    var i = this.keyOfEntity(e2);
    if (i) {
      var n = keyOfField(r3, t);
      if (void 0 === (a = readRecord(i, n))) {
        a = readLink(i, n);
      }
    }
    return a;
  }
  resolveFieldByKey(e2, r3, t) {
    return this.resolve(e2, r3, t);
  }
  invalidate(e2, r3, t) {
    var a = this.keyOfEntity(e2);
    invariant(a, true ? "Can't generate a key for invalidate(...).\nYou have to pass an id or _id field or create a custom `keys` field for `" + ("object" == typeof e2 ? e2.__typename : e2 + "`.") : "", 19);
    ((e3, r4, t2) => {
      var a2 = r4 ? [{
        fieldKey: keyOfField(r4, t2)
      }] : inspectFields(e3);
      for (var i = 0, n = a2.length; i < n; i++) {
        var { fieldKey: o } = a2[i];
        if (void 0 !== readLink(e3, o)) {
          writeLink(e3, o, void 0);
        } else {
          writeRecord(e3, o, void 0);
        }
      }
    })(a, r3, t);
  }
  inspectFields(e2) {
    var r3 = this.keyOfEntity(e2);
    return r3 ? inspectFields(r3) : [];
  }
  updateQuery(e2, r3) {
    var a = createRequest(e2.query, e2.variables);
    var i = r3(this.readQuery(a));
    if (null !== i) {
      _write(this, a, i, void 0);
    }
  }
  readQuery(e2) {
    var r3 = createRequest(e2.query, e2.variables);
    return _query(this, r3, void 0, void 0).data;
  }
  readFragment(e2, t, a, i) {
    return ((e3, r3, t2, a2, i2) => {
      var n = getFragments(r3);
      var o;
      if (i2) {
        if (!(o = n[i2])) {
          warn("readFragment(...) was called with a fragment name that does not exist.\nYou provided " + i2 + " but could only find " + Object.keys(n).join(", ") + ".", 6, e3.logger);
          return null;
        }
      } else if (!(o = n[Object.keys(n)[0]])) {
        warn("readFragment(...) was called with an empty fragment.\nYou have to call it with at least one fragment in your GraphQL document.", 6, e3.logger);
        return null;
      }
      var s = getFragmentTypeName(o);
      if ("string" != typeof t2 && !t2.__typename) {
        t2.__typename = s;
      }
      var l = e3.keyOfEntity(t2);
      if (!l) {
        warn("Can't generate a key for readFragment(...).\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `" + s + "`.", 7, e3.logger);
        return null;
      }
      if (true) {
        pushDebugNode(s, o);
      }
      var v = makeContext(e3, a2 || {}, n, s, l, void 0);
      var d2 = readSelection(v, l, getSelectionSet(o), makeData()) || null;
      if (true) {
        popDebugNode();
      }
      return d2;
    })(this, formatDocument(e2), t, a, i);
  }
  writeFragment(e2, t, a, i) {
    ((e3, r3, t2, a2, i2) => {
      var n = getFragments(r3);
      var o;
      if (i2) {
        if (!(o = n[i2])) {
          warn("writeFragment(...) was called with a fragment name that does not exist.\nYou provided " + i2 + " but could only find " + Object.keys(n).join(", ") + ".", 11, e3.logger);
          return null;
        }
      } else if (!(o = n[Object.keys(n)[0]])) {
        warn("writeFragment(...) was called with an empty fragment.\nYou have to call it with at least one fragment in your GraphQL document.", 11, e3.logger);
        return null;
      }
      var s = getFragmentTypeName(o);
      var l = {
        __typename: s,
        ...t2
      };
      var v = e3.keyOfEntity(l);
      if (!v) {
        return true ? warn("Can't generate a key for writeFragment(...) data.\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `" + s + "`.", 12, e3.logger) : void 0;
      }
      if (true) {
        pushDebugNode(s, o);
      }
      var d2 = makeContext(e3, a2 || {}, n, s, v, void 0);
      writeSelection(d2, v, getSelectionSet(o), l);
      if (true) {
        popDebugNode();
      }
    })(this, formatDocument(e2), t, a, i);
  }
  link(e2, r3, ...t) {
    var a = 2 === t.length ? t[0] : null;
    var i = 2 === t.length ? t[1] : t[0];
    var n = this.keyOfEntity(e2);
    if (n) {
      writeLink(n, keyOfField(r3, a), ensureLink(this, i));
    }
  }
};
var addMetadata = (e2, r3) => makeOperation(e2.kind, e2, {
  ...e2.context,
  meta: {
    ...e2.context.meta,
    ...r3
  }
});
var toRequestPolicy = (e2, r3) => makeOperation(e2.kind, e2, {
  ...e2.context,
  requestPolicy: r3
});
var cacheExchange = (e2) => ({ forward: t, client: i, dispatchDebug: n }) => {
  var o = new Store(e2);
  if (e2 && e2.storage) {
    o.data.hydrating = true;
    e2.storage.readData().then((r3) => {
      ((e3, r4, t2) => {
        initDataState("write", e3, null);
        for (var a in t2) {
          var i2 = t2[a];
          if (void 0 !== i2) {
            var { entityKey: n2, fieldKey: o2 } = deserializeKeyInfo(a);
            if (":" === i2[0]) {
              if (void 0 === readLink(n2, o2)) {
                writeLink(n2, o2, JSON.parse(i2.slice(1)));
              }
            } else if (void 0 === readRecord(n2, o2)) {
              writeRecord(n2, o2, JSON.parse(i2));
            }
          }
        }
        e3.storage = r4;
        e3.hydrating = false;
        clearDataState();
      })(o.data, e2.storage, r3);
      if (e2.storage.onCacheHydrated) {
        e2.storage.onCacheHydrated();
      }
    });
  }
  var f2 = /* @__PURE__ */ new Map();
  var y = [];
  var h2 = /* @__PURE__ */ new Map();
  var m2 = /* @__PURE__ */ new Map();
  var g2 = /* @__PURE__ */ new Set();
  var N2 = /* @__PURE__ */ new Set();
  var _2 = /* @__PURE__ */ new Map();
  var k2 = /* @__PURE__ */ new Set();
  var E2 = /* @__PURE__ */ new Set();
  var isBlockedByOptimisticUpdate = (e3) => {
    for (var r3 of e3.values()) {
      if (g2.has(r3)) {
        return true;
      }
    }
    return false;
  };
  var collectPendingOperations = (e3, r3) => {
    if (r3) {
      for (var t2 of r3.values()) {
        var a = _2.get(t2);
        if (a) {
          for (var i2 of a.values()) {
            e3.add(i2);
          }
        }
      }
    }
  };
  var executePendingOperations = (e3, r3, t2) => {
    for (var a of r3.values()) {
      if (a !== e3.key) {
        var n2 = h2.get(a);
        if (n2) {
          if ("query" === e3.kind) {
            E2.add(a);
          }
          var o2 = "cache-first";
          if (N2.has(a)) {
            N2.delete(a);
            o2 = "cache-and-network";
          }
          i.reexecuteOperation(toRequestPolicy(n2, o2));
        }
      }
    }
    if (!t2) {
      var s = k2;
      if ("query" === e3.kind) {
        (k2 = E2).add(e3.key);
      }
      (E2 = s).clear();
    }
  };
  var prepareForwardedOperation = (e3) => {
    var t2 = false;
    if ("query" === e3.kind) {
      reserveLayer(o.data, e3.key);
      h2.set(e3.key, e3);
    } else if ("teardown" === e3.kind) {
      h2.delete(e3.key);
      m2.delete(e3.key);
      k2.delete(e3.key);
      noopDataState(o.data, e3.key);
      return e3;
    } else if ("mutation" === e3.kind && "network-only" !== e3.context.requestPolicy) {
      h2.set(e3.key, e3);
      initDataState("write", o.data, e3.key, true, false);
      var { dependencies: i2 } = _write(o, e3, void 0, void 0);
      clearDataState();
      if (i2.size) {
        for (var n2 of i2.values()) {
          g2.add(n2);
        }
        f2.set(e3.key, i2);
        var s = /* @__PURE__ */ new Set();
        collectPendingOperations(s, i2);
        executePendingOperations(e3, s, true);
        t2 = true;
      }
    }
    return makeOperation(e3.kind, {
      key: e3.key,
      query: formatDocument(e3.query),
      variables: e3.variables ? filterVariables(getMainOperation(e3.query), e3.variables) : e3.variables
    }, {
      ...e3.context,
      optimistic: t2
    });
  };
  var updateDependencies2 = (e3, r3) => {
    for (var t2 of r3.values()) {
      var a = _2.get(t2);
      if (!a) {
        _2.set(t2, a = /* @__PURE__ */ new Set());
      }
      a.add(e3.key);
    }
  };
  var operationResultFromCache = (e3) => {
    initDataState("read", o.data, void 0, false, false);
    var r3 = _query(o, e3, m2.get(e3.key), void 0);
    clearDataState();
    var t2 = r3.data ? !r3.partial && !r3.hasNext ? "hit" : "partial" : "miss";
    m2.set(e3.key, r3.data);
    h2.set(e3.key, e3);
    updateDependencies2(e3, r3.dependencies);
    return {
      outcome: t2,
      operation: e3,
      data: r3.data,
      dependencies: r3.dependencies,
      hasNext: r3.hasNext
    };
  };
  var updateCacheWithResult = (e3, r3) => {
    var t2 = h2.get(e3.operation.key) || e3.operation;
    if ("mutation" === t2.kind) {
      var a = f2.get(t2.key);
      collectPendingOperations(r3, a);
      f2.delete(t2.key);
    }
    if ("subscription" === t2.kind || e3.hasNext) {
      reserveLayer(o.data, t2.key, true);
    }
    var i2;
    var n2 = e3.data;
    if (n2) {
      initDataState("write", o.data, t2.key, false, false);
      var s = _write(o, t2, n2, e3.error).dependencies;
      clearDataState();
      collectPendingOperations(r3, s);
      var l = "query" === t2.kind ? m2.get(t2.key) : null;
      initDataState("read", o.data, t2.key, false, l !== n2);
      var v = _query(o, t2, l || n2, e3.error);
      clearDataState();
      n2 = v.data;
      if ("query" === t2.kind) {
        collectPendingOperations(r3, i2 = v.dependencies);
        m2.set(t2.key, n2);
      }
    } else {
      noopDataState(o.data, t2.key);
    }
    if (i2) {
      updateDependencies2(e3.operation, i2);
    }
    return {
      operation: t2,
      data: n2,
      error: e3.error,
      extensions: e3.extensions,
      hasNext: e3.hasNext,
      stale: e3.stale
    };
  };
  return (e3) => {
    var r3 = share(map(operationResultFromCache)(filter((e4) => "query" === e4.kind && "network-only" !== e4.context.requestPolicy)(e3)));
    var a = filter((e4) => "query" !== e4.kind || "network-only" === e4.context.requestPolicy)(e3);
    var m3 = map((e4) => {
      n({
        type: "cacheMiss",
        message: "The result could not be retrieved from the cache",
        operation: e4.operation,
        source: "cacheExchange"
      });
      return true ? addMetadata(e4.operation, {
        cacheOutcome: "miss"
      }) : e4.operation;
    })(filter((e4) => "miss" === e4.outcome && "cache-only" !== e4.operation.context.requestPolicy && !isBlockedByOptimisticUpdate(e4.dependencies) && !k2.has(e4.operation.key))(r3));
    var _3 = map((e4) => {
      var { requestPolicy: r4 } = e4.operation.context;
      var t2 = "cache-only" !== r4 && (e4.hasNext || "cache-and-network" === r4 || "cache-first" === r4 && "partial" === e4.outcome && !k2.has(e4.operation.key));
      var a2 = "cache-only" !== r4 && (t2 || "partial" === e4.outcome && k2.has(e4.operation.key) && ((s = o.data).commutativeKeys.has(l = e4.operation.key) || s.optimisticOrder.indexOf(l) > -1));
      var s, l;
      var v = {
        operation: true ? addMetadata(e4.operation, {
          cacheOutcome: e4.outcome
        }) : e4.operation,
        data: e4.data,
        error: e4.error,
        extensions: e4.extensions,
        stale: a2 && !e4.hasNext,
        hasNext: t2 && e4.hasNext
      };
      if (!t2) {
      } else if (!isBlockedByOptimisticUpdate(e4.dependencies)) {
        i.reexecuteOperation(toRequestPolicy(h2.get(e4.operation.key) || e4.operation, "network-only"));
      } else if ("cache-and-network" === r4) {
        N2.add(e4.operation.key);
      }
      n({
        type: "cacheHit",
        message: "A requested operation was found and returned from the cache.",
        operation: e4.operation,
        data: {
          value: v
        },
        source: "cacheExchange"
      });
      return v;
    })(filter((e4) => "miss" !== e4.outcome || "cache-only" === e4.operation.context.requestPolicy)(r3));
    var E3 = t(map(prepareForwardedOperation)(merge([a, m3])));
    var O2 = map((e4) => {
      var r4 = /* @__PURE__ */ new Set();
      var t2 = updateCacheWithResult(e4, r4);
      executePendingOperations(e4.operation, r4, false);
      return t2;
    })(filter((e4) => !f2.has(e4.operation.key))(E3));
    var w2 = mergeMap((e4) => {
      if (y.push(e4) < f2.size) {
        return empty;
      }
      for (var r4 = 0; r4 < y.length; r4++) {
        reserveLayer(o.data, y[r4].operation.key);
      }
      g2.clear();
      var t2 = [];
      var a2 = /* @__PURE__ */ new Set();
      var i2;
      while (i2 = y.shift()) {
        t2.push(updateCacheWithResult(i2, a2));
      }
      executePendingOperations(e4.operation, a2, false);
      return r(t2);
    })(filter((e4) => f2.has(e4.operation.key))(E3));
    return merge([O2, w2, _3]);
  };
};

// node_modules/@urql/exchange-auth/dist/urql-exchange-auth.mjs
var addAuthAttemptToOperation = (t, e2) => makeOperation(t.kind, t, {
  ...t.context,
  authAttempt: e2
});
function authExchange(s) {
  return ({ client: f2, forward: d2 }) => {
    var l = /* @__PURE__ */ new Set();
    var p2 = makeSubject();
    var x2 = makeSubject();
    var A2 = /* @__PURE__ */ new Map();
    function flushQueue() {
      v = void 0;
      var t = A2;
      A2 = /* @__PURE__ */ new Map();
      t.forEach(p2.next);
    }
    function errorQueue(t) {
      v = void 0;
      var e2 = A2;
      A2 = /* @__PURE__ */ new Map();
      e2.forEach((e3) => {
        x2.next(makeErrorResult(e3, t));
      });
    }
    var v;
    var w2 = null;
    return (t) => {
      function initAuth() {
        v = Promise.resolve().then(() => s({
          mutate(t2, n, r3) {
            var u = f2.createRequestOperation("mutation", createRequest(t2, n), r3);
            return toPromise(take(1)(filter((t3) => t3.operation.key === u.key && u.context._instance === t3.operation.context._instance)(onStart(() => {
              var t3 = addAuthToOperation(u);
              l.add(t3.context._instance);
              p2.next(t3);
            })(E2))));
          },
          appendHeaders(t2, e2) {
            var n = "function" == typeof t2.context.fetchOptions ? t2.context.fetchOptions() : t2.context.fetchOptions || {};
            return makeOperation(t2.kind, t2, {
              ...t2.context,
              fetchOptions: {
                ...n,
                headers: {
                  ...n.headers,
                  ...e2
                }
              }
            });
          }
        })).then((t2) => {
          if (t2) {
            w2 = t2;
          }
          flushQueue();
        }).catch((t2) => {
          if (true) {
            console.warn("authExchange()’s initialization function has failed, which is unexpected.\nIf your initialization function is expected to throw/reject, catch this error and handle it explicitly.\nUnless this error is handled it’ll be passed onto any `OperationResult` instantly and authExchange() will block further operations and retry.", t2);
          }
          errorQueue(t2);
        });
      }
      initAuth();
      function refreshAuth(t2) {
        A2.set(t2.key, addAuthAttemptToOperation(t2, true));
        if (w2 && !v) {
          v = w2.refreshAuth().then(flushQueue).catch(errorQueue);
        }
      }
      function addAuthToOperation(t2) {
        return w2 ? w2.addAuthToOperation(t2) : t2;
      }
      var h2 = filter(Boolean)(map((t2) => {
        if ("teardown" === t2.kind) {
          A2.delete(t2.key);
          return t2;
        } else if (t2.context._instance && l.has(t2.context._instance)) {
          return t2;
        } else if (t2.context.authAttempt) {
          return addAuthToOperation(t2);
        } else if (v || !w2) {
          if (!v) {
            initAuth();
          }
          if (!A2.has(t2.key)) {
            A2.set(t2.key, addAuthAttemptToOperation(t2, false));
          }
          return null;
        } else if (function willAuthError(t3) {
          return !t3.context.authAttempt && w2 && w2.willAuthError && w2.willAuthError(t3);
        }(t2)) {
          refreshAuth(t2);
          return null;
        }
        return addAuthToOperation(addAuthAttemptToOperation(t2, false));
      })(merge([p2.source, t])));
      var E2 = d2(h2);
      return merge([x2.source, filter((t2) => {
        if (!l.has(t2.operation.context._instance) && t2.error && function didAuthError(t3) {
          return w2 && w2.didAuthError && w2.didAuthError(t3.error, t3.operation);
        }(t2) && !t2.operation.context.authAttempt) {
          refreshAuth(t2.operation);
          return false;
        }
        if (l.has(t2.operation.context._instance)) {
          l.delete(t2.operation.context._instance);
        }
        return true;
      })(E2)]);
    };
  };
}

// node_modules/@urql/exchange-persisted/dist/urql-exchange-persisted.mjs
var d = "undefined" != typeof window ? window.crypto : "undefined" != typeof self ? self.crypto : null;
var p;
var hash = async (e2) => {
  if (d && d.subtle) {
    var r3 = await d.subtle.digest({
      name: "SHA-256"
    }, new TextEncoder().encode(e2));
    return new Uint8Array(r3).reduce((e3, r4) => e3 + r4.toString(16).padStart(2, "0"), "");
  } else if (await (async () => {
    if (!p) {
      try {
        p = new Function("require", 'return require("crypto")')(__require);
      } catch (e3) {
        try {
          p = new Function('return import("crypto")')();
        } catch (e4) {
        }
      }
    }
    return p;
  })()) {
    return (await p).createHash("sha256").update(e2).digest("hex");
  }
  if (true) {
    console.warn("[@urql/exchange-persisted-fetch]: The Node Crypto and Web Crypto APIs are not available.\nThis is an unexpected error. Please report it by filing a GitHub Issue.");
  }
  return "";
};
var persistedExchange = (d2) => ({ forward: p2 }) => {
  if (!d2) {
    d2 = {};
  }
  var c = d2.preferGetForPersistedQueries;
  var y = !!d2.enforcePersistedQueries;
  var f2 = d2.generateHash || hash;
  var h2 = !!d2.enableForMutation;
  var l = true;
  var operationFilter = (e2) => l && !e2.context.persistAttempt && (h2 && "mutation" === e2.kind || "query" === e2.kind);
  return (d3) => {
    var h3 = makeSubject();
    var x2 = filter((e2) => !operationFilter(e2))(d3);
    var v = mergeMap((e2) => {
      var t = (async (e3) => {
        var r3 = makeOperation(e3.kind, e3, {
          ...e3.context,
          persistAttempt: true
        });
        var t2 = await f2(stringifyDocument(e3.query), e3.query);
        if (t2) {
          r3.extensions = {
            ...r3.extensions,
            persistedQuery: {
              version: 1,
              sha256Hash: t2
            }
          };
          if ("query" === r3.kind && c) {
            r3.context.preferGetMethod = c;
          }
        }
        return r3;
      })(e2);
      return takeUntil(filter((r3) => "teardown" === r3.kind && r3.key === e2.key)(d3))(fromPromise(t));
    })(filter(operationFilter)(d3));
    return filter((e2) => !!e2)(map((e2) => {
      if (!y && e2.operation.extensions && e2.operation.extensions.persistedQuery) {
        if (e2.error && e2.error.graphQLErrors.some((e3) => "PersistedQueryNotSupported" === e3.message)) {
          l = false;
          var r3 = makeOperation(e2.operation.kind, e2.operation);
          if (r3.extensions) {
            delete r3.extensions.persistedQuery;
          }
          h3.next(r3);
          return null;
        } else if (e2.error && ((e3) => e3.graphQLErrors.some((e4) => "PersistedQueryNotFound" === e4.message))(e2.error)) {
          if (e2.operation.extensions.persistedQuery.miss) {
            if (true) {
              console.warn("persistedExchange()’s results include two misses for the same operation.\nThis is not expected as it means a persisted error has been delivered for a non-persisted query!\nAnother exchange with a cache may be delivering an outdated result. For example, a server-side ssrExchange() may be caching an errored result.\nTry moving the persistedExchange() in past these exchanges, for example in front of your fetchExchange.");
            }
            return e2;
          }
          var t = makeOperation(e2.operation.kind, e2.operation);
          t.extensions = {
            ...t.extensions,
            persistedQuery: {
              ...(t.extensions || {}).persistedQuery,
              miss: true
            }
          };
          h3.next(t);
          return null;
        }
      }
      return e2;
    })(p2(merge([v, x2, h3.source]))));
  };
};

// node_modules/@urql/exchange-graphcache/dist/urql-exchange-graphcache-extras.mjs
var r2 = {
  __typename: "PageInfo",
  endCursor: null,
  startCursor: null,
  hasNextPage: false,
  hasPreviousPage: false
};
var ensureKey = (e2) => "string" == typeof e2 ? e2 : null;
var concatEdges = (e2, r3, a) => {
  var n = /* @__PURE__ */ new Set();
  for (var t = 0, s = r3.length; t < s; t++) {
    var o = e2.resolve(r3[t], "node");
    if ("string" == typeof o) {
      n.add(o);
    }
  }
  var f2 = r3.slice();
  for (var i = 0, v = a.length; i < v; i++) {
    var l = a[i];
    var u = e2.resolve(l, "node");
    if ("string" == typeof u && !n.has(u)) {
      n.add(u);
      f2.push(l);
    }
  }
  return f2;
};
var concatNodes = (e2, r3) => {
  var a = /* @__PURE__ */ new Set();
  for (var n = 0, t = e2.length; n < t; n++) {
    var s = e2[n];
    if ("string" == typeof s) {
      a.add(s);
    }
  }
  var o = e2.slice();
  for (var f2 = 0, i = r3.length; f2 < i; f2++) {
    var v = r3[f2];
    if ("string" == typeof v && !a.has(v)) {
      a.add(v);
      o.push(v);
    }
  }
  return o;
};
var compareArgs = (r3, a) => {
  for (var n in a) {
    if ("first" === n || "last" === n || "after" === n || "before" === n) {
      continue;
    } else if (!(n in r3)) {
      return false;
    }
    var t = r3[n];
    var s = a[n];
    if (typeof t != typeof s || "object" != typeof t ? t !== s : stringifyVariables(t) !== stringifyVariables(s)) {
      return false;
    }
  }
  for (var o in r3) {
    if ("first" === o || "last" === o || "after" === o || "before" === o) {
      continue;
    }
    if (!(o in a)) {
      return false;
    }
  }
  return true;
};
var getPage = (e2, a, n) => {
  var t = ensureKey(e2.resolve(a, n));
  if (!t) {
    return null;
  }
  var s = e2.resolve(t, "__typename");
  var o = e2.resolve(t, "edges") || [];
  var f2 = e2.resolve(t, "nodes") || [];
  if ("string" != typeof s) {
    return null;
  }
  var i = {
    __typename: s,
    edges: o,
    nodes: f2,
    pageInfo: r2
  };
  var v = e2.resolve(t, "pageInfo");
  if ("string" == typeof v) {
    var l = ensureKey(e2.resolve(v, "__typename"));
    var u = ensureKey(e2.resolve(v, "endCursor"));
    var g2 = ensureKey(e2.resolve(v, "startCursor"));
    var p2 = e2.resolve(v, "hasNextPage");
    var d2 = e2.resolve(v, "hasPreviousPage");
    var y = i.pageInfo = {
      __typename: "string" == typeof l ? l : "PageInfo",
      hasNextPage: "boolean" == typeof p2 ? p2 : !!u,
      hasPreviousPage: "boolean" == typeof d2 ? d2 : !!g2,
      endCursor: u,
      startCursor: g2
    };
    if (null === y.endCursor) {
      var m2 = o[o.length - 1];
      if (m2) {
        var h2 = e2.resolve(m2, "cursor");
        y.endCursor = ensureKey(h2);
      }
    }
    if (null === y.startCursor) {
      var _2 = o[0];
      if (_2) {
        var c = e2.resolve(_2, "cursor");
        y.startCursor = ensureKey(c);
      }
    }
  }
  return i;
};
var relayPagination = (e2 = {}) => {
  var a = e2.mergeMode || "inwards";
  return (e3, n, t, s) => {
    var { parentKey: o, fieldName: f2 } = s;
    var i = t.inspectFields(o).filter((e4) => e4.fieldName === f2);
    var v = i.length;
    if (0 === v) {
      return;
    }
    var l = null;
    var u = [];
    var g2 = [];
    var p2 = [];
    var d2 = [];
    var y = {
      ...r2
    };
    for (var m2 = 0; m2 < v; m2++) {
      var { fieldKey: h2, arguments: _2 } = i[m2];
      if (null === _2 || !compareArgs(n, _2)) {
        continue;
      }
      var c = getPage(t, o, h2);
      if (null === c) {
        continue;
      }
      if (0 === c.nodes.length && 0 === c.edges.length && l) {
        continue;
      }
      if ("inwards" === a && "number" == typeof _2.last && "number" == typeof _2.first) {
        var P = c.edges.slice(0, _2.first + 1);
        var C = c.edges.slice(-_2.last);
        var I2 = c.nodes.slice(0, _2.first + 1);
        var b2 = c.nodes.slice(-_2.last);
        u = concatEdges(t, u, P);
        g2 = concatEdges(t, C, g2);
        p2 = concatNodes(p2, I2);
        d2 = concatNodes(b2, d2);
        y = c.pageInfo;
      } else if (_2.after) {
        u = concatEdges(t, u, c.edges);
        p2 = concatNodes(p2, c.nodes);
        y.endCursor = c.pageInfo.endCursor;
        y.hasNextPage = c.pageInfo.hasNextPage;
      } else if (_2.before) {
        g2 = concatEdges(t, c.edges, g2);
        d2 = concatNodes(c.nodes, d2);
        y.startCursor = c.pageInfo.startCursor;
        y.hasPreviousPage = c.pageInfo.hasPreviousPage;
      } else if ("number" == typeof _2.last) {
        g2 = concatEdges(t, c.edges, g2);
        d2 = concatNodes(c.nodes, d2);
        y = c.pageInfo;
      } else {
        u = concatEdges(t, u, c.edges);
        p2 = concatNodes(p2, c.nodes);
        y = c.pageInfo;
      }
      if (c.pageInfo.__typename !== y.__typename) {
        y.__typename = c.pageInfo.__typename;
      }
      if (l !== c.__typename) {
        l = c.__typename;
      }
    }
    if ("string" != typeof l) {
      return;
    }
    if (!!!ensureKey(t.resolve(o, f2, n))) {
      if (!s.store.schema) {
        return;
      } else {
        s.partial = true;
      }
    }
    return {
      __typename: l,
      edges: "inwards" === a ? concatEdges(t, u, g2) : concatEdges(t, g2, u),
      nodes: "inwards" === a ? concatNodes(p2, d2) : concatNodes(d2, p2),
      pageInfo: {
        __typename: y.__typename,
        endCursor: y.endCursor,
        startCursor: y.startCursor,
        hasNextPage: y.hasNextPage,
        hasPreviousPage: y.hasPreviousPage
      }
    };
  };
};

// node_modules/@keystatic/core/dist/keystatic-core-ui.js
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
var import_cookie = __toESM(require_cookie());
var collator = new Intl.Collator(void 0, {
  sensitivity: "base"
});
function sortBy(direction, valueA, valueB) {
  const modifier = direction === "ascending" ? 1 : -1;
  if (valueA == null)
    return 1;
  if (valueB == null)
    return -1;
  if (typeof valueA === "string" && typeof valueB === "string") {
    return collator.compare(valueA, valueB) * modifier;
  }
  return compare(valueA, valueB) * modifier;
}
function compare(a, b2) {
  if (a < b2)
    return -1;
  if (a > b2)
    return 1;
  return 0;
}
function EmptyState(props) {
  return (0, import_jsx_runtime18.jsx)(Flex, {
    alignItems: "center",
    direction: "column",
    gap: "large",
    justifyContent: "center",
    minHeight: "scale.3000",
    paddingX: {
      mobile: "medium",
      tablet: "xlarge",
      desktop: "xxlarge"
    },
    children: "children" in props ? props.children : (0, import_jsx_runtime18.jsxs)(import_jsx_runtime18.Fragment, {
      children: [props.icon && (0, import_jsx_runtime18.jsx)(Icon, {
        src: props.icon,
        size: "large",
        color: "neutralEmphasis"
      }), props.title && (0, import_jsx_runtime18.jsx)(Heading, {
        align: "center",
        size: "medium",
        children: props.title
      }), props.message && (0, import_jsx_runtime18.jsx)(Text, {
        align: "center",
        children: props.message
      }), props.actions]
    })
  });
}
var NotFoundError = class extends Error {
  constructor() {
    super("Not found");
    this.name = "NotFoundError";
  }
};
function isNotFoundError(err) {
  return typeof err === "object" && err !== null && err instanceof NotFoundError;
}
function notFound() {
  throw new NotFoundError();
}
var NotFoundErrorBoundaryInner = class extends import_react8.default.Component {
  constructor(props) {
    super(props);
    this.state = {
      notFound: false,
      lastHref: props.href
    };
  }
  static getDerivedStateFromError(err) {
    if (isNotFoundError(err)) {
      return {
        notFound: true
      };
    }
    throw err;
  }
  static getDerivedStateFromProps(props, state) {
    if (props.href !== state.lastHref && state.notFound) {
      return {
        notFound: false,
        lastHref: props.href
      };
    }
    return {
      notFound: state.notFound,
      lastHref: props.href
    };
  }
  render() {
    if (this.state.notFound)
      return this.props.fallback;
    return this.props.children;
  }
};
function NotFoundBoundary(props) {
  const router = useRouter();
  return (0, import_jsx_runtime18.jsx)(NotFoundErrorBoundaryInner, {
    ...props,
    href: router.href
  });
}
var _onGet;
var TrackedMap = class extends Map {
  constructor(onGet, entries) {
    super(entries);
    __privateAdd(this, _onGet, void 0);
    __privateSet(this, _onGet, onGet);
  }
  get(key) {
    __privateGet(this, _onGet).call(this, key);
    return super.get(key);
  }
};
_onGet = new WeakMap();
function parseEntry(args, files) {
  const dataFilepath = getEntryDataFilepath(args.dirpath, args.format);
  const data = files.get(dataFilepath);
  if (!data) {
    throw new Error(`Could not find data file at ${dataFilepath}`);
  }
  const {
    loaded,
    extraFakeFile
  } = loadDataFile(data, args.format);
  const filesWithFakeFile = new Map(files);
  if (extraFakeFile) {
    filesWithFakeFile.set(`${args.dirpath}/${extraFakeFile.path}`, extraFakeFile.contents);
  }
  const usedFiles = /* @__PURE__ */ new Set([dataFilepath]);
  const rootSchema = object(args.schema);
  let initialState;
  const getFile = (filepath) => {
    usedFiles.add(filepath);
    return filesWithFakeFile.get(filepath);
  };
  try {
    initialState = parseProps(rootSchema, loaded, [], [], (schema2, value, path, pathWithArrayFieldSlugs) => {
      var _args$slug;
      if (path.length === 1 && path[0] === ((_args$slug = args.slug) === null || _args$slug === void 0 ? void 0 : _args$slug.field)) {
        if (schema2.formKind !== "slug") {
          throw new Error(`slugField is not a slug field`);
        }
        return schema2.parse(value, {
          slug: args.slug.slug
        });
      }
      if (schema2.formKind === "asset") {
        var _args$slug2, _args$slug3, _args$slug4;
        const suggestedFilenamePrefix = pathWithArrayFieldSlugs.join("/");
        const filepath = schema2.filename(value, {
          suggestedFilenamePrefix,
          slug: (_args$slug2 = args.slug) === null || _args$slug2 === void 0 ? void 0 : _args$slug2.slug
        });
        const asset = filepath ? getFile(`${schema2.directory ? `${schema2.directory}${((_args$slug3 = args.slug) === null || _args$slug3 === void 0 ? void 0 : _args$slug3.slug) === void 0 ? "" : `/${args.slug.slug}`}` : args.dirpath}/${filepath}`) : void 0;
        return schema2.parse(value, {
          asset,
          slug: (_args$slug4 = args.slug) === null || _args$slug4 === void 0 ? void 0 : _args$slug4.slug
        });
      }
      if (schema2.formKind === "content") {
        var _args$slug7;
        const rootPath = `${args.dirpath}/${pathWithArrayFieldSlugs.join("/")}`;
        const mainFilepath = rootPath + schema2.contentExtension;
        const mainContents = getFile(mainFilepath);
        const otherFiles = new TrackedMap((key) => {
          usedFiles.add(`${rootPath}/${key}`);
        });
        const otherDirectories = /* @__PURE__ */ new Map();
        for (const [filename] of filesWithFakeFile) {
          if (filename.startsWith(rootPath + "/")) {
            const relativePath = filename.slice(rootPath.length + 1);
            otherFiles.set(relativePath, filesWithFakeFile.get(filename));
          }
        }
        for (const dir of (_schema$directories = schema2.directories) !== null && _schema$directories !== void 0 ? _schema$directories : []) {
          var _schema$directories, _args$slug5, _args$slug6;
          const dirFiles = new TrackedMap((relativePath) => usedFiles.add(start + relativePath));
          const start = `${dir}${((_args$slug5 = args.slug) === null || _args$slug5 === void 0 ? void 0 : _args$slug5.slug) === void 0 ? "" : `/${(_args$slug6 = args.slug) === null || _args$slug6 === void 0 ? void 0 : _args$slug6.slug}`}/`;
          for (const [filename, val] of filesWithFakeFile) {
            if (filename.startsWith(start)) {
              const relativePath = filename.slice(start.length);
              dirFiles.set(relativePath, val);
            }
          }
          if (dirFiles.size) {
            otherDirectories.set(dir, dirFiles);
          }
        }
        return schema2.parse(value, {
          content: mainContents,
          other: otherFiles,
          external: otherDirectories,
          slug: (_args$slug7 = args.slug) === null || _args$slug7 === void 0 ? void 0 : _args$slug7.slug
        });
      }
      return schema2.parse(value, void 0);
    }, false);
  } catch (err) {
    throw toFormattedFormDataError(err);
  }
  if (extraFakeFile) {
    usedFiles.delete(`${args.dirpath}/${extraFakeFile.path}`);
  }
  return {
    initialState,
    initialFiles: [...usedFiles]
  };
}
function getAllFilesInTree(tree) {
  return [...tree.values()].flatMap((val) => val.children ? getAllFilesInTree(val.children) : [val.entry]);
}
function useItemData(args) {
  var _args$slug9;
  const {
    current: currentBranch
  } = useTree();
  const baseCommit = useBaseCommit();
  const isRepoPrivate = useIsRepoPrivate();
  const branchInfo = useBranchInfo();
  const rootTree = currentBranch.kind === "loaded" ? currentBranch.data.tree : void 0;
  const locationsForTreeKey = (0, import_react8.useMemo)(() => {
    var _args$slug8;
    return getDirectoriesForTreeKey(object(args.schema), args.dirpath, (_args$slug8 = args.slug) === null || _args$slug8 === void 0 ? void 0 : _args$slug8.slug, args.format);
  }, [args.dirpath, args.format, args.schema, (_args$slug9 = args.slug) === null || _args$slug9 === void 0 ? void 0 : _args$slug9.slug]);
  const localTreeKey = (0, import_react8.useMemo)(() => getTreeKey(locationsForTreeKey, rootTree !== null && rootTree !== void 0 ? rootTree : /* @__PURE__ */ new Map()), [locationsForTreeKey, rootTree]);
  const tree = (0, import_react8.useMemo)(() => {
    return rootTree !== null && rootTree !== void 0 ? rootTree : /* @__PURE__ */ new Map();
  }, [localTreeKey, locationsForTreeKey]);
  const hasLoaded = currentBranch.kind === "loaded";
  return useData((0, import_react8.useCallback)(() => {
    var _getTreeNodeAtPath;
    if (!hasLoaded)
      return LOADING;
    const dataFilepathSha = (_getTreeNodeAtPath = getTreeNodeAtPath(tree, getEntryDataFilepath(args.dirpath, args.format))) === null || _getTreeNodeAtPath === void 0 ? void 0 : _getTreeNodeAtPath.entry.sha;
    if (dataFilepathSha === void 0) {
      return "not-found";
    }
    const _args = {
      config: args.config,
      dirpath: args.dirpath,
      format: args.format,
      schema: args.schema,
      slug: args.slug
    };
    const allBlobs = locationsForTreeKey.flatMap((dir) => {
      const node = getTreeNodeAtPath(tree, dir);
      if (!node)
        return [];
      return node.children ? getAllFilesInTree(node.children) : [node.entry];
    }).map((entry) => {
      const blob = fetchBlob(args.config, entry.sha, entry.path, baseCommit, isRepoPrivate, {
        owner: branchInfo.mainOwner,
        name: branchInfo.mainRepo
      });
      if (blob instanceof Uint8Array) {
        return [entry.path, blob];
      }
      return blob.then((blob2) => [entry.path, blob2]);
    });
    if (allBlobs.every((x2) => Array.isArray(x2))) {
      const {
        initialFiles,
        initialState
      } = parseEntry(_args, new Map(allBlobs));
      return {
        initialState,
        initialFiles,
        localTreeKey
      };
    }
    return Promise.all(allBlobs).then(async (data) => {
      const {
        initialState,
        initialFiles
      } = parseEntry(_args, new Map(data));
      return {
        initialState,
        initialFiles,
        localTreeKey
      };
    });
  }, [hasLoaded, tree, args.dirpath, args.format, args.config, args.schema, args.slug, locationsForTreeKey, baseCommit, isRepoPrivate, branchInfo.mainOwner, branchInfo.mainRepo, localTreeKey]));
}
var blobCache = new lru_cache_default({
  max: 200
});
async function hydrateBlobCache(contents) {
  const sha = await blobSha(contents);
  blobCache.set(sha, contents);
  await setBlobToPersistedCache(sha, contents);
  return sha;
}
async function fetchGitHubBlob(config, oid, filepath, commitSha, isRepoPrivate, repo) {
  if (!isRepoPrivate) {
    var _getPathPrefix;
    return fetch(`https://raw.githubusercontent.com/${serializeRepoConfig(repo)}/${commitSha}/${(_getPathPrefix = getPathPrefix(config.storage)) !== null && _getPathPrefix !== void 0 ? _getPathPrefix : ""}${filepath}`);
  }
  const auth = await getAuth(config);
  return fetch(config.storage.kind === "github" ? `https://api.github.com/repos/${serializeRepoConfig(config.storage.repo)}/git/blobs/${oid}` : `${KEYSTATIC_CLOUD_API_URL}/v1/github/blob/${oid}`, {
    headers: {
      Authorization: `Bearer ${auth.accessToken}`,
      Accept: "application/vnd.github.raw",
      ...config.storage.kind === "cloud" ? KEYSTATIC_CLOUD_HEADERS : {}
    }
  });
}
function fetchBlob(config, oid, filepath, commitSha, isRepoPrivate, repo) {
  if (blobCache.has(oid))
    return blobCache.get(oid);
  const promise = (async () => {
    const isLocal = config.storage.kind === "local";
    if (!isLocal) {
      const stored = await getBlobFromPersistedCache(oid);
      if (stored) {
        blobCache.set(oid, stored);
        return stored;
      }
    }
    return (isLocal ? fetch(`/api/keystatic/blob/${oid}/${filepath}`, {
      headers: {
        "no-cors": "1"
      }
    }) : fetchGitHubBlob(config, oid, filepath, commitSha, isRepoPrivate, repo)).then(async (x2) => {
      if (!x2.ok) {
        throw new Error(`Could not fetch blob ${oid} (${filepath}): ${x2.status}
${await x2.text()}`);
      }
      return x2.arrayBuffer();
    }).then((x2) => {
      const array = new Uint8Array(x2);
      blobCache.set(oid, array);
      if (config.storage.kind !== "local") {
        setBlobToPersistedCache(oid, array);
      }
      return array;
    }).catch((err) => {
      blobCache.delete(oid);
      throw err;
    });
  })();
  blobCache.set(oid, promise);
  return promise;
}
function CollectionPage(props) {
  var _config$collections;
  const {
    collection,
    config
  } = props;
  const containerWidth = "none";
  const collectionConfig = (_config$collections = config.collections) === null || _config$collections === void 0 ? void 0 : _config$collections[collection];
  if (!collectionConfig)
    notFound();
  const [searchTerm, setSearchTerm] = (0, import_react8.useState)("");
  let debouncedSearchTerm = useDebouncedValue(searchTerm, 300);
  return (0, import_jsx_runtime18.jsxs)(PageRoot, {
    containerWidth,
    children: [(0, import_jsx_runtime18.jsx)(CollectionPageHeader, {
      collectionLabel: collectionConfig.label,
      createHref: `${props.basePath}/collection/${encodeURIComponent(props.collection)}/create`,
      searchTerm,
      onSearchTermChange: setSearchTerm
    }), (0, import_jsx_runtime18.jsx)(CollectionPageContent, {
      searchTerm: debouncedSearchTerm,
      ...props
    })]
  });
}
function CollectionPageHeader(props) {
  const {
    collectionLabel,
    createHref
  } = props;
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  const isAboveMobile = useMediaQuery(breakpointQueries$1.above.mobile);
  const [searchVisible, setSearchVisible] = (0, import_react8.useState)(isAboveMobile);
  const searchRef = (0, import_react8.useRef)(null);
  (0, import_react8.useEffect)(() => {
    setSearchVisible(isAboveMobile);
  }, [isAboveMobile]);
  (0, import_react8.useEffect)(() => {
    const listener = (event) => {
      if (document.activeElement === searchRef.current) {
        return;
      }
      if ((0, import_is_hotkey.isHotkey)("mod+f", event)) {
        var _searchRef$current;
        event.preventDefault();
        (_searchRef$current = searchRef.current) === null || _searchRef$current === void 0 || _searchRef$current.select();
      }
    };
    document.addEventListener("keydown", listener);
    return () => document.removeEventListener("keydown", listener);
  }, []);
  return (0, import_jsx_runtime18.jsxs)(PageHeader, {
    children: [(0, import_jsx_runtime18.jsx)(Heading, {
      elementType: "h1",
      id: "page-title",
      size: "small",
      flex: true,
      minWidth: 0,
      children: collectionLabel
    }), (0, import_jsx_runtime18.jsx)("div", {
      role: "search",
      style: {
        display: searchVisible ? "block" : "none"
      },
      children: (0, import_jsx_runtime18.jsx)(SearchField, {
        ref: searchRef,
        "aria-label": stringFormatter.format("search"),
        onChange: props.onSearchTermChange,
        onClear: () => {
          props.onSearchTermChange("");
          if (!isAboveMobile) {
            setTimeout(() => {
              setSearchVisible(false);
            }, 250);
          }
        },
        onBlur: () => {
          if (!isAboveMobile && props.searchTerm === "") {
            setSearchVisible(false);
          }
        },
        placeholder: stringFormatter.format("search"),
        value: props.searchTerm,
        width: "scale.2400"
      })
    }), (0, import_jsx_runtime18.jsx)(ActionButton, {
      "aria-label": "show search",
      isHidden: searchVisible || {
        above: "mobile"
      },
      onPress: () => {
        setSearchVisible(true);
        let tempInput = document.createElement("input");
        tempInput.style.position = "absolute";
        tempInput.style.opacity = "0";
        document.body.appendChild(tempInput);
        tempInput.focus();
        setTimeout(() => {
          var _searchRef$current2;
          (_searchRef$current2 = searchRef.current) === null || _searchRef$current2 === void 0 || _searchRef$current2.focus();
          tempInput.remove();
        }, 0);
      },
      children: (0, import_jsx_runtime18.jsx)(Icon, {
        src: searchIcon
      })
    }), (0, import_jsx_runtime18.jsx)(Button, {
      marginStart: "auto",
      prominence: "high",
      href: createHref,
      isHidden: searchVisible ? {
        below: "tablet"
      } : void 0,
      children: stringFormatter.format("add")
    })]
  });
}
function CollectionPageContent(props) {
  const trees = useTree();
  const tree = trees.merged.kind === "loaded" ? trees.merged.data.current.entries.get(getCollectionPath(props.config, props.collection)) : null;
  if (trees.merged.kind === "error") {
    return (0, import_jsx_runtime18.jsx)(EmptyState, {
      icon: alertCircleIcon,
      title: "Unable to load collection",
      message: trees.merged.error.message,
      actions: (0, import_jsx_runtime18.jsx)(Button, {
        tone: "accent",
        href: props.basePath,
        children: "Dashboard"
      })
    });
  }
  if (trees.merged.kind === "loading") {
    return (0, import_jsx_runtime18.jsx)(EmptyState, {
      children: (0, import_jsx_runtime18.jsx)(ProgressCircle, {
        "aria-label": "Loading Entries",
        isIndeterminate: true,
        size: "large"
      })
    });
  }
  if (!tree) {
    return (0, import_jsx_runtime18.jsx)(EmptyState, {
      icon: listXIcon,
      title: "Empty collection",
      message: (0, import_jsx_runtime18.jsxs)(import_jsx_runtime18.Fragment, {
        children: ["There aren't any entries yet.", " ", (0, import_jsx_runtime18.jsx)(TextLink, {
          href: `${props.basePath}/collection/${encodeURIComponent(props.collection)}/create`,
          children: "Create the first entry"
        }), " ", "to see it here."]
      })
    });
  }
  return (0, import_jsx_runtime18.jsx)(CollectionTable, {
    ...props,
    trees: trees.merged.data
  });
}
var SLUG = "@@slug";
var STATUS = "@@status";
function CollectionTable(props) {
  let {
    searchTerm
  } = props;
  let {
    currentBranch,
    defaultBranch
  } = useBranchInfo();
  let isLocalMode = isLocalConfig(props.config);
  let router = useRouter();
  let [sortDescriptor, setSortDescriptor] = (0, import_react8.useState)({
    column: SLUG,
    direction: "ascending"
  });
  let hideStatusColumn = isLocalMode || currentBranch === defaultBranch;
  const branchInfo = useBranchInfo();
  const isRepoPrivate = useIsRepoPrivate();
  const baseCommit = useBaseCommit();
  const collection = props.config.collections[props.collection];
  const entriesWithStatus = (0, import_react8.useMemo)(() => {
    const defaultEntries = new Map(getEntriesInCollectionWithTreeKey(props.config, props.collection, props.trees.default.tree).map((x2) => [x2.slug, x2.key]));
    return getEntriesInCollectionWithTreeKey(props.config, props.collection, props.trees.current.tree).map((entry) => {
      return {
        name: entry.slug,
        status: defaultEntries.has(entry.slug) ? defaultEntries.get(entry.slug) === entry.key ? "Unchanged" : "Changed" : "Added",
        sha: entry.sha
      };
    });
  }, [props.collection, props.config, props.trees]);
  const mainFiles = useData((0, import_react8.useCallback)(async () => {
    var _collection$columns;
    if (!((_collection$columns = collection.columns) !== null && _collection$columns !== void 0 && _collection$columns.length))
      return void 0;
    const formatInfo = getCollectionFormat(props.config, props.collection);
    const entries = await Promise.all(entriesWithStatus.map(async (entry) => {
      return [entry.name, await fetchBlob(props.config, entry.sha, getEntryDataFilepath(getCollectionItemPath(props.config, props.collection, entry.name), formatInfo), baseCommit, isRepoPrivate, {
        owner: branchInfo.mainOwner,
        name: branchInfo.mainRepo
      })];
    }));
    const glob = getSlugGlobForCollection(props.config, props.collection);
    const rootSchema = {
      kind: "object",
      fields: collection.schema
    };
    return new Map(entries.map(([slug, dataFile]) => {
      const {
        loaded
      } = loadDataFile(dataFile, formatInfo);
      const validated = parseProps(rootSchema, loaded, [], [], (schema2, value, path) => {
        if (schema2.formKind === "asset") {
          return schema2.reader.parse(value);
        }
        if (schema2.formKind === "content") {
          return;
        }
        if (path.length === 1 && slug !== void 0) {
          if (path[0] === collection.slugField) {
            if (schema2.formKind !== "slug") {
              throw new Error(`Slug field ${collection.slugField} is not a slug field`);
            }
            return schema2.reader.parseWithSlug(value, {
              slug,
              glob
            });
          }
        }
        return schema2.reader.parse(value);
      }, true);
      return [slug, validated];
    }));
  }, [baseCommit, branchInfo.mainOwner, branchInfo.mainRepo, collection, entriesWithStatus, isRepoPrivate, props.collection, props.config]));
  const entriesWithData = (0, import_react8.useMemo)(() => {
    if (mainFiles.kind !== "loaded" || !mainFiles.data) {
      return entriesWithStatus;
    }
    const {
      data
    } = mainFiles;
    return entriesWithStatus.map((entry) => {
      return {
        ...entry,
        data: data.get(entry.name)
      };
    });
  }, [entriesWithStatus, mainFiles]);
  const filteredItems = (0, import_react8.useMemo)(() => {
    return entriesWithData.filter((item) => item.name.toLowerCase().includes(searchTerm.toLowerCase()));
  }, [entriesWithData, searchTerm]);
  const sortedItems = (0, import_react8.useMemo)(() => {
    return [...filteredItems].sort((a, b2) => {
      const readCol = (row, other2) => {
        var _other;
        if (sortDescriptor.column === SLUG) {
          var _collection$parseSlug, _collection$parseSlug2;
          return (_collection$parseSlug = (_collection$parseSlug2 = collection.parseSlugForSort) === null || _collection$parseSlug2 === void 0 ? void 0 : _collection$parseSlug2.call(collection, row.name)) !== null && _collection$parseSlug !== void 0 ? _collection$parseSlug : row.name;
        }
        if (sortDescriptor.column === STATUS) {
          return row.status;
        }
        return (_other = other2 === null || other2 === void 0 ? void 0 : other2[sortDescriptor.column]) !== null && _other !== void 0 ? _other : row.name;
      };
      const other = mainFiles.kind === "loaded" ? mainFiles.data : void 0;
      return sortBy(sortDescriptor.direction, readCol(a, other === null || other === void 0 ? void 0 : other.get(a.name)), readCol(b2, other === null || other === void 0 ? void 0 : other.get(b2.name)));
    });
  }, [collection, filteredItems, mainFiles, sortDescriptor.column, sortDescriptor.direction]);
  const columns = (0, import_react8.useMemo)(() => {
    var _collection$columns2;
    if ((_collection$columns2 = collection.columns) !== null && _collection$columns2 !== void 0 && _collection$columns2.length) {
      return [...hideStatusColumn ? [] : [{
        name: "Status",
        key: STATUS,
        minWidth: 32,
        width: 32
      }], {
        name: "Slug",
        key: SLUG
      }, ...collection.columns.map((column) => {
        const schema2 = collection.schema[column];
        return {
          name: "label" in schema2 && schema2.label || column,
          key: column
        };
      })];
    }
    return hideStatusColumn ? [{
      name: "Name",
      key: SLUG
    }] : [{
      name: "Status",
      key: STATUS,
      minWidth: 32,
      width: 32
    }, {
      name: "Name",
      key: SLUG
    }];
  }, [collection, hideStatusColumn]);
  return (0, import_jsx_runtime18.jsxs)(TableView, {
    "aria-labelledby": "page-title",
    selectionMode: "none",
    onSortChange: setSortDescriptor,
    sortDescriptor,
    density: "spacious",
    overflowMode: "truncate",
    prominence: "low",
    onRowAction: (key) => {
      router.push(getItemPath(props.basePath, props.collection, key));
    },
    renderEmptyState: () => (0, import_jsx_runtime18.jsx)(EmptyState, {
      icon: searchXIcon,
      title: "No results",
      message: `No items matching "${searchTerm}" were found.`
    }),
    flex: true,
    marginTop: {
      tablet: "large"
    },
    marginBottom: {
      mobile: "regular",
      tablet: "xlarge"
    },
    UNSAFE_className: css({
      marginInline: tokenSchema.size.space.regular,
      [breakpointQueries$1.above.mobile]: {
        marginInline: `calc(${tokenSchema.size.space.xlarge} - ${tokenSchema.size.space.medium})`
      },
      [breakpointQueries$1.above.tablet]: {
        marginInline: `calc(${tokenSchema.size.space.xxlarge} - ${tokenSchema.size.space.medium})`
      },
      "[role=rowheader]": {
        cursor: "pointer"
      }
    }),
    children: [(0, import_jsx_runtime18.jsx)($312ae3b56a94a86e$export$f850895b287ef28e, {
      columns,
      children: ({
        name,
        key,
        ...options
      }) => key === STATUS ? (0, import_jsx_runtime18.jsx)(VoussoirColumn, {
        isRowHeader: true,
        allowsSorting: true,
        ...options,
        children: (0, import_jsx_runtime18.jsx)(Icon, {
          "aria-label": "Status",
          src: diffIcon
        })
      }, key) : (0, import_jsx_runtime18.jsx)(VoussoirColumn, {
        isRowHeader: true,
        allowsSorting: true,
        ...options,
        children: name
      }, key)
    }), (0, import_jsx_runtime18.jsx)($4ae5314bf50db1a3$export$76ccd210b9029917, {
      items: sortedItems,
      children: (item) => {
        var _collection$columns3;
        const statusCell = (0, import_jsx_runtime18.jsx)($941d1d9a6a28982a$export$f6f0c3fe4ec306ea, {
          textValue: item.status,
          children: item.status === "Added" ? (0, import_jsx_runtime18.jsx)(Icon, {
            color: "positive",
            src: plusSquareIcon
          }) : item.status === "Changed" ? (0, import_jsx_runtime18.jsx)(Icon, {
            color: "accent",
            src: dotSquareIcon
          }) : null
        }, STATUS + item.name);
        const nameCell = (0, import_jsx_runtime18.jsx)($941d1d9a6a28982a$export$f6f0c3fe4ec306ea, {
          textValue: item.name,
          children: (0, import_jsx_runtime18.jsx)(Text, {
            weight: "medium",
            children: item.name
          })
        }, SLUG + item.name);
        if ((_collection$columns3 = collection.columns) !== null && _collection$columns3 !== void 0 && _collection$columns3.length) {
          return (0, import_jsx_runtime18.jsx)($70d70eb16ea48428$export$b59bdbef9ce70de2, {
            children: [...hideStatusColumn ? [] : [statusCell], nameCell, ...collection.columns.map((column) => {
              var _item$data;
              let val;
              val = (_item$data = item.data) === null || _item$data === void 0 ? void 0 : _item$data[column];
              if (val == null) {
                val = void 0;
              } else {
                val = val + "";
              }
              return (0, import_jsx_runtime18.jsx)($941d1d9a6a28982a$export$f6f0c3fe4ec306ea, {
                textValue: val,
                children: (0, import_jsx_runtime18.jsx)(Text, {
                  weight: "medium",
                  children: val
                })
              }, column + item.name);
            })]
          }, item.name);
        }
        return hideStatusColumn ? (0, import_jsx_runtime18.jsx)($70d70eb16ea48428$export$b59bdbef9ce70de2, {
          children: nameCell
        }, item.name) : (0, import_jsx_runtime18.jsxs)($70d70eb16ea48428$export$b59bdbef9ce70de2, {
          children: [statusCell, nameCell]
        }, item.name);
      }
    })]
  });
}
function getItemPath(basePath, collection, key) {
  return `${basePath}/collection/${encodeURIComponent(collection)}/item/${encodeURIComponent(key)}`;
}
function useDebouncedValue(value, delay = 300) {
  const [debouncedValue, setDebouncedValue] = (0, import_react8.useState)(value);
  (0, import_react8.useEffect)(() => {
    const timer = setTimeout(() => setDebouncedValue(value), delay);
    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]);
  return debouncedValue;
}
var AppSlugContext = (0, import_react8.createContext)(void 0);
var AppSlugProvider = AppSlugContext.Provider;
function InstallGitHubApp(props) {
  var _URL$searchParams$get;
  const router = useRouter();
  const appSlugFromContext = (0, import_react8.useContext)(AppSlugContext);
  const appSlug = (_URL$searchParams$get = new URL(router.href, "https://example.com").searchParams.get("slug")) !== null && _URL$searchParams$get !== void 0 ? _URL$searchParams$get : appSlugFromContext === null || appSlugFromContext === void 0 ? void 0 : appSlugFromContext.value;
  const parsedRepo = parseRepoConfig(props.config.storage.repo);
  return (0, import_jsx_runtime18.jsxs)(Flex, {
    direction: "column",
    gap: "regular",
    children: [(0, import_jsx_runtime18.jsxs)(Flex, {
      alignItems: "end",
      gap: "regular",
      children: [(0, import_jsx_runtime18.jsx)(TextField, {
        label: "Repo Name",
        width: "100%",
        isReadOnly: true,
        value: parsedRepo.name
      }), (0, import_jsx_runtime18.jsx)(ActionButton, {
        onPress: () => {
          navigator.clipboard.writeText(parsedRepo.name);
        },
        children: "Copy Repo Name"
      })]
    }), appSlug ? (0, import_jsx_runtime18.jsx)(Button, {
      prominence: "high",
      href: `https://github.com/apps/${appSlug}/installations/new`,
      children: "Install GitHub App"
    }) : (0, import_jsx_runtime18.jsx)(Notice, {
      tone: "caution",
      children: appSlugFromContext ? (0, import_jsx_runtime18.jsxs)(Text, {
        children: ["The ", (0, import_jsx_runtime18.jsx)("code", {
          children: appSlugFromContext.envName
        }), " environment variable wasn't provided so we can't link to the GitHub app installation page. You should find the App on GitHub and add the repo yourself."]
      }) : (0, import_jsx_runtime18.jsx)(Text, {
        children: "Find the App on GitHub and add the repo."
      })
    })]
  });
}
function ForkRepoDialog(props) {
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  const client = useClient();
  const [state, setState] = (0, import_react8.useState)({
    kind: "idle"
  });
  (0, import_react8.useEffect)(() => {
    const listener = async (event) => {
      if (event.key === "ks-refetch-installations" && event.newValue === "true") {
        localStorage.removeItem("ks-refetch-installations");
        try {
          var _res$data;
          const auth = await getAuth(props.config);
          if (!auth)
            throw new Error("Unauthorized");
          const res = await client.query(GitHubAppShellQuery, parseRepoConfig(props.config.storage.repo)).toPromise();
          if ((_res$data = res.data) !== null && _res$data !== void 0 && (_res$data = _res$data.repository) !== null && _res$data !== void 0 && (_res$data = _res$data.forks.nodes) !== null && _res$data !== void 0 && _res$data.some((x2) => (x2 === null || x2 === void 0 ? void 0 : x2.viewerPermission) === "ADMIN" || (x2 === null || x2 === void 0 ? void 0 : x2.viewerPermission) === "WRITE" || (x2 === null || x2 === void 0 ? void 0 : x2.viewerPermission) === "MAINTAIN")) {
            await new Promise((resolve) => setTimeout(resolve, 100));
            props.onCreate();
          }
        } catch (err) {
          setState({
            kind: "error",
            error: err
          });
        }
      }
    };
    addEventListener("storage", listener);
    return () => removeEventListener("storage", listener);
  }, [client, props]);
  const appSlug = (0, import_react8.useContext)(AppSlugContext);
  return (0, import_jsx_runtime18.jsxs)(Dialog, {
    size: "small",
    isDismissable: true,
    onDismiss: () => {
      props.onDismiss();
    },
    children: [(0, import_jsx_runtime18.jsx)(Heading, {
      children: "Fork Repo"
    }), state.kind === "error" ? (0, import_jsx_runtime18.jsxs)(import_jsx_runtime18.Fragment, {
      children: [(0, import_jsx_runtime18.jsx)(Content, {
        children: (0, import_jsx_runtime18.jsx)(Notice, {
          tone: "critical",
          children: state.error.message
        })
      }), (0, import_jsx_runtime18.jsx)(ButtonGroup, {
        children: (0, import_jsx_runtime18.jsx)(Button, {
          onPress: props.onDismiss,
          children: stringFormatter.format("cancel")
        })
      })]
    }) : (0, import_jsx_runtime18.jsx)(import_jsx_runtime18.Fragment, {
      children: (0, import_jsx_runtime18.jsx)(Content, {
        children: (0, import_jsx_runtime18.jsxs)(Flex, {
          gap: "large",
          direction: "column",
          marginBottom: "large",
          children: [(0, import_jsx_runtime18.jsx)(Text, {
            children: "You don't have permission to write to this repo so to save your changes, you need to fork the repo."
          }), (0, import_jsx_runtime18.jsxs)(Text, {
            children: ["To start,", " ", (0, import_jsx_runtime18.jsx)(TextLink, {
              href: `https://github.com/${serializeRepoConfig(props.config.storage.repo)}/fork`,
              target: "_blank",
              rel: "noopener noreferrer",
              children: "fork the repo on GitHub"
            }), ". Then, come back to this page and", " ", (0, import_jsx_runtime18.jsx)(TextLink, {
              href: `https://github.com/apps/${appSlug === null || appSlug === void 0 ? void 0 : appSlug.value}/installations/new?state=close`,
              target: "_blank",
              rel: "noopener noreferrer",
              children: "install the Keystatic GitHub App on your fork."
            })]
          })]
        })
      })
    })]
  });
}
injectGlobal({
  body: {
    overflow: "hidden"
  }
});
function createUrqlClient(config) {
  const repo = config.storage.kind === "github" ? parseRepoConfig(config.storage.repo) : {
    owner: "repo-owner",
    name: "repo-name"
  };
  return j({
    url: config.storage.kind === "github" ? "https://api.github.com/graphql" : `${KEYSTATIC_CLOUD_API_URL}/v1/github/graphql`,
    requestPolicy: "cache-and-network",
    exchanges: [authExchange(async (utils) => {
      let authState = await getAuth(config);
      return {
        addAuthToOperation(operation) {
          authState = getSyncAuth(config);
          if (!authState) {
            return operation;
          }
          return utils.appendHeaders(operation, {
            Authorization: `Bearer ${authState.accessToken}`,
            ...config.storage.kind === "cloud" ? KEYSTATIC_CLOUD_HEADERS : {}
          });
        },
        didAuthError() {
          return false;
        },
        willAuthError(operation) {
          var _operation$query$defi;
          authState = getSyncAuth(config);
          if (operation.query.definitions[0].kind === "OperationDefinition" && (_operation$query$defi = operation.query.definitions[0].name) !== null && _operation$query$defi !== void 0 && _operation$query$defi.value.includes("AppShell") && !authState) {
            if (config.storage.kind === "github") {
              window.location.href = "/api/keystatic/github/login";
            } else {
              redirectToCloudAuth("", config);
            }
            return true;
          }
          if (!authState) {
            return true;
          }
          return false;
        },
        async refreshAuth() {
          authState = await getAuth(config);
        }
      };
    }), cacheExchange({
      resolvers: {
        Repository: {
          refs: relayPagination()
        }
      },
      updates: {
        Mutation: {
          createRef(result, args, cache, _info) {
            cache.updateQuery({
              query: config.storage.kind === "github" ? GitHubAppShellQuery : CloudAppShellQuery,
              variables: repo
            }, (data) => {
              var _data$repository;
              if (data !== null && data !== void 0 && (_data$repository = data.repository) !== null && _data$repository !== void 0 && (_data$repository = _data$repository.refs) !== null && _data$repository !== void 0 && _data$repository.nodes && result.createRef && typeof result.createRef === "object" && "ref" in result.createRef) {
                return {
                  ...data,
                  repository: {
                    ...data.repository,
                    refs: {
                      ...data.repository.refs,
                      nodes: [...data.repository.refs.nodes, result.createRef.ref]
                    }
                  }
                };
              }
              return data;
            });
          },
          deleteRef(result, args, cache, _info) {
            cache.updateQuery({
              query: config.storage.kind === "github" ? GitHubAppShellQuery : CloudAppShellQuery,
              variables: repo
            }, (data) => {
              var _data$repository2;
              if (data !== null && data !== void 0 && (_data$repository2 = data.repository) !== null && _data$repository2 !== void 0 && (_data$repository2 = _data$repository2.refs) !== null && _data$repository2 !== void 0 && _data$repository2.nodes && result.deleteRef && typeof result.deleteRef === "object" && "__typename" in result.deleteRef && typeof args.input === "object" && args.input !== null && "refId" in args.input && typeof args.input.refId === "string") {
                const refId = args.input.refId;
                return {
                  ...data,
                  repository: {
                    ...data.repository,
                    refs: {
                      ...data.repository.refs,
                      nodes: data.repository.refs.nodes.filter((x2) => (x2 === null || x2 === void 0 ? void 0 : x2.id) !== refId)
                    }
                  }
                };
              }
              return data;
            });
          }
        }
      }
    }), ...config.storage.kind === "github" ? [] : [persistedExchange({
      enableForMutation: true,
      enforcePersistedQueries: true
    })], fetchExchange]
  });
}
function Provider({
  children,
  config
}) {
  const themeContext = useTheme();
  const {
    push: navigate
  } = useRouter();
  const keystarRouter = (0, import_react8.useMemo)(() => ({
    navigate
  }), [navigate]);
  return (0, import_jsx_runtime18.jsx)(ThemeProvider, {
    value: themeContext,
    children: (0, import_jsx_runtime18.jsxs)(KeystarProvider, {
      locale: config.locale || "en-US",
      colorScheme: themeContext.theme,
      router: keystarRouter,
      children: [(0, import_jsx_runtime18.jsx)(ClientSideOnlyDocumentElement, {}), (0, import_jsx_runtime18.jsx)("link", {
        href: "https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap",
        rel: "stylesheet"
      }), (0, import_jsx_runtime18.jsx)(f, {
        value: (0, import_react8.useMemo)(() => createUrqlClient(config), [config]),
        children
      }), (0, import_jsx_runtime18.jsx)(Toaster, {})]
    })
  });
}
var textEncoder2 = new TextEncoder();
var frontmatterSplit = textEncoder2.encode("---\n");
function combineFrontmatterAndContents(frontmatter, contents) {
  const array = new Uint8Array(frontmatter.byteLength + contents.byteLength + frontmatterSplit.byteLength * 2);
  array.set(frontmatterSplit);
  array.set(frontmatter, frontmatterSplit.byteLength);
  array.set(frontmatterSplit, frontmatterSplit.byteLength + frontmatter.byteLength);
  array.set(contents, frontmatterSplit.byteLength * 2 + frontmatter.byteLength);
  return array;
}
function serializeEntryToFiles(args) {
  var _args$slug, _args$slug2;
  let {
    value: stateWithExtraFilesRemoved,
    extraFiles
  } = serializeProps(args.state, object(args.schema), (_args$slug = args.slug) === null || _args$slug === void 0 ? void 0 : _args$slug.field, (_args$slug2 = args.slug) === null || _args$slug2 === void 0 ? void 0 : _args$slug2.value, true);
  const dataFormat = args.format.data;
  let dataContent = textEncoder2.encode(dataFormat === "json" ? JSON.stringify(stateWithExtraFilesRemoved, null, 2) + "\n" : dump(stateWithExtraFilesRemoved));
  if (args.format.contentField) {
    const filename = `${args.format.contentField.key}${args.format.contentField.config.contentExtension}`;
    let contents;
    extraFiles = extraFiles.filter((x2) => {
      if (x2.path !== filename)
        return true;
      contents = x2.contents;
      return false;
    });
    assert(contents !== void 0, "Expected content field to be present");
    dataContent = combineFrontmatterAndContents(dataContent, contents);
  }
  return [{
    path: getEntryDataFilepath(args.basePath, args.format),
    contents: dataContent
  }, ...extraFiles.map((file) => ({
    path: `${file.parent ? args.slug ? `${file.parent}/${args.slug.value}` : file.parent : args.basePath}/${file.path}`,
    contents: file.contents
  }))];
}
function useUpsertItem(args) {
  const [state, setState] = (0, import_react8.useState)({
    kind: "idle"
  });
  const baseCommit = useBaseCommit();
  const branchInfo = (0, import_react8.useContext)(BranchInfoContext);
  const setTreeSha = useSetTreeSha();
  const [, mutate] = useMutation(createCommitMutation);
  const repoWithWriteAccess = (0, import_react8.useContext)(RepoWithWriteAccessContext);
  const appSlug = (0, import_react8.useContext)(AppSlugContext);
  const unscopedTreeData = useCurrentUnscopedTree();
  return [state, async (override) => {
    try {
      var _getPathPrefix, _args$initialFiles;
      const unscopedTree = unscopedTreeData.kind === "loaded" ? unscopedTreeData.data.tree : void 0;
      if (!unscopedTree)
        return false;
      if (repoWithWriteAccess === null && args.config.storage.kind === "github" && appSlug !== null && appSlug !== void 0 && appSlug.value) {
        setState({
          kind: "needs-fork"
        });
        return false;
      }
      setState({
        kind: "loading"
      });
      const pathPrefix = (_getPathPrefix = getPathPrefix(args.config.storage)) !== null && _getPathPrefix !== void 0 ? _getPathPrefix : "";
      let additions = serializeEntryToFiles({
        basePath: args.basePath,
        config: args.config,
        schema: args.schema,
        format: args.format,
        state: args.state,
        slug: args.slug
      }).map((addition) => ({
        ...addition,
        path: pathPrefix + addition.path
      }));
      const additionPathToSha = new Map(await Promise.all(additions.map(async (addition) => [addition.path, await hydrateBlobCache(addition.contents)])));
      const filesToDelete = new Set((_args$initialFiles = args.initialFiles) === null || _args$initialFiles === void 0 ? void 0 : _args$initialFiles.map((x2) => pathPrefix + x2));
      for (const file of additions) {
        filesToDelete.delete(file.path);
      }
      additions = additions.filter((addition) => {
        const sha = additionPathToSha.get(addition.path);
        const existing = getTreeNodeAtPath(unscopedTree, addition.path);
        return (existing === null || existing === void 0 ? void 0 : existing.entry.sha) !== sha;
      });
      const deletions = [...filesToDelete].map((path) => ({
        path
      }));
      const updatedTree = await updateTreeWithChanges(unscopedTree, {
        additions,
        deletions: [...filesToDelete]
      });
      await hydrateTreeCacheWithEntries(updatedTree.entries);
      if (args.config.storage.kind === "github" || args.config.storage.kind === "cloud") {
        var _override$branch, _override$sha, _result$error, _result$data;
        const branch = {
          branchName: (_override$branch = override === null || override === void 0 ? void 0 : override.branch) !== null && _override$branch !== void 0 ? _override$branch : branchInfo.currentBranch,
          repositoryNameWithOwner: `${repoWithWriteAccess.owner}/${repoWithWriteAccess.name}`
        };
        const runMutation = (expectedHeadOid) => mutate({
          input: {
            branch,
            expectedHeadOid,
            message: {
              headline: `Update ${args.basePath}`
            },
            fileChanges: {
              additions: additions.map((addition) => ({
                ...addition,
                contents: fromUint8Array(addition.contents)
              })),
              deletions
            }
          }
        });
        let result = await runMutation((_override$sha = override === null || override === void 0 ? void 0 : override.sha) !== null && _override$sha !== void 0 ? _override$sha : baseCommit);
        const gqlError = (_result$error = result.error) === null || _result$error === void 0 || (_result$error = _result$error.graphQLErrors[0]) === null || _result$error === void 0 ? void 0 : _result$error.originalError;
        if (gqlError && "type" in gqlError) {
          if (gqlError.type === "BRANCH_PROTECTION_RULE_VIOLATION") {
            setState({
              kind: "needs-new-branch",
              reason: "Changes must be made via pull request to this branch. Create a new branch to save changes."
            });
            return false;
          }
          if (gqlError.type === "STALE_DATA") {
            var _refData$data, _args$slug3;
            const refData = await createUrqlClient(args.config).query(FetchRef, {
              owner: repoWithWriteAccess.owner,
              name: repoWithWriteAccess.name,
              ref: `refs/heads/${branchInfo.currentBranch}`
            }).toPromise();
            if (!((_refData$data = refData.data) !== null && _refData$data !== void 0 && (_refData$data = _refData$data.repository) !== null && _refData$data !== void 0 && (_refData$data = _refData$data.ref) !== null && _refData$data !== void 0 && _refData$data.target)) {
              throw new Error("Branch not found");
            }
            const tree = scopeEntriesWithPathPrefix(await fetchGitHubTreeData(refData.data.repository.ref.target.oid, args.config), args.config);
            const treeKey = getTreeKey(getDirectoriesForTreeKey(object(args.schema), args.basePath, (_args$slug3 = args.slug) === null || _args$slug3 === void 0 ? void 0 : _args$slug3.value, args.format), tree.tree);
            if (treeKey === args.currentLocalTreeKey) {
              result = await runMutation(refData.data.repository.ref.target.oid);
            } else {
              setState({
                kind: "needs-new-branch",
                reason: "This entry has been updated since it was opened. Create a new branch to save changes."
              });
              return false;
            }
          }
        }
        if (result.error) {
          throw result.error;
        }
        const target = (_result$data = result.data) === null || _result$data === void 0 || (_result$data = _result$data.createCommitOnBranch) === null || _result$data === void 0 || (_result$data = _result$data.ref) === null || _result$data === void 0 ? void 0 : _result$data.target;
        if (target) {
          setState({
            kind: "updated"
          });
          return true;
        }
        throw new Error("Failed to update");
      } else {
        const res = await fetch("/api/keystatic/update", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "no-cors": "1"
          },
          body: JSON.stringify({
            additions: additions.map((addition) => ({
              ...addition,
              contents: fromUint8Array(addition.contents)
            })),
            deletions
          })
        });
        if (!res.ok) {
          throw new Error(await res.text());
        }
        const newTree = await res.json();
        const {
          tree
        } = await hydrateTreeCacheWithEntries(newTree);
        setTreeSha(await treeSha(tree));
        setState({
          kind: "updated"
        });
        return true;
      }
    } catch (err) {
      setState({
        kind: "error",
        error: err
      });
      return false;
    }
  }, () => {
    setState({
      kind: "idle"
    });
  }];
}
var createCommitMutation = lib_default`
  mutation CreateCommit($input: CreateCommitOnBranchInput!) {
    createCommitOnBranch(input: $input) {
      ref {
        id
        target {
          id
          oid
          ... on Commit {
            tree {
              id
              oid
            }
          }
        }
      }
    }
  }
`;
function useDeleteItem(args) {
  const [state, setState] = (0, import_react8.useState)({
    kind: "idle"
  });
  const baseCommit = useBaseCommit();
  const branchInfo = (0, import_react8.useContext)(BranchInfoContext);
  const [, mutate] = useMutation(createCommitMutation);
  const setTreeSha = useSetTreeSha();
  const repoWithWriteAccess = (0, import_react8.useContext)(RepoWithWriteAccessContext);
  const appSlug = (0, import_react8.useContext)(AppSlugContext);
  const unscopedTreeData = useCurrentUnscopedTree();
  return [state, async () => {
    try {
      const unscopedTree = unscopedTreeData.kind === "loaded" ? unscopedTreeData.data.tree : void 0;
      if (!unscopedTree)
        return false;
      if (repoWithWriteAccess === null && args.storage.kind === "github" && appSlug !== null && appSlug !== void 0 && appSlug.value) {
        setState({
          kind: "needs-fork"
        });
        return false;
      }
      setState({
        kind: "loading"
      });
      const deletions = args.initialFiles.map((x2) => {
        var _getPathPrefix2;
        return ((_getPathPrefix2 = getPathPrefix(args.storage)) !== null && _getPathPrefix2 !== void 0 ? _getPathPrefix2 : "") + x2;
      });
      const updatedTree = await updateTreeWithChanges(unscopedTree, {
        additions: [],
        deletions
      });
      await hydrateTreeCacheWithEntries(updatedTree.entries);
      if (args.storage.kind === "github" || args.storage.kind === "cloud") {
        const {
          error
        } = await mutate({
          input: {
            branch: {
              repositoryNameWithOwner: `${repoWithWriteAccess.owner}/${repoWithWriteAccess.name}`,
              branchName: branchInfo.currentBranch
            },
            message: {
              headline: `Delete ${args.basePath}`
            },
            expectedHeadOid: baseCommit,
            fileChanges: {
              deletions: deletions.map((path) => ({
                path
              }))
            }
          }
        });
        if (error) {
          throw error;
        }
        setState({
          kind: "updated"
        });
        return true;
      } else {
        const res = await fetch("/api/keystatic/update", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "no-cors": "1"
          },
          body: JSON.stringify({
            additions: [],
            deletions: deletions.map((path) => ({
              path
            }))
          })
        });
        if (!res.ok) {
          throw new Error(await res.text());
        }
        const newTree = await res.json();
        const {
          tree
        } = await hydrateTreeCacheWithEntries(newTree);
        setTreeSha(await treeSha(tree));
        setState({
          kind: "updated"
        });
        return true;
      }
    } catch (err) {
      setState({
        kind: "error",
        error: err
      });
    }
  }, () => {
    setState({
      kind: "idle"
    });
  }];
}
var FetchRef = lib_default`
  query FetchRef($owner: String!, $name: String!, $ref: String!) {
    repository(owner: $owner, name: $name) {
      id
      ref(qualifiedName: $ref) {
        id
        target {
          id
          oid
        }
      }
    }
  }
`;
function useHasChanged(args) {
  const serialize = (0, import_react8.useCallback)((state) => {
    const slug = args.slugField ? getSlugFromState({
      schema: args.schema.fields,
      slugField: args.slugField
    }, state) : void 0;
    return {
      slug,
      state: serializeProps(state, args.schema, args.slugField, slug, true)
    };
  }, [args.schema, args.slugField]);
  const initialFilesForUpdate = (0, import_react8.useMemo)(() => args.initialState === null ? null : serialize(args.initialState), [args.initialState, serialize]);
  const filesForUpdate = (0, import_react8.useMemo)(() => serialize(args.state), [serialize, args.state]);
  return (0, import_react8.useMemo)(() => {
    return !(0, import_fast_deep_equal.default)(initialFilesForUpdate, filesForUpdate);
  }, [initialFilesForUpdate, filesForUpdate]);
}
function useSlugFieldInfo(collection, slugToExclude) {
  const config = useConfig();
  const allSlugs = useSlugsInCollection(collection);
  return (0, import_react8.useMemo)(() => {
    const slugs = new Set(allSlugs);
    if (slugToExclude) {
      slugs.delete(slugToExclude);
    }
    const collectionConfig = config.collections[collection];
    return {
      field: collectionConfig.slugField,
      slugs,
      glob: getSlugGlobForCollection(config, collection)
    };
  }, [allSlugs, collection, config, slugToExclude]);
}
function useYJsValue(schema2, type2) {
  const yjsInfo = useYjs();
  const thing = (0, import_react8.useMemo)(() => {
    let lastVal = yjsToVal(schema2, yjsInfo.awareness, type2);
    return {
      getSnapshot: () => lastVal,
      subscribe: (cb) => {
        const handler = () => {
          lastVal = yjsToVal(schema2, yjsInfo.awareness, type2);
          cb();
        };
        type2.observeDeep(handler);
        return () => {
          type2.unobserveDeep(handler);
        };
      }
    };
  }, [schema2, type2, yjsInfo.awareness]);
  return (0, import_react8.useSyncExternalStore)(thing.subscribe, thing.getSnapshot, thing.getSnapshot);
}
function castToMemoizedInfoForSchema(val) {
  return val;
}
function getOrInsert(map3, key, val) {
  if (!map3.has(key)) {
    map3.set(key, val(key));
  }
  return map3.get(key);
}
function findSingleReorderedElement(oldKeys, newKeys) {
  if (oldKeys.length !== newKeys.length)
    return;
  const sortedOldKeys = [...oldKeys].sort();
  const sortedNewKeys = [...newKeys].sort();
  if (sortedOldKeys.join() !== sortedNewKeys.join())
    return;
  let reorderedKey;
  for (let i = 0; i < oldKeys.length; i++) {
    if (oldKeys[i] !== newKeys[i]) {
      if (reorderedKey === newKeys[i])
        continue;
      if (reorderedKey !== void 0)
        return;
      reorderedKey = oldKeys[i];
    }
  }
  return reorderedKey;
}
function createGetPreviewPropsFromY(rootSchema, yMap, awareness) {
  const memoizedInfoForSchema = castToMemoizedInfoForSchema({
    form(schema2, onChange) {
      return onChange;
    },
    array(schema2, onChange) {
      return {
        rawOnChange: onChange,
        inner: /* @__PURE__ */ new Map(),
        onChange(updater) {
          const yArr = onChange.yjs();
          const oldVal = yjsToVal(schema2, awareness, yArr);
          const oldKeys = getKeysForArrayValue(yArr);
          const uniqueKeys = /* @__PURE__ */ new Set();
          for (const x2 of updater) {
            if (x2.key !== void 0) {
              if (uniqueKeys.has(x2.key)) {
                throw new Error("Array elements must have unique keys");
              }
              uniqueKeys.add(x2.key);
            }
          }
          const newKeys = updater.map((x2) => {
            if (x2.key !== void 0)
              return x2.key;
            let elementKey = getNewArrayElementKey();
            while (uniqueKeys.has(elementKey)) {
              elementKey = getNewArrayElementKey();
            }
            uniqueKeys.add(elementKey);
            return elementKey;
          });
          setKeysForArrayValue(yArr, newKeys);
          const reorderedKey = findSingleReorderedElement(oldKeys, newKeys);
          if (reorderedKey !== void 0) {
            const oldIndex = oldKeys.indexOf(reorderedKey);
            const newIndex = newKeys.indexOf(reorderedKey);
            let val = yArr.get(oldIndex);
            if (val instanceof AbstractType) {
              val = val.clone();
            }
            yArr.delete(oldIndex);
            yArr.insert(newIndex, [val]);
            for (const [idx, {
              value
            }] of updater.entries()) {
              const oldIndex2 = oldKeys.indexOf(newKeys[idx]);
              const newVal = updateValue(schema2.element, oldVal[oldIndex2], value);
              if (newVal !== oldVal) {
                yArr.delete(oldIndex2);
                yArr.insert(idx, [parsedValToYjs(schema2.element, newVal)]);
              }
            }
            return;
          }
          const oldKeysJoined = oldKeys.join();
          const newKeysJoined = newKeys.slice(0, oldKeys.length).join();
          if (oldKeysJoined === newKeysJoined) {
            for (const [idx, {
              value
            }] of updater.entries()) {
              const oldIndex = oldKeys.indexOf(newKeys[idx]);
              const newVal = updateValue(schema2.element, oldVal[oldIndex], value);
              if (newVal !== oldVal) {
                yArr.delete(oldIndex);
                yArr.insert(idx, [parsedValToYjs(schema2.element, newVal)]);
              }
            }
            const valsToInsert = [];
            for (const {
              value
            } of updater.slice(oldKeys.length)) {
              valsToInsert.push(parsedValToYjs(schema2.element, getInitialPropsValueFromInitializer(schema2.element, value)));
            }
            if (valsToInsert.length) {
              yArr.insert(oldKeys.length, valsToInsert);
            }
            return;
          }
          const newVals = updater.map((x2, i) => {
            const key = newKeys[i];
            const oldIndex = oldKeys.indexOf(key);
            if (oldIndex !== -1) {
              const oldElement = yArr.get(oldIndex);
              if (x2.value === void 0) {
                if (oldElement instanceof AbstractType) {
                  return oldElement.clone();
                }
                return oldElement;
              }
              const newVal = updateValue(schema2.element, oldVal[oldIndex], x2.value);
              return parsedValToYjs(schema2.element, newVal);
            }
            return parsedValToYjs(schema2.element, getInitialPropsValueFromInitializer(schema2.element, x2.value));
          });
          yArr.delete(0, yArr.length);
          yArr.insert(0, newVals);
        }
      };
    },
    conditional(schema2, stateUpdater) {
      return {
        onChange: (discriminant, value) => {
          stateUpdater.yjs().set("discriminant", discriminant);
          if (value !== void 0) {
            const old = yjsToVal(schema2, awareness, stateUpdater.yjs().get("value"));
            stateUpdater.yjs().set("value", parsedValToYjs(schema2, updateValue(schema2.values[discriminant.toString()], old, value)));
          }
        },
        onChangeForValue: Object.assign((cb) => {
          const old = yjsToVal(schema2, awareness, stateUpdater.yjs().get("value"));
          stateUpdater.yjs().set("value", parsedValToYjs(schema2, cb(old)));
        }, {
          yjs() {
            return stateUpdater.yjs().get("value");
          }
        })
      };
    },
    object(schema2, stateUpdater) {
      return {
        onChange: (updater) => {
          for (const [key, val] of Object.entries(updater)) {
            const oldVal = yjsToVal(schema2.fields[key], awareness, stateUpdater.yjs().get(key));
            stateUpdater.yjs().set(key, parsedValToYjs(schema2.fields[key], updateValue(schema2.fields[key], oldVal, val)));
          }
        },
        innerOnChanges: Object.fromEntries(Object.entries(schema2.fields).map(([key, val]) => {
          let func = Object.assign((newVal) => {
            stateUpdater.yjs().set(key, parsedValToYjs(val, newVal));
          }, {
            yjs() {
              return stateUpdater.yjs().get(key);
            }
          });
          return [key, func];
        }))
      };
    }
  });
  const previewPropsFactories = {
    form(schema2, value, onChange) {
      return {
        value,
        onChange,
        schema: schema2
      };
    },
    object(schema2, value, memoized, path, getInnerProp) {
      const fields = {};
      for (const key of Object.keys(schema2.fields)) {
        fields[key] = getInnerProp(schema2.fields[key], value[key], memoized.innerOnChanges[key], key);
      }
      const previewProps = {
        fields,
        onChange: memoized.onChange,
        schema: schema2
      };
      return previewProps;
    },
    array(schema2, value, memoized, path, getInnerProp) {
      const arrayValue = value;
      const keys = getKeysForArrayValue(arrayValue);
      const unusedKeys = new Set(getKeysForArrayValue(value));
      const props = {
        elements: arrayValue.map((val, i) => {
          const key = keys[i];
          unusedKeys.delete(key);
          const element = getOrInsert(memoized.inner, key, () => {
            const onChange = Object.assign((val2) => {
              const yArr = memoized.rawOnChange.yjs();
              const keys2 = getKeysForArrayValue(yArr);
              const index = keys2.indexOf(key);
              const newVal = val2(yjsToVal(schema2, awareness, yArr.get(index)));
              yArr.delete(index);
              yArr.insert(index, [parsedValToYjs(schema2.element, newVal)]);
            }, {
              yjs() {
                const keys2 = getKeysForArrayValue(memoized.rawOnChange.yjs());
                const i2 = keys2.indexOf(key);
                return memoized.rawOnChange.yjs().get(i2);
              }
            });
            const element2 = getInnerProp(schema2.element, val, onChange, key);
            return {
              element: element2,
              elementWithKey: {
                ...element2,
                key
              },
              onChange
            };
          });
          const currentInnerProp = getInnerProp(schema2.element, val, element.onChange, key);
          if (element.element !== currentInnerProp) {
            element.element = currentInnerProp;
            element.elementWithKey = {
              ...currentInnerProp,
              key
            };
          }
          return element.elementWithKey;
        }),
        schema: schema2,
        onChange: memoized.onChange
      };
      for (const key of unusedKeys) {
        memoized.inner.delete(key);
      }
      return props;
    },
    conditional(schema2, value, memoized, path, getInnerProp) {
      const props = {
        discriminant: value.discriminant,
        onChange: memoized.onChange,
        value: getInnerProp(schema2.values[value.discriminant.toString()], value.value, memoized.onChangeForValue, "value"),
        schema: schema2
      };
      return props;
    }
  };
  function getPreviewPropsForProp(schema2, value, memoedThing, path, getInnerProp) {
    return previewPropsFactories[schema2.kind](schema2, value, memoedThing, path, getInnerProp);
  }
  function getInitialMemoState(schema2, value, stateUpdater, path) {
    const innerState = /* @__PURE__ */ new Map();
    const memoizedInfo = memoizedInfoForSchema[schema2.kind](schema2, stateUpdater);
    const state = {
      value,
      inner: innerState,
      props: getPreviewPropsForProp(schema2, value, memoizedInfo, path, (schema3, value2, onChange, key) => {
        const state2 = getInitialMemoState(schema3, value2, onChange, path.concat(key));
        innerState.set(key, state2);
        return state2.props;
      }),
      schema: schema2,
      cached: memoizedInfo
    };
    return state;
  }
  function getUpToDateProps(schema2, value, stateUpdater, memoState2, path) {
    if (memoState2.schema !== schema2) {
      Object.assign(memoState2, getInitialMemoState(schema2, value, stateUpdater, path));
      return memoState2.props;
    }
    if (memoState2.value === value) {
      return memoState2.props;
    }
    memoState2.value = value;
    const unusedKeys = new Set(memoState2.inner.keys());
    memoState2.props = getPreviewPropsForProp(schema2, value, memoState2.cached, path, (schema3, value2, onChange, innerMemoStateKey) => {
      unusedKeys.delete(innerMemoStateKey);
      if (!memoState2.inner.has(innerMemoStateKey)) {
        const innerState = getInitialMemoState(schema3, value2, onChange, path.concat(innerMemoStateKey));
        memoState2.inner.set(innerMemoStateKey, innerState);
        return innerState.props;
      }
      return getUpToDateProps(schema3, value2, onChange, memoState2.inner.get(innerMemoStateKey), path.concat(innerMemoStateKey));
    });
    for (const key of unusedKeys) {
      memoState2.inner.delete(key);
    }
    return memoState2.props;
  }
  let memoState;
  const rootUpdater = Object.assign((cb) => {
    const newValue = cb(memoState.value);
    const innerYMap = parsedValToYjs(rootSchema, newValue);
    for (const [key, val] of innerYMap.entries()) {
      innerYMap.delete(key);
      yMap.set(key, val);
    }
  }, {
    yjs() {
      return yMap;
    }
  });
  return (value) => {
    if (memoState === void 0) {
      memoState = getInitialMemoState(rootSchema, value, rootUpdater, []);
      return memoState.props;
    }
    return getUpToDateProps(rootSchema, value, rootUpdater, memoState, []);
  };
}
var storedValSchema$2 = z.object({
  version: z.literal(1),
  savedAt: z.date(),
  slug: z.string(),
  beforeTreeKey: z.string(),
  files: z.map(z.string(), z.instanceof(Uint8Array))
});
function ItemPageInner(props) {
  var _getPathPrefix, _getPathPrefix2;
  const {
    collection,
    config,
    itemSlug,
    updateResult,
    onUpdate: parentOnUpdate
  } = props;
  const collectionConfig = props.config.collections[collection];
  const schema2 = (0, import_react8.useMemo)(() => object(collectionConfig.schema), [collectionConfig.schema]);
  const router = useRouter();
  const baseCommit = useBaseCommit();
  const currentBasePath = getCollectionItemPath(config, collection, itemSlug);
  const formatInfo = getCollectionFormat(config, collection);
  const branchInfo = useBranchInfo();
  const [forceValidation, setForceValidation] = (0, import_react8.useState)(false);
  const previewHref = (0, import_react8.useMemo)(() => {
    return collectionConfig.previewUrl ? collectionConfig.previewUrl.replace("{slug}", props.itemSlug).replace("{branch}", branchInfo.currentBranch) : void 0;
  }, [branchInfo.currentBranch, collectionConfig.previewUrl, props.itemSlug]);
  const onDelete = async () => {
    if (await deleteItem()) {
      router.push(`${props.basePath}/collection/${encodeURIComponent(collection)}`);
    }
  };
  const slugInfo = useSlugFieldInfo(collection, itemSlug);
  const [deleteResult, deleteItem, resetDeleteItem] = useDeleteItem({
    initialFiles: props.initialFiles,
    storage: config.storage,
    basePath: currentBasePath
  });
  const onDuplicate = () => {
    router.push(`${props.basePath}/collection/${encodeURIComponent(collection)}/create?duplicate=${itemSlug}`);
  };
  const isSavingDisabled = updateResult.kind === "loading" || !props.hasChanged;
  const onUpdate = (0, import_react8.useCallback)(async () => {
    if (isSavingDisabled)
      return false;
    if (!clientSideValidateProp(schema2, props.state, slugInfo)) {
      setForceValidation(true);
      return false;
    }
    const slug = getSlugFromState(collectionConfig, props.state);
    const hasUpdated = await parentOnUpdate();
    if (hasUpdated && slug !== itemSlug) {
      router.replace(`${props.basePath}/collection/${encodeURIComponent(collection)}/item/${encodeURIComponent(slug)}`);
    }
    return hasUpdated;
  }, [collection, collectionConfig, isSavingDisabled, itemSlug, parentOnUpdate, props.basePath, props.state, router, schema2, slugInfo]);
  const viewHref = config.storage.kind !== "local" ? `${getRepoUrl(branchInfo)}${formatInfo.dataLocation === "index" ? `/tree/${branchInfo.currentBranch}/${(_getPathPrefix = getPathPrefix(config.storage)) !== null && _getPathPrefix !== void 0 ? _getPathPrefix : ""}${currentBasePath}` : `/blob/${branchInfo.currentBranch}/${(_getPathPrefix2 = getPathPrefix(config.storage)) !== null && _getPathPrefix2 !== void 0 ? _getPathPrefix2 : ""}${currentBasePath}${getDataFileExtension(formatInfo)}`}` : void 0;
  const formID = "item-edit-form";
  (0, import_react8.useEffect)(() => {
    const listener = (event) => {
      if (updateResult.kind === "loading") {
        return;
      }
      if ((0, import_is_hotkey.isHotkey)("mod+s", event)) {
        event.preventDefault();
        onUpdate();
      }
    };
    document.addEventListener("keydown", listener);
    return () => document.removeEventListener("keydown", listener);
  }, [updateResult.kind, onUpdate]);
  return (0, import_jsx_runtime18.jsx)(import_jsx_runtime18.Fragment, {
    children: (0, import_jsx_runtime18.jsxs)(ItemPageShell, {
      headerActions: (0, import_jsx_runtime18.jsx)(HeaderActions, {
        formID,
        isLoading: updateResult.kind === "loading",
        hasChanged: props.hasChanged,
        onDelete,
        onDuplicate,
        onReset: props.onReset,
        viewHref,
        previewHref
      }),
      ...props,
      children: [updateResult.kind === "error" && (0, import_jsx_runtime18.jsx)(Notice, {
        tone: "critical",
        children: updateResult.error.message
      }), deleteResult.kind === "error" && (0, import_jsx_runtime18.jsx)(Notice, {
        tone: "critical",
        children: deleteResult.error.message
      }), (0, import_jsx_runtime18.jsx)(Box, {
        id: formID,
        height: "100%",
        minHeight: 0,
        minWidth: 0,
        elementType: "form",
        onSubmit: (event) => {
          if (event.target !== event.currentTarget)
            return;
          event.preventDefault();
          onUpdate();
        },
        children: (0, import_jsx_runtime18.jsx)(FormForEntry, {
          previewProps: props.previewProps,
          forceValidation,
          entryLayout: collectionConfig.entryLayout,
          formatInfo,
          slugField: slugInfo
        })
      }), (0, import_jsx_runtime18.jsx)(
        DialogContainer,
        {
          onDismiss: props.onResetUpdateItem,
          children: updateResult.kind === "needs-new-branch" && (0, import_jsx_runtime18.jsx)(CreateBranchDuringUpdateDialog, {
            branchOid: baseCommit,
            onCreate: async (newBranch) => {
              const itemBasePath = `/keystatic/branch/${encodeURIComponent(newBranch)}/collection/${encodeURIComponent(collection)}/item/`;
              router.push(itemBasePath + encodeURIComponent(itemSlug));
              const slug = getSlugFromState(collectionConfig, props.state);
              const hasUpdated = await parentOnUpdate({
                branch: newBranch,
                sha: baseCommit
              });
              if (hasUpdated && slug !== itemSlug) {
                router.replace(itemBasePath + encodeURIComponent(slug));
              }
            },
            reason: updateResult.reason,
            onDismiss: props.onResetUpdateItem
          })
        }
      ), (0, import_jsx_runtime18.jsx)(
        DialogContainer,
        {
          onDismiss: props.onResetUpdateItem,
          children: updateResult.kind === "needs-fork" && isGitHubConfig(props.config) && (0, import_jsx_runtime18.jsx)(ForkRepoDialog, {
            onCreate: async () => {
              const slug = getSlugFromState(collectionConfig, props.state);
              const hasUpdated = await props.onUpdate();
              if (hasUpdated && slug !== itemSlug) {
                router.replace(`${props.basePath}/collection/${encodeURIComponent(collection)}/item/${encodeURIComponent(slug)}`);
              }
            },
            onDismiss: props.onResetUpdateItem,
            config: props.config
          })
        }
      ), (0, import_jsx_runtime18.jsx)(
        DialogContainer,
        {
          onDismiss: resetDeleteItem,
          children: deleteResult.kind === "needs-fork" && isGitHubConfig(props.config) && (0, import_jsx_runtime18.jsx)(ForkRepoDialog, {
            onCreate: async () => {
              await deleteItem();
              router.push(`${props.basePath}/collection/${encodeURIComponent(collection)}`);
            },
            onDismiss: resetDeleteItem,
            config: props.config
          })
        }
      )]
    })
  });
}
function LocalItemPage(props) {
  var _draft$state;
  const {
    collection,
    config,
    initialFiles,
    initialState,
    localTreeKey,
    draft
  } = props;
  const collectionConfig = config.collections[collection];
  const schema2 = (0, import_react8.useMemo)(() => object(collectionConfig.schema), [collectionConfig.schema]);
  const [{
    state,
    localTreeKey: localTreeKeyInState
  }, setState] = (0, import_react8.useState)({
    state: (_draft$state = draft === null || draft === void 0 ? void 0 : draft.state) !== null && _draft$state !== void 0 ? _draft$state : initialState,
    localTreeKey
  });
  (0, import_react8.useEffect)(() => {
    if (draft && state === draft.state) {
      showDraftRestoredToast(draft.savedAt, localTreeKey !== draft.treeKey);
    }
  }, [draft]);
  if (localTreeKeyInState !== localTreeKey) {
    setState({
      state: initialState,
      localTreeKey
    });
  }
  const previewProps = (0, import_react8.useMemo)(() => createGetPreviewProps(schema2, (stateUpdater) => {
    setState((state2) => ({
      localTreeKey: state2.localTreeKey,
      state: stateUpdater(state2.state)
    }));
  }, () => void 0), [schema2])(state);
  const hasChanged = useHasChanged({
    initialState,
    schema: schema2,
    state,
    slugField: collectionConfig.slugField
  });
  const slug = getSlugFromState(collectionConfig, state);
  const formatInfo = getCollectionFormat(config, collection);
  const futureBasePath = getCollectionItemPath(config, collection, slug);
  const [updateResult, _update, resetUpdateItem] = useUpsertItem({
    state,
    initialFiles,
    config,
    schema: collectionConfig.schema,
    basePath: futureBasePath,
    format: formatInfo,
    currentLocalTreeKey: localTreeKey,
    slug: {
      field: collectionConfig.slugField,
      value: slug
    }
  });
  (0, import_react8.useEffect)(() => {
    const key = ["collection", collection, props.itemSlug];
    if (hasChanged) {
      const serialized = serializeEntryToFiles({
        basePath: futureBasePath,
        config,
        format: getCollectionFormat(config, collection),
        schema: collectionConfig.schema,
        slug: {
          field: collectionConfig.slugField,
          value: slug
        },
        state
      });
      const files = new Map(serialized.map((x2) => [x2.path, x2.contents]));
      const data = {
        beforeTreeKey: localTreeKey,
        slug,
        files,
        savedAt: /* @__PURE__ */ new Date(),
        version: 1
      };
      setDraft(key, data);
    } else {
      delDraft(key);
    }
  }, [collection, collectionConfig, config, futureBasePath, localTreeKey, props.itemSlug, slug, state, hasChanged]);
  const update = useEventCallback(_update);
  const onReset = () => {
    setState({
      state: initialState,
      localTreeKey
    });
  };
  return (0, import_jsx_runtime18.jsx)(ItemPageInner, {
    ...props,
    onUpdate: update,
    onReset,
    updateResult,
    onResetUpdateItem: resetUpdateItem,
    previewProps,
    state,
    hasChanged
  });
}
function CollabItemPage(props) {
  const {
    collection,
    config,
    initialFiles,
    initialState,
    localTreeKey
  } = props;
  const collectionConfig = config.collections[collection];
  const schema2 = (0, import_react8.useMemo)(() => object(collectionConfig.schema), [collectionConfig.schema]);
  const yjsInfo = useYjs();
  const state = useYJsValue(schema2, props.map);
  const previewProps = (0, import_react8.useMemo)(() => createGetPreviewPropsFromY(schema2, props.map, yjsInfo.awareness), [props.map, schema2, yjsInfo.awareness])(state);
  const slug = getSlugFromState(collectionConfig, state);
  const formatInfo = getCollectionFormat(props.config, props.collection);
  const hasChanged = useHasChanged({
    initialState,
    schema: schema2,
    state,
    slugField: collectionConfig.slugField
  });
  const futureBasePath = getCollectionItemPath(config, collection, slug);
  const [updateResult, _update, resetUpdateItem] = useUpsertItem({
    state,
    initialFiles,
    config,
    schema: collectionConfig.schema,
    basePath: futureBasePath,
    format: formatInfo,
    currentLocalTreeKey: localTreeKey,
    slug: {
      field: collectionConfig.slugField,
      value: slug
    }
  });
  const update = useEventCallback(_update);
  const onReset = () => {
    props.map.doc.transact(() => {
      for (const [key, value] of Object.entries(collectionConfig.schema)) {
        const val = getYjsValFromParsedValue(value, props.initialState[key]);
        props.map.set(key, val);
      }
    });
  };
  return (0, import_jsx_runtime18.jsx)(ItemPageInner, {
    ...props,
    onUpdate: update,
    onReset,
    updateResult,
    onResetUpdateItem: resetUpdateItem,
    previewProps,
    state,
    hasChanged
  });
}
function HeaderActions(props) {
  let {
    formID,
    hasChanged,
    isLoading,
    onDelete,
    onDuplicate,
    onReset,
    previewHref,
    viewHref
  } = props;
  const isBelowTablet = useMediaQuery(breakpointQueries$1.below.tablet);
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  const [deleteAlertIsOpen, setDeleteAlertOpen] = (0, import_react8.useState)(false);
  const [duplicateAlertIsOpen, setDuplicateAlertOpen] = (0, import_react8.useState)(false);
  const menuActions = (0, import_react8.useMemo)(() => {
    let items = [{
      key: "reset",
      label: "Reset changes",
      // TODO: l10n
      icon: historyIcon
    }, {
      key: "delete",
      label: "Delete entry…",
      // TODO: l10n
      icon: trash2Icon
    }, {
      key: "duplicate",
      label: "Duplicate entry…",
      // TODO: l10n
      icon: copyPlusIcon
    }];
    if (previewHref) {
      items.push({
        key: "preview",
        label: "Preview",
        icon: externalLinkIcon,
        href: previewHref,
        target: "_blank",
        rel: "noopener noreferrer"
      });
    }
    if (viewHref) {
      items.push({
        key: "view",
        label: "View on GitHub",
        icon: githubIcon,
        href: viewHref,
        target: "_blank",
        rel: "noopener noreferrer"
      });
    }
    return items;
  }, [previewHref, viewHref]);
  const indicatorElement = (() => {
    if (isLoading) {
      return (0, import_jsx_runtime18.jsx)(ProgressCircle, {
        "aria-label": "Saving changes",
        isIndeterminate: true,
        size: "small",
        alignSelf: "center"
      });
    }
    if (hasChanged) {
      return isBelowTablet ? (0, import_jsx_runtime18.jsx)(Box, {
        backgroundColor: "pendingEmphasis",
        height: "scale.75",
        width: "scale.75",
        borderRadius: "full",
        children: (0, import_jsx_runtime18.jsx)(Text, {
          visuallyHidden: true,
          children: "Unsaved"
        })
      }) : (0, import_jsx_runtime18.jsx)(Badge, {
        tone: "pending",
        children: "Unsaved"
      });
    }
    return null;
  })();
  return (0, import_jsx_runtime18.jsxs)(import_jsx_runtime18.Fragment, {
    children: [indicatorElement, (0, import_jsx_runtime18.jsx)(_ActionGroup, {
      buttonLabelBehavior: "hide",
      overflowMode: "collapse",
      prominence: "low",
      density: "compact",
      maxWidth: isBelowTablet ? "element.regular" : void 0,
      items: menuActions,
      disabledKeys: hasChanged ? [] : ["reset"],
      onAction: (key) => {
        switch (key) {
          case "reset":
            onReset();
            break;
          case "delete":
            setDeleteAlertOpen(true);
            break;
          case "duplicate":
            if (hasChanged) {
              setDuplicateAlertOpen(true);
            } else {
              onDuplicate();
            }
            break;
        }
      },
      children: (item) => (0, import_jsx_runtime18.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
        textValue: item.label,
        href: item.href,
        target: item.target,
        rel: item.rel,
        children: [(0, import_jsx_runtime18.jsx)(Icon, {
          src: item.icon
        }), (0, import_jsx_runtime18.jsx)(Text, {
          children: item.label
        })]
      }, item.key)
    }), (0, import_jsx_runtime18.jsx)(Button, {
      form: formID,
      isDisabled: isLoading,
      prominence: "high",
      type: "submit",
      children: stringFormatter.format("save")
    }), (0, import_jsx_runtime18.jsx)(DialogContainer, {
      onDismiss: () => setDeleteAlertOpen(false),
      children: deleteAlertIsOpen && (0, import_jsx_runtime18.jsx)(AlertDialog, {
        title: "Delete entry",
        tone: "critical",
        cancelLabel: "Cancel",
        primaryActionLabel: "Yes, delete",
        autoFocusButton: "cancel",
        onPrimaryAction: onDelete,
        children: "Are you sure? This action cannot be undone."
      })
    }), (0, import_jsx_runtime18.jsx)(DialogContainer, {
      onDismiss: () => setDuplicateAlertOpen(false),
      children: duplicateAlertIsOpen && (0, import_jsx_runtime18.jsx)(AlertDialog, {
        title: "Save and duplicate entry",
        tone: "neutral",
        cancelLabel: "Cancel",
        primaryActionLabel: "Save and duplicate",
        autoFocusButton: "primary",
        onPrimaryAction: onDuplicate,
        children: "You have unsaved changes. Save this entry to duplicate it."
      })
    })]
  });
}
function CreateBranchDuringUpdateDialog(props) {
  var _data$createRef;
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  const repositoryId = useRepositoryId();
  const [branchName, setBranchName] = (0, import_react8.useState)("");
  const [{
    error,
    fetching,
    data
  }, createBranch] = useCreateBranchMutation();
  const isLoading = fetching || !!(data !== null && data !== void 0 && (_data$createRef = data.createRef) !== null && _data$createRef !== void 0 && _data$createRef.__typename);
  const config = useConfig();
  const branchPrefix = getBranchPrefix(config);
  const propsForBranchPrefix = branchPrefix ? {
    UNSAFE_className: css({
      "& input": {
        paddingInlineStart: tokenSchema.size.space.xsmall
      }
    }),
    startElement: (0, import_jsx_runtime18.jsx)(Flex, {
      alignItems: "center",
      paddingStart: "regular",
      justifyContent: "center",
      pointerEvents: "none",
      children: (0, import_jsx_runtime18.jsx)(Text, {
        color: "neutralSecondary",
        children: branchPrefix
      })
    })
  } : {};
  return (0, import_jsx_runtime18.jsx)(Dialog, {
    children: (0, import_jsx_runtime18.jsxs)("form", {
      style: {
        display: "contents"
      },
      onSubmit: async (event) => {
        var _result$data;
        if (event.target !== event.currentTarget)
          return;
        event.preventDefault();
        const fullBranchName = (branchPrefix !== null && branchPrefix !== void 0 ? branchPrefix : "") + branchName;
        const name = `refs/heads/${fullBranchName}`;
        const result = await createBranch({
          input: {
            name,
            oid: props.branchOid,
            repositoryId
          }
        });
        if ((_result$data = result.data) !== null && _result$data !== void 0 && (_result$data = _result$data.createRef) !== null && _result$data !== void 0 && _result$data.__typename) {
          props.onCreate(fullBranchName);
        }
      },
      children: [(0, import_jsx_runtime18.jsx)(Heading, {
        children: stringFormatter.format("newBranch")
      }), (0, import_jsx_runtime18.jsx)(Content, {
        children: (0, import_jsx_runtime18.jsx)(Flex, {
          gap: "large",
          direction: "column",
          children: (0, import_jsx_runtime18.jsx)(TextField, {
            value: branchName,
            onChange: setBranchName,
            label: "Branch name",
            description: props.reason,
            autoFocus: true,
            errorMessage: prettyErrorForCreateBranchMutation(error),
            ...propsForBranchPrefix
          })
        })
      }), (0, import_jsx_runtime18.jsxs)(ButtonGroup, {
        children: [isLoading && (0, import_jsx_runtime18.jsx)(ProgressCircle, {
          isIndeterminate: true,
          size: "small",
          "aria-label": "Creating Branch"
        }), (0, import_jsx_runtime18.jsx)(Button, {
          isDisabled: isLoading,
          onPress: props.onDismiss,
          children: stringFormatter.format("cancel")
        }), (0, import_jsx_runtime18.jsx)(Button, {
          isDisabled: isLoading,
          prominence: "high",
          type: "submit",
          children: "Create branch and save"
        })]
      })]
    })
  });
}
function ItemPageWrapper(props) {
  var _props$config$collect;
  const collectionConfig = (_props$config$collect = props.config.collections) === null || _props$config$collect === void 0 ? void 0 : _props$config$collect[props.collection];
  if (!collectionConfig)
    notFound();
  const format = (0, import_react8.useMemo)(() => getCollectionFormat(props.config, props.collection), [props.config, props.collection]);
  const slugInfo = (0, import_react8.useMemo)(() => {
    return {
      slug: props.itemSlug,
      field: collectionConfig.slugField
    };
  }, [collectionConfig.slugField, props.itemSlug]);
  const draftData = useData((0, import_react8.useCallback)(async () => {
    const raw = await getDraft(["collection", props.collection, props.itemSlug]);
    if (!raw)
      throw new Error("No draft found");
    const stored = storedValSchema$2.parse(raw);
    const parsed = parseEntry({
      config: props.config,
      dirpath: getCollectionItemPath(props.config, props.collection, stored.slug),
      format,
      schema: collectionConfig.schema,
      slug: {
        field: collectionConfig.slugField,
        slug: stored.slug
      }
    }, stored.files);
    return {
      state: parsed.initialState,
      savedAt: stored.savedAt,
      treeKey: stored.beforeTreeKey
    };
  }, [collectionConfig, format, props.collection, props.config, props.itemSlug]));
  const itemData = useItemData({
    config: props.config,
    dirpath: getCollectionItemPath(props.config, props.collection, props.itemSlug),
    schema: collectionConfig.schema,
    format,
    slug: slugInfo
  });
  const branchInfo = useBranchInfo();
  const key = `${branchInfo.currentBranch}/${props.collection}/item/${props.itemSlug}`;
  const yjsInfo = useYjsIfAvailable();
  const mapData = useData((0, import_react8.useCallback)(async () => {
    if (!yjsInfo)
      return;
    if (yjsInfo === "loading")
      return LOADING;
    await yjsInfo.doc.whenSynced;
    if (itemData.kind !== "loaded")
      return LOADING;
    if (itemData.data === "not-found")
      return;
    let doc = yjsInfo.data.get(key);
    if (doc instanceof Doc) {
      const promise = doc.whenLoaded;
      doc.load();
      await promise;
    } else {
      doc = new Doc();
      yjsInfo.data.set(key, doc);
    }
    const data = doc.getMap("data");
    if (!data.size) {
      const {
        data: {
          initialState
        }
      } = itemData;
      doc.transact(() => {
        for (const [key2, value] of Object.entries(collectionConfig.schema)) {
          const val = getYjsValFromParsedValue(value, initialState[key2]);
          data.set(key2, val);
        }
      });
    }
    return data;
  }, [collectionConfig, itemData, key, yjsInfo]));
  if (itemData.kind === "error") {
    return (0, import_jsx_runtime18.jsx)(ItemPageShell, {
      ...props,
      children: (0, import_jsx_runtime18.jsx)(PageBody, {
        children: (0, import_jsx_runtime18.jsx)(Notice, {
          tone: "critical",
          children: itemData.error.message
        })
      })
    });
  }
  if (mapData.kind === "error") {
    return (0, import_jsx_runtime18.jsx)(ItemPageShell, {
      ...props,
      children: (0, import_jsx_runtime18.jsx)(PageBody, {
        children: (0, import_jsx_runtime18.jsx)(Notice, {
          tone: "critical",
          children: mapData.error.message
        })
      })
    });
  }
  if (itemData.kind === "loading" || draftData.kind === "loading" || mapData.kind === "loading") {
    return (0, import_jsx_runtime18.jsx)(ItemPageShell, {
      ...props,
      children: (0, import_jsx_runtime18.jsx)(Flex, {
        alignItems: "center",
        justifyContent: "center",
        minHeight: "scale.3000",
        children: (0, import_jsx_runtime18.jsx)(ProgressCircle, {
          "aria-label": "Loading Item",
          isIndeterminate: true,
          size: "large"
        })
      })
    });
  }
  if (itemData.data === "not-found") {
    return (0, import_jsx_runtime18.jsx)(ItemPageShell, {
      ...props,
      children: (0, import_jsx_runtime18.jsx)(PageBody, {
        children: (0, import_jsx_runtime18.jsx)(Notice, {
          tone: "caution",
          children: "Entry not found."
        })
      })
    });
  }
  const loadedDraft = draftData.kind === "loaded" ? draftData.data : void 0;
  if (mapData.data) {
    return (0, import_jsx_runtime18.jsx)(CollabItemPage, {
      collection: props.collection,
      basePath: props.basePath,
      config: props.config,
      itemSlug: props.itemSlug,
      initialState: itemData.data.initialState,
      initialFiles: itemData.data.initialFiles,
      localTreeKey: itemData.data.localTreeKey,
      map: mapData.data
    });
  }
  return (0, import_jsx_runtime18.jsx)(LocalItemPage, {
    collection: props.collection,
    basePath: props.basePath,
    config: props.config,
    itemSlug: props.itemSlug,
    initialState: itemData.data.initialState,
    initialFiles: itemData.data.initialFiles,
    draft: loadedDraft,
    localTreeKey: itemData.data.localTreeKey
  });
}
var ItemPageShell = (props) => {
  const router = useRouter();
  const collectionConfig = props.config.collections[props.collection];
  return (0, import_jsx_runtime18.jsxs)(PageRoot, {
    containerWidth: containerWidthForEntryLayout(collectionConfig),
    children: [(0, import_jsx_runtime18.jsxs)(PageHeader, {
      children: [(0, import_jsx_runtime18.jsxs)(_Breadcrumbs, {
        flex: true,
        size: "medium",
        minWidth: 0,
        onAction: (key) => {
          if (key === "collection") {
            router.push(`${props.basePath}/collection/${encodeURIComponent(props.collection)}`);
          }
        },
        children: [(0, import_jsx_runtime18.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
          children: collectionConfig.label
        }, "collection"), (0, import_jsx_runtime18.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
          children: props.itemSlug
        }, "item")]
      }), props.headerActions]
    }), props.children]
  });
};
function PresenceAvatars() {
  const yJsInfo = useYjsIfAvailable();
  return yJsInfo && yJsInfo !== "loading" ? (0, import_jsx_runtime18.jsx)(PresenceAvatarsInner, {
    yjsInfo: yJsInfo
  }) : null;
}
function PresenceAvatarsInner({
  yjsInfo
}) {
  const awarenessStates = (0, import_react8.useSyncExternalStore)((0, import_react8.useCallback)((onStoreChange) => {
    yjsInfo.awareness.on("change", onStoreChange);
    return () => yjsInfo.awareness.off("change", onStoreChange);
  }, [yjsInfo]), () => {
    var _yjsInfo$awareness;
    return (_yjsInfo$awareness = yjsInfo.awareness) === null || _yjsInfo$awareness === void 0 ? void 0 : _yjsInfo$awareness.getStates();
  });
  const seenUserIds = /* @__PURE__ */ new Set();
  return (0, import_jsx_runtime18.jsx)(Flex, {
    children: [...awarenessStates].map(([key, val]) => {
      var _val$user, _val$user2;
      if (yjsInfo.awareness.clientID === key || !val.user || seenUserIds.has(val.user.id)) {
        return null;
      }
      seenUserIds.add(val.user.id);
      return (0, import_jsx_runtime18.jsxs)(_TooltipTrigger, {
        children: [(0, import_jsx_runtime18.jsx)(Avatar, {
          src: (_val$user = val.user) === null || _val$user === void 0 ? void 0 : _val$user.avatarUrl
        }), (0, import_jsx_runtime18.jsx)(Tooltip, {
          children: (_val$user2 = val.user) === null || _val$user2 === void 0 ? void 0 : _val$user2.name
        })]
      }, key);
    })
  });
}
function CreateItemWrapper(props) {
  var _props$config$collect;
  const router = useRouter();
  const duplicateSlug = (0, import_react8.useMemo)(() => {
    const url = new URL(router.href, "http://localhost");
    return url.searchParams.get("duplicate");
  }, [router.href]);
  const collectionConfig = (_props$config$collect = props.config.collections) === null || _props$config$collect === void 0 ? void 0 : _props$config$collect[props.collection];
  if (!collectionConfig)
    notFound();
  const format = (0, import_react8.useMemo)(() => getCollectionFormat(props.config, props.collection), [props.config, props.collection]);
  const draftData = useData((0, import_react8.useCallback)(async () => {
    const raw = await getDraft(["collection-create", props.collection, ...duplicateSlug ? [duplicateSlug] : []]);
    if (!raw)
      throw new Error("No draft found");
    const stored = storedValSchema$1.parse(raw);
    const parsed = parseEntry({
      config: props.config,
      dirpath: getCollectionItemPath(props.config, props.collection, stored.slug),
      format,
      schema: collectionConfig.schema,
      slug: {
        field: collectionConfig.slugField,
        slug: stored.slug
      }
    }, stored.files);
    return {
      state: parsed.initialState,
      savedAt: stored.savedAt
    };
  }, [collectionConfig, duplicateSlug, format, props.collection, props.config]));
  const slug = (0, import_react8.useMemo)(() => {
    if (duplicateSlug) {
      return {
        field: collectionConfig.slugField,
        slug: duplicateSlug
      };
    }
    if (collectionConfig.template) {
      return {
        field: collectionConfig.slugField,
        slug: ""
      };
    }
  }, [duplicateSlug, collectionConfig]);
  const isFromTemplate = !!duplicateSlug || !!collectionConfig.template;
  const itemData = useItemData({
    config: props.config,
    dirpath: collectionConfig.template && !duplicateSlug ? collectionConfig.template : getCollectionItemPath(props.config, props.collection, duplicateSlug !== null && duplicateSlug !== void 0 ? duplicateSlug : ""),
    schema: collectionConfig.schema,
    format,
    slug
  });
  const duplicateInitalState = isFromTemplate && itemData.kind === "loaded" && itemData.data !== "not-found" ? itemData.data.initialState : void 0;
  const duplicateInitalStateWithUpdatedSlug = (0, import_react8.useMemo)(() => {
    if (duplicateInitalState) {
      let slugFieldValue = duplicateInitalState[collectionConfig.slugField];
      try {
        const slugFieldSchema = collectionConfig.schema[collectionConfig.slugField];
        if (slugFieldSchema.kind !== "form" || slugFieldSchema.formKind !== "slug") {
          throw new Error("not slug field");
        }
        const serialized = slugFieldSchema.serializeWithSlug(slugFieldValue);
        slugFieldValue = slugFieldSchema.parse(serialized.value, {
          slug: serialized.slug ? `${serialized.slug}-copy` : ""
        });
      } catch {
      }
      return {
        ...duplicateInitalState,
        [collectionConfig.slugField]: slugFieldValue
      };
    }
  }, [collectionConfig.schema, collectionConfig.slugField, duplicateInitalState]);
  const branchInfo = useBranchInfo();
  const yjsInfo = useYjsIfAvailable();
  const key = `${branchInfo.currentBranch}/${props.collection}/create${duplicateSlug !== null && duplicateSlug !== void 0 && duplicateSlug.length ? `?duplicate=${duplicateSlug}` : ""}`;
  const mapData = useData((0, import_react8.useCallback)(async () => {
    if (!yjsInfo)
      return;
    if (yjsInfo === "loading")
      return LOADING;
    await yjsInfo.doc.whenSynced;
    if (isFromTemplate && !duplicateInitalState)
      return LOADING;
    let doc = yjsInfo.data.get(key);
    if (doc instanceof Doc) {
      const promise = doc.whenLoaded;
      doc.load();
      await promise;
    } else {
      doc = new Doc();
      yjsInfo.data.set(key, doc);
    }
    const data = doc.getMap("data");
    if (!data.size) {
      doc.transact(() => {
        for (const [key2, value] of Object.entries(collectionConfig.schema)) {
          var _duplicateInitalState;
          const val = getYjsValFromParsedValue(value, (_duplicateInitalState = duplicateInitalState === null || duplicateInitalState === void 0 ? void 0 : duplicateInitalState[key2]) !== null && _duplicateInitalState !== void 0 ? _duplicateInitalState : getInitialPropsValue(value));
          data.set(key2, val);
        }
      });
    }
    return data;
  }, [collectionConfig, duplicateInitalState, isFromTemplate, key, yjsInfo]));
  if (isFromTemplate && itemData.kind === "error") {
    return (0, import_jsx_runtime18.jsx)(PageBody, {
      children: (0, import_jsx_runtime18.jsx)(Notice, {
        tone: "critical",
        children: itemData.error.message
      })
    });
  }
  if (mapData.kind === "error") {
    console.log(mapData.error);
    return (0, import_jsx_runtime18.jsx)(PageBody, {
      children: (0, import_jsx_runtime18.jsx)(Notice, {
        tone: "critical",
        children: mapData.error.message
      })
    });
  }
  if (isFromTemplate && itemData.kind === "loading" || draftData.kind === "loading" || mapData.kind === "loading") {
    return (0, import_jsx_runtime18.jsx)(Flex, {
      alignItems: "center",
      justifyContent: "center",
      minHeight: "scale.3000",
      children: (0, import_jsx_runtime18.jsx)(ProgressCircle, {
        "aria-label": "Loading Item",
        isIndeterminate: true,
        size: "large"
      })
    });
  }
  if (isFromTemplate && itemData.kind === "loaded" && itemData.data === "not-found") {
    return (0, import_jsx_runtime18.jsx)(PageBody, {
      children: (0, import_jsx_runtime18.jsx)(Notice, {
        tone: "caution",
        children: "Entry not found."
      })
    });
  }
  if (!mapData.data) {
    return (0, import_jsx_runtime18.jsx)(CreateItemLocal, {
      collection: props.collection,
      config: props.config,
      basePath: props.basePath,
      draft: draftData.kind === "loaded" ? draftData.data : void 0,
      duplicateSlug,
      initialState: duplicateInitalStateWithUpdatedSlug
    });
  }
  return (0, import_jsx_runtime18.jsx)(CreateItemCollab, {
    collection: props.collection,
    config: props.config,
    basePath: props.basePath,
    duplicateSlug,
    initialState: duplicateInitalStateWithUpdatedSlug,
    map: mapData.data
  });
}
var storedValSchema$1 = z.object({
  version: z.literal(1),
  savedAt: z.date(),
  slug: z.string(),
  files: z.map(z.string(), z.instanceof(Uint8Array))
});
function CreateItemLocal(props) {
  var _props$config$collect2, _props$draft$state, _props$draft;
  const collectionConfig = (_props$config$collect2 = props.config.collections) === null || _props$config$collect2 === void 0 ? void 0 : _props$config$collect2[props.collection];
  if (!collectionConfig)
    notFound();
  const schema2 = (0, import_react8.useMemo)(() => object(collectionConfig.schema), [collectionConfig.schema]);
  const initialState = (0, import_react8.useMemo)(() => {
    var _props$initialState;
    return (_props$initialState = props.initialState) !== null && _props$initialState !== void 0 ? _props$initialState : getInitialPropsValue(schema2);
  }, [props.initialState, schema2]);
  const [state, setState] = (0, import_react8.useState)((_props$draft$state = (_props$draft = props.draft) === null || _props$draft === void 0 ? void 0 : _props$draft.state) !== null && _props$draft$state !== void 0 ? _props$draft$state : initialState);
  const previewProps = (0, import_react8.useMemo)(() => createGetPreviewProps(schema2, setState, () => void 0), [schema2])(state);
  (0, import_react8.useEffect)(() => {
    if (props.draft && state === props.draft.state) {
      showDraftRestoredToast(props.draft.savedAt, false);
    }
  }, [props.draft]);
  const slug = getSlugFromState(collectionConfig, state);
  const formatInfo = getCollectionFormat(props.config, props.collection);
  const basePath = getCollectionItemPath(props.config, props.collection, slug);
  const [createResult, _createItem, resetCreateItemState] = useUpsertItem({
    state,
    basePath,
    initialFiles: void 0,
    config: props.config,
    schema: collectionConfig.schema,
    format: formatInfo,
    currentLocalTreeKey: void 0,
    slug: {
      field: collectionConfig.slugField,
      value: slug
    }
  });
  const createItem = useEventCallback(_createItem);
  const hasChanged = useHasChanged({
    initialState,
    schema: schema2,
    state,
    slugField: collectionConfig.slugField
  });
  const hasCreated = createResult.kind === "updated" || createResult.kind === "loading";
  (0, import_react8.useEffect)(() => {
    const key = ["collection-create", props.collection, ...props.duplicateSlug ? [props.duplicateSlug] : []];
    if (hasChanged && !hasCreated) {
      const serialized = serializeEntryToFiles({
        basePath,
        config: props.config,
        format: formatInfo,
        schema: collectionConfig.schema,
        slug: {
          field: collectionConfig.slugField,
          value: slug
        },
        state
      });
      const files = new Map(serialized.map((x2) => [x2.path, x2.contents]));
      const data = {
        slug,
        files,
        savedAt: /* @__PURE__ */ new Date(),
        version: 1
      };
      setDraft(key, data);
    } else {
      delDraft(key);
    }
  }, [collectionConfig, slug, state, hasChanged, props.duplicateSlug, props.collection, props.config, basePath, formatInfo, hasCreated]);
  return (0, import_jsx_runtime18.jsx)(CreateItemInner, {
    basePath: props.basePath,
    collection: props.collection,
    createResult,
    createItem,
    resetCreateItemState,
    state,
    slug,
    previewProps,
    onReset: () => {
      setState(initialState);
    }
  });
}
function CreateItemCollab(props) {
  var _props$config$collect3;
  const collectionConfig = (_props$config$collect3 = props.config.collections) === null || _props$config$collect3 === void 0 ? void 0 : _props$config$collect3[props.collection];
  if (!collectionConfig)
    notFound();
  const schema2 = (0, import_react8.useMemo)(() => object(collectionConfig.schema), [collectionConfig.schema]);
  const yjsInfo = useYjs();
  const state = useYJsValue(schema2, props.map);
  const previewProps = (0, import_react8.useMemo)(() => createGetPreviewPropsFromY(schema2, props.map, yjsInfo.awareness), [props.map, schema2, yjsInfo.awareness])(state);
  const slug = getSlugFromState(collectionConfig, state);
  const formatInfo = getCollectionFormat(props.config, props.collection);
  const basePath = getCollectionItemPath(props.config, props.collection, slug);
  const [createResult, _createItem, resetCreateItemState] = useUpsertItem({
    state,
    basePath,
    initialFiles: void 0,
    config: props.config,
    schema: collectionConfig.schema,
    format: formatInfo,
    currentLocalTreeKey: void 0,
    slug: {
      field: collectionConfig.slugField,
      value: slug
    }
  });
  const createItem = useEventCallback(_createItem);
  return (0, import_jsx_runtime18.jsx)(CreateItemInner, {
    basePath: props.basePath,
    collection: props.collection,
    createResult,
    createItem,
    resetCreateItemState,
    state,
    slug,
    previewProps,
    onReset: () => {
      props.map.doc.transact(() => {
        for (const [key, value] of Object.entries(collectionConfig.schema)) {
          var _props$initialState$k, _props$initialState2;
          const val = getYjsValFromParsedValue(value, (_props$initialState$k = (_props$initialState2 = props.initialState) === null || _props$initialState2 === void 0 ? void 0 : _props$initialState2[key]) !== null && _props$initialState$k !== void 0 ? _props$initialState$k : getInitialPropsValue(value));
          props.map.set(key, val);
        }
      });
    }
  });
}
function CreateItemInner(props) {
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  const router = useRouter();
  const config = useConfig();
  const collectionConfig = config.collections[props.collection];
  const schema2 = (0, import_react8.useMemo)(() => object(collectionConfig.schema), [collectionConfig]);
  const [forceValidation, setForceValidation] = (0, import_react8.useState)(false);
  const formatInfo = getCollectionFormat(config, props.collection);
  const baseCommit = useBaseCommit();
  let collectionPath = `${props.basePath}/collection/${encodeURIComponent(props.collection)}`;
  const {
    createResult
  } = props;
  const currentSlug = createResult.kind === "updated" || createResult.kind === "loading" ? props.slug : void 0;
  const slugInfo = useSlugFieldInfo(props.collection, currentSlug);
  const onCreate = async () => {
    if (createResult.kind === "loading")
      return;
    if (!clientSideValidateProp(schema2, props.state, slugInfo)) {
      setForceValidation(true);
      return;
    }
    if (await props.createItem()) {
      const slug = getSlugFromState(collectionConfig, props.state);
      router.push(`${collectionPath}/item/${encodeURIComponent(slug)}`);
      toastQueue.positive("Entry created", {
        timeout: 5e3
      });
    }
  };
  const isLoading = createResult.kind === "loading" || createResult.kind === "updated";
  const formID = "item-create-form";
  return (0, import_jsx_runtime18.jsxs)(import_jsx_runtime18.Fragment, {
    children: [(0, import_jsx_runtime18.jsxs)(PageRoot, {
      containerWidth: containerWidthForEntryLayout(collectionConfig),
      children: [(0, import_jsx_runtime18.jsxs)(PageHeader, {
        children: [(0, import_jsx_runtime18.jsxs)(_Breadcrumbs, {
          size: "medium",
          flex: true,
          minWidth: 0,
          onAction: (key) => {
            if (key === "collection") {
              router.push(collectionPath);
            }
          },
          children: [(0, import_jsx_runtime18.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
            children: collectionConfig.label
          }, "collection"), (0, import_jsx_runtime18.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
            children: stringFormatter.format("add")
          }, "current")]
        }), (0, import_jsx_runtime18.jsx)(PresenceAvatars, {}), isLoading && (0, import_jsx_runtime18.jsx)(ProgressCircle, {
          "aria-label": "Creating entry",
          isIndeterminate: true,
          size: "small"
        }), (0, import_jsx_runtime18.jsxs)(_TooltipTrigger, {
          children: [(0, import_jsx_runtime18.jsx)(Button, {
            prominence: "low",
            "aria-label": "Reset",
            onPress: () => {
              props.onReset();
              setForceValidation(false);
            },
            children: (0, import_jsx_runtime18.jsx)(Icon, {
              src: historyIcon
            })
          }), (0, import_jsx_runtime18.jsx)(Tooltip, {
            children: "Reset"
          })]
        }), (0, import_jsx_runtime18.jsx)(Button, {
          isDisabled: isLoading,
          prominence: "high",
          type: "submit",
          form: formID,
          marginStart: "auto",
          children: stringFormatter.format("create")
        })]
      }), (0, import_jsx_runtime18.jsxs)(Flex, {
        id: formID,
        elementType: "form",
        onSubmit: (event) => {
          if (event.target !== event.currentTarget)
            return;
          event.preventDefault();
          onCreate();
        },
        direction: "column",
        gap: "xxlarge",
        height: "100%",
        minHeight: 0,
        minWidth: 0,
        children: [createResult.kind === "error" && (0, import_jsx_runtime18.jsx)(Notice, {
          tone: "critical",
          children: createResult.error.message
        }), (0, import_jsx_runtime18.jsx)(FormForEntry, {
          previewProps: props.previewProps,
          forceValidation,
          entryLayout: collectionConfig.entryLayout,
          formatInfo,
          slugField: slugInfo
        })]
      })]
    }), (0, import_jsx_runtime18.jsx)(
      DialogContainer,
      {
        onDismiss: props.resetCreateItemState,
        children: createResult.kind === "needs-new-branch" && (0, import_jsx_runtime18.jsx)(CreateBranchDuringUpdateDialog, {
          branchOid: baseCommit,
          onCreate: async (newBranch) => {
            router.push(`/keystatic/branch/${encodeURIComponent(newBranch)}/collection/${encodeURIComponent(props.collection)}/create`);
            if (await props.createItem({
              branch: newBranch,
              sha: baseCommit
            })) {
              const slug = getSlugFromState(collectionConfig, props.state);
              router.push(`/keystatic/branch/${encodeURIComponent(newBranch)}/collection/${encodeURIComponent(props.collection)}/item/${encodeURIComponent(slug)}`);
            }
          },
          reason: createResult.reason,
          onDismiss: props.resetCreateItemState
        })
      }
    ), (0, import_jsx_runtime18.jsx)(
      DialogContainer,
      {
        onDismiss: props.resetCreateItemState,
        children: createResult.kind === "needs-fork" && isGitHubConfig(config) && (0, import_jsx_runtime18.jsx)(ForkRepoDialog, {
          onCreate: async () => {
            if (await props.createItem()) {
              const slug = getSlugFromState(collectionConfig, props.state);
              router.push(`${collectionPath}/item/${encodeURIComponent(slug)}`);
            }
          },
          onDismiss: props.resetCreateItemState,
          config
        })
      }
    )]
  });
}
var DashboardSection = ({
  children,
  title
}) => {
  return (0, import_jsx_runtime18.jsxs)(Flex, {
    elementType: "section",
    direction: "column",
    gap: "medium",
    children: [(0, import_jsx_runtime18.jsx)(Text, {
      casing: "uppercase",
      color: "neutralTertiary",
      size: "small",
      weight: "bold",
      elementType: "h2",
      children: title
    }), children]
  });
};
var FILL_COLS = "fill";
var DashboardGrid = (props) => {
  return (0, import_jsx_runtime18.jsx)("div", {
    className: css({
      display: "grid",
      gap: tokenSchema.size.space.large,
      gridAutoRows: tokenSchema.size.element.xlarge,
      gridTemplateColumns: `[${FILL_COLS}-start] 1fr [${FILL_COLS}-end]`,
      [containerQueries.above.mobile]: {
        gridTemplateColumns: `[${FILL_COLS}-start] 1fr 1fr [${FILL_COLS}-end]`
      },
      [containerQueries.above.tablet]: {
        gridTemplateColumns: `[${FILL_COLS}-start] 1fr 1fr 1fr [${FILL_COLS}-end]`
      }
    }),
    ...props
  });
};
var DashboardCard = (props) => {
  const ref = (0, import_react8.useRef)(null);
  const {
    linkProps
  } = $298d61e98472621b$export$dcf14c9974fe2767(props, ref);
  return (0, import_jsx_runtime18.jsxs)(Flex, {
    alignItems: "center",
    backgroundColor: "canvas",
    padding: "large",
    position: "relative",
    children: [(0, import_jsx_runtime18.jsxs)(Flex, {
      direction: "column",
      gap: "medium",
      flex: true,
      children: [(0, import_jsx_runtime18.jsx)(Heading, {
        elementType: "h3",
        size: "small",
        truncate: true,
        children: (0, import_jsx_runtime18.jsx)("a", {
          ref,
          href: props.href,
          ...linkProps,
          className: classNames(css({
            color: tokenSchema.color.foreground.neutral,
            outline: "none",
            "&:hover": {
              color: tokenSchema.color.foreground.neutralEmphasis,
              "::before": {
                backgroundColor: tokenSchema.color.alias.backgroundIdle,
                borderColor: tokenSchema.color.border.neutral
              }
            },
            "&:active": {
              "::before": {
                backgroundColor: tokenSchema.color.alias.backgroundHovered,
                borderColor: tokenSchema.color.alias.borderHovered
              }
            },
            "&:focus-visible::before": {
              outline: `${tokenSchema.size.alias.focusRing} solid ${tokenSchema.color.alias.focusRing}`,
              outlineOffset: tokenSchema.size.alias.focusRingGap
            },
            // fill the available space so that the card is clickable
            "::before": {
              border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.muted}`,
              borderRadius: tokenSchema.size.radius.medium,
              content: '""',
              position: "absolute",
              inset: 0,
              transition: transition(["background-color", "border-color"])
            }
          })),
          children: props.label
        })
      }), props.children]
    }), props.endElement]
  });
};
function useLocalizedString() {
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  return stringFormatter;
}
function BranchSection(props) {
  let branchInfo = useBranchInfo();
  let router = useRouter();
  let localizedString = useLocalizedString();
  if (isLocalConfig(props.config)) {
    return null;
  }
  let repoURL = getRepoUrl(branchInfo);
  let isDefaultBranch = branchInfo.currentBranch === branchInfo.defaultBranch;
  return (0, import_jsx_runtime18.jsxs)(DashboardSection, {
    title: localizedString.format("currentBranch"),
    children: [(0, import_jsx_runtime18.jsxs)(Flex, {
      alignItems: "center",
      gap: "regular",
      border: "muted",
      borderRadius: "medium",
      backgroundColor: "canvas",
      padding: "large",
      children: [(0, import_jsx_runtime18.jsx)(Icon, {
        src: gitBranchIcon,
        color: "neutralTertiary"
      }), (0, import_jsx_runtime18.jsx)(Text, {
        size: "medium",
        weight: "semibold",
        children: branchInfo.currentBranch
      })]
    }), (0, import_jsx_runtime18.jsxs)(Flex, {
      gap: "regular",
      wrap: true,
      children: [(0, import_jsx_runtime18.jsxs)(_DialogTrigger, {
        children: [(0, import_jsx_runtime18.jsxs)(ActionButton, {
          children: [(0, import_jsx_runtime18.jsx)(Icon, {
            src: gitBranchPlusIcon
          }), (0, import_jsx_runtime18.jsx)(Text, {
            children: localizedString.format("newBranch")
          })]
        }), (close) => (0, import_jsx_runtime18.jsx)(CreateBranchDialog, {
          onDismiss: close,
          onCreate: (branchName) => {
            close();
            router.push(router.href.replace(/\/branch\/[^/]+/, "/branch/" + encodeURIComponent(branchName)));
          }
        })]
      }), !isDefaultBranch && (branchInfo.pullRequestNumber === void 0 ? (0, import_jsx_runtime18.jsxs)(ActionButton, {
        href: `${repoURL}/pull/new/${branchInfo.currentBranch}`,
        target: "_blank",
        children: [(0, import_jsx_runtime18.jsx)(Icon, {
          src: gitPullRequestIcon
        }), (0, import_jsx_runtime18.jsx)(Text, {
          children: localizedString.format("createPullRequest")
        })]
      }) : (0, import_jsx_runtime18.jsxs)(ActionButton, {
        href: `${repoURL}/pull/${branchInfo.pullRequestNumber}`,
        target: "_blank",
        children: [(0, import_jsx_runtime18.jsx)(Icon, {
          src: gitPullRequestIcon
        }), (0, import_jsx_runtime18.jsxs)(Text, {
          children: ["Pull request #", branchInfo.pullRequestNumber]
        })]
      }))]
    })]
  });
}
function DashboardCards() {
  const navItems = useNavItems();
  const hasSections = navItems.some((item) => "children" in item);
  const items = navItems.map((item) => renderItemOrGroup(item));
  return hasSections ? (0, import_jsx_runtime18.jsx)(import_jsx_runtime18.Fragment, {
    children: items
  }) : (0, import_jsx_runtime18.jsx)(DashboardSection, {
    title: "Content",
    children: (0, import_jsx_runtime18.jsx)(DashboardGrid, {
      children: items
    })
  });
}
var dividerCount = 0;
function renderItemOrGroup(itemOrGroup) {
  if ("isDivider" in itemOrGroup) {
    return (0, import_jsx_runtime18.jsx)(Flex, {
      gridColumn: FILL_COLS,
      children: (0, import_jsx_runtime18.jsx)(Divider, {
        alignSelf: "center",
        size: "medium",
        width: "alias.singleLineWidth"
      })
    }, dividerCount++);
  }
  if ("children" in itemOrGroup) {
    return (0, import_jsx_runtime18.jsx)(DashboardSection, {
      title: itemOrGroup.title,
      children: (0, import_jsx_runtime18.jsx)(DashboardGrid, {
        children: itemOrGroup.children.map((child) => renderItemOrGroup(child))
      })
    }, itemOrGroup.title);
  }
  let changeElement = (() => {
    if (!itemOrGroup.changed) {
      return void 0;
    }
    return typeof itemOrGroup.changed === "number" ? (0, import_jsx_runtime18.jsx)(Badge, {
      tone: "accent",
      marginStart: "auto",
      children: pluralize(itemOrGroup.changed, {
        singular: "change",
        plural: "changes"
      })
    }) : (0, import_jsx_runtime18.jsx)(Badge, {
      tone: "accent",
      children: "Changed"
    });
  })();
  let endElement = (() => {
    if (typeof itemOrGroup.entryCount !== "number") {
      return changeElement;
    }
    return (0, import_jsx_runtime18.jsxs)(Flex, {
      gap: "medium",
      alignItems: "center",
      children: [changeElement, (0, import_jsx_runtime18.jsx)(ActionButton, {
        "aria-label": "Add",
        href: `${itemOrGroup.href}/create`,
        children: (0, import_jsx_runtime18.jsx)(Icon, {
          src: plusIcon
        })
      })]
    });
  })();
  return (0, import_jsx_runtime18.jsx)(DashboardCard, {
    label: itemOrGroup.label,
    href: itemOrGroup.href,
    endElement,
    children: typeof itemOrGroup.entryCount === "number" ? (0, import_jsx_runtime18.jsx)(Text, {
      color: "neutralSecondary",
      children: pluralize(itemOrGroup.entryCount, {
        singular: "entry",
        plural: "entries"
      })
    }) : null
  }, itemOrGroup.key);
}
function DashboardPage(props) {
  var _viewer$name;
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  const viewer = useViewer();
  const cloudInfo = useCloudInfo();
  const user = viewer ? {
    name: (_viewer$name = viewer.name) !== null && _viewer$name !== void 0 ? _viewer$name : viewer.login,
    avatarUrl: viewer.avatarUrl
  } : cloudInfo === null || cloudInfo === void 0 ? void 0 : cloudInfo.user;
  return (0, import_jsx_runtime18.jsxs)(PageRoot, {
    containerWidth: "large",
    children: [(0, import_jsx_runtime18.jsx)(PageHeader, {
      children: (0, import_jsx_runtime18.jsx)(Heading, {
        elementType: "h1",
        id: "page-title",
        size: "small",
        children: stringFormatter.format("dashboard")
      })
    }), (0, import_jsx_runtime18.jsx)(PageBody, {
      isScrollable: true,
      children: (0, import_jsx_runtime18.jsxs)(Flex, {
        direction: "column",
        gap: "xxlarge",
        children: [user && (0, import_jsx_runtime18.jsx)(UserInfo, {
          user,
          manageAccount: !!cloudInfo
        }), (0, import_jsx_runtime18.jsx)(BranchSection, {
          config: props.config
        }), (0, import_jsx_runtime18.jsx)(DashboardCards, {})]
      })
    })]
  });
}
function UserInfo({
  user,
  manageAccount
}) {
  return (0, import_jsx_runtime18.jsxs)(Flex, {
    alignItems: "center",
    gap: "medium",
    isHidden: {
      below: "tablet"
    },
    children: [(0, import_jsx_runtime18.jsx)(Avatar, {
      src: user.avatarUrl,
      name: user.name,
      size: "large"
    }), (0, import_jsx_runtime18.jsxs)(VStack, {
      gap: "medium",
      children: [(0, import_jsx_runtime18.jsxs)(Heading, {
        size: "medium",
        elementType: "p",
        UNSAFE_style: {
          fontWeight: tokenSchema.typography.fontWeight.bold
        },
        children: ["Hello, ", user.name, "!"]
      }), manageAccount && (0, import_jsx_runtime18.jsx)(TextLink, {
        href: "https://keystatic.cloud/account",
        children: "Manage Account"
      })]
    })]
  });
}
var MainPanelLayout = (props) => {
  let isBelowDesktop = useMediaQuery(breakpointQueries$1.below.desktop);
  let sidebarState = useSidebar();
  let ref = (0, import_react8.useRef)(null);
  let context = useContentPanelState(ref);
  return (0, import_jsx_runtime18.jsx)(ContentPanelProvider, {
    value: context,
    children: (0, import_jsx_runtime18.jsxs)(SplitView, {
      autoSaveId: "keystatic-app-split-view",
      isCollapsed: isBelowDesktop || !sidebarState.isOpen,
      onCollapseChange: sidebarState.toggle,
      defaultSize: 260,
      minSize: 180,
      maxSize: 400,
      height: "100vh",
      children: [isBelowDesktop ? (0, import_jsx_runtime18.jsx)(SidebarDialog, {}) : (0, import_jsx_runtime18.jsx)(SplitPanePrimary, {
        children: (0, import_jsx_runtime18.jsx)(SidebarPanel, {})
      }), (0, import_jsx_runtime18.jsx)(SplitPaneSecondary, {
        ref,
        children: props.children
      })]
    })
  });
};
var AppShell = (props) => {
  const content = (0, import_jsx_runtime18.jsx)(AppShellErrorContext.Consumer, {
    children: (error) => error && !(error !== null && error !== void 0 && error.graphQLErrors.some((err) => {
      var _err$originalError;
      return (err === null || err === void 0 || (_err$originalError = err.originalError) === null || _err$originalError === void 0 ? void 0 : _err$originalError.type) === "NOT_FOUND";
    })) ? (0, import_jsx_runtime18.jsx)(EmptyState, {
      icon: alertCircleIcon,
      title: "Failed to load shell",
      message: error.message
    }) : props.children
  });
  const inner = (0, import_jsx_runtime18.jsx)(ConfigContext.Provider, {
    value: props.config,
    children: (0, import_jsx_runtime18.jsx)(AppStateContext.Provider, {
      value: {
        basePath: props.basePath
      },
      children: (0, import_jsx_runtime18.jsx)(SidebarProvider, {
        children: (0, import_jsx_runtime18.jsx)(MainPanelLayout, {
          children: content
        })
      })
    })
  });
  if (isGitHubConfig(props.config) || props.config.storage.kind === "cloud") {
    return (0, import_jsx_runtime18.jsx)(GitHubAppShellProvider, {
      currentBranch: props.currentBranch,
      config: props.config,
      children: inner
    });
  }
  if (isLocalConfig(props.config)) {
    return (0, import_jsx_runtime18.jsx)(LocalAppShellProvider, {
      config: props.config,
      children: inner
    });
  }
  return null;
};
function SingletonPageInner(props) {
  var _getPathPrefix, _getPathPrefix2;
  const isBelowTablet = useMediaQuery(breakpointQueries$1.below.tablet);
  const singletonConfig = props.config.singletons[props.singleton];
  const branchInfo = useBranchInfo();
  const [forceValidation, setForceValidation] = (0, import_react8.useState)(false);
  const schema2 = (0, import_react8.useMemo)(() => object(singletonConfig.schema), [singletonConfig.schema]);
  const router = useRouter();
  const previewHref = (0, import_react8.useMemo)(() => {
    if (!singletonConfig.previewUrl)
      return void 0;
    return singletonConfig.previewUrl.replace("{branch}", branchInfo.currentBranch);
  }, [branchInfo.currentBranch, singletonConfig.previewUrl]);
  const isGitHub = isGitHubConfig(props.config) || isCloudConfig(props.config);
  const formatInfo = getSingletonFormat(props.config, props.singleton);
  const singletonExists = !!props.initialState;
  const singletonPath = getSingletonPath(props.config, props.singleton);
  const viewHref = isGitHub && singletonExists ? `${getRepoUrl(branchInfo)}${formatInfo.dataLocation === "index" ? `/tree/${branchInfo.currentBranch}/${(_getPathPrefix = getPathPrefix(props.config.storage)) !== null && _getPathPrefix !== void 0 ? _getPathPrefix : ""}${singletonPath}` : `/blob/${(_getPathPrefix2 = getPathPrefix(props.config.storage)) !== null && _getPathPrefix2 !== void 0 ? _getPathPrefix2 : ""}${branchInfo.currentBranch}/${singletonPath}${getDataFileExtension(formatInfo)}`}` : void 0;
  const menuActions = (0, import_react8.useMemo)(() => {
    const actions = [{
      key: "reset",
      label: "Reset",
      icon: historyIcon
    }];
    if (previewHref) {
      actions.push({
        key: "preview",
        label: "Preview",
        icon: externalLinkIcon,
        href: previewHref,
        target: "_blank",
        rel: "noopener noreferrer"
      });
    }
    if (viewHref) {
      actions.push({
        key: "view",
        label: "View on GitHub",
        icon: githubIcon,
        href: viewHref,
        target: "_blank",
        rel: "noopener noreferrer"
      });
    }
    return actions;
  }, [previewHref, viewHref]);
  const formID = "singleton-form";
  const baseCommit = useBaseCommit();
  const isCreating = props.initialState === null;
  const onCreate = async () => {
    if (props.updateResult.kind === "loading" || !props.hasChanged)
      return;
    if (!clientSideValidateProp(schema2, props.state, void 0)) {
      setForceValidation(true);
      return;
    }
    await props.onUpdate();
  };
  return (0, import_jsx_runtime18.jsxs)(PageRoot, {
    containerWidth: containerWidthForEntryLayout(singletonConfig),
    children: [(0, import_jsx_runtime18.jsxs)(PageHeader, {
      children: [(0, import_jsx_runtime18.jsxs)(Flex, {
        flex: true,
        alignItems: "center",
        gap: "regular",
        children: [(0, import_jsx_runtime18.jsx)(Heading, {
          elementType: "h1",
          id: "page-title",
          size: "small",
          children: singletonConfig.label
        }), props.updateResult.kind === "loading" ? (0, import_jsx_runtime18.jsx)(ProgressCircle, {
          "aria-label": `Updating ${singletonConfig.label}`,
          isIndeterminate: true,
          size: "small",
          alignSelf: "center"
        }) : props.hasChanged && (0, import_jsx_runtime18.jsx)(Badge, {
          tone: "pending",
          children: "Unsaved"
        })]
      }), (0, import_jsx_runtime18.jsx)(_ActionGroup, {
        buttonLabelBehavior: "hide",
        overflowMode: "collapse",
        prominence: "low",
        density: "compact",
        maxWidth: isBelowTablet ? "element.regular" : void 0,
        items: menuActions,
        disabledKeys: props.hasChanged ? [] : ["reset"],
        onAction: (key) => {
          switch (key) {
            case "reset":
              props.onReset();
              break;
          }
        },
        children: (item) => (0, import_jsx_runtime18.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
          textValue: item.label,
          href: item.href,
          target: item.target,
          rel: item.rel,
          children: [(0, import_jsx_runtime18.jsx)(Icon, {
            src: item.icon
          }), (0, import_jsx_runtime18.jsx)(Text, {
            children: item.label
          })]
        }, item.key)
      }), (0, import_jsx_runtime18.jsx)(Button, {
        form: formID,
        isDisabled: props.updateResult.kind === "loading",
        prominence: "high",
        type: "submit",
        children: isCreating ? "Create" : "Save"
      })]
    }), (0, import_jsx_runtime18.jsxs)(Flex, {
      elementType: "form",
      id: formID,
      onSubmit: (event) => {
        if (event.target !== event.currentTarget)
          return;
        event.preventDefault();
        onCreate();
      },
      direction: "column",
      gap: "xxlarge",
      height: "100%",
      minHeight: 0,
      minWidth: 0,
      children: [props.updateResult.kind === "error" && (0, import_jsx_runtime18.jsx)(Notice, {
        tone: "critical",
        children: props.updateResult.error.message
      }), (0, import_jsx_runtime18.jsx)(FormForEntry, {
        previewProps: props.previewProps,
        forceValidation,
        entryLayout: singletonConfig.entryLayout,
        formatInfo,
        slugField: void 0
      }), (0, import_jsx_runtime18.jsx)(
        DialogContainer,
        {
          onDismiss: props.onResetUpdateItem,
          children: props.updateResult.kind === "needs-new-branch" && (0, import_jsx_runtime18.jsx)(CreateBranchDuringUpdateDialog, {
            branchOid: baseCommit,
            onCreate: async (newBranch) => {
              router.push(`/keystatic/branch/${encodeURIComponent(newBranch)}/singleton/${encodeURIComponent(props.singleton)}`);
              props.onUpdate({
                branch: newBranch,
                sha: baseCommit
              });
            },
            reason: props.updateResult.reason,
            onDismiss: props.onResetUpdateItem
          })
        }
      ), (0, import_jsx_runtime18.jsx)(
        DialogContainer,
        {
          onDismiss: props.onResetUpdateItem,
          children: props.updateResult.kind === "needs-fork" && isGitHubConfig(props.config) && (0, import_jsx_runtime18.jsx)(ForkRepoDialog, {
            onCreate: async () => {
              props.onUpdate();
            },
            onDismiss: props.onResetUpdateItem,
            config: props.config
          })
        }
      )]
    })]
  });
}
function LocalSingletonPage(props) {
  const {
    singleton,
    initialFiles,
    initialState,
    localTreeKey,
    config,
    draft
  } = props;
  const singletonConfig = config.singletons[singleton];
  const schema2 = (0, import_react8.useMemo)(() => object(singletonConfig.schema), [singletonConfig.schema]);
  const singletonPath = getSingletonPath(config, singleton);
  const [{
    state,
    localTreeKey: localTreeKeyInState
  }, setState] = (0, import_react8.useState)(() => {
    var _draft$state;
    return {
      localTreeKey,
      state: (_draft$state = draft === null || draft === void 0 ? void 0 : draft.state) !== null && _draft$state !== void 0 ? _draft$state : initialState === null ? getInitialPropsValue(schema2) : initialState
    };
  });
  (0, import_react8.useEffect)(() => {
    if (draft && state === draft.state) {
      showDraftRestoredToast(draft.savedAt, localTreeKey !== draft.treeKey);
    }
  }, [draft]);
  if (localTreeKeyInState !== localTreeKey) {
    setState({
      localTreeKey,
      state: initialState === null ? getInitialPropsValue(schema2) : initialState
    });
  }
  const isCreating = initialState === null;
  const hasChanged = useHasChanged({
    initialState,
    state,
    schema: schema2,
    slugField: void 0
  }) || isCreating;
  (0, import_react8.useEffect)(() => {
    const key = ["singleton", singleton];
    if (hasChanged) {
      const serialized = serializeEntryToFiles({
        basePath: singletonPath,
        config,
        format: getSingletonFormat(config, singleton),
        schema: singletonConfig.schema,
        slug: void 0,
        state
      });
      const files = new Map(serialized.map((x2) => [x2.path, x2.contents]));
      const data = {
        beforeTreeKey: localTreeKey,
        files,
        savedAt: /* @__PURE__ */ new Date(),
        version: 1
      };
      setDraft(key, data);
    } else {
      delDraft(key);
    }
  }, [config, localTreeKey, state, hasChanged, singleton, singletonPath, singletonConfig]);
  const previewProps = (0, import_react8.useMemo)(() => createGetPreviewProps(schema2, (stateUpdater) => {
    setState((state2) => ({
      localTreeKey: state2.localTreeKey,
      state: stateUpdater(state2.state)
    }));
  }, () => void 0), [schema2])(state);
  const formatInfo = getSingletonFormat(config, singleton);
  const [updateResult, _update, resetUpdateItem] = useUpsertItem({
    state,
    initialFiles,
    config,
    schema: singletonConfig.schema,
    basePath: singletonPath,
    format: formatInfo,
    currentLocalTreeKey: localTreeKey,
    slug: void 0
  });
  const update = useEventCallback(_update);
  const onReset = () => setState({
    localTreeKey,
    state: initialState === null ? getInitialPropsValue(schema2) : initialState
  });
  return (0, import_jsx_runtime18.jsx)(SingletonPageInner, {
    ...props,
    hasChanged,
    onReset,
    onUpdate: update,
    onResetUpdateItem: resetUpdateItem,
    updateResult,
    state,
    previewProps
  });
}
function CollabSingletonPage(props) {
  const {
    singleton,
    initialFiles,
    initialState,
    localTreeKey,
    config
  } = props;
  const singletonConfig = config.singletons[singleton];
  const schema2 = (0, import_react8.useMemo)(() => object(singletonConfig.schema), [singletonConfig.schema]);
  const singletonPath = getSingletonPath(config, singleton);
  const yjsInfo = useYjs();
  const state = useYJsValue(schema2, props.map);
  const previewProps = (0, import_react8.useMemo)(() => createGetPreviewPropsFromY(schema2, props.map, yjsInfo.awareness), [props.map, schema2, yjsInfo.awareness])(state);
  const isCreating = initialState === null;
  const hasChanged = useHasChanged({
    initialState,
    state,
    schema: schema2,
    slugField: void 0
  }) || isCreating;
  const formatInfo = getSingletonFormat(config, singleton);
  const [updateResult, _update, resetUpdateItem] = useUpsertItem({
    state,
    initialFiles,
    config,
    schema: singletonConfig.schema,
    basePath: singletonPath,
    format: formatInfo,
    currentLocalTreeKey: localTreeKey,
    slug: void 0
  });
  const update = useEventCallback(_update);
  const onReset = () => {
    props.map.doc.transact(() => {
      for (const [key, value] of Object.entries(singletonConfig.schema)) {
        var _props$initialState$k, _props$initialState;
        const val = getYjsValFromParsedValue(value, (_props$initialState$k = (_props$initialState = props.initialState) === null || _props$initialState === void 0 ? void 0 : _props$initialState[key]) !== null && _props$initialState$k !== void 0 ? _props$initialState$k : getInitialPropsValue(value));
        props.map.set(key, val);
      }
    });
  };
  return (0, import_jsx_runtime18.jsx)(SingletonPageInner, {
    ...props,
    hasChanged,
    onReset,
    onUpdate: update,
    onResetUpdateItem: resetUpdateItem,
    updateResult,
    state,
    previewProps
  });
}
var storedValSchema = z.object({
  version: z.literal(1),
  savedAt: z.date(),
  beforeTreeKey: z.string().optional(),
  files: z.map(z.string(), z.instanceof(Uint8Array))
});
function SingletonPageWrapper(props) {
  var _props$config$singlet;
  const singletonConfig = (_props$config$singlet = props.config.singletons) === null || _props$config$singlet === void 0 ? void 0 : _props$config$singlet[props.singleton];
  if (!singletonConfig)
    notFound();
  const header = (0, import_jsx_runtime18.jsx)(PageHeader, {
    children: (0, import_jsx_runtime18.jsx)(Heading, {
      elementType: "h1",
      id: "page-title",
      size: "small",
      children: singletonConfig.label
    })
  });
  const format = (0, import_react8.useMemo)(() => getSingletonFormat(props.config, props.singleton), [props.config, props.singleton]);
  const dirpath = getSingletonPath(props.config, props.singleton);
  const draftData = useData((0, import_react8.useCallback)(async () => {
    const raw = await getDraft(["singleton", props.singleton]);
    if (!raw)
      throw new Error("No draft found");
    const stored = storedValSchema.parse(raw);
    const parsed = parseEntry({
      config: props.config,
      dirpath,
      format,
      schema: singletonConfig.schema,
      slug: void 0
    }, stored.files);
    return {
      state: parsed.initialState,
      savedAt: stored.savedAt,
      treeKey: stored.beforeTreeKey
    };
  }, [dirpath, format, props.config, props.singleton, singletonConfig.schema]));
  const itemData = useItemData({
    config: props.config,
    dirpath,
    schema: singletonConfig.schema,
    format,
    slug: void 0
  });
  const branchInfo = useBranchInfo();
  const key = `${branchInfo.currentBranch}/${props.singleton}`;
  const yjsInfo = useYjsIfAvailable();
  const mapData = useData((0, import_react8.useCallback)(async () => {
    if (!yjsInfo)
      return;
    if (yjsInfo === "loading")
      return LOADING;
    await yjsInfo.doc.whenSynced;
    if (itemData.kind !== "loaded")
      return LOADING;
    let doc = yjsInfo.data.get(key);
    if (doc instanceof Doc) {
      const promise = doc.whenLoaded;
      doc.load();
      await promise;
    } else {
      doc = new Doc();
      yjsInfo.data.set(key, doc);
    }
    const data = doc.getMap("data");
    if (!data.size) {
      doc.transact(() => {
        for (const [key2, value] of Object.entries(singletonConfig.schema)) {
          const val = getYjsValFromParsedValue(value, itemData.data === "not-found" ? getInitialPropsValue(value) : itemData.data.initialState[key2]);
          data.set(key2, val);
        }
      });
    }
    return data;
  }, [singletonConfig, itemData, key, yjsInfo]));
  if (itemData.kind === "error") {
    return (0, import_jsx_runtime18.jsxs)(PageRoot, {
      children: [header, (0, import_jsx_runtime18.jsx)(PageBody, {
        children: (0, import_jsx_runtime18.jsx)(Notice, {
          margin: "xxlarge",
          tone: "critical",
          children: itemData.error.message
        })
      })]
    });
  }
  if (mapData.kind === "error") {
    return (0, import_jsx_runtime18.jsxs)(PageRoot, {
      children: [header, (0, import_jsx_runtime18.jsx)(PageBody, {
        children: (0, import_jsx_runtime18.jsx)(Notice, {
          margin: "xxlarge",
          tone: "critical",
          children: mapData.error.message
        })
      })]
    });
  }
  if (itemData.kind === "loading" || draftData.kind === "loading" || mapData.kind === "loading") {
    return (0, import_jsx_runtime18.jsxs)(PageRoot, {
      children: [header, (0, import_jsx_runtime18.jsx)(PageBody, {
        children: (0, import_jsx_runtime18.jsx)(Flex, {
          alignItems: "center",
          justifyContent: "center",
          minHeight: "scale.3000",
          children: (0, import_jsx_runtime18.jsx)(ProgressCircle, {
            "aria-label": `Loading ${singletonConfig.label}`,
            isIndeterminate: true,
            size: "large"
          })
        })
      })]
    });
  }
  if (mapData.data) {
    return (0, import_jsx_runtime18.jsx)(CollabSingletonPage, {
      singleton: props.singleton,
      config: props.config,
      initialState: itemData.data === "not-found" ? null : itemData.data.initialState,
      initialFiles: itemData.data === "not-found" ? [] : itemData.data.initialFiles,
      localTreeKey: itemData.data === "not-found" ? void 0 : itemData.data.localTreeKey,
      map: mapData.data
    });
  }
  return (0, import_jsx_runtime18.jsx)(LocalSingletonPage, {
    singleton: props.singleton,
    config: props.config,
    initialState: itemData.data === "not-found" ? null : itemData.data.initialState,
    initialFiles: itemData.data === "not-found" ? [] : itemData.data.initialFiles,
    localTreeKey: itemData.data === "not-found" ? void 0 : itemData.data.localTreeKey,
    draft: draftData.kind === "loaded" ? draftData.data : void 0
  });
}
function CreatedGitHubApp(props) {
  return (0, import_jsx_runtime18.jsx)(Flex, {
    alignItems: "center",
    justifyContent: "center",
    margin: "xxlarge",
    children: (0, import_jsx_runtime18.jsxs)(Flex, {
      backgroundColor: "surface",
      padding: "large",
      border: "color.alias.borderIdle",
      borderRadius: "medium",
      direction: "column",
      justifyContent: "center",
      gap: "xlarge",
      maxWidth: "scale.4600",
      children: [(0, import_jsx_runtime18.jsx)(Heading, {
        children: "You've installed Keystatic! 🎉"
      }), (0, import_jsx_runtime18.jsx)(Text, {
        children: "To start using Keystatic, you need to install the GitHub app you've created."
      }), (0, import_jsx_runtime18.jsxs)(Text, {
        children: ["Make sure to add the App to the", " ", (0, import_jsx_runtime18.jsx)("code", {
          children: serializeRepoConfig(props.config.storage.repo)
        }), " ", "repository."]
      }), (0, import_jsx_runtime18.jsx)(InstallGitHubApp, {
        config: props.config
      })]
    })
  });
}
function KeystaticSetup(props) {
  const [deployedURL, setDeployedURL] = (0, import_react8.useState)("");
  const [organization, setOrganization] = (0, import_react8.useState)("");
  return (0, import_jsx_runtime18.jsx)(Flex, {
    alignItems: "center",
    justifyContent: "center",
    margin: "xxlarge",
    children: (0, import_jsx_runtime18.jsxs)(Flex, {
      backgroundColor: "surface",
      padding: "large",
      border: "color.alias.borderIdle",
      borderRadius: "medium",
      direction: "column",
      justifyContent: "center",
      gap: "xlarge",
      maxWidth: "scale.4600",
      elementType: "form",
      action: `https://github.com${organization ? `/organizations/${organization}` : ""}/settings/apps/new`,
      method: "post",
      children: [(0, import_jsx_runtime18.jsx)(Flex, {
        justifyContent: "center",
        children: (0, import_jsx_runtime18.jsx)(Heading, {
          children: "Keystatic Setup"
        })
      }), (0, import_jsx_runtime18.jsx)(Text, {
        children: "Keystatic doesn't have the required config."
      }), (0, import_jsx_runtime18.jsx)(Text, {
        children: "If you've already created your GitHub app, make sure to add the following environment variables:"
      }), (0, import_jsx_runtime18.jsxs)(Box, {
        elementType: "ul",
        children: [(0, import_jsx_runtime18.jsx)("li", {
          children: (0, import_jsx_runtime18.jsx)("code", {
            children: "KEYSTATIC_GITHUB_CLIENT_ID"
          })
        }), (0, import_jsx_runtime18.jsx)("li", {
          children: (0, import_jsx_runtime18.jsx)("code", {
            children: "KEYSTATIC_GITHUB_CLIENT_SECRET"
          })
        }), (0, import_jsx_runtime18.jsx)("li", {
          children: (0, import_jsx_runtime18.jsx)("code", {
            children: "KEYSTATIC_SECRET"
          })
        })]
      }), (0, import_jsx_runtime18.jsx)(Text, {
        children: "If you haven't created your GitHub app for Keystatic, you can create one below."
      }), (0, import_jsx_runtime18.jsx)(TextField, {
        label: "Deployed App URL",
        description: "This should the root of your domain. If you're not sure where Keystatic will be deployed, leave this blank and you can update the GitHub app later.",
        value: deployedURL,
        onChange: setDeployedURL
      }), (0, import_jsx_runtime18.jsx)(TextField, {
        label: "GitHub organization (if any)",
        description: "You must be an owner or GitHub App manager in the organization to create the GitHub App. Leave this blank to create the app in your personal account.",
        value: organization,
        onChange: setOrganization
      }), (0, import_jsx_runtime18.jsxs)(Text, {
        children: ["After visiting GitHub to create the GitHub app, you'll be redirected back here and secrets generated from GitHub will be written to your", " ", (0, import_jsx_runtime18.jsx)("code", {
          children: ".env"
        }), " file."]
      }), (0, import_jsx_runtime18.jsx)("input", {
        type: "text",
        name: "manifest",
        className: css({
          display: "none"
        }),
        value: JSON.stringify({
          name: `${parseRepoConfig(props.config.storage.repo).owner} Keystatic`,
          url: deployedURL ? `${deployedURL}/keystatic` : `${window.location.origin}/keystatic`,
          public: true,
          redirect_url: `${window.location.origin}/api/keystatic/github/created-app`,
          callback_urls: [`${window.location.origin}/api/keystatic/github/oauth/callback`, `http://127.0.0.1/api/keystatic/github/oauth/callback`, ...deployedURL ? [`${deployedURL}/api/keystatic/github/oauth/callback`] : []],
          request_oauth_on_install: true,
          default_permissions: {
            contents: "write",
            metadata: "read",
            pull_requests: "read"
          }
        })
      }), (0, import_jsx_runtime18.jsx)(Button, {
        prominence: "high",
        type: "submit",
        children: "Create GitHub App"
      })]
    })
  });
}
function RepoNotFound(props) {
  const repo = serializeRepoConfig(props.config.storage.repo);
  return (0, import_jsx_runtime18.jsx)(Flex, {
    alignItems: "center",
    justifyContent: "center",
    margin: "xxlarge",
    children: (0, import_jsx_runtime18.jsxs)(Flex, {
      backgroundColor: "surface",
      padding: "large",
      border: "color.alias.borderIdle",
      borderRadius: "medium",
      direction: "column",
      justifyContent: "center",
      gap: "xlarge",
      maxWidth: "scale.4600",
      children: [(0, import_jsx_runtime18.jsx)(Flex, {
        justifyContent: "center",
        children: (0, import_jsx_runtime18.jsx)(Heading, {
          children: "Repo not found"
        })
      }), (0, import_jsx_runtime18.jsxs)(Text, {
        children: ["Keystatic is configured for the", " ", (0, import_jsx_runtime18.jsx)("a", {
          href: `https://github.com/${repo}`,
          children: repo
        }), " GitHub repo but Keystatic isn't able to access this repo. This is either because you don't have access to this repo or you haven't added the GitHub app to it."]
      }), (0, import_jsx_runtime18.jsx)(InstallGitHubApp, {
        config: props.config
      })]
    })
  });
}
var storedStateSchema = z.object({
  state: z.string(),
  from: z.string(),
  code_verifier: z.string()
});
var tokenResponseSchema = z.object({
  access_token: z.string(),
  token_type: z.string(),
  expires_in: z.number()
});
function KeystaticCloudAuthCallback({
  config
}) {
  var _config$cloud2;
  const router = useRouter();
  const url = new URL(window.location.href);
  const code = url.searchParams.get("code");
  const state = url.searchParams.get("state");
  const storedState = (0, import_react8.useMemo)(() => {
    const _storedState = localStorage.getItem("keystatic-cloud-state");
    const storedState2 = storedStateSchema.safeParse((() => {
      try {
        return JSON.parse(_storedState || "");
      } catch {
        return null;
      }
    })());
    return storedState2;
  }, []);
  const [error, setError] = (0, import_react8.useState)(null);
  (0, import_react8.useEffect)(() => {
    var _config$cloud;
    if (code && state && storedState.success && (_config$cloud = config.cloud) !== null && _config$cloud !== void 0 && _config$cloud.project) {
      const {
        project
      } = config.cloud;
      (async () => {
        const res = await fetch(`${KEYSTATIC_CLOUD_API_URL}/oauth/token`, {
          method: "POST",
          body: new URLSearchParams({
            code,
            client_id: project,
            redirect_uri: `${window.location.origin}/keystatic/cloud/oauth/callback`,
            code_verifier: storedState.data.code_verifier,
            grant_type: "authorization_code"
          }).toString(),
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
            ...KEYSTATIC_CLOUD_HEADERS
          }
        });
        if (!res.ok) {
          throw new Error(`Bad response: ${res.status} ${res.statusText}

${await res.text()}`);
        }
        const data = await res.json();
        const parsed = tokenResponseSchema.parse(data);
        localStorage.setItem("keystatic-cloud-access-token", JSON.stringify({
          token: parsed.access_token,
          project,
          validUntil: Date.now() + parsed.expires_in * 1e3
        }));
        router.push(`/keystatic/${storedState.data.from}`);
      })().catch((error2) => {
        setError(error2);
      });
    }
  }, [code, state, router, storedState, config]);
  if (!((_config$cloud2 = config.cloud) !== null && _config$cloud2 !== void 0 && _config$cloud2.project)) {
    return (0, import_jsx_runtime18.jsx)(Text, {
      children: "Missing Keystatic Cloud config"
    });
  }
  if (!code || !state) {
    return (0, import_jsx_runtime18.jsx)(Text, {
      children: "Missing code or state"
    });
  }
  if (storedState.success === false || state !== storedState.data.state) {
    return (0, import_jsx_runtime18.jsx)(Text, {
      children: "Invalid state"
    });
  }
  if (error) {
    return (0, import_jsx_runtime18.jsx)(Text, {
      children: error.message
    });
  }
  return (0, import_jsx_runtime18.jsx)(Flex, {
    justifyContent: "center",
    alignItems: "center",
    height: "100vh",
    children: (0, import_jsx_runtime18.jsx)(ProgressCircle, {
      size: "large",
      isIndeterminate: true,
      "aria-label": "Authenticating"
    })
  });
}
function parseParamsWithoutBranch(params) {
  if (params.length === 0) {
    return {};
  }
  if (params.length === 2 && params[0] === "singleton") {
    return {
      singleton: params[1]
    };
  }
  if (params.length < 2 || params[0] !== "collection")
    return null;
  const collection = params[1];
  if (params.length === 2) {
    return {
      collection
    };
  }
  if (params.length === 3 && params[2] === "create") {
    return {
      collection,
      kind: "create"
    };
  }
  if (params.length === 4 && params[2] === "item") {
    const slug = params[3];
    return {
      collection,
      kind: "edit",
      slug
    };
  }
  return null;
}
function RedirectToBranch(props) {
  const {
    push
  } = useRouter();
  const {
    data,
    error
  } = (0, import_react8.useContext)(GitHubAppShellDataContext);
  (0, import_react8.useEffect)(() => {
    var _error$response, _data$repository, _data$repository2, _error$graphQLErrors, _error$graphQLErrors2;
    if ((error === null || error === void 0 || (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401) {
      if (props.config.storage.kind === "github") {
        window.location.href = "/api/keystatic/github/login";
      } else {
        redirectToCloudAuth("", props.config);
      }
    }
    if (data !== null && data !== void 0 && (_data$repository = data.repository) !== null && _data$repository !== void 0 && _data$repository.defaultBranchRef) {
      push(`/keystatic/branch/${encodeURIComponent(data.repository.defaultBranchRef.name)}`);
    }
    if (props.config.storage.kind === "github" && !(data !== null && data !== void 0 && (_data$repository2 = data.repository) !== null && _data$repository2 !== void 0 && _data$repository2.id) && (error === null || error === void 0 || (_error$graphQLErrors = error.graphQLErrors) === null || _error$graphQLErrors === void 0 || (_error$graphQLErrors = _error$graphQLErrors[0]) === null || _error$graphQLErrors === void 0 || (_error$graphQLErrors = _error$graphQLErrors.originalError) === null || _error$graphQLErrors === void 0 ? void 0 : _error$graphQLErrors.type) === "NOT_FOUND" || (error === null || error === void 0 || (_error$graphQLErrors2 = error.graphQLErrors) === null || _error$graphQLErrors2 === void 0 || (_error$graphQLErrors2 = _error$graphQLErrors2[0]) === null || _error$graphQLErrors2 === void 0 || (_error$graphQLErrors2 = _error$graphQLErrors2.originalError) === null || _error$graphQLErrors2 === void 0 ? void 0 : _error$graphQLErrors2.type) === "FORBIDDEN") {
      window.location.href = "/api/keystatic/github/repo-not-found";
    }
  }, [data, error, push, props.config]);
  return null;
}
function PageInner({
  config
}) {
  var _config$cloud;
  const {
    params
  } = useRouter();
  let branch = null, parsedParams, basePath;
  if (params.join("/") === "cloud/oauth/callback") {
    return (0, import_jsx_runtime18.jsx)(KeystaticCloudAuthCallback, {
      config
    });
  }
  let wrapper = (x2) => x2;
  if (isCloudConfig(config) || isLocalConfig(config) && (_config$cloud = config.cloud) !== null && _config$cloud !== void 0 && _config$cloud.project) {
    wrapper = (element) => (0, import_jsx_runtime18.jsx)(CloudInfoProvider, {
      config,
      children: element
    });
  }
  if (isGitHubConfig(config) || isCloudConfig(config)) {
    const origWrapper = wrapper;
    wrapper = (element) => (0, import_jsx_runtime18.jsx)(AuthWrapper, {
      config,
      children: (0, import_jsx_runtime18.jsx)(GitHubAppShellDataProvider, {
        config,
        children: origWrapper(element)
      })
    });
    if (params.length === 0) {
      return wrapper((0, import_jsx_runtime18.jsx)(RedirectToBranch, {
        config
      }));
    }
    if (params.length === 1 && isGitHubConfig(config)) {
      if (params[0] === "setup")
        return (0, import_jsx_runtime18.jsx)(KeystaticSetup, {
          config
        });
      if (params[0] === "repo-not-found") {
        return (0, import_jsx_runtime18.jsx)(RepoNotFound, {
          config
        });
      }
      if (params[0] === "created-github-app") {
        return (0, import_jsx_runtime18.jsx)(CreatedGitHubApp, {
          config
        });
      }
    }
    if (params[0] !== "branch" || params.length < 2) {
      return (0, import_jsx_runtime18.jsx)(Text, {
        children: "Not found"
      });
    }
    branch = params[1];
    basePath = `/keystatic/branch/${encodeURIComponent(branch)}`;
    parsedParams = parseParamsWithoutBranch(params.slice(2));
  } else {
    parsedParams = parseParamsWithoutBranch(params);
    basePath = "/keystatic";
  }
  return wrapper((0, import_jsx_runtime18.jsx)(AppShell, {
    config,
    currentBranch: branch || "",
    basePath,
    children: (0, import_jsx_runtime18.jsx)(NotFoundBoundary, {
      fallback: (0, import_jsx_runtime18.jsx)(PageRoot, {
        children: (0, import_jsx_runtime18.jsx)(PageBody, {
          children: (0, import_jsx_runtime18.jsx)(EmptyState, {
            icon: fileX2Icon,
            title: "Not found",
            message: "This page could not be found."
          })
        })
      }),
      children: parsedParams === null ? (0, import_jsx_runtime18.jsx)(AlwaysNotFound, {}) : parsedParams.collection ? parsedParams.kind === "create" ? (0, import_jsx_runtime18.jsx)(CreateItemWrapper, {
        collection: parsedParams.collection,
        config,
        basePath
      }, parsedParams.collection) : parsedParams.kind === "edit" ? (0, import_jsx_runtime18.jsx)(ItemPageWrapper, {
        collection: parsedParams.collection,
        basePath,
        config,
        itemSlug: parsedParams.slug
      }, parsedParams.collection) : (0, import_jsx_runtime18.jsx)(CollectionPage, {
        basePath,
        collection: parsedParams.collection,
        config
      }, parsedParams.collection) : parsedParams.singleton ? (0, import_jsx_runtime18.jsx)(SingletonPageWrapper, {
        config,
        singleton: parsedParams.singleton
      }, parsedParams.singleton) : (0, import_jsx_runtime18.jsx)(DashboardPage, {
        config,
        basePath
      })
    })
  }));
}
function AlwaysNotFound() {
  notFound();
}
function AuthWrapper(props) {
  const [state, setState] = (0, import_react8.useState)("unknown");
  const router = useRouter();
  (0, import_react8.useEffect)(() => {
    getAuth(props.config).then((auth) => {
      if (auth) {
        setState("valid");
        return;
      }
      setState("explicit-auth");
    });
  }, [props.config]);
  if (state === "valid") {
    return props.children;
  }
  if (state === "explicit-auth") {
    if (props.config.storage.kind === "github") {
      return (0, import_jsx_runtime18.jsx)(Flex, {
        justifyContent: "center",
        alignItems: "center",
        height: "100vh",
        children: (0, import_jsx_runtime18.jsxs)(Button, {
          href: `/api/keystatic/github/login${router.params.length ? `?${new URLSearchParams({
            from: router.params.map(encodeURIComponent).join("/")
          })}` : ""}`,
          target: "_top",
          children: [(0, import_jsx_runtime18.jsx)(Icon, {
            src: githubIcon
          }), (0, import_jsx_runtime18.jsx)(Text, {
            children: "Log in with GitHub"
          })]
        })
      });
    }
    if (props.config.storage.kind === "cloud") {
      return (0, import_jsx_runtime18.jsx)(Flex, {
        justifyContent: "center",
        alignItems: "center",
        height: "100vh",
        children: (0, import_jsx_runtime18.jsx)(Button, {
          onPress: () => {
            redirectToCloudAuth(router.params.map(encodeURIComponent).join("/"), props.config);
          },
          children: (0, import_jsx_runtime18.jsx)(Text, {
            children: "Log in with Keystatic Cloud"
          })
        })
      });
    }
  }
  return null;
}
function RedirectToLoopback(props) {
  (0, import_react8.useEffect)(() => {
    if (window.location.hostname === "localhost") {
      window.location.href = window.location.href.replace("localhost", "127.0.0.1");
    }
  }, []);
  if (window.location.hostname === "localhost") {
    return null;
  }
  return props.children;
}
function Keystatic(props) {
  if (props.config.storage.kind === "github") {
    assertValidRepoConfig(props.config.storage.repo);
  }
  return (0, import_jsx_runtime18.jsx)(ClientOnly, {
    children: (0, import_jsx_runtime18.jsx)(RedirectToLoopback, {
      children: (0, import_jsx_runtime18.jsx)(AppSlugProvider, {
        value: props.appSlug,
        children: (0, import_jsx_runtime18.jsx)(RouterProvider, {
          children: (0, import_jsx_runtime18.jsx)(Provider, {
            config: props.config,
            children: (0, import_jsx_runtime18.jsx)(PageInner, {
              config: props.config
            })
          })
        })
      })
    })
  });
}
function ClientOnly(props) {
  const [mounted, setMounted] = (0, import_react8.useState)(false);
  (0, import_react8.useEffect)(() => {
    setMounted(true);
  }, []);
  if (!mounted)
    return null;
  return props.children;
}

export {
  Keystatic
};
/*! Bundled license information:

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/
//# sourceMappingURL=chunk-BZZMUGL3.js.map
